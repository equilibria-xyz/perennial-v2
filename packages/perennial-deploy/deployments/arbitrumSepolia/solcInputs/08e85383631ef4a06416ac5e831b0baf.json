{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@equilibria/emptyset-batcher/interfaces/IBatcher.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed18.sol\";\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/token/types/Token6.sol\";\nimport \"../interfaces/IEmptySetReserve.sol\";\n\ninterface IBatcher {\n    event Wrap(address indexed to, UFixed18 amount);\n    event Unwrap(address indexed to, UFixed18 amount);\n    event Rebalance(UFixed18 newMinted, UFixed18 newRedeemed);\n    event Close(UFixed18 amount);\n\n    error BatcherNotImplementedError();\n    error BatcherBalanceMismatchError(UFixed18 oldBalance, UFixed18 newBalance);\n\n    function RESERVE() external view returns (IEmptySetReserve); // solhint-disable-line func-name-mixedcase\n    function USDC() external view returns (Token6); // solhint-disable-line func-name-mixedcase\n    function DSU() external view returns (Token18); // solhint-disable-line func-name-mixedcase\n    function totalBalance() external view returns (UFixed18);\n    function wrap(UFixed18 amount, address to) external;\n    function unwrap(UFixed18 amount, address to) external;\n    function rebalance() external;\n}\n"
    },
    "@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed18.sol\";\n\ninterface IEmptySetReserve {\n    event Redeem(address indexed account, uint256 costAmount, uint256 redeemAmount);\n    event Mint(address indexed account, uint256 mintAmount, uint256 costAmount);\n    event Repay(address indexed account, uint256 repayAmount);\n\n    function debt(address borrower) external view returns (UFixed18);\n    function repay(address borrower, UFixed18 amount) external;\n    function mint(UFixed18 amount) external;\n    function redeem(UFixed18 amount) external;\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/Account.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { Instance } from \"@equilibria/root/attribute/Instance.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { UFixed18, UFixed18Lib } from \"@equilibria/root/number/types/UFixed18.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\n\nimport { IAccount } from \"./interfaces/IAccount.sol\";\nimport { IMarket, Position } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\n\n/// @title Account\n/// @notice Collateral Accounts allow users to manage collateral across Perennial markets\ncontract Account is IAccount, Instance {\n    UFixed6 private constant UNCHANGED_POSITION = UFixed6Lib.MAX;\n\n    /// @dev EOA of the user who owns this collateral account\n    address public owner;\n\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU Reserve address\n    IEmptySetReserve public immutable reserve;\n\n    /// @dev Construct collateral account and set approvals for controller and DSU reserve\n    /// @param usdc_ USDC stablecoin\n    /// @param dsu_ Digital Standard Unit stablecoin\n    /// @param reserve_ DSU SimpleReserve contract, used for wrapping/unwrapping USDC to/from DSU\n    constructor(Token6 usdc_, Token18 dsu_, IEmptySetReserve reserve_) {\n        USDC = usdc_;\n        DSU = dsu_;\n        reserve = reserve_;\n    }\n\n    /// @inheritdoc IAccount\n    function initialize(address owner_) external initializer(1) {\n        __Instance__initialize();\n        owner = owner_;\n\n        // approve the Controller to interact with this account's DSU\n        DSU.approve(address(factory()));\n\n        // approve DSU facilities to wrap and unwrap USDC for this account\n        DSU.approve(address(reserve));\n        USDC.approve(address(reserve));\n    }\n\n    /// @inheritdoc IAccount\n    function deposit(UFixed6 amount) external {\n        USDC.pull(msg.sender, amount);\n    }\n\n    /// @inheritdoc IAccount\n    function marketTransfer(IMarket market, Fixed6 amount) external ownerOrController {\n        // implicitly approve this market to spend our DSU\n        DSU.approve(address(market));\n\n        // if account does not have enough DSU for the deposit, wrap everything\n         if (amount.gt(Fixed6Lib.ZERO))\n            wrapIfNecessary(UFixed18Lib.from(amount.abs()), true);\n\n        // pass magic numbers to avoid changing position; market will pull/push collateral from/to this contract\n        market.update(owner, UNCHANGED_POSITION, UNCHANGED_POSITION, UNCHANGED_POSITION, amount, false);\n    }\n\n    /// @inheritdoc IAccount\n    function withdraw(UFixed6 amount, bool shouldUnwrap) external ownerOrController {\n        UFixed6 usdcBalance = USDC.balanceOf();\n        if (shouldUnwrap && usdcBalance.lt(amount)) {\n            UFixed18 unwrapAmount = amount.eq(UFixed6Lib.MAX) ?\n                DSU.balanceOf() :\n                UFixed18Lib.from(amount.sub(usdcBalance)).min(DSU.balanceOf());\n            unwrap(unwrapAmount);\n        }\n        UFixed6 pushAmount = amount.eq(UFixed6Lib.MAX) ? USDC.balanceOf() : amount;\n        USDC.push(owner, pushAmount);\n    }\n\n    /// @inheritdoc IAccount\n    function wrap(UFixed18 amount) public ownerOrController {\n        reserve.mint(amount);\n    }\n\n    /// @inheritdoc IAccount\n    function wrapIfNecessary(UFixed18 amount, bool wrapAll) public ownerOrController {\n        if (DSU.balanceOf().lt(amount)) {\n            UFixed6 usdcBalance = USDC.balanceOf();\n            if (!usdcBalance.eq(UFixed6Lib.ZERO))\n                wrap(wrapAll ? UFixed18Lib.from(usdcBalance) : amount);\n        }\n    }\n\n    /// @inheritdoc IAccount\n    function unwrap(UFixed18 amount) public ownerOrController {\n        reserve.redeem(amount);\n    }\n\n    /// @dev Reverts if not called by the owner of the collateral account, or the collateral account controller\n    modifier ownerOrController {\n        if (msg.sender != owner && msg.sender != address(factory())) revert AccountNotAuthorizedError();\n        _;\n    }\n}"
    },
    "@equilibria/perennial-v2-account/contracts/AccountVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport { VerifierBase } from \"@equilibria/root/verifier/VerifierBase.sol\";\n\nimport { IAccountVerifier } from \"./interfaces/IAccountVerifier.sol\";\nimport { IRelayVerifier } from \"./interfaces/IRelayVerifier.sol\"; // only needed for docstrings\nimport { Action, ActionLib } from \"./types/Action.sol\";\nimport { DeployAccount, DeployAccountLib } from \"./types/DeployAccount.sol\";\nimport { MarketTransfer, MarketTransferLib } from \"./types/MarketTransfer.sol\";\nimport { RebalanceConfigChange, RebalanceConfigChangeLib } from \"./types/RebalanceConfigChange.sol\";\nimport { Withdrawal, WithdrawalLib } from \"./types/Withdrawal.sol\";\nimport { RelayedNonceCancellation, RelayedNonceCancellationLib } from \"./types/RelayedNonceCancellation.sol\";\nimport { RelayedGroupCancellation, RelayedGroupCancellationLib } from \"./types/RelayedGroupCancellation.sol\";\nimport { RelayedOperatorUpdate, RelayedOperatorUpdateLib } from \"./types/RelayedOperatorUpdate.sol\";\nimport { RelayedSignerUpdate, RelayedSignerUpdateLib } from \"./types/RelayedSignerUpdate.sol\";\nimport { RelayedAccessUpdateBatch, RelayedAccessUpdateBatchLib } from \"./types/RelayedAccessUpdateBatch.sol\";\n\n/// @title Verifier\n/// @notice ERC712 signed message verifier for the Perennial V2 Collateral Accounts package.\ncontract AccountVerifier is VerifierBase, IAccountVerifier {\n    /// @dev Initializes the domain separator and parameter caches\n    constructor() EIP712(\"Perennial V2 Collateral Accounts\", \"1.0.0\") { }\n\n    /// @inheritdoc IAccountVerifier\n    function verifyAction(Action calldata action, bytes calldata signature)\n        external\n        validateAndCancel(action.common, signature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            action.common.signer,\n            _hashTypedDataV4(ActionLib.hash(action)),\n            signature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @inheritdoc IAccountVerifier\n    function verifyDeployAccount(DeployAccount calldata deployAccount, bytes calldata signature)\n        external\n        validateAndCancel(deployAccount.action.common, signature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            deployAccount.action.common.signer,\n            _hashTypedDataV4(DeployAccountLib.hash(deployAccount)),\n            signature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @inheritdoc IAccountVerifier\n    function verifyMarketTransfer(MarketTransfer calldata marketTransfer, bytes calldata signature)\n        external\n        validateAndCancel(marketTransfer.action.common, signature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            marketTransfer.action.common.signer,\n            _hashTypedDataV4(MarketTransferLib.hash(marketTransfer)),\n            signature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @inheritdoc IAccountVerifier\n    function verifyRebalanceConfigChange(RebalanceConfigChange calldata change, bytes calldata signature)\n        external\n        validateAndCancel(change.action.common, signature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            change.action.common.signer,\n            _hashTypedDataV4(RebalanceConfigChangeLib.hash(change)),\n            signature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @inheritdoc IAccountVerifier\n    function verifyWithdrawal(Withdrawal calldata withdrawal, bytes calldata signature)\n        external\n        validateAndCancel(withdrawal.action.common, signature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            withdrawal.action.common.signer,\n            _hashTypedDataV4(WithdrawalLib.hash(withdrawal)),\n            signature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @inheritdoc IRelayVerifier\n    function verifyRelayedNonceCancellation(\n        RelayedNonceCancellation calldata message,\n        bytes calldata outerSignature\n    ) external validateAndCancel(message.action.common, outerSignature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            message.action.common.signer,\n            _hashTypedDataV4(RelayedNonceCancellationLib.hash(message)),\n            outerSignature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @inheritdoc IRelayVerifier\n    function verifyRelayedGroupCancellation(\n        RelayedGroupCancellation calldata message,\n        bytes calldata outerSignature\n    ) external validateAndCancel(message.action.common, outerSignature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            message.action.common.signer,\n            _hashTypedDataV4(RelayedGroupCancellationLib.hash(message)),\n            outerSignature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @inheritdoc IRelayVerifier\n    function verifyRelayedOperatorUpdate(\n        RelayedOperatorUpdate calldata message,\n        bytes calldata outerSignature\n    ) external validateAndCancel(message.action.common, outerSignature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            message.action.common.signer,\n            _hashTypedDataV4(RelayedOperatorUpdateLib.hash(message)),\n            outerSignature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @inheritdoc IRelayVerifier\n    function verifyRelayedSignerUpdate(\n        RelayedSignerUpdate calldata message,\n        bytes calldata outerSignature\n    ) external validateAndCancel(message.action.common, outerSignature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            message.action.common.signer,\n            _hashTypedDataV4(RelayedSignerUpdateLib.hash(message)),\n            outerSignature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @inheritdoc IRelayVerifier\n    function verifyRelayedAccessUpdateBatch(\n        RelayedAccessUpdateBatch calldata message,\n        bytes calldata outerSignature\n    ) external validateAndCancel(message.action.common, outerSignature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            message.action.common.signer,\n            _hashTypedDataV4(RelayedAccessUpdateBatchLib.hash(message)),\n            outerSignature\n        )) revert VerifierInvalidSignerError();\n    }\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { Kept_Arbitrum, Kept } from \"@equilibria/root/attribute/Kept/Kept_Arbitrum.sol\";\nimport { UFixed18 } from \"@equilibria/root/number/types/UFixed18.sol\";\nimport { IVerifierBase } from \"@equilibria/root/verifier/interfaces/IVerifierBase.sol\";\nimport { Controller_Incentivized } from \"./Controller_Incentivized.sol\";\n\n/// @title Controller_Arbitrum\n/// @notice Controller which compensates keepers for handling or relaying messages on Arbitrum L2.\ncontract Controller_Arbitrum is Controller_Incentivized, Kept_Arbitrum {\n    /// @dev Creates instance of Controller which compensates keepers\n    /// @param implementation Pristine collateral account contract\n    /// @param keepConfig Configuration used to compensate keepers\n    constructor(address implementation, KeepConfig memory keepConfig, IVerifierBase nonceManager)\n    Controller_Incentivized(implementation, keepConfig, nonceManager) {}\n\n    /// @dev Use the Kept_Arbitrum implementation for calculating the dynamic fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view override(Kept_Arbitrum, Kept) returns (UFixed18) {\n        return Kept_Arbitrum._calldataFee(applicableCalldata, multiplierCalldata, bufferCalldata);\n    }\n\n    /// @dev Transfers funds from collateral account to controller, and limits compensation\n    /// to the user-defined maxFee in the Action message\n    /// @param amount Calculated keeper fee\n    /// @param data Encoded address of collateral account and UFixed6 user-specified maximum fee\n    /// @return raisedKeeperFee Amount pulled from controller to keeper\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal override(Controller_Incentivized, Kept) returns (UFixed18 raisedKeeperFee) {\n        return Controller_Incentivized._raiseKeeperFee(amount, data);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/Controller_Incentivized.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { Kept } from \"@equilibria/root/attribute/Kept/Kept.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { UFixed18, UFixed18Lib } from \"@equilibria/root/number/types/UFixed18.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { IVerifierBase } from \"@equilibria/root/verifier/interfaces/IVerifierBase.sol\";\nimport { IMarket } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { IMarketFactory } from \"@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol\";\n\nimport { IAccount } from \"./interfaces/IAccount.sol\";\nimport { IController } from \"./interfaces/IController.sol\";\nimport { IRelayer } from \"./interfaces/IRelayer.sol\";\nimport { Controller, IAccountVerifier } from \"./Controller.sol\";\nimport { Action } from \"./types/Action.sol\";\nimport { DeployAccount } from \"./types/DeployAccount.sol\";\nimport { MarketTransfer } from \"./types/MarketTransfer.sol\";\nimport { RebalanceConfigChange } from \"./types/RebalanceConfigChange.sol\";\nimport { RelayedNonceCancellation } from \"./types/RelayedNonceCancellation.sol\";\nimport { RelayedGroupCancellation } from \"./types/RelayedGroupCancellation.sol\";\nimport { RelayedOperatorUpdate } from \"./types/RelayedOperatorUpdate.sol\";\nimport { RelayedSignerUpdate } from \"./types/RelayedSignerUpdate.sol\";\nimport { RelayedAccessUpdateBatch } from \"./types/RelayedAccessUpdateBatch.sol\";\nimport { Withdrawal } from \"./types/Withdrawal.sol\";\n\n/// @title Controller_Incentivized\n/// @notice Controller which compensates keepers for handling or relaying messages. Subclass to handle differences in\n/// gas calculations on different chains.\nabstract contract Controller_Incentivized is Controller, IRelayer, Kept {\n    /// @dev Configuration used to calculate keeper compensation\n    KeepConfig public keepConfig;\n\n    /// @dev Handles relayed messages for nonce cancellation\n    IVerifierBase public nonceManager;\n\n    /// @dev Creates instance of Controller which compensates keepers\n    /// @param implementation_ Pristine collateral account contract\n    /// @param keepConfig_ Configuration used to compensate keepers\n    constructor(address implementation_, KeepConfig memory keepConfig_, IVerifierBase nonceManager_)\n    Controller(implementation_) {\n        keepConfig = keepConfig_;\n        nonceManager = nonceManager_;\n    }\n\n    /// @notice Configures message verification and keeper compensation\n    /// @param marketFactory_ Contract used to validate delegated signers\n    /// @param verifier_ Contract used to validate collateral account message signatures\n    /// @param chainlinkFeed_ ETH-USD price feed used for calculating keeper compensation\n    function initialize(\n        IMarketFactory marketFactory_,\n        IAccountVerifier verifier_,\n        AggregatorV3Interface chainlinkFeed_\n    ) external initializer(1) {\n        __Factory__initialize();\n        __Kept__initialize(chainlinkFeed_, DSU);\n        marketFactory = marketFactory_;\n        verifier = verifier_;\n    }\n\n    /// @inheritdoc IController\n    function changeRebalanceConfigWithSignature(\n        RebalanceConfigChange calldata configChange,\n        bytes calldata signature\n    ) override external {\n        _changeRebalanceConfigWithSignature(configChange, signature);\n        _compensateKeeper(configChange.action);\n    }\n\n    /// @inheritdoc IController\n    function deployAccountWithSignature(\n        DeployAccount calldata deployAccount_,\n        bytes calldata signature\n    ) override external {\n        IAccount account = _deployAccountWithSignature(deployAccount_, signature);\n        bytes memory data = abi.encode(address(account), deployAccount_.action.maxFee);\n        _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\n    }\n\n    /// @inheritdoc IController\n    function marketTransferWithSignature(\n        MarketTransfer calldata marketTransfer,\n        bytes calldata signature\n    ) override external {\n        IAccount account = IAccount(getAccountAddress(marketTransfer.action.common.account));\n        bytes memory data = abi.encode(account, marketTransfer.action.maxFee);\n\n        // if we're depositing collateral to the market, pay the keeper before transferring funds\n        if (marketTransfer.amount.gte(Fixed6Lib.ZERO)) {\n            _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\n            _marketTransferWithSignature(account, marketTransfer, signature);\n        // otherwise handle the keeper fee normally, after withdrawing to the collateral account\n        } else {\n            _marketTransferWithSignature(account, marketTransfer, signature);\n            _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\n        }\n    }\n\n    /// @inheritdoc IController\n    function rebalanceGroup(address owner, uint256 group) override external {\n        _rebalanceGroup(owner, group);\n        address account = getAccountAddress(owner);\n        bytes memory data = abi.encode(account, groupToMaxRebalanceFee[owner][group]);\n        _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\n    }\n\n    /// @inheritdoc IController\n    function withdrawWithSignature(\n        Withdrawal calldata withdrawal,\n        bytes calldata signature\n    ) override external {\n        address account = getAccountAddress(withdrawal.action.common.account);\n        // levy fee prior to withdrawal\n        bytes memory data = abi.encode(account, withdrawal.action.maxFee);\n        _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\n        _withdrawWithSignature(IAccount(account), withdrawal, signature);\n    }\n\n    /// @inheritdoc IRelayer\n    function relayNonceCancellation(\n        RelayedNonceCancellation calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) override external {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRelayedNonceCancellation(message, outerSignature);\n        _ensureValidSigner(message.action.common.account, message.action.common.signer);\n\n        _compensateKeeper(message.action);\n\n        // relay the message to Verifier\n        nonceManager.cancelNonceWithSignature(message.nonceCancellation, innerSignature);\n    }\n\n    /// @inheritdoc IRelayer\n    function relayGroupCancellation(\n        RelayedGroupCancellation calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) override external {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRelayedGroupCancellation(message, outerSignature);\n        _ensureValidSigner(message.action.common.account, message.action.common.signer);\n\n        _compensateKeeper(message.action);\n\n        // relay the message to Verifier\n        nonceManager.cancelGroupWithSignature(message.groupCancellation, innerSignature);\n    }\n\n    /// @inheritdoc IRelayer\n    function relayOperatorUpdate(\n        RelayedOperatorUpdate calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) override external {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRelayedOperatorUpdate(message, outerSignature);\n        _ensureValidSigner(message.action.common.account, message.action.common.signer);\n\n        _compensateKeeper(message.action);\n\n        // relay the message to MarketFactory\n        marketFactory.updateOperatorWithSignature(message.operatorUpdate, innerSignature);\n    }\n\n    /// @inheritdoc IRelayer\n    function relaySignerUpdate(\n        RelayedSignerUpdate calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) override external {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRelayedSignerUpdate(message, outerSignature);\n        _ensureValidSigner(message.action.common.account, message.action.common.signer);\n\n        _compensateKeeper(message.action);\n\n        // relay the message to MarketFactory\n        marketFactory.updateSignerWithSignature(message.signerUpdate, innerSignature);\n    }\n\n    /// @inheritdoc IRelayer\n    function relayAccessUpdateBatch(\n        RelayedAccessUpdateBatch calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) override external {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRelayedAccessUpdateBatch(message, outerSignature);\n        _ensureValidSigner(message.action.common.account, message.action.common.signer);\n\n        _compensateKeeper(message.action);\n\n        // relay the message to MarketFactory\n        marketFactory.updateAccessBatchWithSignature(message.accessUpdateBatch, innerSignature);\n    }\n\n    function _compensateKeeper(Action calldata action) internal virtual {\n        bytes memory data = abi.encode(getAccountAddress(action.common.account), action.maxFee);\n        _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\n    }\n\n    /// @dev Transfers funds from collateral account to controller, and limits compensation\n    /// to the user-defined maxFee in the Action message\n    /// @param amount Calculated keeper fee\n    /// @param data Encoded address of collateral account and UFixed6 user-specified maximum fee\n    /// @return raisedKeeperFee Amount pulled from controller to keeper\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal virtual override returns (UFixed18 raisedKeeperFee) {\n        (address account, UFixed6 maxFee) = abi.decode(data, (address, UFixed6));\n        raisedKeeperFee = amount.min(UFixed18Lib.from(maxFee));\n\n        // if the account has insufficient DSU to pay the fee, wrap\n        IAccount(account).wrapIfNecessary(raisedKeeperFee, false);\n\n        // transfer DSU to the Controller, such that Kept can transfer to keeper\n        DSU.pull(account, raisedKeeperFee);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/Controller.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport { Factory } from \"@equilibria/root/attribute/Factory.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { IMarketFactory } from \"@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol\";\n\nimport { IAccount, IMarket } from \"./interfaces/IAccount.sol\";\nimport { IAccountVerifier, IController } from \"./interfaces/IController.sol\";\nimport { RebalanceLib } from \"./libs/RebalanceLib.sol\";\nimport { Account } from \"./Account.sol\";\nimport { DeployAccount, DeployAccountLib } from \"./types/DeployAccount.sol\";\nimport { MarketTransfer, MarketTransferLib } from \"./types/MarketTransfer.sol\";\nimport { RebalanceConfig, RebalanceConfigLib } from \"./types/RebalanceConfig.sol\";\nimport { RebalanceConfigChange, RebalanceConfigChangeLib } from \"./types/RebalanceConfigChange.sol\";\nimport { Withdrawal, WithdrawalLib } from \"./types/Withdrawal.sol\";\n\n/// @title Controller\n/// @notice Facilitates unpermissioned actions between collateral accounts and markets,\n/// without keeper compensation.  No message relaying facilities are provided.\ncontract Controller is Factory, IController {\n    // used for deterministic address creation through create2\n    bytes32 constant SALT = keccak256(\"Perennial V2 Collateral Accounts\");\n\n    uint256 constant MAX_GROUPS_PER_OWNER = 8;\n    uint256 constant MAX_MARKETS_PER_GROUP = 4;\n\n    /// @dev USDC stablecoin address\n    Token6 public USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @inheritdoc IController\n    IMarketFactory public marketFactory;\n\n    /// @inheritdoc IController\n    IAccountVerifier public verifier;\n\n    /// @dev Mapping of rebalance configuration\n    /// owner => group => market => config\n    mapping(address => mapping(uint256 => mapping(address => RebalanceConfig))) private _rebalanceConfigs;\n\n    /// @dev Prevents markets from being added to multiple rebalance groups\n    /// owner => market => group\n    mapping(address => mapping(address => uint256)) public marketToGroup;\n\n    /// @dev Allows iteration through markets in a rebalance group\n    /// owner => group => markets\n    mapping(address => mapping(uint256 => IMarket[])) public groupToMarkets;\n\n    /// @dev Limits relayer/keeper compensation for rebalancing a group, in DSU\n    mapping(address => mapping(uint256 => UFixed6)) public groupToMaxRebalanceFee;\n\n    /// @dev Creates instance of Controller\n    /// @param implementation_ Collateral account contract initialized with stablecoin addresses\n    constructor(address implementation_) Factory(implementation_) {\n        USDC = Account(implementation_).USDC();\n        DSU = Account(implementation_).DSU();\n    }\n\n    /// @inheritdoc IController\n    function initialize(\n        IMarketFactory marketFactory_,\n        IAccountVerifier verifier_\n    ) external initializer(1) {\n        __Factory__initialize();\n        marketFactory = marketFactory_;\n        verifier = verifier_;\n    }\n\n    /// @inheritdoc IController\n    function getAccountAddress(address owner) public view returns (address) {\n        // calculate the hash for an uninitialized account for the owner\n        return _computeCreate2Address(abi.encodeCall(Account.initialize, (owner)), SALT);\n    }\n\n    /// @inheritdoc IController\n    function changeRebalanceConfigWithSignature(\n        RebalanceConfigChange calldata configChange,\n        bytes calldata signature\n    ) virtual external {\n        _changeRebalanceConfigWithSignature(configChange, signature);\n    }\n\n    /// @inheritdoc IController\n    function checkGroup(address owner, uint256 group) public view returns (\n        Fixed6 groupCollateral,\n        bool canRebalance,\n        Fixed6[] memory imbalances\n    ) {\n        // query owner's collateral in each market and calculate sum\n        Fixed6[] memory actualCollateral;\n        (actualCollateral, groupCollateral) = _queryMarketCollateral(owner, group);\n        imbalances = new Fixed6[](actualCollateral.length);\n\n        // determine if anything is outside the rebalance threshold\n        for (uint256 i; i < actualCollateral.length; i++) {\n            IMarket market = groupToMarkets[owner][group][i];\n            RebalanceConfig memory marketRebalanceConfig = _rebalanceConfigs[owner][group][address(market)];\n            (bool canMarketRebalance, Fixed6 imbalance) =\n                RebalanceLib.checkMarket(marketRebalanceConfig, groupCollateral, actualCollateral[i]);\n            imbalances[i] = imbalance;\n            canRebalance = canRebalance || canMarketRebalance;\n        }\n    }\n\n    /// @inheritdoc IController\n    function deployAccount() public returns (IAccount) {\n        return _createAccount(msg.sender);\n    }\n\n    /// @inheritdoc IController\n    function deployAccountWithSignature(\n        DeployAccount calldata deployAccountAction,\n        bytes calldata signature\n    ) virtual external {\n        _deployAccountWithSignature(deployAccountAction, signature);\n    }\n\n    /// @inheritdoc IController\n    function marketTransferWithSignature(\n        MarketTransfer calldata marketTransfer,\n        bytes calldata signature\n    ) virtual external {\n        IAccount account = IAccount(getAccountAddress(marketTransfer.action.common.account));\n        _marketTransferWithSignature(account, marketTransfer, signature);\n    }\n\n    /// @inheritdoc IController\n    function rebalanceConfigs(\n        address owner,\n        uint256 group,\n        address market\n    ) external view returns (RebalanceConfig memory) {\n        return _rebalanceConfigs[owner][group][market];\n    }\n\n    /// @inheritdoc IController\n    function rebalanceGroupMarkets(\n        address owner,\n        uint256 group\n    ) external view returns (IMarket[] memory markets) {\n        markets = groupToMarkets[owner][group];\n    }\n\n    /// @inheritdoc IController\n    function withdrawWithSignature(Withdrawal calldata withdrawal, bytes calldata signature) virtual external {\n        IAccount account = IAccount(getAccountAddress(withdrawal.action.common.account));\n        _withdrawWithSignature(account, withdrawal, signature);\n    }\n\n    /// @inheritdoc IController\n    function rebalanceGroup(address owner, uint256 group) virtual external {\n        _rebalanceGroup(owner, group);\n    }\n\n    function _changeRebalanceConfigWithSignature(RebalanceConfigChange calldata configChange, bytes calldata signature) internal {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRebalanceConfigChange(configChange, signature);\n        _ensureValidSigner(configChange.action.common.account, configChange.action.common.signer);\n\n        // sum of the target allocations of all markets in the group\n        _updateRebalanceGroup(configChange, configChange.action.common.account);\n    }\n\n    function _createAccount(address owner) internal returns (IAccount account) {\n        account = Account(address(_create2(abi.encodeCall(Account.initialize, (owner)), SALT)));\n        emit AccountDeployed(owner, account);\n    }\n\n    /// @dev reverts if user is not authorized to sign transactions for the owner\n    function _ensureValidSigner(address owner, address signer) internal view {\n        if (signer != owner && !marketFactory.signers(owner, signer)) revert ControllerInvalidSignerError();\n    }\n\n    function _deployAccountWithSignature(\n        DeployAccount calldata deployAccount_,\n        bytes calldata signature\n    ) internal returns (IAccount account) {\n        address owner = deployAccount_.action.common.account;\n        verifier.verifyDeployAccount(deployAccount_, signature);\n        _ensureValidSigner(owner, deployAccount_.action.common.signer);\n\n        // create the account\n        account = _createAccount(owner);\n    }\n\n    function _marketTransferWithSignature(\n        IAccount account,\n        MarketTransfer calldata marketTransfer,\n        bytes calldata signature\n    ) internal {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyMarketTransfer(marketTransfer, signature);\n        _ensureValidSigner(marketTransfer.action.common.account, marketTransfer.action.common.signer);\n\n        // only Markets with DSU collateral are supported\n        IMarket market = IMarket(marketTransfer.market);\n        if (!market.token().eq(DSU)) revert ControllerUnsupportedMarketError(market);\n\n        account.marketTransfer(market, marketTransfer.amount);\n    }\n\n    function _withdrawWithSignature(\n        IAccount account,\n        Withdrawal calldata withdrawal,\n        bytes calldata signature\n    ) internal {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyWithdrawal(withdrawal, signature);\n        _ensureValidSigner(withdrawal.action.common.account, withdrawal.action.common.signer);\n\n        // call the account's implementation to push to owner\n        account.withdraw(withdrawal.amount, withdrawal.unwrap);\n    }\n\n    function _rebalanceGroup(address owner, uint256 group) internal {\n        // settles each markets, such that locals are up-to-date\n        _settleMarkets(owner, group);\n\n        // determine imbalances\n        (, bool canRebalance, Fixed6[] memory imbalances) = checkGroup(owner, group);\n        if (!canRebalance) revert ControllerGroupBalancedError();\n\n        IAccount account = IAccount(getAccountAddress(owner));\n        // pull collateral from markets with surplus collateral\n        for (uint256 i; i < imbalances.length; i++) {\n            IMarket market = groupToMarkets[owner][group][i];\n            if (Fixed6.unwrap(imbalances[i]) < 0) account.marketTransfer(market, imbalances[i]);\n        }\n\n        // push collateral to markets with insufficient collateral\n        for (uint256 i; i < imbalances.length; i++) {\n            IMarket market = groupToMarkets[owner][group][i];\n            if (Fixed6.unwrap(imbalances[i]) > 0) account.marketTransfer(market, imbalances[i]);\n        }\n\n        emit GroupRebalanced(owner, group);\n    }\n\n    /// @dev checks current collateral for each market in a group and aggregates collateral for the group\n    function _queryMarketCollateral(address owner, uint256 group) private view returns (\n        Fixed6[] memory actualCollateral,\n        Fixed6 groupCollateral\n    ) {\n        actualCollateral = new Fixed6[](groupToMarkets[owner][group].length);\n        for (uint256 i; i < actualCollateral.length; i++) {\n            Fixed6 collateral = groupToMarkets[owner][group][i].locals(owner).collateral;\n            actualCollateral[i] = collateral;\n            groupCollateral = groupCollateral.add(collateral);\n        }\n    }\n\n    /// @dev settles each market in a rebalancing group\n    function _settleMarkets(address owner, uint256 group) private {\n        for (uint256 i; i < groupToMarkets[owner][group].length; i++)\n            groupToMarkets[owner][group][i].settle(owner);\n    }\n\n    /// @dev overwrites rebalance configuration of all markets for a particular owner and group\n    /// @param message already-verified message with new configuration\n    /// @param owner identifies the owner of the collateral account\n    function _updateRebalanceGroup(\n        RebalanceConfigChange calldata message,\n        address owner\n    ) private {\n        // ensure group index is valid\n        if (message.group == 0 || message.group > MAX_GROUPS_PER_OWNER)\n            revert ControllerInvalidRebalanceGroupError();\n\n        if (message.markets.length > MAX_MARKETS_PER_GROUP)\n            revert ControllerInvalidRebalanceMarketsError();\n\n        // delete the existing group\n        for (uint256 i; i < groupToMarkets[owner][message.group].length; i++) {\n            address market = address(groupToMarkets[owner][message.group][i]);\n            delete _rebalanceConfigs[owner][message.group][market];\n            delete marketToGroup[owner][market];\n        }\n        delete groupToMarkets[owner][message.group];\n\n        UFixed6 totalAllocation;\n        for (uint256 i; i < message.markets.length; i++) {\n            // ensure market is not pointing to a different group\n            uint256 currentGroup = marketToGroup[owner][message.markets[i]];\n            if (currentGroup != 0)\n                revert ControllerMarketAlreadyInGroupError(IMarket(message.markets[i]), currentGroup);\n\n            // rewrite over all the old configuration\n            marketToGroup[owner][message.markets[i]] = message.group;\n            _rebalanceConfigs[owner][message.group][message.markets[i]] = message.configs[i];\n            groupToMarkets[owner][message.group].push(IMarket(message.markets[i]));\n            groupToMaxRebalanceFee[owner][message.group] = message.maxFee;\n\n            // ensure target allocation across all markets totals 100%\n            // read from storage to trap duplicate markets in the message\n            totalAllocation = totalAllocation.add(message.configs[i].target);\n\n            emit RebalanceMarketConfigured(owner, message.group, message.markets[i], message.configs[i]);\n        }\n\n        // if not deleting the group, ensure rebalance targets add to 100%\n        if (message.markets.length != 0 && !totalAllocation.eq(UFixed6Lib.ONE))\n            revert ControllerInvalidRebalanceTargetsError();\n\n        emit RebalanceGroupConfigured(owner, message.group, message.markets.length);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IMarket } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed18 } from \"@equilibria/root/number/types/UFixed18.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\n\n/// @notice Collateral Accounts allow users to manage collateral across Perennial markets\ninterface IAccount {\n    // sig: 0x9041f6c1\n    /// @custom:error Only the owner or the collateral account controller may withdraw\n    error AccountNotAuthorizedError();\n\n    /// @notice Sets owner, contract, and token addresses, and runs approvals for a collateral account\n    /// @param owner Address of the user for which the account was created\n    function initialize(address owner) external;\n\n    /// @notice Transfer USDC collateral from msg.sender to this account\n    /// @param amount Quantity of USDC to transfer in 6-decimal precision\n    function deposit(UFixed6 amount) external;\n\n    /// @notice used for transferring and rebalancing collateral\n    /// @param market Market to transfer funds to/from, which identifies the token\n    /// @param amount Quantity to deposit (positive) or withdraw (negative)\n    function marketTransfer(IMarket market, Fixed6 amount) external;\n\n    /// @notice Transfer USDC collateral from this account to the owner\n    /// @param amount Quantity of tokens to transfer in 6-decimal precision; set to UFixed6.MAX for full withdrawal\n    /// @param shouldUnwrap If amount exceeds USDC balance and this is true, DSU will be unwrapped as necessary to facilitate withdrawal\n    function withdraw(UFixed6 amount, bool shouldUnwrap) external;\n\n    /// @notice Converts a specified amount of USDC to DSU\n    /// @param amount Quantity of DSU to mint, in 18-decimal precision\n    function wrap(UFixed18 amount) external;\n\n    /// @notice Wraps if DSU balance is under a specified amount\n    /// @param amount Desired quantity of DSU\n    /// @param wrapAll True to wrap full USDC balance, false to wrap specified amount\n    function wrapIfNecessary(UFixed18 amount, bool wrapAll) external;\n\n    /// @notice Converts a specified amount of DSU to USDC\n    /// @param amount Quantity of DSU to burn, in 18-decimal precision\n    function unwrap(UFixed18 amount) external;\n}"
    },
    "@equilibria/perennial-v2-account/contracts/interfaces/IAccountVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IVerifierBase } from \"@equilibria/root/verifier/interfaces/IVerifierBase.sol\";\nimport { IRelayVerifier } from \"./IRelayVerifier.sol\";\nimport { Action } from \"../types/Action.sol\";\nimport { DeployAccount } from \"../types/DeployAccount.sol\";\nimport { MarketTransfer } from \"../types/MarketTransfer.sol\";\nimport { RebalanceConfigChange } from \"../types/RebalanceConfigChange.sol\";\nimport { Withdrawal } from \"../types/Withdrawal.sol\";\n\n/// @notice EIP712 signed message verifier for Perennial V2 Collateral Accounts.\ninterface IAccountVerifier is IVerifierBase, IRelayVerifier {\n    /// @notice Verifies the signature of no-op action message\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param action Data common to all action messages\n    /// @param signature EIP712 signature for the message\n    function verifyAction(Action calldata action, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a request to deploy a collateral account\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param deployAccount message to verify, which includes the owner of the collateral account\n    /// @param signature EIP712 signature for the message\n    function verifyDeployAccount(DeployAccount calldata deployAccount, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a request to transfer funds between a collateral account and a market\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param transfer message to verify\n    /// @param signature EIP712 signature for the message\n    function verifyMarketTransfer(MarketTransfer calldata transfer, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a request to change rebalancing configuration for multiple markets\n    /// @dev Cancels the nonce after verifying the signature\n    /// @param change message to verify\n    /// @param signature EIP712 signature for the message\n    function verifyRebalanceConfigChange(RebalanceConfigChange calldata change, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a request to transfer funds from the collateral account back to the owner\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param withdrawal message to verify, which includes the owner of the collateral account\n    /// @param signature EIP712 signature for the message\n    function verifyWithdrawal(Withdrawal calldata withdrawal, bytes calldata signature) external;\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { IMarketFactory } from \"@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol\";\n\nimport { IAccount, IMarket } from \"../interfaces/IAccount.sol\";\nimport { IAccountVerifier } from \"../interfaces/IAccountVerifier.sol\";\nimport { DeployAccount } from \"../types/DeployAccount.sol\";\nimport { MarketTransfer } from \"../types/MarketTransfer.sol\";\nimport { RebalanceConfig } from \"../types/RebalanceConfig.sol\";\nimport { RebalanceConfigChange } from \"../types/RebalanceConfigChange.sol\";\nimport { Withdrawal } from \"../types/Withdrawal.sol\";\n\n/// @notice Facilitates unpermissioned actions between collateral accounts and markets\ninterface IController {\n    /// @notice Emitted when a collateral account is deployed\n    /// @param owner EOA for whom the collateral account was created\n    /// @param account contract address of the collateral account\n    event AccountDeployed(address indexed owner, IAccount indexed account);\n\n    /// @notice Emitted when a group has been rebalanced\n    /// @param owner Owner of the collateral account for which the rebalance group was created or modified\n    /// @param group Identifies the rebalance group within context of owner\n    event GroupRebalanced(address indexed owner, uint256 indexed group);\n\n    /// @notice Emitted when a rebalance group is created or updated\n    /// @param owner Owner of the collateral account for which the rebalance group was created or modified\n    /// @param group Identifies the rebalance group within context of owner\n    /// @param markets Number of markets in the group (0 if group was deleted)\n    event RebalanceGroupConfigured(address indexed owner, uint256 indexed group, uint256 markets);\n\n    /// @notice Emitted for each market in a rebalance group upon creation of the group\n    /// or when any changes are made to the group\n    /// @param owner Owner of the collateral account for which the rebalance group was created or modified\n    /// @param group Identifies the rebalance group within context of owner\n    /// @param market The Perennial market for which this configuration applies\n    /// @param newConfig Rebalance configuration for the market, which may or may not have changed\n    event RebalanceMarketConfigured(\n        address indexed owner,\n        uint256 indexed group,\n        address indexed market,\n        RebalanceConfig newConfig\n    );\n\n    // sig: 0xdc72f280\n    /// @custom:error Group is balanced and ineligible for rebalance\n    error ControllerGroupBalancedError();\n\n    // sig: 0xbd3648e9\n    /// @custom:error A RebalanceConfigChange message had a mismatch in number of markets and configs\n    error ControllerInvalidRebalanceConfigError();\n\n    // sig: 0xa16ba7f2\n    /// @custom:error Group number was out-of-range; each collateral account may have up to 8 groups, indexed 1-8\n    error ControllerInvalidRebalanceGroupError();\n\n    // sig: 0xecce9fda\n    /// @custom:error Group has too many markets; each group may have 1-4 markets\n    error ControllerInvalidRebalanceMarketsError();\n\n    // sig: 0x64580a1c\n    /// @custom:error The sum of `target` collateral allocations for each market in a group does not total 100%.\n    /// This could also indicate a duplicate market was in the list.\n    error ControllerInvalidRebalanceTargetsError();\n\n    // sig: 0x43e749f8\n    /// @custom:error Signer is not authorized to interact with the specified collateral account\n    error ControllerInvalidSignerError();\n\n    // sig: 0xa4a79a03\n    /// @custom:error A market in this rebalancing configuration is already a member of a different group\n    /// @param market Identifies which market in the message which is causing the problem\n    /// @param group Identifies the group in which the aforementioned market is a member\n    error ControllerMarketAlreadyInGroupError(IMarket market, uint256 group);\n\n    // sig: 0xdcca49cd\n    /// @custom:error Attempt to interact with a Market which does not use DSU as collateral\n    /// @param market Market with non-DSU collateral\n    error ControllerUnsupportedMarketError(IMarket market);\n\n    /// @dev Contract used to validate delegated signers and relay certain messages\n    function marketFactory() external view returns (IMarketFactory);\n\n    /// @dev Contract used to validate message signatures\n    function verifier() external view returns (IAccountVerifier);\n\n    /// @notice Sets contract addresses used for message verification and token management\n    /// @param marketFactory Contract used to validate delegated signers\n    /// @param verifier Contract used to validate collateral account message signatures\n    function initialize(\n        IMarketFactory marketFactory,\n        IAccountVerifier verifier\n    ) external;\n\n    /// @notice Returns the deterministic address of the collateral account for a user,\n    /// regardless of whether or not it exists.\n    /// @param owner Identifies the user whose collateral account address is desired\n    function getAccountAddress(address owner) external view returns (address);\n\n    /// @notice Deploys the collateral account for msg.sender and returns the address of the account\n    function deployAccount() external returns (IAccount);\n\n    /// @notice Deploys a collateral account via a signed message\n    /// @param deployAccountAction Message requesting creation of a collateral account\n    /// @param signature ERC712 message signature\n    function deployAccountWithSignature(DeployAccount calldata deployAccountAction, bytes calldata signature) external;\n\n    /// @notice Transfers tokens between a collateral account and a specified Perennial Market\n    /// @param marketTransfer Message requesting a deposit to or withdrawal from the Market\n    /// @param signature ERC712 message signature\n    function marketTransferWithSignature(MarketTransfer calldata marketTransfer, bytes calldata signature) external;\n\n    /// @notice Adjusts the rebalancing configuration of one or more markets\n    /// @param configChange Message with new rebalance group configuration\n    /// @param signature ERC712 message signature\n    function changeRebalanceConfigWithSignature(RebalanceConfigChange calldata configChange,\n        bytes calldata signature) external;\n\n    /// @notice Checks all markets in a rebalance group to see if anything may be rebalanced\n    /// @param owner User whose collateral account may be rebalanced using this group\n    /// @param group Identifies the group within the context of the owner\n    /// @return groupCollateral Sum of ower's collateral across each market in the group\n    /// @return canRebalance True if one or more markets in the group are eligible for rebalancing\n    /// @return imbalances The difference between target and actual collateral for each market\n    function checkGroup(address owner, uint256 group) external view returns (\n        Fixed6 groupCollateral,\n        bool canRebalance,\n        Fixed6[] memory imbalances\n    );\n\n    /// @notice Called by keepers to rebalance an unbalanced group\n    /// @param owner User whose collateral account may be rebalanced using this group\n    /// @param group Identifies the group within the context of the owner\n    function rebalanceGroup(address owner, uint256 group) external;\n\n    /// @notice Retrieves rebalance configuration for a specified owner, group, and market\n    /// @param owner User for whom the collateral account was created\n    /// @param group Identifies a collection of markets, each with their own configuration\n    /// @param market Identifies which Perennial market for which the configuration is desired\n    function rebalanceConfigs(\n        address owner,\n        uint256 group,\n        address market\n    ) external view returns (RebalanceConfig memory);\n\n    /// @notice Retrieves array of markets in an owner's rebalance group\n    /// @param owner User for whom the collateral account was created\n    /// @param group Identifies which collection of markets is desired for the owner\n    /// @return markets Array containing each market in the rebalance group\n    function rebalanceGroupMarkets(\n        address owner,\n        uint256 group\n    ) external view returns (IMarket[] memory markets);\n\n    /// @notice Transfers tokens from the collateral account back to the owner of the account\n    /// @param withdrawal Message requesting a withdrawal\n    /// @param signature ERC712 message signature\n    function withdrawWithSignature(Withdrawal calldata withdrawal, bytes calldata signature) external;\n}"
    },
    "@equilibria/perennial-v2-account/contracts/interfaces/IRelayer.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { RelayedNonceCancellation } from \"../types/RelayedNonceCancellation.sol\";\nimport { RelayedGroupCancellation } from \"../types/RelayedGroupCancellation.sol\";\nimport { RelayedOperatorUpdate } from \"../types/RelayedOperatorUpdate.sol\";\nimport { RelayedSignerUpdate } from \"../types/RelayedSignerUpdate.sol\";\nimport { RelayedAccessUpdateBatch } from \"../types/RelayedAccessUpdateBatch.sol\";\n\n// @notice Relays messages to downstream handlers, compensating keepers for the transaction\ninterface IRelayer {\n    /// @notice Relays a message to Verifier extension to invalidate a nonce\n    /// @param message Request with details needed for keeper compensation\n    /// @param outerSignature Signature of the RelayedNonceCancellation message\n    /// @param innerSignature Signature of the embedded Common message\n    function relayNonceCancellation(\n        RelayedNonceCancellation calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) external;\n\n    /// @notice Relays a message to Verifier extension to invalidate a group nonce\n    /// @param message Request with details needed for keeper compensation\n    /// @param outerSignature Signature of the RelayedGroupCancellation message\n    /// @param innerSignature Signature of the embedded GroupCancellation message\n    function relayGroupCancellation(\n        RelayedGroupCancellation calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) external;\n\n    /// @notice Relays a message to MarketFactory to update status of an operator\n    /// @param message Request with details needed for keeper compensation\n    /// @param outerSignature Signature of the RelayedOperatorUpdate message\n    /// @param innerSignature Signature of the embedded OperatorUpdate message\n    function relayOperatorUpdate(\n        RelayedOperatorUpdate calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) external;\n\n    /// @notice Relays a message to MarketFactory to update status of a delegated signer\n    /// @param message Request with details needed for keeper compensation\n    /// @param outerSignature Signature of the RelayedSignerUpdate message\n    /// @param innerSignature Signature of the embedded SignerUpdate message\n    function relaySignerUpdate(\n        RelayedSignerUpdate calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) external;\n\n    /// @notice Relays a message to MarketFactory to update multiple operators and signers\n    /// @param message Request with details needed for keeper compensation\n    /// @param outerSignature Signature of the RelayedAccessUpdateBatch message\n    /// @param innerSignature Signature of the embedded AccessUpdateBatch message\n    function relayAccessUpdateBatch(\n        RelayedAccessUpdateBatch calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) external;\n}"
    },
    "@equilibria/perennial-v2-account/contracts/interfaces/IRelayVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IVerifierBase } from \"@equilibria/root/verifier/interfaces/IVerifierBase.sol\";\nimport { RelayedNonceCancellation } from \"../types/RelayedNonceCancellation.sol\";\nimport { RelayedGroupCancellation } from \"../types/RelayedGroupCancellation.sol\";\nimport { RelayedOperatorUpdate } from \"../types/RelayedOperatorUpdate.sol\";\nimport { RelayedSignerUpdate } from \"../types/RelayedSignerUpdate.sol\";\nimport { RelayedAccessUpdateBatch } from \"../types/RelayedAccessUpdateBatch.sol\";\n\n/// @notice EIP712 signed message verifier for relaying messages through Collateral Accounts Controller.\ninterface IRelayVerifier is IVerifierBase {\n    /// @dev Verifies a request to relay a nonce cancellation request\n    /// @param message Wrapped message adding details needed for keeper compensation\n    /// @param outerSignature EIP712 signature for the preceeding message\n    function verifyRelayedNonceCancellation(\n        RelayedNonceCancellation calldata message,\n        bytes calldata outerSignature\n    ) external;\n\n    /// @dev Verifies a request to relay a group nonce cancellation request\n    /// @param message Wrapped message adding details needed for keeper compensation\n    /// @param outerSignature EIP712 signature for the preceeding message\n    function verifyRelayedGroupCancellation(\n        RelayedGroupCancellation calldata message,\n        bytes calldata outerSignature\n    ) external;\n\n    /// @dev Verifies a request to relay an operator update\n    /// @param message Wrapped message adding details needed for keeper compensation\n    /// @param outerSignature EIP712 signature for the preceeding message\n    function verifyRelayedOperatorUpdate(\n        RelayedOperatorUpdate calldata message,\n        bytes calldata outerSignature\n    ) external;\n\n    /// @dev Verifies a request to relay an update to designated signers\n    /// @param message Wrapped message adding details needed for keeper compensation\n    /// @param outerSignature EIP712 signature for the preceeding message\n    function verifyRelayedSignerUpdate(\n        RelayedSignerUpdate calldata message,\n        bytes calldata outerSignature\n    ) external;\n\n    /// @dev Verifies a request to relay a message updating multiple operators and signers\n    /// @param message Wrapped message adding details needed for keeper compensation\n    /// @param outerSignature EIP712 signature for the preceeding message\n    function verifyRelayedAccessUpdateBatch(\n        RelayedAccessUpdateBatch calldata message,\n        bytes calldata outerSignature\n    ) external;\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/libs/RebalanceLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { IController } from \"../interfaces/IController.sol\";\nimport { RebalanceConfig } from \"../types/RebalanceConfig.sol\";\n\n/// @title RebalanceLib\n/// @notice Facilities for rebalancing collateral accounts\nlibrary RebalanceLib {\n    /// @dev Compares actual market collateral for owner with their account's target\n    /// @param marketConfig Rebalance group configuration for this market\n    /// @param groupCollateral Owner's collateral across all markets in the group\n    /// @param marketCollateral Owner's actual amount of collateral in this market\n    /// @return canRebalance True if actual collateral in this market is outside of configured threshold\n    /// @return imbalance Amount which needs to be transferred to balance the market\n    function checkMarket(\n        RebalanceConfig memory marketConfig,\n        Fixed6 groupCollateral,\n        Fixed6 marketCollateral\n    ) external pure returns (bool canRebalance, Fixed6 imbalance) {\n        // determine how much collateral the market should have\n        Fixed6 targetCollateral = groupCollateral.mul(Fixed6Lib.from(marketConfig.target));\n\n        // if market is empty, prevent divide-by-zero condition\n        if (marketCollateral.eq(Fixed6Lib.ZERO)) return (false, targetCollateral);\n        // calculate percentage difference between target and actual collateral\n        Fixed6 pctFromTarget = Fixed6Lib.ONE.sub(targetCollateral.div(marketCollateral));\n        // if this percentage exceeds the configured threshold, the market may be rebelanced\n        canRebalance = pctFromTarget.abs().gt(marketConfig.threshold);\n\n        // return negative number for surplus, positive number for deficit\n        imbalance = targetCollateral.sub(marketCollateral);\n    }\n}"
    },
    "@equilibria/perennial-v2-account/contracts/types/Action.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @notice Fields which need to be hashed for each collateral account action\nstruct Action {\n    /// @dev Largest amount to compensate relayer/keeper for the transaction in DSU\n    UFixed6 maxFee;\n    /// @dev Information shared across all EIP712 collateral account actions;\n    /// populate common.account with the owner of the collateral account\n    Common common;\n}\nusing ActionLib for Action global;\n\n/// @title ActionLib\n/// @notice Library used to hash and verifiy fields common to all collateral-account-related messages\nlibrary ActionLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(Action memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.maxFee, CommonLib.hash(self.common)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/types/DeployAccount.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct DeployAccount {\n    /// @dev Common information for collateral account actions\n    Action action;\n}\nusing DeployAccountLib for DeployAccount global;\n\n/// @title DeployAccountLib\n/// @notice Library used to hash and verify action to deploy a collateral account\nlibrary DeployAccountLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"DeployAccount(Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(DeployAccount memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, ActionLib.hash(self.action)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/types/MarketTransfer.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct MarketTransfer {\n    /// @dev Identifies the market to which funds should be sent\n    address market;\n    /// @dev Amount to deposit (positive) or withdraw (negative);\n    /// set to Fixed6Lib.MIN to fully withdraw from market.\n    Fixed6 amount;\n    /// @dev Common information for collateral account actions\n    Action action;\n}\nusing MarketTransferLib for MarketTransfer global;\n\n/// @title MarketTransferLib\n/// @notice Library used to hash and verify action to move funds to/from a market\nlibrary MarketTransferLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"MarketTransfer(address market,int256 amount,Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(MarketTransfer memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.market, self.amount, ActionLib.hash(self.action)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/types/RebalanceConfig.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev Rebalancing configuration for a single market\nstruct RebalanceConfig {\n    /// @dev Percentage of collateral from the group to deposit into the market\n    UFixed6 target;\n    /// @dev Percentage away from the target at which keepers may rebalance\n    UFixed6 threshold;\n}\n\nstruct RebalanceConfigStorage { uint256 slot0; }\nusing RebalanceConfigLib for RebalanceConfigStorage global;\n\n/// @title RebalanceConfigLib\n/// @notice Library used to hash and manage storage for rebalancing configuration for a single market\nlibrary RebalanceConfigLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RebalanceConfig(uint256 target,uint256 threshold)\"\n    );\n\n    /// sig: 0xd673935e\n    error RebalanceConfigStorageInvalidError();\n\n    /// @dev hashes this instance for inclusion in an EIP-712 message\n    function hash(RebalanceConfig memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.target, self.threshold));\n    }\n\n    /// @dev extracts two unsigned values from a single storage slot\n    function read(RebalanceConfigStorage storage self) internal view returns (RebalanceConfig memory) {\n        uint256 slot0 = self.slot0;\n        return RebalanceConfig(\n            UFixed6.wrap(uint256(slot0 << (256 - 32)) >> (256 - 32)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32)) >> (256 - 32))\n        );\n    }\n\n    /// @dev ensures values do not exceed 100% and writes them to a single storage slot\n    function store(RebalanceConfigStorage storage self, RebalanceConfig memory newValue) external {\n        if (newValue.target.gt(UFixed6Lib.ONE)) revert RebalanceConfigStorageInvalidError();\n        if (newValue.threshold.gt(UFixed6Lib.ONE)) revert RebalanceConfigStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(UFixed6.unwrap(newValue.target)    << (256 - 32)) >> (256 - 32) |\n            uint256(UFixed6.unwrap(newValue.threshold) << (256 - 32)) >> (256 - 32 - 32);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/types/RebalanceConfigChange.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\nimport { RebalanceConfig, RebalanceConfigLib } from \"./RebalanceConfig.sol\";\nimport { IController } from \"../interfaces/IController.sol\";\n\n/// @dev Action message to change configuration for a group of markets\nstruct RebalanceConfigChange {\n    /// @dev Identifies which group to change; indexed 1-8\n    uint256 group;\n    /// @dev List of 1-4 markets in which collateral shall be managed.\n    /// Markets may be added to or removed from an existing group. Leave empty to delete the group.\n    address[] markets;\n    /// @dev Target allocation for markets in the aforementioned array\n    RebalanceConfig[] configs;\n    /// @dev Largest amount to compensate a relayer/keeper for rebalancing the group in DSU\n    UFixed6 maxFee;\n    /// @dev Common information for collateral account actions\n    Action action;\n}\nusing RebalanceConfigChangeLib for RebalanceConfigChange global;\n\n/// @title RebalanceConfigChangeLib\n/// @notice Library used to hash and verify action to change rebalancing configuration\nlibrary RebalanceConfigChangeLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RebalanceConfigChange(uint256 group,address[] markets,RebalanceConfig[] configs,uint256 maxFee,Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n        \"RebalanceConfig(uint256 target,uint256 threshold)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RebalanceConfigChange memory self) internal pure returns (bytes32) {\n        bytes32[] memory encodedAddresses = new bytes32[](self.markets.length);\n        bytes32[] memory encodedConfigs = new bytes32[](self.configs.length);\n\n        // ensure consistent error for length mismatch\n        if (self.markets.length != self.configs.length)\n            revert IController.ControllerInvalidRebalanceConfigError();\n\n        for (uint256 i = 0; i < self.markets.length; ++i) {\n            encodedAddresses[i] = keccak256(abi.encode(self.markets[i]));\n            encodedConfigs[i] = RebalanceConfigLib.hash(self.configs[i]);\n        }\n        return keccak256(abi.encode(\n            STRUCT_HASH,\n            self.group,\n            keccak256(abi.encodePacked(self.markets)),\n            keccak256(abi.encodePacked(encodedConfigs)),\n            self.maxFee,\n            ActionLib.hash(self.action)\n        ));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/types/RelayedAccessUpdateBatch.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AccessUpdateBatch, AccessUpdateBatchLib } from \"@equilibria/perennial-v2-verifier/contracts/types/AccessUpdateBatch.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct RelayedAccessUpdateBatch {\n    /// @dev Message to relay to MarketFactory\n    AccessUpdateBatch accessUpdateBatch;\n    /// @dev Common information for relayed actions\n    Action action;\n}\nusing RelayedAccessUpdateBatchLib for RelayedAccessUpdateBatch global;\n\n/// @title RelayedAccessUpdateBatchLib\n/// @notice Library used to hash and verify action to relay a message to change status of operators and signers\nlibrary RelayedAccessUpdateBatchLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RelayedAccessUpdateBatch(AccessUpdateBatch accessUpdateBatch,Action action)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"AccessUpdateBatch(AccessUpdate[] operators,AccessUpdate[] signers,Common common)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RelayedAccessUpdateBatch memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, AccessUpdateBatchLib.hash(self.accessUpdateBatch), ActionLib.hash(self.action)));\n    }\n}"
    },
    "@equilibria/perennial-v2-account/contracts/types/RelayedGroupCancellation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { GroupCancellation, GroupCancellationLib } from \"@equilibria/root/verifier/types/GroupCancellation.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct RelayedGroupCancellation {\n    /// @dev Message to relay to verifier, identifying the group to cancel\n    GroupCancellation groupCancellation;\n    /// @dev Common information for relayed actions\n    Action action;\n}\nusing RelayedGroupCancellationLib for RelayedGroupCancellation global;\n\n/// @title RelayedGroupCancellationLib\n/// @notice Library used to hash and verify action to relay a message to cancel a group\nlibrary RelayedGroupCancellationLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RelayedGroupCancellation(GroupCancellation groupCancellation,Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n        \"GroupCancellation(uint256 group,Common common)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RelayedGroupCancellation memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, GroupCancellationLib.hash(self.groupCancellation), ActionLib.hash(self.action)));\n    }\n}"
    },
    "@equilibria/perennial-v2-account/contracts/types/RelayedNonceCancellation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct RelayedNonceCancellation {\n    /// @dev Message to relay to verifier, identifying the nonce to cancel\n    Common nonceCancellation;\n    /// @dev Common information for relayed actions\n    Action action;\n}\nusing RelayedNonceCancellationLib for RelayedNonceCancellation global;\n\n/// @title RelayedNonceCancellationLib\n/// @notice Library used to hash and verify action to relay a message to cancel a nonce\nlibrary RelayedNonceCancellationLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RelayedNonceCancellation(Common nonceCancellation,Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RelayedNonceCancellation memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, CommonLib.hash(self.nonceCancellation), ActionLib.hash(self.action)));\n    }\n}"
    },
    "@equilibria/perennial-v2-account/contracts/types/RelayedOperatorUpdate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { OperatorUpdate, OperatorUpdateLib } from \"@equilibria/perennial-v2-verifier/contracts/types/OperatorUpdate.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct RelayedOperatorUpdate {\n    /// @dev Message to relay to MarketFactory\n    OperatorUpdate operatorUpdate;\n    /// @dev Common information for relayed actions\n    Action action;\n}\nusing RelayedOperatorUpdateLib for RelayedOperatorUpdate global;\n\n/// @title RelayedOperatorUpdateLib\n/// @notice Library used to hash and verify action to relay a message to update an operator\nlibrary RelayedOperatorUpdateLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RelayedOperatorUpdate(OperatorUpdate operatorUpdate,Action action)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n        \"OperatorUpdate(AccessUpdate access,Common common)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RelayedOperatorUpdate memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, OperatorUpdateLib.hash(self.operatorUpdate), ActionLib.hash(self.action)));\n    }\n}"
    },
    "@equilibria/perennial-v2-account/contracts/types/RelayedSignerUpdate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { SignerUpdate, SignerUpdateLib } from \"@equilibria/perennial-v2-verifier/contracts/types/SignerUpdate.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct RelayedSignerUpdate {\n    /// @dev Message to relay to MarketFactory\n    SignerUpdate signerUpdate;\n    /// @dev Common information for relayed actions\n    Action action;\n}\nusing RelayedSignerUpdateLib for RelayedSignerUpdate global;\n\n/// @title RelayedSignerUpdateLib\n/// @notice Library used to hash and verify action to relay a message to update a signer\nlibrary RelayedSignerUpdateLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RelayedSignerUpdate(SignerUpdate signerUpdate,Action action)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n        \"SignerUpdate(AccessUpdate access,Common common)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RelayedSignerUpdate memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, SignerUpdateLib.hash(self.signerUpdate), ActionLib.hash(self.action)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-account/contracts/types/Withdrawal.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct Withdrawal {\n    /// @dev Quantity to transfer from account to owner; set to UFixed6.MAX for full withdrawal\n    UFixed6 amount;\n    /// @dev True unwrap DSU to USDC as needed to satisfy specified withdrawal amount\n    bool unwrap;\n    /// @dev Common information for collateral account actions;\n    /// set action.common.account to the owner of the collateral account\n    Action action;\n}\nusing WithdrawalLib for Withdrawal global;\n\n/// @title WithdrawalLib\n/// @notice Library used to hash and verify action to withdraw from a collateral account\nlibrary WithdrawalLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"Withdrawal(uint256 amount,bool unwrap,Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(Withdrawal memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.amount, self.unwrap, ActionLib.hash(self.action)));\n    }\n}"
    },
    "@equilibria/perennial-v2-extensions/contracts/Coordinator.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { Ownable } from \"@equilibria/root/attribute/Ownable.sol\";\nimport { ICoordinator, IMarket, RiskParameter, Token18 } from \"./interfaces/ICoordinator.sol\";\n\n/// @title Coordinator\n/// @notice Manages claiming fees and updating risk parameters for markets\ncontract Coordinator is ICoordinator, Ownable {\n    /// @dev The address of the comptroller (who can claim the fee)\n    address public comptroller;\n\n    /// @dev The address of the coordinator (who can update risk parameters)\n    address public coordinator;\n\n    /// @notice Constructs the contract\n    constructor() {\n        __Ownable__initialize();\n    }\n\n    /// @notice Updates the comptroller\n    /// @param comptroller_ The address of the new comptroller\n    function setComptroller(address comptroller_) external onlyOwner {\n        comptroller = comptroller_;\n        emit ComptrollerSet(comptroller_);\n    }\n\n    /// @notice Updates the coordinator\n    /// @param coordinator_ The address of the new coordinator\n    function setCoordinator(address coordinator_) external onlyOwner {\n        coordinator = coordinator_;\n        emit CoordinatorSet(coordinator_);\n    }\n\n    /// @notice Claims the fee for a market\n    /// @param market The market to claim the fee for\n    function claimFee(IMarket market) external {\n        if (msg.sender != comptroller) revert NotComptroller();\n        market.claimFee(msg.sender);\n        market.token().push(comptroller);\n    }\n\n    /// @notice Updates the risk parameter for a market\n    /// @param market The market to update the risk parameter for\n    /// @param riskParameter The new risk parameter\n    function updateRiskParameter(IMarket market, RiskParameter calldata riskParameter) external {\n        if (msg.sender != coordinator) revert NotCoordinator();\n        market.updateRiskParameter(riskParameter);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-extensions/contracts/interfaces/ICoordinator.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { IMarket, RiskParameter } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\n\ninterface ICoordinator {\n    function setComptroller(address comptroller) external;\n    function setCoordinator(address coordinator) external;\n    function claimFee(IMarket market) external;\n    function updateRiskParameter(IMarket market, RiskParameter calldata riskParameter) external;\n\n    event ComptrollerSet(address comptroller);\n    event CoordinatorSet(address coordinator);\n\n    error NotComptroller();\n    error NotCoordinator();\n    error NotFeeWithdrawer();\n}\n"
    },
    "@equilibria/perennial-v2-extensions/contracts/interfaces/IMultiInvoker.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\nimport {\n    IFactory,\n    IMarket,\n    Position,\n    Local,\n    UFixed18Lib,\n    UFixed18,\n    OracleVersion,\n    RiskParameter\n} from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { IBatcher } from \"@equilibria/emptyset-batcher/interfaces/IBatcher.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { TriggerOrder } from \"../types/TriggerOrder.sol\";\nimport { InterfaceFee } from \"../types/InterfaceFee.sol\";\n\ninterface IMultiInvoker {\n    enum PerennialAction {\n        NO_OP,           // 0\n        UPDATE_POSITION, // 1\n        UPDATE_VAULT,    // 2\n        PLACE_ORDER,     // 3\n        CANCEL_ORDER,    // 4\n        EXEC_ORDER,      // 5\n        COMMIT_PRICE,    // 6\n        __LIQUIDATE__DEPRECATED,\n        APPROVE,         // 8\n        UPDATE_INTENT,   // 9\n        CLAIM_FEE        // 10\n    }\n\n    struct Invocation {\n        PerennialAction action;\n        bytes args;\n    }\n\n    event OperatorUpdated(address indexed account, address indexed operator, bool newEnabled);\n    event KeeperFeeCharged(address indexed account, address indexed market, address indexed to, UFixed6 fee);\n    event OrderPlaced(address indexed account, IMarket indexed market, uint256 indexed nonce, TriggerOrder order);\n    event OrderExecuted(address indexed account, IMarket indexed market, uint256 nonce);\n    event OrderCancelled(address indexed account, IMarket indexed market, uint256 nonce);\n    event InterfaceFeeCharged(address indexed account, IMarket indexed market, InterfaceFee fee);\n\n    // sig: 0x42ecdedb\n    error MultiInvokerUnauthorizedError();\n    // sig: 0x88d67968\n    error MultiInvokerOrderMustBeSingleSidedError();\n    // sig: 0xbccd78e7\n    error MultiInvokerMaxFeeExceededError();\n    // sig: 0x47b7c1b0\n    error MultiInvokerInvalidInstanceError();\n    // sig: 0xb6befb58\n    error MultiInvokerInvalidOrderError();\n    // sig: 0x6f462962\n    error MultiInvokerCantExecuteError();\n\n    function updateOperator(address operator, bool newEnabled) external;\n    function operators(address account, address operator) external view returns (bool);\n    function invoke(address account, Invocation[] calldata invocations) external payable;\n    function invoke(Invocation[] calldata invocations) external payable;\n    function marketFactory() external view returns (IFactory);\n    function vaultFactory() external view returns (IFactory);\n    function batcher() external view returns (IBatcher);\n    function reserve() external view returns (IEmptySetReserve);\n    function keepBufferBase() external view returns (uint256);\n    function keepBufferCalldata() external view returns (uint256);\n    function latestNonce() external view returns (uint256);\n    function orders(address account, IMarket market, uint256 nonce) external view returns (TriggerOrder memory);\n    function canExecuteOrder(address account, IMarket market, uint256 nonce) external view returns (bool);\n}"
    },
    "@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Kept/Kept_Arbitrum.sol\";\nimport \"./MultiInvoker.sol\";\n\n/// @title MultiInvoker_Arbitrum\n/// @notice Arbitrum Kept MultiInvoker implementation.\n/// @dev Additionally incentivizes keepers with L1 rollup fees according to the Arbitrum spec\ncontract MultiInvoker_Arbitrum is MultiInvoker, Kept_Arbitrum {\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        uint256 keepBufferBase_,\n        uint256 keepBufferCalldata_\n    ) MultiInvoker(\n        usdc_,\n        dsu_,\n        marketFactory_,\n        vaultFactory_,\n        batcher_,\n        reserve_,\n        keepBufferBase_,\n        keepBufferCalldata_\n    ) { }\n\n    /// @dev Use the Kept_Arbitrum implementation for calculating the dynamic fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view override(Kept_Arbitrum, Kept) returns (UFixed18) {\n        return Kept_Arbitrum._calldataFee(applicableCalldata, multiplierCalldata, bufferCalldata);\n    }\n\n    /// @dev Use the PythOracle implementation for raising the keeper fee\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal override(MultiInvoker, Kept) returns (UFixed18) {\n        return MultiInvoker._raiseKeeperFee(amount, data);\n    }\n}"
    },
    "@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Optimism.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Kept/Kept_Optimism.sol\";\nimport \"./MultiInvoker.sol\";\n\n/// @title MultiInvoker_Optimism\n/// @notice Optimism Kept MultiInvoker implementation.\n/// @dev Additionally incentivizes keepers with L1 rollup fees according to the Optimism spec\ncontract MultiInvoker_Optimism is MultiInvoker, Kept_Optimism {\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        uint256 keepBufferBase_,\n        uint256 keepBufferCalldata_\n    ) MultiInvoker(\n        usdc_,\n        dsu_,\n        marketFactory_,\n        vaultFactory_,\n        batcher_,\n        reserve_,\n        keepBufferBase_,\n        keepBufferCalldata_\n    ) { }\n\n    /// @dev Use the Kept_Optimism implementation for calculating the dynamic fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view override(Kept_Optimism, Kept) returns (UFixed18) {\n        return Kept_Optimism._calldataFee(applicableCalldata, multiplierCalldata, bufferCalldata);\n    }\n\n    /// @dev Use the PythOracle implementation for raising the keeper fee\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal override(MultiInvoker, Kept) returns (UFixed18) {\n        return MultiInvoker._raiseKeeperFee(amount, data);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-extensions/contracts/MultiInvoker.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { IFactory } from \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport { IBatcher } from \"@equilibria/emptyset-batcher/interfaces/IBatcher.sol\";\nimport { IInstance } from \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport { IPythFactory } from \"@equilibria/perennial-v2-oracle/contracts/interfaces/IPythFactory.sol\";\nimport { IVault } from \"@equilibria/perennial-v2-vault/contracts/interfaces/IVault.sol\";\nimport \"./interfaces/IMultiInvoker.sol\";\nimport \"./types/TriggerOrder.sol\";\nimport \"./types/InterfaceFee.sol\";\nimport \"@equilibria/root/attribute/Kept/Kept.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title MultiInvoker\n/// @notice Extension to handle batched calls to the Perennial protocol\ncontract MultiInvoker is IMultiInvoker, Kept {\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Protocol factory to validate market approvals\n    IFactory public immutable marketFactory;\n\n    /// @dev Vault factory to validate vault approvals\n    IFactory public immutable vaultFactory;\n\n    /// @dev Batcher address\n    IBatcher public immutable batcher;\n\n    /// @dev Reserve address\n    IEmptySetReserve public immutable reserve;\n\n    /// @dev The fixed gas buffer that is added to the keeper fee\n    uint256 public immutable keepBufferBase;\n\n    /// @dev The fixed gas buffer that is added to the calldata portion of the keeper fee\n    uint256 public immutable keepBufferCalldata;\n\n    /// @dev UID for an order\n    uint256 public latestNonce;\n\n    /// @dev State for the order data\n    mapping(address => mapping(IMarket => mapping(uint256 => TriggerOrderStorage))) private _orders;\n\n    /// @dev Mapping of allowed operators for each account\n    mapping(address => mapping(address => bool)) public operators;\n\n    /// @notice Constructs the MultiInvoker contract\n    /// @param usdc_ USDC stablecoin address\n    /// @param dsu_ DSU address\n    /// @param marketFactory_ Protocol factory to validate market approvals\n    /// @param vaultFactory_ Protocol factory to validate vault approvals\n    /// @param batcher_ Batcher address\n    /// @param reserve_ Reserve address\n    /// @param keepBufferBase_ The fixed gas buffer that is added to the keeper fee\n    /// @param keepBufferCalldata_ The fixed calldata buffer that is added to the keeper fee\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        uint256 keepBufferBase_,\n        uint256 keepBufferCalldata_\n    ) {\n        USDC = usdc_;\n        DSU = dsu_;\n        marketFactory = marketFactory_;\n        vaultFactory = vaultFactory_;\n        batcher = batcher_;\n        reserve = reserve_;\n        keepBufferBase = keepBufferBase_;\n        keepBufferCalldata = keepBufferCalldata_;\n    }\n\n    /// @notice Initialize the contract\n    /// @param ethOracle_ Chainlink ETH/USD oracle address\n    function initialize(AggregatorV3Interface ethOracle_) external initializer(2) {\n        __Kept__initialize(ethOracle_, DSU);\n\n        if (address(batcher) != address(0)) {\n            DSU.approve(address(batcher));\n            USDC.approve(address(batcher));\n        }\n\n        DSU.approve(address(reserve));\n        USDC.approve(address(reserve));\n    }\n\n    /// @notice View function to get order state\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    function orders(address account, IMarket market, uint256 nonce) public view returns (TriggerOrder memory) {\n        return _orders[account][market][nonce].read();\n    }\n\n    /// @notice Returns whether an order can be executed\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    /// @return canFill Whether the order can be executed\n    function canExecuteOrder(address account, IMarket market, uint256 nonce) public view returns (bool) {\n        TriggerOrder memory order = orders(account, market, nonce);\n        if (order.fee.isZero()) return false;\n\n        return order.fillable(market.oracle().latest());\n    }\n\n    /// @notice Updates the status of an operator for the caller\n    /// @param operator The operator to update\n    /// @param newEnabled The new status of the operator\n    function updateOperator(address operator, bool newEnabled) external {\n        operators[msg.sender][operator] = newEnabled;\n        emit OperatorUpdated(msg.sender, operator, newEnabled);\n    }\n\n    /// @notice entry to perform invocations for msg.sender\n    /// @param invocations List of actions to execute in order\n    function invoke(Invocation[] calldata invocations) external payable {\n        _invoke(msg.sender, invocations);\n    }\n\n    /// @notice entry to perform invocations for account\n    /// @param account Account to perform invocations for\n    /// @param invocations List of actions to execute in order\n    function invoke(address account, Invocation[] calldata invocations) external payable {\n        _invoke(account, invocations);\n    }\n\n    /// @notice Performs a batch of invocations for an account\n    /// @param account Account to perform invocations for\n    /// @param invocations List of actions to execute in order\n    function _invoke(address account, Invocation[] calldata invocations) private {\n        if (msg.sender != account && !operators[account][msg.sender]) revert MultiInvokerUnauthorizedError();\n\n        for(uint i = 0; i < invocations.length; ++i) {\n            Invocation memory invocation = invocations[i];\n\n            if (invocation.action == PerennialAction.UPDATE_POSITION) {\n                (\n                    // update data\n                    IMarket market,\n                    UFixed6 newMaker,\n                    UFixed6 newLong,\n                    UFixed6 newShort,\n                    Fixed6 collateral,\n                    bool wrap,\n                    InterfaceFee memory interfaceFee1,\n                    InterfaceFee memory interfaceFee2\n                ) = abi.decode(invocation.args, (IMarket, UFixed6, UFixed6, UFixed6, Fixed6, bool, InterfaceFee, InterfaceFee));\n\n                _update(account, market, newMaker, newLong, newShort, collateral, wrap, interfaceFee1, interfaceFee2);\n            } else if (invocation.action == PerennialAction.UPDATE_INTENT) {\n                (IMarket market, Intent memory intent, bytes memory signature) = abi.decode(invocation.args, (IMarket, Intent, bytes));\n\n                _updateIntent(account, market, intent, signature);\n            } else if (invocation.action == PerennialAction.UPDATE_VAULT) {\n                (IVault vault, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets, bool wrap)\n                    = abi.decode(invocation.args, (IVault, UFixed6, UFixed6, UFixed6, bool));\n\n                _vaultUpdate(account, vault, depositAssets, redeemShares, claimAssets, wrap);\n            } else if (invocation.action == PerennialAction.PLACE_ORDER) {\n                (IMarket market, TriggerOrder memory order) = abi.decode(invocation.args, (IMarket, TriggerOrder));\n\n                _placeOrder(account, market, order);\n            } else if (invocation.action == PerennialAction.CANCEL_ORDER) {\n                (IMarket market, uint256 nonce) = abi.decode(invocation.args, (IMarket, uint256));\n\n                _cancelOrder(account, market, nonce);\n            } else if (invocation.action == PerennialAction.EXEC_ORDER) {\n                (address execAccount, IMarket market, uint256 nonce)\n                    = abi.decode(invocation.args, (address, IMarket, uint256));\n\n                _executeOrder(execAccount, market, nonce);\n            } else if (invocation.action == PerennialAction.COMMIT_PRICE) {\n                (address oracleProviderFactory, uint256 value, bytes32[] memory ids, uint256 version, bytes memory data, bool revertOnFailure) =\n                    abi.decode(invocation.args, (address, uint256, bytes32[], uint256, bytes, bool));\n\n                _commitPrice(oracleProviderFactory, value, ids, version, data, revertOnFailure);\n            } else if (invocation.action == PerennialAction.APPROVE) {\n                (address target) = abi.decode(invocation.args, (address));\n\n                _approve(target);\n            } else if (invocation.action == PerennialAction.CLAIM_FEE) {\n                (IMarket market, bool unwrap) = abi.decode(invocation.args, (IMarket, bool));\n\n                _claimFee(account, market, unwrap);\n            }\n        }\n        // ETH must not remain in this contract at rest\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Updates market on behalf of account\n    /// @param account Address of account to update\n    /// @param market Address of market up update\n    /// @param newMaker New maker position for account in `market`\n    /// @param newLong New long position for account in `market`\n    /// @param newShort New short position for account in `market`\n    /// @param collateral Net change in collateral for account in `market`\n    /// @param wrap Wheather to wrap/unwrap collateral on deposit/withdrawal\n    /// @param interfaceFee1 Primary interface fee to charge\n    /// @param interfaceFee2 Secondary interface fee to charge\n    function _update(\n        address account,\n        IMarket market,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool wrap,\n        InterfaceFee memory interfaceFee1,\n        InterfaceFee memory interfaceFee2\n    ) internal isMarketInstance(market) {\n        Fixed18 balanceBefore =  Fixed18Lib.from(DSU.balanceOf());\n\n        // collateral is transferred here as DSU then an optional interface fee is charged from it\n        if (collateral.sign() == 1) _deposit(account, collateral.abs(), wrap);\n\n        market.update(\n            account,\n            newMaker,\n            newLong,\n            newShort,\n            collateral,\n            false,\n            interfaceFee1.receiver == address(0) ? interfaceFee2.receiver : interfaceFee1.receiver\n        );\n\n        Fixed6 withdrawAmount = Fixed6Lib.from(Fixed18Lib.from(DSU.balanceOf()).sub(balanceBefore));\n        if (!withdrawAmount.isZero()) _withdraw(account, withdrawAmount.abs(), wrap);\n\n        // charge interface fee\n        _chargeFee(account, market, interfaceFee1);\n        _chargeFee(account, market, interfaceFee2);\n    }\n\n    /// @notice Fills an intent update on behalf of account\n    /// @param account Address of account to update\n    /// @param intent The intent that is being filled\n    /// @param signature The signature of the intent that is being filled\n    function _updateIntent(\n        address account,\n        IMarket market,\n        Intent memory intent,\n        bytes memory signature\n    ) internal isMarketInstance(market) {\n        market.update(account, intent, signature);\n    }\n\n    /// @notice Update vault on behalf of account\n    /// @param account Address of account to update\n    /// @param vault Address of vault to update\n    /// @param depositAssets Amount of assets to deposit into vault\n    /// @param redeemShares Amount of shares to redeem from vault\n    /// @param claimAssets Amount of assets to claim from vault\n    /// @param wrap Whether to wrap assets before depositing\n    function _vaultUpdate(\n        address account,\n        IVault vault,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets,\n        bool wrap\n    ) internal isVaultInstance(vault) {\n        if (!depositAssets.isZero()) {\n            _deposit(account, depositAssets, wrap);\n        }\n\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        vault.update(account, depositAssets, redeemShares, claimAssets);\n\n        // handle socialization, settlement fees, and magic values\n        UFixed6 claimAmount = claimAssets.isZero() ?\n            UFixed6Lib.ZERO :\n            UFixed6Lib.from(DSU.balanceOf().sub(balanceBefore));\n\n        if (!claimAmount.isZero()) {\n            _withdraw(account, claimAmount, wrap);\n        }\n    }\n\n    /// @notice Helper to max approve DSU for usage in a market or vault deployed by the registered factories\n    /// @param target Market or Vault to approve\n    function _approve(address target) internal {\n        if (\n            !marketFactory.instances(IInstance(target)) &&\n            !vaultFactory.instances(IInstance(target))\n        ) revert MultiInvokerInvalidInstanceError();\n\n        DSU.approve(target);\n    }\n\n    /// @notice Charges an interface fee from collateral in this address during an update to a receiver\n    /// @param account Account to charge fee from\n    /// @param market Market to charge fee from\n    /// @param interfaceFee Interface fee to charge\n    function _chargeFee(address account, IMarket market, InterfaceFee memory interfaceFee) internal {\n        if (interfaceFee.amount.isZero()) return;\n        _marketWithdraw(market, account, interfaceFee.amount);\n\n        if (interfaceFee.unwrap) _unwrap(interfaceFee.receiver, UFixed18Lib.from(interfaceFee.amount));\n        else DSU.push(interfaceFee.receiver, UFixed18Lib.from(interfaceFee.amount));\n\n        emit InterfaceFeeCharged(account, market, interfaceFee);\n    }\n\n    /// @notice Claims market fees, unwraps DSU, and pushes USDC to fee earner\n    /// @param market Market from which fees should be claimed\n    /// @param account Address of the user who earned fees\n    /// @param unwrap Set true to unwrap DSU to USDC when withdrawing\n    function _claimFee(address account, IMarket market, bool unwrap) internal isMarketInstance(market) {\n        UFixed6 claimAmount = market.claimFee(account);\n        _withdraw(account, claimAmount, unwrap);\n    }\n\n    /// @notice Pull DSU or wrap and deposit USDC from `account` to this address for market usage\n    /// @param account Account to pull DSU or USDC from\n    /// @param amount Amount to transfer\n    /// @param wrap Flag to wrap USDC to DSU\n    function _deposit(address account, UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            USDC.pull(account, amount);\n            _wrap(address(this), UFixed18Lib.from(amount));\n        } else {\n            DSU.pull(account, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Push DSU or unwrap DSU to push USDC from this address to `account`\n    /// @param account Account to push DSU or USDC to\n    /// @param amount Amount to transfer\n    /// @param unwrap flag to unwrap DSU to USDC\n    function _withdraw(address account, UFixed6 amount, bool unwrap) internal {\n        if (unwrap) {\n            _unwrap(account, UFixed18Lib.from(amount));\n        } else {\n            DSU.push(account, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Helper function to wrap `amount` USDC from `address(this)` into DSU using the batcher or reserve\n    /// @param receiver Address to receive the DSU\n    /// @param amount Amount of USDC to wrap\n    function _wrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or  doesn't have enough for this wrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(DSU.balanceOf(address(batcher)))) {\n            reserve.mint(amount);\n            if (receiver != address(this)) DSU.push(receiver, amount);\n        } else {\n            // Wrap the USDC into DSU and return to the receiver\n            batcher.wrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to unwrap `amount` DSU into USDC and send to `receiver`\n    /// @param receiver Address to receive the USDC\n    /// @param amount Amount of DSU to unwrap\n    function _unwrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or doesn't have enough for this unwrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(UFixed18Lib.from(USDC.balanceOf(address(batcher))))) {\n            reserve.redeem(amount);\n            if (receiver != address(this)) USDC.push(receiver, UFixed6Lib.from(amount));\n        } else {\n            // Unwrap the DSU into USDC and return to the receiver\n            batcher.unwrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to commit a price to an oracle\n    /// @param oracleProviderFactory Address of oracle provider factory\n    /// @param value The ether value to pass on with the commit sub-call\n    /// @param version Version of oracle to commit to\n    /// @param data Data to commit to oracle\n    /// @param revertOnFailure Whether to revert on sub-call failure\n    function _commitPrice(\n        address oracleProviderFactory,\n        uint256 value,\n        bytes32[] memory ids,\n        uint256 version,\n        bytes memory data,\n        bool revertOnFailure\n    ) internal {\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        try IPythFactory(oracleProviderFactory).commit{value: value}(ids, version, data) {\n            // Return through keeper fee if any\n            DSU.push(msg.sender, DSU.balanceOf().sub(balanceBefore));\n        } catch (bytes memory reason) {\n            if (revertOnFailure) Address.verifyCallResult(false, reason, \"\");\n        }\n    }\n\n    /// @notice executes an `account's` open order for a `market` and pays a fee to `msg.sender`\n    /// @param account Account to execute order of\n    /// @param market Market to execute order for\n    /// @param nonce Id of open order to index\n    function _executeOrder(address account, IMarket market, uint256 nonce) internal {\n        if (!canExecuteOrder(account, market, nonce)) revert MultiInvokerCantExecuteError();\n\n        TriggerOrder memory order = orders(account, market, nonce);\n\n        _handleKeeperFee(\n            KeepConfig(\n                UFixed18Lib.ZERO,\n                keepBufferBase,\n                UFixed18Lib.ZERO,\n                keepBufferCalldata\n            ),\n            0,\n            msg.data[0:0],\n            0,\n            abi.encode(account, market, order.fee)\n        );\n\n        _marketSettle(market, account);\n\n        Order memory pending = market.pendings(account);\n        Position memory currentPosition = market.positions(account);\n        currentPosition.update(pending);\n\n        Fixed6 collateral = order.execute(currentPosition);\n\n        _update(\n            account,\n            market,\n            currentPosition.maker,\n            currentPosition.long,\n            currentPosition.short,\n            collateral,\n            true,\n            order.interfaceFee1,\n            order.interfaceFee2\n        );\n\n        delete _orders[account][market][nonce];\n        emit OrderExecuted(account, market, nonce);\n    }\n\n    /// @notice Helper function to raise keeper fee\n    /// @param keeperFee Keeper fee to raise\n    /// @param data Data to raise keeper fee with\n    /// @return Amount of keeper fee raised\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory data) internal virtual override returns (UFixed18) {\n        (address account, IMarket market, UFixed6 fee) = abi.decode(data, (address, IMarket, UFixed6));\n        UFixed6 raisedKeeperFee = UFixed6Lib.from(keeperFee, true).min(fee);\n        _marketWithdraw(market, account, raisedKeeperFee);\n\n        return UFixed18Lib.from(raisedKeeperFee);\n    }\n\n    /// @notice Places order on behalf of account from the invoker\n    /// @param account Account to place order for\n    /// @param market Market to place order in\n    /// @param order Order state to place\n    function _placeOrder(\n        address account,\n        IMarket market,\n        TriggerOrder memory order\n    ) internal isMarketInstance(market) {\n        if (order.fee.isZero()) revert MultiInvokerInvalidOrderError();\n        if (order.comparison != -1 && order.comparison != 1) revert MultiInvokerInvalidOrderError();\n        if (\n            order.side > 3 ||                                       // Invalid side\n            (order.side == 3 && order.delta.gte(Fixed6Lib.ZERO))    // Disallow placing orders that increase collateral\n        ) revert MultiInvokerInvalidOrderError();\n\n        _orders[account][market][++latestNonce].store(order);\n        emit OrderPlaced(account, market, latestNonce, order);\n    }\n\n    /// @notice Cancels an open order for account\n    /// @param account Account to cancel order for\n    /// @param market Market order is open in\n    /// @param nonce UID of order\n    function _cancelOrder(address account, IMarket market, uint256 nonce) internal {\n        delete _orders[account][market][nonce];\n        emit OrderCancelled(account, market, nonce);\n    }\n\n    /// @notice Withdraws `withdrawal` from `account`'s `market` position\n    /// @param market Market to withdraw from\n    /// @param account Account to withdraw from\n    /// @param withdrawal Amount to withdraw\n    function _marketWithdraw(IMarket market, address account, UFixed6 withdrawal) private {\n        market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.from(-1, withdrawal), false);\n    }\n\n    /// @notice Settles `account`'s `market` position\n    /// @param market Market to settle\n    /// @param account Account to settle\n    function _marketSettle(IMarket market, address account) private {\n        market.settle(account);\n    }\n\n    /// @notice Target market must be created by MarketFactory\n    modifier isMarketInstance(IMarket market) {\n        if (!marketFactory.instances(market))\n            revert MultiInvokerInvalidInstanceError();\n        _;\n    }\n\n    /// @notice Target vault must be created by VaultFactory\n    modifier isVaultInstance(IVault vault) {\n        if (!vaultFactory.instances(vault))\n            revert MultiInvokerInvalidInstanceError();\n        _;\n    }\n}\n"
    },
    "@equilibria/perennial-v2-extensions/contracts/types/InterfaceFee.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev Interface fee type\nstruct InterfaceFee {\n    /// @dev The amount of the fee\n    UFixed6 amount;\n\n    /// @dev The address to send the fee to\n    address receiver;\n\n    /// @dev Whether or not to unwrap the fee\n    bool unwrap;\n}\n"
    },
    "@equilibria/perennial-v2-extensions/contracts/types/TriggerOrder.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport \"@equilibria/perennial-v2/contracts/types/Position.sol\";\nimport \"./InterfaceFee.sol\";\n\nstruct TriggerOrder {\n    uint8 side;\n    int8 comparison;\n    UFixed6 fee;\n    Fixed6 price;\n    Fixed6 delta;\n    InterfaceFee interfaceFee1;\n    InterfaceFee interfaceFee2;\n}\nusing TriggerOrderLib for TriggerOrder global;\nstruct StoredTriggerOrder {\n    /* slot 0 */\n    uint8 side;         // 0 = maker, 1 = long, 2 = short\n    int8 comparison;    // -2 = lt, -1 = lte, 0 = eq, 1 = gte, 2 = gt\n    uint64 fee;         // <= 18.44tb\n    int64 price;        // <= 9.22t\n    int64 delta;        // <= 9.22t\n    bytes6 __unallocated0__;\n\n    /* slot 1 */\n    address interfaceFeeReceiver1;\n    uint48 interfaceFeeAmount1;      // <= 281m\n    bool interfaceFeeUnwrap1;\n    bytes5 __unallocated1__;\n\n    /* slot 2 */\n    address interfaceFeeReceiver2;\n    uint48 interfaceFeeAmount2;      // <= 281m\n    bool interfaceFeeUnwrap2;\n    bytes5 __unallocated2__;\n}\nstruct TriggerOrderStorage { StoredTriggerOrder value; }\nusing TriggerOrderStorageLib for TriggerOrderStorage global;\n\n/// @title TriggerOrderLib\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Library for TriggerOrder logic and data.\nlibrary TriggerOrderLib {\n    /// @notice Returns whether the trigger order is fillable at the latest price\n    /// @param self The trigger order\n    /// @param latestVersion The latest oracle version\n    /// @return Whether the trigger order is fillable\n    function fillable(TriggerOrder memory self, OracleVersion memory latestVersion) internal pure returns (bool) {\n        if (!latestVersion.valid) return false;\n        if (self.comparison == 1) return latestVersion.price.gte(self.price);\n        if (self.comparison == -1) return latestVersion.price.lte(self.price);\n        return false;\n    }\n\n    /// @notice Executes the trigger order on the given position\n    /// @param self The trigger order\n    /// @param currentPosition The current position\n    /// @return collateral The collateral delta, if any\n    function execute(\n        TriggerOrder memory self,\n        Position memory currentPosition\n    ) internal pure returns (Fixed6 collateral) {\n        // update position\n        if (self.side == 0)\n            currentPosition.maker = self.delta.isZero() ?\n                UFixed6Lib.ZERO :\n                UFixed6Lib.from(Fixed6Lib.from(currentPosition.maker).add(self.delta));\n        if (self.side == 1)\n            currentPosition.long = self.delta.isZero() ?\n                UFixed6Lib.ZERO :\n                UFixed6Lib.from(Fixed6Lib.from(currentPosition.long).add(self.delta));\n        if (self.side == 2)\n            currentPosition.short = self.delta.isZero() ?\n                UFixed6Lib.ZERO :\n                UFixed6Lib.from(Fixed6Lib.from(currentPosition.short).add(self.delta));\n\n        // Handles collateral withdrawal magic value\n        if (self.side == 3) collateral = (self.delta.eq(Fixed6.wrap(type(int64).min)) ? Fixed6Lib.MIN : self.delta);\n    }\n}\n\n/// @dev (external-safe): this library is safe to externalize\nlibrary TriggerOrderStorageLib {\n    // sig: 0xf3469aa7\n    error TriggerOrderStorageInvalidError();\n\n    function read(TriggerOrderStorage storage self) internal view returns (TriggerOrder memory) {\n        StoredTriggerOrder memory storedValue = self.value;\n        return TriggerOrder(\n            uint8(storedValue.side),\n            int8(storedValue.comparison),\n            UFixed6.wrap(uint256(storedValue.fee)),\n            Fixed6.wrap(int256(storedValue.price)),\n            Fixed6.wrap(int256(storedValue.delta)),\n            InterfaceFee(\n                UFixed6.wrap(uint256(storedValue.interfaceFeeAmount1)),\n                storedValue.interfaceFeeReceiver1,\n                storedValue.interfaceFeeUnwrap1\n            ),\n            InterfaceFee(\n                UFixed6.wrap(uint256(storedValue.interfaceFeeAmount2)),\n                storedValue.interfaceFeeReceiver2,\n                storedValue.interfaceFeeUnwrap2\n            )\n        );\n    }\n\n    function store(TriggerOrderStorage storage self, TriggerOrder memory newValue) internal {\n        if (newValue.side > type(uint8).max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison > type(int8).max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison < type(int8).min) revert TriggerOrderStorageInvalidError();\n        if (newValue.fee.gt(UFixed6.wrap(type(uint64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n        if (newValue.interfaceFee1.amount.gt(UFixed6.wrap(type(uint48).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.interfaceFee2.amount.gt(UFixed6.wrap(type(uint48).max))) revert TriggerOrderStorageInvalidError();\n\n        self.value = StoredTriggerOrder(\n            uint8(newValue.side),\n            int8(newValue.comparison),\n            uint64(UFixed6.unwrap(newValue.fee)),\n            int64(Fixed6.unwrap(newValue.price)),\n            int64(Fixed6.unwrap(newValue.delta)),\n            bytes6(0),\n            newValue.interfaceFee1.receiver,\n            uint48(UFixed6.unwrap(newValue.interfaceFee1.amount)),\n            newValue.interfaceFee1.unwrap,\n            bytes5(0),\n            newValue.interfaceFee2.receiver,\n            uint48(UFixed6.unwrap(newValue.interfaceFee2.amount)),\n            newValue.interfaceFee2.unwrap,\n            bytes5(0)\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IKeeperFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\";\nimport { IGasOracle } from \"@equilibria/root/gas/GasOracle.sol\";\nimport \"./IKeeperOracle.sol\";\nimport \"./IOracleFactory.sol\";\nimport \"./IPayoffProvider.sol\";\nimport { KeeperOracleParameter } from \"../keeper/types/KeeperOracleParameter.sol\";\n\ninterface IKeeperFactory is IOracleProviderFactory, IFactory {\n    struct PayoffDefinition {\n        IPayoffProvider provider;\n        int16 decimals;\n    }\n\n    struct PriceRecord {\n        uint256 timestamp;\n        Fixed18 price;\n        uint256 cost;\n    }\n\n    event OracleAssociated(bytes32 indexed id, bytes32 indexed underlyingId);\n    event ParameterUpdated(KeeperOracleParameter newParameter);\n    event PayoffRegistered(IPayoffProvider indexed payoff);\n\n    // sig: 0xe65b0914\n    error KeeperFactoryNotInstanceError();\n    // sig: 0xef8e774c\n    error KeeperFactoryInvalidParameterError();\n    // sig: 0x953ec95c\n    error KeeperFactoryAlreadyCreatedError();\n    // sig: 0x7e387175\n    error KeeperFactoryNotCreatedError();\n    // sig: 0x131b567b\n    error KeeperFactoryInvalidIdError();\n    // sig: 0xb043fd7b\n    error KeeperFactoryInvalidSettleError();\n    // sig: 0xb2e11555\n    error KeeperFactoryInvalidPayoffError();\n    // sig: 0x0afa0593\n    error KeeperFactoryVersionOutsideRangeError();\n\n    function initialize(IOracleFactory oracleFactory) external;\n    function factoryType() external view returns (string memory);\n    function commitmentGasOracle() external view returns (IGasOracle);\n    function settlementGasOracle() external view returns (IGasOracle);\n    function updateId(IOracleProvider oracleProvider, bytes32 oracleId) external;\n    function register(IPayoffProvider payoff) external;\n    function toUnderlyingId(bytes32 oracleId) external view returns (bytes32);\n    function toUnderlyingPayoff(bytes32 oracleId) external view returns (PayoffDefinition memory payoff);\n    function fromUnderlying(bytes32 underlyingId, IPayoffProvider payoff) external view returns (bytes32);\n    function create(bytes32 oracleId, bytes32 underlyingId, PayoffDefinition memory payoff) external returns (IKeeperOracle oracle);\n    function current() external view returns (uint256);\n    function parameter() external view returns (KeeperOracleParameter memory);\n    function updateParameter(uint256 newGranularity, UFixed6 newOracleFee, uint256 newValidFrom, uint256 newValidTo) external;\n    function commit(bytes32[] memory oracleIds, uint256 version, bytes calldata data) external payable;\n    function settle(bytes32[] memory oracleIds, uint256[] memory versions, uint256[] memory maxCounts) external;\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IKeeperOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProvider.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport \"../Oracle.sol\";\nimport { PriceResponse } from \"../keeper/types/PriceResponse.sol\";\n\ninterface IKeeperOracle is IOracleProvider, IInstance {\n    event CallbackRequested(SettlementCallback indexed callback);\n    event CallbackFulfilled(SettlementCallback indexed callback);\n    event OracleUpdated(IOracleProvider newOracle);\n\n    struct SettlementCallback {\n        /// @dev The market to settle\n        IMarket market;\n\n        /// @dev The account to settle\n        address account;\n\n        /// @dev The version to settle for\n        uint256 version;\n    }\n\n    struct KeeperOracleGlobal {\n        /// @dev The latest committed oracle version\n        uint64 latestVersion;\n\n        /// @dev Index in `versions` of the most recent version requested\n        uint64 currentIndex;\n\n        /// @dev Index in `versions` of the latest version a keeper has committed\n        uint64 latestIndex;\n    }\n\n    // sig: 0xb8499c31\n    error KeeperOracleVersionOutsideRangeError();\n    // sig: 0xce9529c8\n    error KeeperOracleInvalidPriceError();\n    //sig: 0x4889ef6f\n    error KeeperOracleInvalidCallbackError();\n    //sig: 0x7321f78c\n    error KeeperOracleNoPriorRequestsError();\n    //sig: 0xdcfc48f1\n    error KeeperOracleNotOracleError();\n\n    function initialize() external;\n    function register(IOracle newOracle) external;\n    function commit(OracleVersion memory version, address receiver, uint256 value) external;\n    function settle(uint256 version, uint256 maxCount) external;\n    function next() external view returns (uint256);\n    function localCallbacks(uint256 version) external view returns (address[] memory);\n\n    function timeout() external view returns (uint256);\n    function oracle() external view returns (IOracle);\n    function requests(uint256 index) external view returns (uint256);\n    function responses(uint256 timestamp) external view returns (PriceResponse memory);\n    function global() external view returns (KeeperOracleGlobal memory);\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IMetaQuantsFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@pythnetwork/pyth-sdk-solidity/PythStructs.sol\";\nimport \"./IKeeperFactory.sol\";\n\ninterface IMetaQuantsFactory is IKeeperFactory {\n    struct UpdateAndSignature {\n        bytes encodedUpdate;\n        bytes signature;\n    }\n\n    struct MetaQuantsUpdate {\n        PythStructs.PriceFeed priceFeed;\n        uint256 prevPublishTime;\n    }\n\n    error MetaQuantsFactoryInputLengthMismatchError();\n    error MetaQuantsFactoryInvalidSignatureError();\n    error MetaQuantsFactoryInvalidIdError();\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProvider.sol\";\n\ninterface IOracle is IOracleProvider, IInstance {\n    // sig: 0x8852e53b\n    error OracleOutOfSyncError();\n    // sig: 0x0f7338e5\n    error OracleOutOfOrderCommitError();\n    // sig: 0xb0850572\n    error OracleNotSubOracleError();\n    // sig: 0xc65186ee\n    error OracleNotMarketError();\n    // sig: 0x337304b2\n    error OracleNotBeneficiaryError();\n\n    event OracleUpdated(IOracleProvider newProvider);\n    event MarketUpdated(IMarket newMarket);\n    event FeeReceived(UFixed6 settlementFee, UFixed6 oracleFee);\n    event BeneficiaryUpdated(address newBeneficiary);\n\n    /// @dev The state for a single epoch\n    struct Epoch {\n        /// @dev The oracle provider for this epoch\n        IOracleProvider provider;\n\n        /// @dev The last timestamp that this oracle provider is valid\n        uint96 timestamp;\n    }\n\n    /// @dev The global state for oracle\n    struct OracleGlobal {\n        /// @dev The current epoch\n        uint128 current;\n\n        /// @dev The latest epoch\n        uint128 latest;\n    }\n\n    function initialize(IOracleProvider initialProvider, string calldata name_) external;\n    function register(IMarket newMarket) external;\n    function update(IOracleProvider newProvider) external;\n    function updateBeneficiary(address newBeneficiary) external;\n    function updateName(string calldata newName) external;\n    function claimFee(UFixed6 settlementFeeRequested) external;\n    function market() external view returns (IMarket);\n    function withdraw(Token18 token) external;\n    function beneficiary() external view returns (address);\n}"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IOracleFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport \"./IOracle.sol\";\nimport { OracleParameter } from \"../types/OracleParameter.sol\";\n\ninterface IOracleFactory is IOracleProviderFactory, IFactory {\n    event FactoryRegistered(IOracleProviderFactory factory);\n    event CallerAuthorized(IFactory caller);\n\n    // sig: 0xe7911099\n    error OracleFactoryInvalidIdError();\n    // sig: 0xe232e366\n    error OracleFactoryAlreadyCreatedError();\n    // sig: 0xbbfaa925\n    error OracleFactoryNotRegisteredError();\n    // sig: 0xfeb0e18c\n    error OracleFactoryNotCreatedError();\n\n    function factories(IOracleProviderFactory factory) external view returns (bool);\n    function initialize() external;\n    function parameter() external view returns (OracleParameter memory);\n    function updateParameter(OracleParameter memory newParameter) external;\n    function updateId(IOracleProvider oracleProvider, bytes32 id) external;\n    function register(IOracleProviderFactory factory) external;\n    function create(bytes32 id, IOracleProviderFactory factory, string calldata name) external returns (IOracle newOracle);\n    function update(bytes32 id, IOracleProviderFactory factory) external;\n    function withdraw(Token18 token) external;\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IPayoffProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/Fixed18.sol\";\n\ninterface IPayoffProvider {\n    function payoff(Fixed18 price) external pure returns (Fixed18 payoff);\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IPythFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IKeeperFactory.sol\";\n\ninterface IPythFactory is IKeeperFactory {\n    // sig: 0x22445848\n    error PythFactoryInvalidIdError();\n}\n\n/// @dev PythStaticFee interface, this is not exposed in the AbstractPyth contract\ninterface IPythStaticFee {\n    function singleUpdateFeeInWei() external view returns (uint);\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@equilibria/root/attribute/Factory.sol\";\nimport { IGasOracle } from \"@equilibria/root/gas/GasOracle.sol\";\nimport \"../interfaces/IKeeperFactory.sol\";\nimport \"../interfaces/IOracleFactory.sol\";\nimport { KeeperOracleParameter, KeeperOracleParameterStorage } from \"./types/KeeperOracleParameter.sol\";\nimport { DedupLib } from \"./libs/DedupLib.sol\";\n\n/// @title KeeperFactory\n/// @notice Factory contract for creating and managing keeper-based oracles\nabstract contract KeeperFactory is IKeeperFactory, Factory {\n    /// @dev The root oracle factory\n    IOracleFactory public oracleFactory;\n\n    /// @dev The gas oracles for pricing a commit keeper reward\n    IGasOracle public immutable commitmentGasOracle;\n\n    /// @dev The gas oracles for pricing a settle keeper reward\n    IGasOracle public immutable settlementGasOracle;\n\n    /// @dev Registered payoff providers\n    mapping(IPayoffProvider => bool) public payoffs;\n\n    /// @dev Mapping of oracle id to oracle instance\n    mapping(bytes32 => IOracleProvider) public oracles;\n\n    /// @dev Mapping of oracle id to underlying id\n    mapping(bytes32 => bytes32) public toUnderlyingId;\n\n    /// @dev Mapping of oracle id to payoff provider\n    mapping(bytes32 => PayoffDefinition) public _toUnderlyingPayoff;\n\n    /// @dev Mapping of oracle id to underlying id\n    mapping(bytes32 => mapping(IPayoffProvider => bytes32)) public fromUnderlying;\n\n    /// @notice The granularity of the oracle\n    KeeperOracleParameterStorage private _parameter;\n\n    /// @notice Mapping of oracle instance to oracle id\n    mapping(IOracleProvider => bytes32) public ids;\n\n    /// @notice Initializes the immutable contract state\n    /// @param implementation_ IKeeperOracle implementation contract\n    /// @param commitmentGasOracle_ The gas oracle for pricing a commit keeper reward\n    /// @param settlementGasOracle_ The gas oracle for pricing a settle keeper reward\n    constructor(\n        IGasOracle commitmentGasOracle_,\n        IGasOracle settlementGasOracle_,\n        address implementation_\n    ) Factory(implementation_) {\n        commitmentGasOracle = commitmentGasOracle_;\n        settlementGasOracle = settlementGasOracle_;\n    }\n\n    /// @notice Initializes the contract state\n    /// @param oracleFactory_ The root oracle factory\n    function initialize(IOracleFactory oracleFactory_) external initializer(1) {\n        __Factory__initialize();\n\n        oracleFactory = oracleFactory_;\n        payoffs[IPayoffProvider(address(0))] = true;\n\n        KeeperOracleParameter memory providerParameter;\n        providerParameter.currentGranularity = 1;\n        _parameter.store(providerParameter);\n    }\n\n    /// @notice Retroactively sets the mapping of the oracle id to the oracle instance\n    /// @dev Part of the v2.3 migration\n    /// @param oracleProvider The oracle instance\n    /// @param oracleId The id of the oracle\n    function updateId(IOracleProvider oracleProvider, bytes32 oracleId) external onlyOwner {\n        ids[oracleProvider] = oracleId;\n    }\n\n    /// @notice Authorizes a factory's instances to request from this factory's instances\n    /// @param payoff The payoff provider to register\n    function register(IPayoffProvider payoff) external onlyOwner {\n        payoffs[payoff] = true;\n        emit PayoffRegistered(payoff);\n    }\n\n    /// @notice Creates a new oracle instance\n    /// @param oracleId The id of the oracle to create\n    /// @param underlyingId The underlying id of the oracle to create\n    /// @param payoff The payoff provider for the oracle\n    /// @return newOracle The newly created oracle instance\n    function create(\n        bytes32 oracleId,\n        bytes32 underlyingId,\n        PayoffDefinition memory payoff\n     ) public virtual onlyOwner returns (IKeeperOracle newOracle) {\n        if (oracles[oracleId] != IOracleProvider(address(0))) revert KeeperFactoryAlreadyCreatedError();\n        if (!payoffs[payoff.provider]) revert KeeperFactoryInvalidPayoffError();\n        if (fromUnderlying[underlyingId][payoff.provider] != bytes32(0)) revert KeeperFactoryAlreadyCreatedError();\n\n        newOracle = IKeeperOracle(address(_create(abi.encodeCall(IKeeperOracle.initialize, ()))));\n        oracles[oracleId] = newOracle;\n        ids[newOracle] = oracleId;\n        toUnderlyingId[oracleId] = underlyingId;\n        _toUnderlyingPayoff[oracleId] = payoff;\n        fromUnderlying[underlyingId][payoff.provider] = oracleId;\n\n        emit OracleCreated(newOracle, oracleId);\n    }\n\n    /// @notice Returns the current timestamp\n    /// @dev Rounded up to the nearest granularity\n    /// @return The current timestamp\n    function current() public view returns (uint256) {\n        KeeperOracleParameter memory keeperOracleParameter = _parameter.read();\n\n        uint256 effectiveGranularity = block.timestamp <= keeperOracleParameter.effectiveAfter ?\n            keeperOracleParameter.latestGranularity :\n            keeperOracleParameter.currentGranularity;\n\n        return Math.ceilDiv(block.timestamp, effectiveGranularity) * effectiveGranularity;\n    }\n\n    /// @notice Commits the price to specified version\n    /// @dev Accepts both requested and non-requested versions.\n    ///      Requested versions will pay out a keeper fee, non-requested versions will not.\n    ///      Accepts any publish time in the underlying price message, as long as it is within the validity window,\n    ///      which means its possible for publish times to be slightly out of order with respect to versions.\n    ///      Batched updates are supported by passing in a list of price feed ids along with a valid batch update data.\n    /// @param oracleIds The list of price feed ids to commit\n    /// @param version The oracle version to commit\n    /// @param data The update data to commit\n    function commit(bytes32[] memory oracleIds, uint256 version, bytes calldata data) external payable {\n        // commit invalid version if no data\n        bool valid = data.length != 0;\n\n        // create array of underlying ids\n        bytes32[] memory underlyingIds = _toUnderlyingIds(oracleIds);\n\n        // dedup underlying ids\n        (bytes32[] memory dedupedIds, uint256[] memory indices) = DedupLib.dedup(underlyingIds);\n\n        // parse prices\n        PriceRecord[] memory dedupedPrices;\n        if (valid) {\n            dedupedPrices = _parsePrices(dedupedIds, data);\n            _validatePrices(version, dedupedPrices);\n        }\n\n        // create array of prices\n        (Fixed6[] memory prices, uint256[] memory costs) = _transformPrices(oracleIds, indices, dedupedPrices, valid);\n\n        for (uint256 i; i < oracleIds.length; i++)\n            IKeeperOracle(address(oracles[oracleIds[i]]))\n                .commit(OracleVersion(version, prices[i], valid), msg.sender, costs[i]);\n    }\n\n    /// @notice Performs a list of local settlement callbacks\n    /// @dev Pays out a keeper incentive if all supplied local settlement callbacks succeed\n    ///      Each array must be the same length, each index is a separate corresponding callback entry\n    /// @param oracleIds The list of price feed ids to settle\n    /// @param versions The list of versions to settle\n    /// @param maxCounts The list of maximum number of settlement callbacks to perform before exiting\n    function settle(bytes32[] memory oracleIds, uint256[] memory versions, uint256[] memory maxCounts) external {\n        if (oracleIds.length == 0 || oracleIds.length != versions.length || oracleIds.length != maxCounts.length)\n            revert KeeperFactoryInvalidSettleError();\n\n        for (uint256 i; i < oracleIds.length; i++)\n            IKeeperOracle(address(oracles[oracleIds[i]])).settle(versions[i], maxCounts[i]);\n    }\n\n    /// @notice Returns the oracle parameter set\n    /// @return The oracle parameter set\n    function parameter() external view returns (KeeperOracleParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Updates the oracle parameter set\n    /// @param newGranularity The new granularity value in seconds\n    /// @param newOraclefee The new relative oracle fee percentage\n    /// @param newValidFrom The new valid from value in seconds\n    /// @param newValidTo The new valid to value in seconds\n    function updateParameter(\n        uint256 newGranularity,\n        UFixed6 newOraclefee,\n        uint256 newValidFrom,\n        uint256 newValidTo\n    ) external onlyOwner {\n        uint256 currentTimestamp = current();\n        OracleParameter memory oracleParameter = oracleFactory.parameter();\n        KeeperOracleParameter memory keeperOracleParameter = _parameter.read();\n\n        if (currentTimestamp <= keeperOracleParameter.effectiveAfter) revert KeeperFactoryInvalidParameterError();\n        if (newGranularity > oracleParameter.maxGranularity) revert KeeperFactoryInvalidParameterError();\n        if (newOraclefee.gt(oracleParameter.maxOracleFee)) revert KeeperFactoryInvalidParameterError();\n\n        keeperOracleParameter.latestGranularity = keeperOracleParameter.currentGranularity;\n        keeperOracleParameter.currentGranularity = newGranularity;\n        keeperOracleParameter.effectiveAfter = currentTimestamp;\n        keeperOracleParameter.oracleFee = newOraclefee;\n        keeperOracleParameter.validFrom = newValidFrom;\n        keeperOracleParameter.validTo = newValidTo;\n\n        _parameter.store(keeperOracleParameter);\n        emit ParameterUpdated(keeperOracleParameter);\n    }\n\n    /// @notice Returns the payoff definition for the specified id\n    /// @param id The id to lookup\n    /// @return The payoff definition\n    function toUnderlyingPayoff(bytes32 id) external view returns (PayoffDefinition memory) {\n        return _toUnderlyingPayoff[id];\n    }\n\n    /// @notice Transforms the price records by the payoff and decimal offset\n    /// @param oracleIds The list of price feed ids to transform\n    /// @param indices The mapping of indecies from oracle ids to deduped ids\n    /// @param dedupedPrices The list of deduped price records to transform\n    /// @param valid Whether the prices we are committing are valid\n    /// @return prices The transformed prices\n    /// @return costs The keeper costs associated with the prices\n    function _transformPrices(\n        bytes32[] memory oracleIds,\n        uint256[] memory indices,\n        PriceRecord[] memory dedupedPrices,\n        bool valid\n    ) private view returns (Fixed6[] memory prices, uint256[] memory costs) {\n        prices = new Fixed6[](oracleIds.length);\n        costs = new uint256[](oracleIds.length);\n        if (!valid) return (prices, costs);\n\n        for (uint256 i; i < oracleIds.length; i++) {\n            // remap the price to the original index\n            Fixed18 price = dedupedPrices[indices[i]].price;\n\n            // apply payoff if it exists\n            PayoffDefinition memory payoff = _toUnderlyingPayoff[oracleIds[i]];\n            if (payoff.provider != IPayoffProvider(address(0)))\n                price = payoff.provider.payoff(price);\n\n            // apply decimal offset\n            Fixed18 base = Fixed18Lib.from(int256(10 ** SignedMath.abs(payoff.decimals)));\n            price = payoff.decimals < 0 ? price.div(base) : price.mul(base);\n\n            // trucate to 6-decimal\n            prices[i] = Fixed6Lib.from(price);\n            costs[i] = dedupedPrices[indices[i]].cost;\n        }\n    }\n\n    /// @notice Validates that the parse price record has a valid timestamp\n    /// @param version The oracle version to validate against\n    /// @param prices The list of price records to validate\n    function _validatePrices(uint256 version, PriceRecord[] memory prices) private view {\n        KeeperOracleParameter memory keeperOracleParameter = _parameter.read();\n        for (uint256 i; i < prices.length; i++)\n            if (\n                prices[i].timestamp < version + keeperOracleParameter.validFrom ||\n                prices[i].timestamp > version + keeperOracleParameter.validTo\n            ) revert KeeperFactoryVersionOutsideRangeError();\n    }\n\n    /// @notice Converts a list of oracle ids to a list of underlying ids\n    /// @dev Reverts if any of the ids are not associated\n    /// @param oraderIds The list of oracle ids to convert\n    /// @return underlyingIds The list of underlying ids\n    function _toUnderlyingIds(bytes32[] memory oraderIds) private view returns (bytes32[] memory underlyingIds) {\n        underlyingIds = new bytes32[](oraderIds.length);\n        for (uint256 i; i < oraderIds.length; i++) {\n            underlyingIds[i] = toUnderlyingId[oraderIds[i]];\n            if (underlyingIds[i] == bytes32(0)) revert KeeperFactoryNotCreatedError();\n        }\n    }\n\n    /// @notice Validates and parses the update data payload against the specified version\n    /// @param ids The list of price feed ids validate against\n    /// @param data The update data to validate\n    /// @return prices The parsed price list if valid\n    function _parsePrices(\n        bytes32[] memory ids,\n        bytes calldata data\n    ) internal virtual returns (PriceRecord[] memory prices);\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle_Migration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport {IMarket, OracleVersion, OracleReceipt } from \"../interfaces/IKeeperFactory.sol\";\nimport { PriceResponse } from \"./types/PriceResponse.sol\";\nimport { KeeperOracle } from \"./KeeperOracle.sol\";\n\n/// @title KeeperOracle_Migration\n/// @notice Stub implementation to upgrade the prior KeeperOracle to during the v2.3 migration for compatibility.\ncontract KeeperOracle_Migration is KeeperOracle {\n    // sig: 0xd41c17e7\n    error NotImplementedError();\n\n    constructor(uint256 timeout_) KeeperOracle(timeout_) { }\n\n    /// @notice Returns an empty response of the correct v2.3 format for forwards compatibility of the previous sub-oracle\n    /// @dev Empty responses, as long as they are of the correct format, will be overridden by the Global.latestPrice\n    /// @return oracleVersion The empty oracle version\n    /// @return oracleReceipt The empty oracle receipt\n    function at(uint256 timestamp) public pure override returns (\n        OracleVersion memory oracleVersion,\n        OracleReceipt memory oracleReceipt\n    ) {\n        oracleVersion.timestamp = timestamp;\n        return (oracleVersion, oracleReceipt);\n    }\n\n    /* Do not allow any unintented calls to the previous sub-oracle after migration */\n\n    function localCallbacks(uint256) external pure override returns (address[] memory) { revert NotImplementedError(); }\n    function next() public pure override returns (uint256) { revert NotImplementedError(); }\n    function responses(uint256) external pure override returns (PriceResponse memory) { revert NotImplementedError(); }\n    function request(IMarket, address) external pure override { revert NotImplementedError(); }\n    function status() external pure override returns (OracleVersion memory, uint256) { revert NotImplementedError(); }\n    function latest() public pure override returns (OracleVersion memory) { revert NotImplementedError(); }\n    function current() public pure override returns (uint256) { revert NotImplementedError(); }\n    function commit(OracleVersion memory, address, uint256) external pure override { revert NotImplementedError(); }\n    function settle(uint256, uint256) external pure override { revert NotImplementedError(); }\n}"
    },
    "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport { IGasOracle } from \"@equilibria/root/gas/GasOracle.sol\";\nimport \"../interfaces/IKeeperFactory.sol\";\nimport { PriceResponse, PriceResponseStorage, PriceResponseLib } from \"./types/PriceResponse.sol\";\n\n/// @title KeeperOracle\n/// @notice Generic implementation of the IOracle interface for keeper-based oracles.\n/// @dev One instance per price feed should be deployed. Multiple products may use the same\n///      KeeperOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract KeeperOracle is IKeeperOracle, Instance {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev The oracle provider authorized to call this sub oracle\n    IOracle public oracle;\n\n    /// @dev The gas oracles for pricing a commit keeper reward\n    IGasOracle public immutable commitmentGasOracle;\n\n    /// @dev The gas oracles for pricing a settle keeper reward\n    IGasOracle public immutable settlementGasOracle;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 public immutable timeout;\n\n    /// @dev List of all requested new price oracle versions by index\n    mapping(uint256 => uint256) public requests;\n\n    /// @dev The global state of the oracle\n    KeeperOracleGlobal private _global;\n\n    /// @dev Mapping from timestamp to oracle version responses\n    mapping(uint256 => PriceResponseStorage) private _responses;\n\n    /// @dev Mapping from version and market to a set of registered accounts for settlement callback\n    mapping(uint256 => EnumerableSet.AddressSet) private _localCallbacks;\n\n    /// @notice Constructs the contract\n    /// @param timeout_ The timeout for a version to be committed\n    constructor(uint256 timeout_) {\n        timeout = timeout_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Instance__initialize();\n    }\n\n    /// @notice Returns the global state of the oracle\n    /// @return The global state of the oracle\n    function global() external view returns (KeeperOracleGlobal memory) { return _global; }\n\n    /// @notice Updates the registered oracle provider\n    /// @dev The oracle provider is the only authorized caller\n    /// @param newOracle The new oracle provider\n    function register(IOracle newOracle) external onlyOwner {\n        oracle = newOracle;\n        emit OracleUpdated(newOracle);\n    }\n\n    /// @notice Returns the local oracle callback set for a version and market\n    /// @param version The version to lookup\n    /// @return The local oracle callback set for the version and market\n    function localCallbacks(uint256 version) external view virtual returns (address[] memory) {\n        return _localCallbacks[version].values();\n    }\n\n    /// @notice Returns the next requested oracle version\n    /// @dev Returns 0 if no next version is requested\n    /// @return The next requested oracle version\n    function next() public view virtual returns (uint256) {\n        return requests[_global.latestIndex + 1];\n    }\n\n    /// @notice Returns the response for a given oracle version\n    /// @param timestamp The timestamp of the oracle version\n    /// @return The response for the given oracle version\n    function responses(uint256 timestamp) external view virtual returns (PriceResponse memory) {\n        return _responses[timestamp].read();\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @dev  - If no request has been made this version, a price request will be created\n    ///       - If a request has been made this version, no action will be taken\n    /// @param account The account to callback to\n    function request(IMarket, address account) external virtual onlyOracle {\n        uint256 currentTimestamp = current();\n\n        _localCallbacks[currentTimestamp].add(account);\n        emit CallbackRequested(SettlementCallback(oracle.market(), account, currentTimestamp));\n\n        if (requests[_global.currentIndex] == currentTimestamp) return; // already requested new price\n\n        requests[++_global.currentIndex] = currentTimestamp;\n        emit OracleProviderVersionRequested(currentTimestamp, true);\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view virtual returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return latestVersion Latest oracle version\n    function latest() public view virtual returns (OracleVersion memory latestVersion) {\n        (latestVersion, ) = at(_global.latestVersion);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view virtual returns (uint256) {\n        return IKeeperFactory(address(factory())).current();\n    }\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return Oracle version at version `version`\n    /// @return Oracle receipt at version `version`\n    function at(uint256 timestamp) public view virtual returns (OracleVersion memory, OracleReceipt memory) {\n        return (\n            _responses[timestamp].read().toOracleVersion(timestamp),\n            _responses[timestamp].read().toOracleReceipt(_localCallbacks[timestamp].length())\n        );\n    }\n\n    /// @notice Commits the price to specified version\n    /// @dev Verification of price happens in the oracle's factory\n    /// @param version The oracle version to commit\n    /// @param receiver The receiver of the settlement fee\n    /// @param value The value charged to commit the price in ether\n    function commit(OracleVersion memory version, address receiver, uint256 value) external virtual onlyFactory {\n        if (version.timestamp == 0) revert KeeperOracleVersionOutsideRangeError();\n        PriceResponse memory priceResponse = (version.timestamp == next()) ?\n            _commitRequested(version, value) :\n            _commitUnrequested(version);\n        _global.latestVersion = uint64(version.timestamp);\n\n        emit OracleProviderVersionFulfilled(version);\n\n        try oracle.market() returns (IMarket market) { // v2.3 migration -- don't callback if Oracle is still on its v2.2 implementation\n            market.settle(address(0));\n            oracle.claimFee(priceResponse.toOracleReceipt(_localCallbacks[version.timestamp].length()).settlementFee);\n            market.token().push(receiver, UFixed18Lib.from(priceResponse.syncFee));\n        } catch {\n            return;\n        }\n    }\n\n    /// @notice Performs an asynchronous local settlement callback\n    /// @dev Distribution of keeper incentive is consolidated in the oracle's factory\n    /// @param version The version to settle\n    /// @param maxCount The maximum number of settlement callbacks to perform before exiting\n    function settle(uint256 version, uint256 maxCount) external virtual onlyFactory {\n        EnumerableSet.AddressSet storage callbacks = _localCallbacks[version];\n\n        if (_global.latestVersion < version) revert KeeperOracleVersionOutsideRangeError();\n        if (maxCount == 0) revert KeeperOracleInvalidCallbackError();\n        if (callbacks.length() == 0) revert KeeperOracleInvalidCallbackError();\n\n        IMarket market = oracle.market();\n\n        for (uint256 i; i < maxCount && callbacks.length() > 0; i++) {\n            address account = callbacks.at(0);\n            market.settle(account);\n            callbacks.remove(account);\n            emit CallbackFulfilled(SettlementCallback(market, account, version));\n\n            // full settlement fee already cleamed in commit\n            PriceResponse memory priceResponse = _responses[version].read();\n            market.token().push(msg.sender, UFixed18Lib.from(priceResponse.asyncFee));\n        }\n    }\n\n    /// @notice Commits the price to a requested version\n    /// @dev This commit function will pay out a keeper fee for providing a valid price or carrying over latest price\n    /// @param oracleVersion The oracle version to commit\n    /// @param value The value charged to commit the price in ether\n    /// @return priceResponse The response to the price request\n    function _commitRequested(\n        OracleVersion memory oracleVersion,\n        uint256 value\n    ) private returns (PriceResponse memory priceResponse) {\n        IKeeperFactory factory = IKeeperFactory(address(factory()));\n        KeeperOracleParameter memory keeperOracleParameter = factory.parameter();\n\n        if (block.timestamp <= (next() + timeout)) {\n            if (!oracleVersion.valid) revert KeeperOracleInvalidPriceError();\n            priceResponse.price = oracleVersion.price;\n            priceResponse.valid = true;\n        } else {\n            PriceResponse memory latestPrice = _responses[_global.latestVersion].read();\n            priceResponse.price = latestPrice.price;\n            priceResponse.valid = false;\n        }\n\n        priceResponse.syncFee = UFixed6Lib.from(factory.commitmentGasOracle().cost(value), true);\n        priceResponse.asyncFee = UFixed6Lib.from(factory.settlementGasOracle().cost(0), true);\n        priceResponse.oracleFee = keeperOracleParameter.oracleFee;\n\n        _responses[oracleVersion.timestamp].store(priceResponse);\n        _global.latestIndex++;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @param oracleVersion The oracle version to commit\n    /// @return priceResponse The response to the price request\n    function _commitUnrequested(OracleVersion memory oracleVersion) private returns (PriceResponse memory priceResponse) {\n        if (!oracleVersion.valid) revert KeeperOracleInvalidPriceError();\n        if (oracleVersion.timestamp <= _global.latestVersion || (next() != 0 && oracleVersion.timestamp >= next()))\n            revert KeeperOracleVersionOutsideRangeError();\n\n        priceResponse = PriceResponseLib.fromUnrequested(oracleVersion);\n\n        _responses[oracleVersion.timestamp].store(priceResponse);\n    }\n\n    /// @dev Only allow authorized oracle provider to call\n    modifier onlyOracle {\n        if (msg.sender != address(oracle)) revert KeeperOracleNotOracleError();\n        _;\n    }\n}"
    },
    "@equilibria/perennial-v2-oracle/contracts/keeper/libs/DedupLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\n/// @title DedupLib\n/// @dev (external-safe): this library is safe to externalize\n/// @notice Encapsulates the logic for ID array computation\nlibrary DedupLib {\n    /// @notice Deduplicates an array of bytes32 IDs\n    /// @dev Runs in O(n^2)\n    /// @param ids The array of IDs to deduplicate\n    /// @return dedupedIds The deduplicated array of IDs\n    /// @return indices The indices that each ID maps to in the deduplicated array\n    function dedup(bytes32[] memory ids) internal pure returns (bytes32[] memory dedupedIds, uint256[] memory indices) {\n        bytes32[] memory dedupedIdsUnpacked = new bytes32[](ids.length);\n        indices = new uint256[](ids.length);\n        uint256 duplicates;\n\n        // dedup\n        for (uint256 i; i < ids.length; i++) {\n            uint256 index = _match(ids, i);\n            if (index == i) {\n                uint256 dedupedIndex = i - duplicates;\n                indices[i] = dedupedIndex;\n                dedupedIdsUnpacked[dedupedIndex] = ids[i];\n            } else {\n                indices[i] = indices[index];\n                duplicates++;\n            }\n        }\n\n        // pack\n        dedupedIds = new bytes32[](ids.length - duplicates);\n        for (uint256 i; i < dedupedIds.length; i++)\n            dedupedIds[i] = dedupedIdsUnpacked[i];\n    }\n\n    /// @notice Finds the index of the first occurrence of an ID in an array\n    /// @dev Runs in O(n)\n    /// @param ids The array of IDs to search\n    /// @param index The index of the ID to search for\n    function _match(bytes32[] memory ids, uint256 index) private pure returns (uint256) {\n        for (uint256 i; i < index; i++)\n            if (ids[index] == ids[i])\n                return i;\n        return index;\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/keeper/types/KeeperOracleParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"@equilibria/perennial-v2/contracts/types/OracleVersion.sol\";\n\nstruct KeeperOracleParameter {\n    /// @dev The latest granularity setting in seconds\n    uint256 latestGranularity;\n\n    /// @dev The current granularity setting in seconds\n    uint256 currentGranularity;\n\n    /// @dev The timestamp at which the current granularity setting becomes effective\n    uint256 effectiveAfter;\n\n    /// @dev The relative oracle fee percentage of the request\n    UFixed6 oracleFee;\n\n    /// @dev Seconds after version a committed price is valid\n    uint256 validFrom;\n\n    /// @dev Seconds after version a committed price is valid until\n    uint256 validTo;\n}\nstruct StoredKeeperOracleParameter {\n    /* slot 0 (21) */\n    uint16 latestGranularity;   // <= 65k\n    uint16 currentGranularity;  // <= 65k\n    uint32 effectiveAfter;      // <= 2038\n    uint24 oracleFee;           // <= 100%\n    uint16 validFrom;           // <= 65k\n    uint16 validTo;             // <= 65k\n}\nstruct KeeperOracleParameterStorage { StoredKeeperOracleParameter value; }\nusing KeeperOracleParameterStorageLib for KeeperOracleParameterStorage global;\n\n/// @dev (external-safe): this library is safe to externalize\nlibrary KeeperOracleParameterStorageLib {\n    // sig: 0xff590172\n    error KeeperOracleParameterStorageInvalidError();\n\n    function read(KeeperOracleParameterStorage storage self) internal view returns (KeeperOracleParameter memory) {\n        StoredKeeperOracleParameter memory storedValue = self.value;\n        return KeeperOracleParameter(\n            uint256(storedValue.latestGranularity),\n            uint256(storedValue.currentGranularity),\n            uint256(storedValue.effectiveAfter),\n            UFixed6.wrap(uint256(storedValue.oracleFee)),\n            uint256(storedValue.validFrom),\n            uint256(storedValue.validTo)\n        );\n    }\n\n    function validate(KeeperOracleParameter memory newValue) private pure {\n        if (newValue.latestGranularity < 1 && newValue.effectiveAfter != 0)\n            revert KeeperOracleParameterStorageInvalidError();\n        if (newValue.currentGranularity < 1) revert KeeperOracleParameterStorageInvalidError();\n    }\n\n    function store(KeeperOracleParameterStorage storage self, KeeperOracleParameter memory newValue) internal {\n        validate(newValue);\n\n        if (newValue.latestGranularity > type(uint16).max) revert KeeperOracleParameterStorageInvalidError();\n        if (newValue.currentGranularity > type(uint16).max) revert KeeperOracleParameterStorageInvalidError();\n        if (newValue.effectiveAfter > type(uint32).max) revert KeeperOracleParameterStorageInvalidError();\n        if (newValue.oracleFee.gt(UFixed6.wrap(type(uint24).max))) revert KeeperOracleParameterStorageInvalidError();\n        if (newValue.validFrom > type(uint16).max) revert KeeperOracleParameterStorageInvalidError();\n        if (newValue.validTo > type(uint16).max) revert KeeperOracleParameterStorageInvalidError();\n\n        self.value = StoredKeeperOracleParameter(\n            uint16(newValue.latestGranularity),\n            uint16(newValue.currentGranularity),\n            uint32(newValue.effectiveAfter),\n            uint24(UFixed6.unwrap(newValue.oracleFee)),\n            uint16(newValue.validFrom),\n            uint16(newValue.validTo)\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/keeper/types/PriceResponse.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport { OracleVersion } from \"@equilibria/perennial-v2/contracts/types/OracleVersion.sol\";\nimport { OracleReceipt } from \"@equilibria/perennial-v2/contracts/types/OracleReceipt.sol\";\n\nstruct PriceResponse {\n    /// @dev The oracle price of the corresponding version\n    Fixed6 price;\n\n    /// @dev the synchronous portion of the fixed settlement fee of the request delivered on commit\n    UFixed6 syncFee;\n\n    /// @dev the asynchronous portion of the fixed settlement fee of the request delivered on settlement callback\n    UFixed6 asyncFee;\n\n    /// @dev The relative oracle fee percentage of the request\n    UFixed6 oracleFee;\n\n    /// @dev Whether the version is valid\n    bool valid;\n}\nusing PriceResponseLib for PriceResponse global;\nstruct StoredPriceResponse {\n    /* slot 0 */\n    int64 price;            // <= 18t\n    uint48 syncFee;         // <= 281m\n    uint48 asyncFee;        // <= 281m\n    uint24 oracleFee;       // <= 100%\n    bool valid;\n}\nstruct PriceResponseStorage { StoredPriceResponse value; }\nusing PriceResponseStorageLib for PriceResponseStorage global;\n\n/// @title PriceResponseLib\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Library for PriceResponse logic and data.\nlibrary PriceResponseLib {\n    /// @notice Constructs a price response from an unrequested oracle version\n    /// @param oracleVersion The oracle version object\n    /// @return The corresponding price response\n    function fromUnrequested(OracleVersion memory oracleVersion) internal pure returns (PriceResponse memory) {\n        return PriceResponse(oracleVersion.price, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, oracleVersion.valid);\n    }\n\n    /// @notice Returns an oracle version based on the price snapshot and timestamp\n    /// @param self The price response object\n    /// @param timestamp The timestamp of the price snapshot\n    /// @return The corresponding oracle version\n    function toOracleVersion(PriceResponse memory self, uint256 timestamp) internal pure returns (OracleVersion memory) {\n        return OracleVersion(timestamp, self.price, self.valid);\n    }\n\n    /// @notice Returns an oracle receipt based on the price snapshot and timestamp\n    /// @param self The price response object\n    /// @param callbacks The number of settlement callbacks to be made\n    /// @return The corresponding oracle receipt\n    function toOracleReceipt(PriceResponse memory self, uint256 callbacks) internal pure returns (OracleReceipt memory) {\n        return OracleReceipt(self.syncFee.add(self.asyncFee.mul(UFixed6Lib.from(callbacks))), self.oracleFee);\n    }\n}\n\n/// @dev (external-safe): this library is safe to externalize\nlibrary PriceResponseStorageLib {\n    // sig: 0xea04171b\n    error PriceResponseStorageInvalidError();\n\n    function read(PriceResponseStorage storage self) internal view returns (PriceResponse memory) {\n        StoredPriceResponse memory storedValue = self.value;\n        return PriceResponse(\n            Fixed6.wrap(int256(storedValue.price)),\n            UFixed6.wrap(uint256(storedValue.syncFee)),\n            UFixed6.wrap(uint256(storedValue.asyncFee)),\n            UFixed6.wrap(uint256(storedValue.oracleFee)),\n            storedValue.valid\n        );\n    }\n\n    function store(PriceResponseStorage storage self, PriceResponse memory newValue) internal {\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert PriceResponseStorageInvalidError();\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert PriceResponseStorageInvalidError();\n        if (newValue.syncFee.gt(UFixed6.wrap(type(uint48).max))) revert PriceResponseStorageInvalidError();\n        if (newValue.asyncFee.gt(UFixed6.wrap(type(uint48).max))) revert PriceResponseStorageInvalidError();\n        if (newValue.oracleFee.gt(UFixed6.wrap(type(uint24).max))) revert PriceResponseStorageInvalidError();\n\n        self.value = StoredPriceResponse(\n            int64(Fixed6.unwrap(newValue.price)),\n            uint48(UFixed6.unwrap(newValue.syncFee)),\n            uint48(UFixed6.unwrap(newValue.asyncFee)),\n            uint24(UFixed6.unwrap(newValue.oracleFee)),\n            newValue.valid\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/metaquants/MetaQuantsFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport \"../interfaces/IMetaQuantsFactory.sol\";\nimport \"../keeper/KeeperFactory.sol\";\n\ncontract MetaQuantsFactory is IMetaQuantsFactory, KeeperFactory {\n    int32 private constant PARSE_DECIMALS = 18;\n\n    address public immutable signer;\n\n    bytes32 private immutable _factoryType;\n\n    constructor(\n        address signer_,\n        IGasOracle commitmentGasOracle_,\n        IGasOracle settlementGasOracle_,\n        string memory factoryType_,\n        address implementation_\n    ) KeeperFactory(commitmentGasOracle_, settlementGasOracle_, implementation_) {\n        signer = signer_;\n        _factoryType = bytes32(abi.encodePacked(factoryType_));\n    }\n\n    function factoryType() external view returns (string memory ret) {\n        bytes memory b = bytes(abi.encodePacked(_factoryType));\n        // Remove null bytes\n        for (uint256 i; i < b.length; i++) {\n            if (b[i] != 0) ret = string.concat(ret, string(abi.encodePacked(b[i])));\n        }\n    }\n\n    /// @notice Validates and parses the update data payload against the specified version\n    /// @param underlyingIds The list of price feed ids validate against\n    /// @param data The update data to validate\n    /// @return prices The parsed price list if valid\n    function _parsePrices(\n        bytes32[] memory underlyingIds,\n        bytes calldata data\n    ) internal view override returns (PriceRecord[] memory prices) {\n        UpdateAndSignature[] memory updates = abi.decode(data, (UpdateAndSignature[]));\n        if (updates.length != underlyingIds.length) revert MetaQuantsFactoryInputLengthMismatchError();\n\n        prices = new PriceRecord[](underlyingIds.length);\n        for (uint256 i; i < updates.length; i++) {\n            if (!_verifySignature(updates[i].encodedUpdate, updates[i].signature))\n                revert MetaQuantsFactoryInvalidSignatureError();\n\n            MetaQuantsUpdate memory parsedUpdate = abi.decode(updates[i].encodedUpdate, (MetaQuantsUpdate));\n\n            if (parsedUpdate.priceFeed.id != underlyingIds[i]) revert MetaQuantsFactoryInvalidIdError();\n\n            (Fixed18 significand, int256 exponent) =\n                (Fixed18.wrap(parsedUpdate.priceFeed.price.price), parsedUpdate.priceFeed.price.expo + PARSE_DECIMALS);\n            Fixed18 base = Fixed18Lib.from(int256(10 ** SignedMath.abs(exponent)));\n            prices[i] = PriceRecord(\n                parsedUpdate.priceFeed.price.publishTime,\n                exponent < 0 ? significand.div(base) : significand.mul(base),\n                0\n            );\n        }\n    }\n\n    function _verifySignature(bytes memory updateData, bytes memory signature) private view returns (bool) {\n        return signer == ECDSA.recover(ECDSA.toEthSignedMessageHash(updateData), signature);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/Oracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport \"./interfaces/IOracle.sol\";\nimport \"./interfaces/IOracleFactory.sol\";\n\n/// @title Oracle\n/// @notice The top-level oracle contract that implements an oracle provider interface.\n/// @dev Manages swapping between different underlying oracle provider interfaces over time.\ncontract Oracle is IOracle, Instance {\n    /// @notice A historical mapping of underlying oracle providers\n    mapping(uint256 => Epoch) public oracles;\n\n    /// @notice The global state of the oracle\n    OracleGlobal public global;\n\n    /// @notice The market associated with this oracle\n    IMarket public market;\n\n    /// @notice The beneficiary of the oracle fee\n    address public beneficiary;\n\n    /// @notice The name of the oracle\n    string public name;\n\n    /// @notice Initializes the contract state\n    /// @param initialProvider The initial oracle provider\n    /// @param name_ The name of the oracle\n    function initialize(IOracleProvider initialProvider, string calldata name_) external initializer(1) {\n        __Instance__initialize();\n        _updateCurrent(initialProvider);\n        _updateLatest(initialProvider.latest());\n        name = name_;\n    }\n\n    /// @notice Updates the current oracle provider\n    /// @dev Both the current and new oracle provider must have the same current\n    /// @param newProvider The new oracle provider\n    function update(IOracleProvider newProvider) external onlyFactory {\n        _updateCurrent(newProvider);\n        _updateLatest(newProvider.latest());\n    }\n\n    /// @notice Registers the market associated with this oracle\n    /// @param newMarket The market to register\n    function register(IMarket newMarket) external onlyOwner {\n        market = newMarket;\n        emit MarketUpdated(newMarket);\n    }\n\n    /// @notice Updates the beneficiary of the oracle fee\n    /// @param newBeneficiary The new beneficiary\n    function updateBeneficiary(address newBeneficiary) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n    }\n\n    /// @notice Updates the name of the oracle\n    /// @dev Allows setting the name for previously deployed oracles (v2.3 migration)\n    /// @param newName The new oracle name\n    function updateName(string calldata newName) external onlyOwner {\n        name = newName;\n    }\n\n    /// @notice Requests a new version at the current timestamp\n    /// @param account Original sender to optionally use for callbacks\n    function request(IMarket, address account) external onlyMarket {\n        (OracleVersion memory latestVersion, uint256 currentTimestamp) = oracles[global.current].provider.status();\n\n        oracles[\n            (currentTimestamp > oracles[global.latest].timestamp) ? global.current : global.latest\n        ].provider.request(market, account);\n\n        oracles[global.current].timestamp = uint96(currentTimestamp);\n        _updateLatest(latestVersion);\n    }\n\n    /// @notice Returns the latest committed version as well as the current timestamp\n    /// @return latestVersion The latest committed version\n    /// @return currentTimestamp The current timestamp\n    function status() external view returns (OracleVersion memory latestVersion, uint256 currentTimestamp) {\n        (latestVersion, currentTimestamp) = oracles[global.current].provider.status();\n        latestVersion = _handleLatest(latestVersion);\n    }\n\n    /// @notice Returns the latest committed version\n    function latest() public view returns (OracleVersion memory) {\n        return _handleLatest(oracles[global.current].provider.latest());\n    }\n\n    /// @notice Returns the current value\n    function current() public view returns (uint256) {\n        return oracles[global.current].provider.current();\n    }\n\n    /// @notice Returns the oracle version at a given timestamp\n    /// @param timestamp The timestamp to query\n    /// @return atVersion The oracle version at the given timestamp\n    /// @return atReceipt The oracle receipt at the given timestamp\n    function at(uint256 timestamp) public view returns (OracleVersion memory atVersion, OracleReceipt memory atReceipt) {\n        if (timestamp == 0) return (atVersion, atReceipt);\n\n        IOracleProvider provider = oracles[global.current].provider;\n        for (uint256 i = global.current - 1; i > 0; i--) {\n            if (timestamp > uint256(oracles[i].timestamp)) break;\n            provider = oracles[i].provider;\n        }\n\n        (atVersion, atReceipt) = provider.at(timestamp);\n    }\n\n    /// @notice Withdraws the accrued oracle fees to the beneficiary\n    /// @param token The token to withdraw\n    function withdraw(Token18 token) external onlyBeneficiary {\n        token.push(beneficiary);\n    }\n\n    /// @notice Claims an amount of incentive tokens, to be paid out as a fee to the keeper\n    /// @dev Will claim all outstanding oracle fees in the underlying market and leave unrequested fees for the beneficiary.\n    ///      Can only be called by a registered underlying oracle provider factory.\n    /// @param settlementFeeRequested The fixed settmentment fee requested by the oracle\n    function claimFee(UFixed6 settlementFeeRequested) external onlySubOracle {\n        // claim the fee from the market\n        UFixed6 feeReceived = market.claimFee(address(this));\n\n        // return the settlement fee portion to the sub oracle's factory\n        market.token().push(msg.sender, UFixed18Lib.from(settlementFeeRequested));\n\n        emit FeeReceived(settlementFeeRequested, feeReceived.sub(settlementFeeRequested));\n    }\n\n    /// @notice Handles update the oracle to the new provider\n    /// @param newProvider The new oracle provider\n    function _updateCurrent(IOracleProvider newProvider) private {\n        // oracle must not already be updating\n        if (global.current != global.latest) revert OracleOutOfSyncError();\n\n        // if the latest version of the underlying oracle is further ahead than its latest request update its timestamp\n        if (global.current != 0) {\n            OracleVersion memory latestVersion = oracles[global.current].provider.latest();\n            if (latestVersion.timestamp > oracles[global.current].timestamp)\n                oracles[global.current].timestamp = uint96(latestVersion.timestamp);\n        }\n\n        // add the new oracle registration\n        oracles[++global.current] = Epoch(newProvider, uint96(newProvider.current()));\n        emit OracleUpdated(newProvider);\n    }\n\n    /// @notice Handles updating the latest oracle to the current if it is ready\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    function _updateLatest(OracleVersion memory currentOracleLatestVersion) private {\n        if (_latestStale(currentOracleLatestVersion)) global.latest = global.current;\n    }\n\n    /// @notice Handles overriding the latest version\n    /// @dev Applicable if we haven't yet switched over to the current oracle from the latest oracle\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    /// @return latestVersion The latest version\n    function _handleLatest(\n        OracleVersion memory currentOracleLatestVersion\n    ) private view returns (OracleVersion memory latestVersion) {\n        if (global.current == global.latest) return currentOracleLatestVersion;\n\n        bool isLatestStale = _latestStale(currentOracleLatestVersion);\n        latestVersion = isLatestStale ? currentOracleLatestVersion : oracles[global.latest].provider.latest();\n\n        uint256 latestOracleTimestamp =\n            uint256(isLatestStale ? oracles[global.current].timestamp : oracles[global.latest].timestamp);\n        if (!isLatestStale && latestVersion.timestamp > latestOracleTimestamp)\n            (latestVersion, ) = at(latestOracleTimestamp);\n    }\n\n    /// @notice Returns whether the latest oracle is ready to be updated\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    /// @return Whether the latest oracle is ready to be updated\n    function _latestStale(OracleVersion memory currentOracleLatestVersion) private view returns (bool) {\n        if (global.current == global.latest) return false;\n        if (global.latest == 0) return true;\n\n        if (uint256(oracles[global.latest].timestamp) > oracles[global.latest].provider.latest().timestamp) return false;\n        if (uint256(oracles[global.latest].timestamp) >= currentOracleLatestVersion.timestamp) return false;\n\n        return true;\n    }\n\n    /// @dev Only if the caller is the beneficiary\n    modifier onlyBeneficiary {\n        if (msg.sender != beneficiary) revert OracleNotBeneficiaryError();\n        _;\n    }\n\n    /// @dev Only if the caller is the registered market\n    modifier onlyMarket {\n        if (msg.sender != address(market)) revert OracleNotMarketError();\n        _;\n    }\n\n    /// @dev Only if the caller is the registered sub oracle\n    modifier onlySubOracle {\n        if (\n            msg.sender != address(oracles[global.current].provider) &&\n            msg.sender != address(oracles[global.latest].provider)\n        ) revert OracleNotSubOracleError();\n        _;\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/OracleFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/attribute/Factory.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\";\nimport \"./interfaces/IOracleFactory.sol\";\nimport { OracleParameter, OracleParameterStorage } from \"./types/OracleParameter.sol\";\n\n/// @title OracleFactory\n/// @notice Factory for creating and managing oracles\ncontract OracleFactory is IOracleFactory, Factory {\n    /// @notice DEPRECATED SLOT -- previously the incentive token\n    bytes32 private __unused0__;\n\n    /// @notice DEPRECATED SLOT -- previously the max claim\n    bytes32 private __unused1__;\n\n    /// @notice  DEPRECATED SLOT -- previously the authrorized callers\n    bytes32 private __unused2__;\n\n    /// @notice Mapping of oracle id to oracle instance\n    mapping(bytes32 => IOracleProvider) public oracles;\n\n    /// @notice Mapping of factory to whether it is registered\n    mapping(IOracleProviderFactory => bool) public factories;\n\n    /// @notice Mapping of oracle instance to oracle id\n    mapping(IOracleProvider => bytes32) public ids;\n\n    /// @notice Global settings for all oracles\n    OracleParameterStorage private _parameter;\n\n    /// @notice Constructs the contract\n    /// @param implementation_ The implementation contract for the oracle\n    constructor(address implementation_) Factory(implementation_) { }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(3) {\n        // Re-initialize if owner is unset\n        if (owner() == address(0)) __Factory__initialize();\n\n        _parameter.store(OracleParameter(1, UFixed6Lib.ZERO, UFixed6Lib.ZERO));\n    }\n\n    /// @notice Withdraws the accrued oracle fees to the owner\n    /// @dev Part of the v2.3 migration\n    /// @param token The token to withdraw\n    function withdraw(Token18 token) external onlyOwner {\n        token.push(owner());\n    }\n\n    /// @notice Returns the global oracle parameter\n    /// @return The global oracle parameter\n    function parameter() external view returns (OracleParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Updates the global oracle parameter\n    /// @param newParameter The new oracle parameter\n    function updateParameter(OracleParameter memory newParameter) external onlyOwner {\n        _parameter.store(newParameter);\n    }\n\n    /// @notice Retroactively sets the mapping of the oracle id to the oracle instance\n    /// @dev Part of the v2.3 migration\n    /// @param oracleProvider The oracle instance\n    /// @param id The id of the oracle\n    function updateId(IOracleProvider oracleProvider, bytes32 id) external onlyOwner {\n        ids[oracleProvider] = id;\n    }\n\n    /// @notice Registers a new oracle provider factory to be used in the underlying oracle instances\n    /// @param factory The factory to register\n    function register(IOracleProviderFactory factory) external onlyOwner {\n        factories[factory] = true;\n        emit FactoryRegistered(factory);\n    }\n\n    /// @notice Creates a new oracle instance\n    /// @param id The id of the oracle to create\n    /// @param factory The initial underlying oracle factory for this oracle to use\n    /// @param name The name of the oracle\n    /// @return newOracle The newly created oracle instance\n    function create(bytes32 id, IOracleProviderFactory factory, string calldata name) external onlyOwner returns (IOracle newOracle) {\n        if (!factories[factory]) revert OracleFactoryNotRegisteredError();\n        if (oracles[id] != IOracleProvider(address(0))) revert OracleFactoryAlreadyCreatedError();\n\n        IOracleProvider oracleProvider = factory.oracles(id);\n        if (oracleProvider == IOracleProvider(address(0))) revert OracleFactoryInvalidIdError();\n\n        newOracle = IOracle(address(_create(abi.encodeCall(IOracle.initialize, (oracleProvider, name)))));\n        oracles[id] = newOracle;\n        ids[newOracle] = id;\n\n        emit OracleCreated(newOracle, id);\n    }\n\n    /// @notice Updates the underlying oracle factory for an oracle instance\n    /// @param id The id of the oracle to update\n    /// @param factory The new underlying oracle factory for this oracle to use\n    function update(bytes32 id, IOracleProviderFactory factory) external onlyOwner {\n        if (!factories[factory]) revert OracleFactoryNotRegisteredError();\n        if (oracles[id] == IOracleProvider(address(0))) revert OracleFactoryNotCreatedError();\n\n        IOracleProvider oracleProvider = factory.oracles(id);\n        if (oracleProvider == IOracleProvider(address(0))) revert OracleFactoryInvalidIdError();\n\n        IOracle oracle = IOracle(address(oracles[id]));\n        oracle.update(oracleProvider);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/payoff/Inverse.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/IPayoffProvider.sol\";\n\ncontract Inverse is IPayoffProvider {\n    function payoff(Fixed18 price) external pure override returns (Fixed18) {\n        return price.isZero() ? price : Fixed18Lib.ONE.div(price);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/payoff/PowerHalf.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/IPayoffProvider.sol\";\n\ncontract PowerHalf is IPayoffProvider {\n    uint256 private constant BASE = 1e18;\n\n    function payoff(Fixed18 price) external pure override returns (Fixed18) {\n        return Fixed18Lib.from(UFixed18.wrap(Math.sqrt(UFixed18.unwrap(price.abs()) * BASE)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/payoff/PowerTwo.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"../interfaces/IPayoffProvider.sol\";\n\ncontract PowerTwo is IPayoffProvider {\n    function payoff(Fixed18 price) external pure override returns (Fixed18) {\n        return price.mul(price);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol\";\nimport \"../interfaces/IPythFactory.sol\";\nimport \"../keeper/KeeperFactory.sol\";\n\n/// @title PythFactory\n/// @notice Factory contract for creating and managing Pyth oracles\ncontract PythFactory is IPythFactory, KeeperFactory {\n    int32 private constant PARSE_DECIMALS = 18;\n    string public constant factoryType = \"PythFactory\";\n\n    /// @dev Pyth contract\n    AbstractPyth public immutable pyth;\n\n    /// @notice Initializes the immutable contract state\n    /// @param pyth_ Pyth contract\n    /// @param commitmentGasOracle_ Commitment gas oracle contract\n    /// @param settlementGasOracle_ Settlement gas oracle contract\n    /// @param implementation_ IPythOracle implementation contract\n    constructor(\n        AbstractPyth pyth_,\n        IGasOracle commitmentGasOracle_,\n        IGasOracle settlementGasOracle_,\n        address implementation_\n    ) KeeperFactory(commitmentGasOracle_, settlementGasOracle_, implementation_) {\n        pyth = pyth_;\n    }\n\n    /// @notice Creates a new oracle instance\n    /// @param id The id of the oracle to create\n    /// @param underlyingId The underlying id of the oracle to create\n    /// @param payoff The payoff provider contract\n    /// @return newOracle The newly created oracle instance\n    function create(\n        bytes32 id,\n        bytes32 underlyingId,\n        PayoffDefinition memory payoff\n    ) public override(IKeeperFactory, KeeperFactory) returns (IKeeperOracle newOracle) {\n        if (!pyth.priceFeedExists(underlyingId)) revert PythFactoryInvalidIdError();\n        return super.create(id, underlyingId, payoff);\n    }\n\n    /// @notice Validates and parses the update data payload against the specified version\n    /// @param underlyingIds The list of price feed ids validate against\n    /// @param data The update data to validate\n    /// @return prices The parsed price list if valid\n    function _parsePrices(\n        bytes32[] memory underlyingIds,\n        bytes calldata data\n    ) internal override returns (PriceRecord[] memory prices) {\n        prices = new PriceRecord[](underlyingIds.length);\n        bytes[] memory datas = new bytes[](1);\n        datas[0] = data;\n\n        PythStructs.PriceFeed[] memory parsedPrices = pyth.parsePriceFeedUpdates{value: msg.value}(\n            datas,\n            underlyingIds,\n            type(uint64).min,\n            type(uint64).max\n        );\n\n        uint256 updateFee = IPythStaticFee(address(pyth)).singleUpdateFeeInWei();\n\n        for (uint256 i; i < parsedPrices.length; i++) {\n            (Fixed18 significand, int256 exponent) =\n                (Fixed18.wrap(parsedPrices[i].price.price), parsedPrices[i].price.expo + PARSE_DECIMALS);\n            Fixed18 base = Fixed18Lib.from(int256(10 ** SignedMath.abs(exponent)));\n            prices[i] = PriceRecord(\n                parsedPrices[i].price.publishTime,\n                exponent < 0 ? significand.div(base) : significand.mul(base),\n                updateFee\n            );\n        }\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/types/OracleParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"@equilibria/perennial-v2/contracts/types/OracleVersion.sol\";\n\nstruct OracleParameter {\n    /// @dev The cap for the granularity setting in seconds\n    uint256 maxGranularity;\n\n    /// @dev the cap for the settle fee in absolute terms\n    UFixed6 maxSettlementFee;\n\n    /// @dev The cap for the oracle fee in relative terms\n    UFixed6 maxOracleFee;\n}\nstruct StoredOracleParameter {\n    /* slot 0 */\n    uint16 maxGranularity;      // <= 65k\n    uint48 maxSettlementFee;    // <= 281m\n    uint24 maxOracleFee;        // <= 100%\n}\nstruct OracleParameterStorage { StoredOracleParameter value; }\nusing OracleParameterStorageLib for OracleParameterStorage global;\n\n/// @dev (external-safe): this library is safe to externalize\nlibrary OracleParameterStorageLib {\n    // sig: 0xfc481d85\n    error OracleParameterStorageInvalidError();\n\n    function read(OracleParameterStorage storage self) internal view returns (OracleParameter memory) {\n        StoredOracleParameter memory storedValue = self.value;\n        return OracleParameter(\n            uint256(storedValue.maxGranularity),\n            UFixed6.wrap(uint256(storedValue.maxSettlementFee)),\n            UFixed6.wrap(uint256(storedValue.maxOracleFee))\n        );\n    }\n\n    function validate(OracleParameter memory newValue) private pure {\n        if (newValue.maxGranularity < 1) revert OracleParameterStorageInvalidError();\n        if (newValue.maxOracleFee.gt(UFixed6Lib.ONE)) revert OracleParameterStorageInvalidError();\n    }\n\n    function store(OracleParameterStorage storage self, OracleParameter memory newValue) internal {\n        validate(newValue);\n\n        if (newValue.maxGranularity > type(uint16).max) revert OracleParameterStorageInvalidError();\n        if (newValue.maxSettlementFee.gt(UFixed6.wrap(type(uint48).max))) revert OracleParameterStorageInvalidError();\n        if (newValue.maxOracleFee.gt(UFixed6.wrap(type(uint24).max))) revert OracleParameterStorageInvalidError();\n\n        self.value = StoredOracleParameter(\n            uint16(newValue.maxGranularity),\n            uint48(UFixed6.unwrap(newValue.maxSettlementFee)),\n            uint24(UFixed6.unwrap(newValue.maxOracleFee))\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-order/contracts/interfaces/IManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IMarket } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\n\nimport { CancelOrderAction } from \"../types/CancelOrderAction.sol\";\nimport { InterfaceFee } from \"../types/InterfaceFee.sol\";\nimport { PlaceOrderAction, TriggerOrder } from \"../types/PlaceOrderAction.sol\";\n\n/// @notice Stores and executes trigger orders\ninterface IManager {\n    /// @notice Emitted when a trigger order is written to storage, whether as a new order or a replacement\n    /// @param market Perennial market for which the order is intended\n    /// @param account Actor who wants to change their position in the market\n    /// @param order Desired change in position and conditions upon which change may be made\n    /// @param orderId Client-supplied order identifier, unique to client\n    event TriggerOrderPlaced(\n        IMarket indexed market,\n        address indexed account,\n        TriggerOrder order,\n        uint256 orderId\n    );\n\n    /// @notice Emitted when an order has been cancelled\n    /// @param market Perennial market for which the order was intended\n    /// @param account Actor whose order was cancelled\n    /// @param orderId Uniquely identifies the cancelled order\n    event TriggerOrderCancelled(IMarket indexed market, address indexed account, uint256 orderId);\n\n    /// @notice Emitted when a trigger orders conditions have been met and the user's position has been updated\n    /// @param market Perennial market which the order affected\n    /// @param account Actor whose position was changed\n    /// @param order Change in position and conditions which were satisfied\n    /// @param orderId Uniquely identifies the executed order\n    event TriggerOrderExecuted(IMarket indexed market, address indexed account, TriggerOrder order, uint256 orderId);\n\n    /// @notice Emitted when an interface fee specified on a trigger order has been paid\n    /// @param account Actor who paid the fee\n    /// @param market Perennial market from which the fee was pulled\n    /// @param fee Details including the fee amount and recipient of the fee\n    event TriggerOrderInterfaceFeeCharged(address indexed account, IMarket indexed market, InterfaceFee fee);\n\n    // sig: 0x955cc4b9\n    /// @custom:error Order does not exist or was already cancelled or executed\n    error ManagerCannotCancelError();\n\n    // sig: 0x8013a216\n    /// @custom:error Conditions required for order execution are not currently met\n    error ManagerCannotExecuteError();\n\n    // sig: 0xd0cfc108\n    /// @custom:error Order nonce has already been used\n    error ManagerInvalidOrderNonceError();\n\n    // sig: 0x6673613b\n    /// @custom:error Signer is not authorized to interact with markets for the specified user\n    error ManagerInvalidSignerError();\n\n    /// @notice Store a new trigger order or replace an existing trigger order\n    /// @param market Perennial market in which user wants to change their position\n    /// @param orderId Client-specific order identifier\n    /// @param order Desired change in position and conditions upon which change may be made\n    function placeOrder(IMarket market, uint256 orderId, TriggerOrder calldata order) external;\n\n    /// @notice Called by keeper to store a new or replace an existing trigger order via a signed message\n    /// @param request Message containing the market, order, and nonce used to uniquely identify the user's order.\n    /// @param signature EIP712 message signature\n    function placeOrderWithSignature(PlaceOrderAction calldata request, bytes calldata signature) external;\n\n    /// @notice Cancels a trigger order\n    /// @param market Perennial market for which the order was submitted\n    /// @param orderId Uniquely identifies the order to cancel\n    function cancelOrder(IMarket market, uint256 orderId) external;\n\n    /// @notice Called by keeper to cancel a trigger order via a signed message\n    /// @param request Message containing the market, order, and nonce used to uniquely identify the order to cancel\n    /// @param signature EIP712 message signature\n    function cancelOrderWithSignature(CancelOrderAction calldata request, bytes calldata signature) external;\n\n    /// @notice Retrieves an unexecuted trigger order\n    /// @param market Perennial market for which the order was submitted\n    /// @param account User for whom the order was submitted\n    /// @param orderId Uniquely identifies the order for a user\n    function orders(IMarket market, address account, uint256 orderId) external view returns (TriggerOrder memory);\n\n    /// @notice Determines whether trigger conditions for an order have been met\n    /// @param market Perennial market for which the order is intended\n    /// @param account Actor whose position is to be changed\n    /// @param orderId Uniquely identifies the order for an account\n    /// @return order Trigger order read from storage\n    /// @return canExecute True if trigger conditions have been met and executeOrder may be called on the order\n    function checkOrder(\n        IMarket market,\n        address account,\n        uint256 orderId\n    ) external returns (TriggerOrder memory order, bool canExecute);\n\n    /// @notice Called by keeper to execute an order whose trigger conditions have been met\n    /// @param market Perennial market for which the order is intended\n    /// @param account Actor whose position is to be changed\n    /// @param orderId Uniquely identifies the order for an account\n    function executeOrder(IMarket market, address account, uint256 orderId) external;\n}\n"
    },
    "@equilibria/perennial-v2-order/contracts/interfaces/IOrderVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IVerifierBase } from \"@equilibria/root/verifier/interfaces/IVerifierBase.sol\";\nimport { Action } from \"../types/Action.sol\";\nimport { CancelOrderAction } from \"../types/CancelOrderAction.sol\";\nimport { PlaceOrderAction } from \"../types/PlaceOrderAction.sol\";\n\n/// @notice EIP712 signed message verifier for Perennial V2 Trigger Orders.\ninterface IOrderVerifier is IVerifierBase {\n    /// @notice Verifies the signature of no-op action message\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param action Data common to all action messages\n    /// @param signature EIP712 signature for the message\n    function verifyAction(Action calldata action, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a request to persist a new trigger order\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param action Order submission request\n    /// @param signature EIP712 signature for the message\n    function verifyPlaceOrder(PlaceOrderAction calldata action, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a request to cancel an already-persisted trigger order\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param action Order cancellation request\n    /// @param signature EIP712 signature for the message\n    function verifyCancelOrder(CancelOrderAction calldata action, bytes calldata signature) external;\n}\n"
    },
    "@equilibria/perennial-v2-order/contracts/Manager_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { Kept, Kept_Arbitrum, Token18, UFixed18 } from \"@equilibria/root/attribute/Kept/Kept_Arbitrum.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { IMarketFactory } from \"@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol\";\n\nimport { IOrderVerifier, Manager } from \"./Manager.sol\";\n\ncontract Manager_Arbitrum is Manager, Kept_Arbitrum {\n    /// @dev passthrough constructor\n    constructor(\n        Token6 usdc,\n        Token18 dsu,\n        IEmptySetReserve reserve,\n        IMarketFactory marketFactory,\n        IOrderVerifier verifier\n    )\n        Manager(usdc, dsu, reserve, marketFactory, verifier) {}\n\n    /// @dev Use the Kept_Arbitrum implementation for calculating the dynamic fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view override(Kept_Arbitrum, Kept) returns (UFixed18) {\n        return Kept_Arbitrum._calldataFee(applicableCalldata, multiplierCalldata, bufferCalldata);\n    }\n\n    /// @dev Use the base implementation for raising the keeper fee\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal override(Manager, Kept) returns (UFixed18) {\n        return Manager._raiseKeeperFee(amount, data);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-order/contracts/Manager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { AggregatorV3Interface, Kept, Token18 } from \"@equilibria/root/attribute/Kept/Kept.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { UFixed18, UFixed18Lib } from \"@equilibria/root/number/types/UFixed18.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { IMarket, IMarketFactory } from \"@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol\";\n\nimport { IManager } from \"./interfaces/IManager.sol\";\nimport { IOrderVerifier } from \"./interfaces/IOrderVerifier.sol\";\nimport { Action } from \"./types/Action.sol\";\nimport { CancelOrderAction } from \"./types/CancelOrderAction.sol\";\nimport { InterfaceFee } from \"./types/InterfaceFee.sol\";\nimport { TriggerOrder, TriggerOrderStorage } from \"./types/TriggerOrder.sol\";\nimport { PlaceOrderAction } from \"./types/PlaceOrderAction.sol\";\n\n/// @notice Base class with business logic to store and execute trigger orders.\n///         Derived implementations created as appropriate for different chains.\nabstract contract Manager is IManager, Kept {\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Digital Standard Unit token used for keeper compensation\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU Reserve address\n    IEmptySetReserve public immutable reserve;\n\n    /// @dev Configuration used for keeper compensation\n    KeepConfig public keepConfig;\n\n    /// @dev Contract used to validate delegated signers\n    IMarketFactory public marketFactory;\n\n    /// @dev Verifies EIP712 messages for this extension\n    IOrderVerifier public verifier;\n\n    /// @dev Stores trigger orders while awaiting their conditions to become true\n    /// Market => Account => Nonce => Order\n    mapping(IMarket => mapping(address => mapping(uint256 => TriggerOrderStorage))) private _orders;\n\n    /// @dev Creates an instance\n    /// @param dsu_ Digital Standard Unit stablecoin\n    /// @param marketFactory_ Contract used to validate delegated signers\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IEmptySetReserve reserve_,\n        IMarketFactory marketFactory_,\n        IOrderVerifier verifier_\n    ) {\n        USDC = usdc_;\n        DSU = dsu_;\n        reserve = reserve_;\n        marketFactory = marketFactory_;\n        verifier = verifier_;\n    }\n\n    /// @notice Initialize the contract\n    /// @param ethOracle_ Chainlink ETH/USD oracle used for keeper compensation\n    /// @param keepConfig_ Keeper compensation configuration\n    function initialize(\n        AggregatorV3Interface ethOracle_,\n        KeepConfig memory keepConfig_\n    ) external initializer(1) {\n        __Kept__initialize(ethOracle_, DSU);\n        keepConfig = keepConfig_;\n        // allows DSU to unwrap to USDC\n        DSU.approve(address(reserve));\n    }\n\n    /// @inheritdoc IManager\n    function placeOrder(IMarket market, uint256 orderId, TriggerOrder calldata order) external {\n        _placeOrder(market, msg.sender, orderId, order);\n    }\n\n    /// @inheritdoc IManager\n    function placeOrderWithSignature(PlaceOrderAction calldata request, bytes calldata signature) external {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyPlaceOrder(request, signature);\n        _ensureValidSigner(request.action.common.account, request.action.common.signer);\n\n        _compensateKeeperAction(request.action);\n        _placeOrder(request.action.market, request.action.common.account, request.action.orderId, request.order);\n    }\n\n    /// @inheritdoc IManager\n    function cancelOrder(IMarket market, uint256 orderId) external {\n        _cancelOrder(market, msg.sender, orderId);\n    }\n\n    /// @inheritdoc IManager\n    function cancelOrderWithSignature(CancelOrderAction calldata request, bytes calldata signature) external {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyCancelOrder(request, signature);\n        _ensureValidSigner(request.action.common.account, request.action.common.signer);\n\n        _compensateKeeperAction(request.action);\n        _cancelOrder(request.action.market, request.action.common.account, request.action.orderId);\n    }\n\n    /// @inheritdoc IManager\n    function orders(IMarket market, address account, uint256 orderId) external view returns (TriggerOrder memory) {\n        return _orders[market][account][orderId].read();\n    }\n\n    /// @inheritdoc IManager\n    function checkOrder(\n        IMarket market,\n        address account,\n        uint256 orderId\n    ) public view returns (TriggerOrder memory order, bool canExecute) {\n        order = _orders[market][account][orderId].read();\n        // prevent calling canExecute on a spent or empty order\n        if (order.isSpent || order.isEmpty()) revert ManagerInvalidOrderNonceError();\n        canExecute = order.canExecute(market.oracle().latest());\n    }\n\n    /// @inheritdoc IManager\n    function executeOrder(IMarket market, address account, uint256 orderId) external {\n        // check conditions to ensure order is executable\n        (TriggerOrder memory order, bool canExecute) = checkOrder(market, account, orderId);\n        if (!canExecute) revert ManagerCannotExecuteError();\n\n        _compensateKeeper(market, account, order.maxFee);\n        order.execute(market, account);\n        bool interfaceFeeCharged = _chargeInterfaceFee(market, account, order);\n\n        // invalidate the order nonce\n        order.isSpent = true;\n        _orders[market][account][orderId].store(order);\n\n        emit TriggerOrderExecuted(market, account, order, orderId);\n        if (interfaceFeeCharged) emit TriggerOrderInterfaceFeeCharged(account, market, order.interfaceFee);\n    }\n\n    /// @notice reads keeper compensation parameters from an action message\n    function _compensateKeeperAction(Action calldata action) internal {\n        _compensateKeeper(action.market, action.common.account, action.maxFee);\n    }\n\n    /// @notice encodes data needed to pull DSU from market to pay keeper for fulfilling requests\n    function _compensateKeeper(IMarket market, address account, UFixed6 maxFee) internal {\n        bytes memory data = abi.encode(market, account, maxFee);\n        _handleKeeperFee(keepConfig, 0, msg.data[0:0], 0, data);\n    }\n\n    /// @notice reverts if user is not authorized to sign transactions for the account\n    function _ensureValidSigner(address account, address signer) internal view {\n        if (account != signer && !marketFactory.signers(account, signer)) revert ManagerInvalidSignerError();\n    }\n\n    /// @notice Transfers DSU from market to manager to compensate keeper\n    /// @param amount Keeper fee as calculated\n    /// @param data Identifies the market from and user for which funds should be withdrawn,\n    ///             and the user-defined fee cap\n    /// @return Amount of funds transferred from market to manager\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal virtual override returns (UFixed18) {\n        (IMarket market, address account, UFixed6 maxFee) = abi.decode(data, (IMarket, address, UFixed6));\n        UFixed6 raisedKeeperFee = UFixed6Lib.from(amount, true).min(maxFee);\n\n        _marketWithdraw(market, account, raisedKeeperFee);\n\n        return UFixed18Lib.from(raisedKeeperFee);\n    }\n\n    function _cancelOrder(IMarket market, address account, uint256 orderId) private {\n        // ensure this order wasn't already executed/cancelled\n        TriggerOrder memory order = _orders[market][account][orderId].read();\n        if (order.isEmpty() || order.isSpent) revert ManagerCannotCancelError();\n\n        // invalidate the order nonce\n        order.isSpent = true;\n        _orders[market][account][orderId].store(order);\n\n        emit TriggerOrderCancelled(market, account, orderId);\n    }\n\n    /// @notice Transfers DSU from market to manager to pay interface fee\n    function _chargeInterfaceFee(IMarket market, address account, TriggerOrder memory order) internal returns (bool) {\n        if (order.interfaceFee.amount.isZero()) return false;\n\n        // determine amount of fee to charge\n        UFixed6 feeAmount = order.interfaceFee.fixedFee ?\n            order.interfaceFee.amount :\n            order.notionalValue(market, account).mul(order.interfaceFee.amount);\n\n        _marketWithdraw(market, account, feeAmount);\n\n        if (order.interfaceFee.unwrap) _unwrapAndWithdaw(order.interfaceFee.receiver, UFixed18Lib.from(feeAmount));\n        else DSU.push(order.interfaceFee.receiver, UFixed18Lib.from(feeAmount));\n\n        return true;\n    }\n\n    /// @notice Transfers DSU from market to manager to pay keeper or interface fee\n    function _marketWithdraw(IMarket market, address account, UFixed6 amount) private {\n        market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.from(-1, amount), false);\n    }\n\n    function _placeOrder(IMarket market, address account, uint256 orderId, TriggerOrder calldata order) private {\n        // prevent user from reusing an order identifier\n        TriggerOrder memory old = _orders[market][account][orderId].read();\n        if (old.isSpent) revert ManagerInvalidOrderNonceError();\n\n        _orders[market][account][orderId].store(order);\n        emit TriggerOrderPlaced(market, account, order, orderId);\n    }\n\n    /// @notice Unwraps DSU to USDC and pushes to interface fee receiver\n    function _unwrapAndWithdaw(address receiver, UFixed18 amount) private {\n        reserve.redeem(amount);\n        USDC.push(receiver, UFixed6Lib.from(amount));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-order/contracts/OrderVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport { VerifierBase } from \"@equilibria/root/verifier/VerifierBase.sol\";\n\nimport { IOrderVerifier } from \"./interfaces/IOrderVerifier.sol\";\nimport { Action, ActionLib } from \"./types/Action.sol\";\nimport { CancelOrderAction, CancelOrderActionLib } from \"./types/CancelOrderAction.sol\";\nimport { PlaceOrderAction, PlaceOrderActionLib } from \"./types/PlaceOrderAction.sol\";\n\ncontract OrderVerifier is VerifierBase, IOrderVerifier {\n    /// @dev Initializes the domain separator and parameter caches\n    constructor() EIP712(\"Perennial V2 Trigger Orders\", \"1.0.0\") { }\n\n    /// @inheritdoc IOrderVerifier\n    function verifyAction(Action calldata action, bytes calldata signature)\n        external\n        validateAndCancel(action.common, signature)\n    {\n        _verifySignature(action, ActionLib.hash(action), signature);\n    }\n\n    /// @inheritdoc IOrderVerifier\n    function verifyPlaceOrder(PlaceOrderAction calldata action, bytes calldata signature)\n        external\n        validateAndCancel(action.action.common, signature)\n    {\n        _verifySignature(action.action, PlaceOrderActionLib.hash(action), signature);\n    }\n\n    /// @inheritdoc IOrderVerifier\n    function verifyCancelOrder(CancelOrderAction calldata action, bytes calldata signature)\n        external\n        validateAndCancel(action.action.common, signature)\n    {\n        _verifySignature(action.action, CancelOrderActionLib.hash(action), signature);\n    }\n\n    function _verifySignature(Action calldata action, bytes32 hash, bytes calldata signature) internal view {\n        if (!SignatureChecker.isValidSignatureNow(\n            action.common.signer,\n            _hashTypedDataV4(hash),\n            signature\n        )) revert VerifierInvalidSignerError();\n    }\n}\n"
    },
    "@equilibria/perennial-v2-order/contracts/types/Action.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { IMarket } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\n\n/// @notice Fields which need to be hashed for each order action\nstruct Action {\n    /// @dev Identifies the market in which user wants to interact\n    IMarket market;\n    /// @dev Client-supplied order identifier which cannot be reused\n    uint256 orderId;\n    /// @dev Largest amount to compensate relayer/keeper for the transaction in DSU;\n    ///      note this has no bearing on protocol or additive fees\n    UFixed6 maxFee;\n    /// @dev Information shared across all EIP712 collateral account actions;\n    ///      populate common.account with the owner of the collateral account\n    Common common;\n}\nusing ActionLib for Action global;\n\n/// @title ActionLib\n/// @notice Library used to hash and verifiy fields common to all collateral-account-related messages\nlibrary ActionLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"Action(address market,uint256 orderId,uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(Action memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.market, self.orderId, self.maxFee, CommonLib.hash(self.common)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-order/contracts/types/CancelOrderAction.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { IMarket } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\n/// @notice Request to cancel a persisted (\"placed\") order\nstruct CancelOrderAction {\n    /// @dev Identifies the order to cancel\n    ///      action.market         - market for which order was placed\n    ///      action.orderId     - order identifier assigned by the user\n    ///      action.maxFee         - maximum amount to compensate keeper\n    ///      action.common.account - the user who submitted the order\n    Action action;\n}\nusing CancelOrderActionLib for CancelOrderAction global;\n\n/// @notice Library used to hash requests to cancel an existing order\nlibrary CancelOrderActionLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"CancelOrderAction(Action action)\"\n        \"Action(address market,uint256 orderId,uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(CancelOrderAction memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, ActionLib.hash(self.action)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-order/contracts/types/InterfaceFee.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev Additive fee optionally awarded to GUIs upon execution of trigger orders\nstruct InterfaceFee {\n    /// @dev Amount of DSU to transfer from market to recipient\n    UFixed6 amount;\n    /// @dev Recipient of the fee\n    address receiver;\n    /// @dev True if fee is a fixed amount, false if fee is percentage of change in notional value\n    bool fixedFee;\n    /// @dev Whether or not to unwrap the DSU fee to USDC\n    bool unwrap;\n}\nusing InterfaceFeeLib for InterfaceFee global;\n\n/// @dev Library used for EIP-712 message signing and verification of InterfaceFee structs\nlibrary InterfaceFeeLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"InterfaceFee(uint64 amount,address receiver,bool fixedFee,bool unwrap)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(InterfaceFee memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.amount, self.receiver, self.fixedFee, self.unwrap));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-order/contracts/types/PlaceOrderAction.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { IMarket } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\n\nimport { Action, ActionLib } from \"./Action.sol\";\nimport { TriggerOrder, TriggerOrderStorageLib } from \"./TriggerOrder.sol\";\n\n/// @notice Request to persist a new trigger order or replace an open trigger order\nstruct PlaceOrderAction {\n    /// @dev Conveys the desired change in position and conditions to make the change\n    TriggerOrder order;\n    /// @dev Information shared across all EIP712 actions;\n    ///      action.market         - market in which user's position should be changed\n    ///      action.orderId        - per-user unique order identifier\n    ///      action.maxFee         - maximum amount to compensate keeper\n    ///      action.common.account - user participating in the market\n    ///      action.common.signer  - user or delegate signing the transaction\n    ///      action.common.domain  - Manager contract verifying the request\n    ///      action.common.nonce   - per-user unique message identifier\n    ///      action.common.group   - may be used to cancel multiple pending orders which have not been persisted\n    ///      action.common.expiry  - order will be implictly cancelled if not persisted after this time\n    Action action;\n}\nusing PlaceOrderActionLib for PlaceOrderAction global;\n\n/// @notice Library used to hash new trigger order requests\nlibrary PlaceOrderActionLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"PlaceOrderAction(TriggerOrder order,Action action)\"\n        \"Action(address market,uint256 orderId,uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n        \"InterfaceFee(uint64 amount,address receiver,bool fixedFee,bool unwrap)\"\n        \"TriggerOrder(uint8 side,int8 comparison,int64 price,int64 delta,uint64 maxFee,bool isSpent,address referrer,InterfaceFee interfaceFee)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(PlaceOrderAction memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, TriggerOrderStorageLib.hash(self.order), ActionLib.hash(self.action)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-order/contracts/types/TriggerOrder.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { IMarket, OracleVersion, Order, Position } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { InterfaceFee, InterfaceFeeLib } from \"./InterfaceFee.sol\";\n\n/// @notice Changes a user's position in a market when price reaches a trigger threshold\nstruct TriggerOrder {\n    /// @dev Determines the desired position type to establish or change\n    uint8 side;       // 4 = maker, 5 = long, 6 = short\n    /// @dev Trigger condition; market price to be less/greater than trigger price\n    int8 comparison;  // -1 = lte, 1 = gte\n    /// @dev Trigger price used on right hand side of comparison\n    Fixed6 price;     // <= 9.22t\n    /// @dev Amount to change position by, or type(int64).min to close position\n    Fixed6 delta;     // <= 9.22t\n    /// @dev Limit on keeper compensation for executing the order\n    UFixed6 maxFee;   // < 18.45t\n    /// @dev Always leave this false; set true after execution/cancellation\n    bool isSpent;\n    /// @dev Passed to market for awarding referral fee\n    address referrer;\n    /// @dev Additive fee optionally awarded to GUIs upon execution\n    InterfaceFee interfaceFee;\n}\nusing TriggerOrderLib for TriggerOrder global;\n\n/// @notice Logic for interacting with trigger orders\n/// @dev (external-unsafe): this library must be used internally only\nlibrary TriggerOrderLib {\n    Fixed6 private constant MAGIC_VALUE_CLOSE_POSITION = Fixed6.wrap(type(int64).min);\n\n    // sig: 0x5b8c7e99\n    /// @custom:error side or comparison is not supported\n    error TriggerOrderInvalidError();\n\n    /// @notice Determines whether the trigger order is fillable at the latest price\n    /// @param self Trigger order\n    /// @param latestVersion Latest oracle version\n    /// @return Whether the trigger order is fillable\n    function canExecute(TriggerOrder memory self, OracleVersion memory latestVersion) internal pure returns (bool) {\n        if (!latestVersion.valid) return false;\n        if (self.comparison == 1) return latestVersion.price.gte(self.price);\n        if (self.comparison == -1) return latestVersion.price.lte(self.price);\n        return false;\n    }\n\n    /// @notice Applies the order to the user's position and updates the market\n    /// @param self Trigger order\n    /// @param market Market for which the trigger order was placed\n    /// @param account Market participant\n    function execute(\n        TriggerOrder memory self,\n        IMarket market,\n        address account\n    ) internal {\n        // settle and get the pending position of the account\n        market.settle(account);\n        Order memory pending = market.pendings(account);\n        Position memory position = market.positions(account);\n        position.update(pending);\n\n        // apply order to position\n        if (self.side == 4) position.maker = _add(position.maker, self.delta);\n        if (self.side == 5) position.long = _add(position.long, self.delta);\n        if (self.side == 6) position.short = _add(position.short, self.delta);\n\n        // apply position to market\n        market.update(\n            account,\n            position.maker,\n            position.long,\n            position.short,\n            Fixed6Lib.ZERO,\n            false,\n            self.referrer\n        );\n    }\n\n    /// @notice Determines if the order has been deleted\n    /// @param self Trigger order\n    /// @return True if order has no function, otherwise false\n    function isEmpty(TriggerOrder memory self) internal pure returns (bool) {\n        return self.side == 0 && self.comparison == 0 && self.price.isZero() && self.delta.isZero();\n    }\n\n    /// @notice Prevents writing invalid side or comparison to storage\n    function isValid(TriggerOrder memory self) internal pure returns (bool) {\n        return self.side > 3 && self.side < 7 && (self.comparison == -1 || self.comparison == 1);\n    }\n\n    function notionalValue(TriggerOrder memory self, IMarket market, address account) internal view returns (UFixed6) {\n        // Consistent with how margin requirements are calculated, charge a positive fee on a negative price.\n        UFixed6 price = market.oracle().latest().price.abs();\n        if (self.delta.eq(MAGIC_VALUE_CLOSE_POSITION)) {\n            return _position(market, account, self.side).mul(price);\n        } else {\n            return self.delta.abs().mul(price);\n        }\n    }\n\n    /// @notice Helper function to improve readability of TriggerOrderLib.execute\n    function _add(UFixed6 lhs, Fixed6 rhs) private pure returns (UFixed6) {\n        return rhs.eq(MAGIC_VALUE_CLOSE_POSITION) ?\n            UFixed6Lib.ZERO :\n            UFixed6Lib.from(Fixed6Lib.from(lhs).add(rhs));\n    }\n\n    /// @notice Returns user's position for the side of the order they placed\n    function _position(IMarket market, address account, uint8 side) private view returns (UFixed6) {\n        Position memory current = market.positions(account);\n        if (side == 4) return current.maker;\n        else if (side == 5) return current.long;\n        else if (side == 6) return current.short;\n        revert TriggerOrderInvalidError();\n    }\n}\n\nstruct StoredTriggerOrder {\n    /* slot 0 */\n    uint8 side;                   // 4 = maker, 5 = long, 6 = short\n    int8 comparison;              // -1 = lte, 1 = gte\n    int64 price;                  // <= 9.22t\n    int64 delta;                  // <= 9.22t\n    uint64 maxFee;                // < 18.45t\n    bool isSpent;\n    bytes5 __unallocated0__;      // padding for 32-byte alignment\n    /* slot 1 */\n    address referrer;\n    bytes12 __unallocated1__;     // padding for 32-byte alignment\n    /* slot 2 */\n    address interfaceFeeReceiver;\n    uint64 interfaceFeeAmount;    // < 18.45t\n    bool interfaceFeeFlat;\n    bool interfaceFeeUnwrap;\n    // 2 bytes left over (no need to pad trailing bytes)\n}\nstruct TriggerOrderStorage { StoredTriggerOrder value; }\nusing TriggerOrderStorageLib for TriggerOrderStorage global;\n\n/// @dev Manually encodes and decodes the TriggerOrder struct to/from storage,\n///      and provides facility for hashing for inclusion in EIP-712 messages\n/// (external-safe): this library is safe to externalize\nlibrary TriggerOrderStorageLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"TriggerOrder(uint8 side,int8 comparison,int64 price,int64 delta,uint64 maxFee,bool isSpent,address referrer,InterfaceFee interfaceFee)\"\n        \"InterfaceFee(uint64 amount,address receiver,bool fixedFee,bool unwrap)\"\n    );\n\n    // sig: 0xf3469aa7\n    /// @custom:error price, delta, maxFee, or interface fee amount is out-of-bounds\n    error TriggerOrderStorageInvalidError();\n\n    /// @notice reads a trigger order struct from storage\n    function read(TriggerOrderStorage storage self) internal view returns (TriggerOrder memory) {\n        StoredTriggerOrder memory storedValue = self.value;\n        return TriggerOrder(\n            uint8(storedValue.side),\n            int8(storedValue.comparison),\n            Fixed6.wrap(int256(storedValue.price)),\n            Fixed6.wrap(int256(storedValue.delta)),\n            UFixed6.wrap(uint256(storedValue.maxFee)),\n            storedValue.isSpent,\n            storedValue.referrer,\n            InterfaceFee(\n                UFixed6.wrap(uint256(storedValue.interfaceFeeAmount)),\n                storedValue.interfaceFeeReceiver,\n                storedValue.interfaceFeeFlat,\n                storedValue.interfaceFeeUnwrap\n            )\n        );\n    }\n\n    /// @notice writes a trigger order struct to storage\n    function store(TriggerOrderStorage storage self, TriggerOrder memory newValue) internal {\n        if (!newValue.isValid()) revert TriggerOrderLib.TriggerOrderInvalidError();\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n        if (newValue.maxFee.gt(UFixed6.wrap(type(uint64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.interfaceFee.amount.gt(UFixed6.wrap(type(uint64).max))) revert TriggerOrderStorageInvalidError();\n\n        self.value = StoredTriggerOrder(\n            uint8(newValue.side),\n            int8(newValue.comparison),\n            int64(Fixed6.unwrap(newValue.price)),\n            int64(Fixed6.unwrap(newValue.delta)),\n            uint64(UFixed6.unwrap(newValue.maxFee)),\n            newValue.isSpent,\n            0,\n            newValue.referrer,\n            0,\n            newValue.interfaceFee.receiver,\n            uint64(UFixed6.unwrap(newValue.interfaceFee.amount)),\n            newValue.interfaceFee.fixedFee,\n            newValue.interfaceFee.unwrap\n        );\n    }\n\n    /// @notice Used to create a signed message\n    function hash(TriggerOrder memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(\n            STRUCT_HASH,\n            self.side,\n            self.comparison,\n            self.price,\n            self.delta,\n            self.maxFee,\n            self.isSpent,\n            self.referrer,\n            InterfaceFeeLib.hash(self.interfaceFee)\n        ));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/interfaces/IVault.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IMarket, Checkpoint as PerennialCheckpoint } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { IInstance } from \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { Account } from \"../types/Account.sol\";\nimport { Checkpoint } from \"../types/Checkpoint.sol\";\nimport { VaultParameter } from \"../types/VaultParameter.sol\";\nimport { Registration } from \"../types/Registration.sol\";\n\ninterface IVault is IInstance {\n    struct Context {\n        // markets\n        uint256 currentId;\n        uint256 currentTimestamp;\n        uint256 latestTimestamp;\n        Registration[] registrations;\n        Fixed6[] collaterals;\n        Fixed6 totalCollateral;\n\n        // state\n        VaultParameter parameter;\n        Checkpoint currentCheckpoint;\n        Checkpoint latestCheckpoint;\n        Account global;\n        Account local;\n    }\n\n    struct Target {\n        Fixed6 collateral;\n        UFixed6 position;\n    }\n\n    event MarketRegistered(uint256 indexed marketId, IMarket market);\n    event MarketUpdated(uint256 indexed marketId, UFixed6 newWeight, UFixed6 newLeverage);\n    event ParameterUpdated(VaultParameter newParameter);\n    event Updated(address indexed sender, address indexed account, uint256 version, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets);\n\n    // sig: 0xa9785d3d\n    error VaultDepositLimitExceededError();\n    // sig: 0xc85650f7\n    error VaultRedemptionLimitExceededError();\n    // sig: 0xe4b29524\n    error VaultExistingOrderError();\n    // sig: 0x499943cd\n    error VaultMarketExistsError();\n    // sig: 0x04467fe8\n    error VaultMarketDoesNotExistError();\n    // sig: 0x7c04a019\n    error VaultNotMarketError();\n    // sig: 0xaddc4c0d\n    error VaultIncorrectAssetError();\n    // sig: 0x7eb267c7\n    error VaultNotOperatorError();\n    // sig: 0xa65ac9fb\n    error VaultNotSingleSidedError();\n    // sig: 0xa65ac9fb\n    error VaultInsufficientMinimumError();\n    // sig: 0xdbdb7620\n    error VaultAggregateWeightError();\n    // sig: 0x50ad85d6\n    error VaultCurrentOutOfSyncError();\n\n    // sig: 0xb8a09499\n    error AccountStorageInvalidError();\n    // sig: 0xba85116a\n    error CheckpointStorageInvalidError();\n    // sig: 0xf003e2c3\n    error MappingStorageInvalidError();\n    // sig: 0x92f03c86\n    error RegistrationStorageInvalidError();\n    // sig: 0x0f9f8b19\n    error VaultParameterStorageInvalidError();\n    // sig: 0x97635122\n    error StrategyLibInsufficientCollateralError();\n    // sig: 0xfd9cbca5\n    error StrategyLibInsufficientAssetsError();\n\n    function initialize(Token18 asset, IMarket initialMaker, UFixed6 initialAmount, string calldata name_) external;\n    function name() external view returns (string memory);\n    function settle(address account) external;\n    function rebalance(address account) external;\n    function update(address account, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets) external;\n    function asset() external view returns (Token18);\n    function totalAssets() external view returns (Fixed6);\n    function totalShares() external view returns (UFixed6);\n    function convertToShares(UFixed6 assets) external view returns (UFixed6);\n    function convertToAssets(UFixed6 shares) external view returns (UFixed6);\n    function totalMarkets() external view returns (uint256);\n    function parameter() external view returns (VaultParameter memory);\n    function registrations(uint256 marketId) external view returns (Registration memory);\n    function accounts(address account) external view returns (Account memory);\n    function checkpoints(uint256 id) external view returns (Checkpoint memory);\n    function register(IMarket market) external;\n    function updateLeverage(uint256 marketId, UFixed6 newLeverage) external;\n    function updateWeights(UFixed6[] calldata newWeights) external;\n    function updateParameter(VaultParameter memory newParameter) external;\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/interfaces/IVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IFactory } from \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport { IMarket } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { IMarketFactory } from \"@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { IVault } from \"./IVault.sol\";\n\ninterface IVaultFactory is IFactory {\n    event OperatorUpdated(address indexed account, address indexed operator, bool newEnabled);\n    event VaultCreated(IVault indexed vault, Token18 indexed asset, IMarket initialMarket);\n\n    function initialAmount() external view returns (UFixed6);\n    function marketFactory() external view returns (IMarketFactory);\n    function initialize() external;\n    function operators(address account, address operator) external view returns (bool);\n    function updateOperator(address operator, bool newEnabled) external;\n    function create(Token18 asset, IMarket initialMarket, string calldata name) external returns (IVault);\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/libs/StrategyLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport {\n    MarketParameter,\n    RiskParameter,\n    Local,\n    Global,\n    Position,\n    PositionLib,\n    Order,\n    OracleVersion\n} from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Registration } from \"../types/Registration.sol\";\n\n/// @dev The context of an underlying market\nstruct MarketStrategyContext {\n    /// @dev Registration of the market\n    Registration registration;\n\n    /// @dev The market parameter set\n    MarketParameter marketParameter;\n\n    /// @dev The risk parameter set\n    RiskParameter riskParameter;\n\n    /// @dev The local state of the vault\n    Local local;\n\n    /// @dev The vault's current account position\n    Position currentAccountPosition;\n\n    /// @dev The vault's latest account position\n    Position latestAccountPosition;\n\n    /// @dev The current global position\n    Position currentPosition;\n\n    /// @dev The latest valid price\n    Fixed6 latestPrice;\n\n    /// @dev The margin requirement of the vault\n    UFixed6 margin;\n\n    /// @dev The current closable amount of the vault\n    UFixed6 closable;\n\n    // @dev minimum position size before crossing the net position\n    UFixed6 minPosition;\n\n    // @dev maximum position size before crossing the maker limit\n    UFixed6 maxPosition;\n}\n\nstruct Strategy {\n    UFixed6 totalMargin;\n\n    Fixed6 totalCollateral;\n\n    UFixed6 minAssets;\n\n    MarketStrategyContext[] marketContexts;\n}\nusing StrategyLib for Strategy global;\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev (external-safe): this library is safe to externalize\n///      - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    error StrategyLibInsufficientCollateralError();\n    error StrategyLibInsufficientAssetsError();\n\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @notice Loads the strategy context of each of the underlying markets\n    /// @param registrations The registrations of the underlying markets\n    /// @return strategy The strategy contexts of the vault\n    function load(Registration[] memory registrations) internal view returns (Strategy memory strategy) {\n        strategy.marketContexts = new MarketStrategyContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            strategy.marketContexts[marketId] = _loadContext(registrations[marketId]);\n            strategy.totalMargin = strategy.totalMargin.add(strategy.marketContexts[marketId].margin);\n            strategy.totalCollateral = strategy.totalCollateral.add(strategy.marketContexts[marketId].local.collateral);\n            strategy.minAssets = strategy.minAssets.max(\n                (registrations[marketId].leverage.isZero() || registrations[marketId].weight.isZero()) ?\n                    UFixed6Lib.ZERO : // skip if no leverage or weight\n                    strategy.marketContexts[marketId].minPosition\n                        .muldiv(strategy.marketContexts[marketId].latestPrice.abs(), registrations[marketId].leverage)\n                        .div(registrations[marketId].weight)\n            );\n        }\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param strategy The strategy of the vault\n    /// @param deposit The amount of assets that are being deposited into the vault\n    /// @param withdrawal The amount of assets to make available for withdrawal\n    /// @param ineligible The amount of assets that are inapplicable for allocation\n    function allocate(\n        Strategy memory strategy,\n        UFixed6 deposit,\n        UFixed6 withdrawal,\n        UFixed6 ineligible\n    ) internal pure returns (MarketTarget[] memory targets) {\n        UFixed6 collateral = UFixed6Lib.unsafeFrom(strategy.totalCollateral).add(deposit).unsafeSub(withdrawal);\n        UFixed6 assets = collateral.unsafeSub(ineligible);\n\n        if (collateral.lt(strategy.totalMargin)) revert StrategyLibInsufficientCollateralError();\n        if (assets.lt(strategy.minAssets)) revert StrategyLibInsufficientAssetsError();\n\n        targets = new MarketTarget[](strategy.marketContexts.length);\n        UFixed6 totalMarketCollateral;\n        for (uint256 marketId; marketId < strategy.marketContexts.length; marketId++) {\n            UFixed6 marketCollateral;\n            (targets[marketId], marketCollateral) = _allocateMarket(\n                strategy.marketContexts[marketId],\n                strategy.totalMargin,\n                collateral,\n                assets\n            );\n            totalMarketCollateral = totalMarketCollateral.add(marketCollateral);\n        }\n\n        if (strategy.marketContexts.length != 0)\n            targets[0].collateral = targets[0].collateral.add(Fixed6Lib.from(collateral.sub(totalMarketCollateral)));\n    }\n\n    /// @notice Compute the target allocation for a market\n    /// @param marketContext The context of the market\n    /// @param totalMargin The total margin requirement of the vault\n    /// @param collateral The total amount of collateral of the vault\n    /// @param assets The total amount of collateral available for allocation\n    function _allocateMarket(\n        MarketStrategyContext memory marketContext,\n        UFixed6 totalMargin,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) private pure returns (MarketTarget memory target, UFixed6 marketCollateral) {\n        marketCollateral = marketContext.margin\n            .add(collateral.sub(totalMargin).mul(marketContext.registration.weight));\n\n        UFixed6 marketAssets = assets\n            .mul(marketContext.registration.weight)\n            .min(marketCollateral.mul(LEVERAGE_BUFFER));\n\n        target.collateral = Fixed6Lib.from(marketCollateral).sub(marketContext.local.collateral);\n\n        UFixed6 minAssets = marketContext.riskParameter.minMargin\n            .unsafeDiv(marketContext.registration.leverage.mul(marketContext.riskParameter.maintenance));\n\n        if (marketContext.marketParameter.closed || marketAssets.lt(minAssets)) marketAssets = UFixed6Lib.ZERO;\n\n        target.position = marketAssets\n            .muldiv(marketContext.registration.leverage, marketContext.latestPrice.abs())\n            .max(marketContext.minPosition)\n            .min(marketContext.maxPosition);\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return marketContext The context of the market\n    function _loadContext(\n        Registration memory registration\n    ) private view returns (MarketStrategyContext memory marketContext) {\n        marketContext.registration = registration;\n        marketContext.marketParameter = registration.market.parameter();\n        marketContext.riskParameter = registration.market.riskParameter();\n        marketContext.local = registration.market.locals(address(this));\n        OracleVersion memory latestVersion = registration.market.oracle().latest();\n\n        marketContext.latestAccountPosition = registration.market.positions(address(this));\n        marketContext.currentAccountPosition = marketContext.latestAccountPosition.clone();\n\n        Order memory pendingLocal = registration.market.pendings(address(this));\n        marketContext.currentAccountPosition.update(pendingLocal);\n\n        marketContext.margin = PositionLib.margin(\n            marketContext.latestAccountPosition.magnitude().add(pendingLocal.pos()),\n            latestVersion,\n            marketContext.riskParameter,\n            UFixed6Lib.ZERO\n        );\n        marketContext.latestPrice = latestVersion.price;\n\n        marketContext.closable = marketContext.latestAccountPosition.magnitude().sub(pendingLocal.neg());\n\n        // current position\n        Order memory pendingGlobal = registration.market.pending();\n        marketContext.currentPosition = registration.market.position();\n        marketContext.currentPosition.update(pendingGlobal);\n        marketContext.minPosition = marketContext.currentAccountPosition.maker\n            .unsafeSub(marketContext.currentPosition.maker\n                .unsafeSub(marketContext.currentPosition.skew().abs()).min(marketContext.closable));\n        marketContext.maxPosition = marketContext.currentAccountPosition.maker\n            .add(marketContext.riskParameter.makerLimit.unsafeSub(marketContext.currentPosition.maker));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/types/Account.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"./Checkpoint.sol\";\n\n/// @dev Account type\nstruct Account {\n    /// @dev The current position id\n    uint256 current;\n\n    /// @dev The latest position id\n    uint256 latest;\n\n    /// @dev The total shares\n    UFixed6 shares;\n\n    /// @dev The total assets\n    UFixed6 assets;\n\n    /// @dev The amount of pending deposits\n    UFixed6 deposit;\n\n    /// @dev The amount of pending redemptions\n    UFixed6 redemption;\n}\nusing AccountLib for Account global;\nstruct StoredAccount {\n    /* slot 0 */\n    uint32 current;         // <= 4.29b\n    uint32 latest;          // <= 4.29b\n    bytes24 __unallocated0__;\n\n    /* slot 1 */\n    uint64 shares;          // <= 18.44t\n    uint64 assets;          // <= 18.44t\n    uint64 deposit;         // <= 18.44t\n    uint64 redemption;      // <= 18.44t\n}\nstruct AccountStorage { StoredAccount value; }\nusing AccountStorageLib for AccountStorage global;\n\n\n/// @title Account\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the state for the account type\nlibrary AccountLib {\n    /// @notice Processes the position in a global context\n    /// @param self The account to update\n    /// @param latestId The latest position id\n    /// @param checkpoint The checkpoint to process\n    /// @param deposit The amount of pending deposits\n    /// @param redemption The amount of pending redemptions\n    function processGlobal(\n        Account memory self,\n        uint256 latestId,\n        Checkpoint memory checkpoint,\n        UFixed6 deposit,\n        UFixed6 redemption\n    ) internal pure {\n        self.latest = latestId;\n        (self.assets, self.shares) = (\n            self.assets.add(checkpoint.toAssetsGlobal(redemption)),\n            self.shares.add(checkpoint.toSharesGlobal(deposit))\n        );\n        (self.deposit, self.redemption) = (self.deposit.sub(deposit), self.redemption.sub(redemption));\n    }\n\n    /// @notice Processes the position in a local context\n    /// @param self The account to update\n    /// @param latestId The latest position id\n    /// @param checkpoint The checkpoint to process\n    /// @param deposit The amount of pending deposits to clear\n    /// @param redemption The amount of pending redemptions to clear\n    function processLocal(\n        Account memory self,\n        uint256 latestId,\n        Checkpoint memory checkpoint,\n        UFixed6 deposit,\n        UFixed6 redemption\n    ) internal pure {\n        self.latest = latestId;\n        (self.assets, self.shares) = (\n            self.assets.add(checkpoint.toAssetsLocal(redemption)),\n            self.shares.add(checkpoint.toSharesLocal(deposit))\n        );\n        (self.deposit, self.redemption) = (self.deposit.sub(deposit), self.redemption.sub(redemption));\n    }\n\n    /// @notice Updates the account with a new order\n    /// @param self The account to update\n    /// @param currentId The current position id\n    /// @param assets The amount of assets to deduct\n    /// @param shares The amount of shares to deduct\n    /// @param deposit The amount of pending deposits\n    /// @param redemption The amount of pending redemptions\n    function update(\n        Account memory self,\n        uint256 currentId,\n        UFixed6 assets,\n        UFixed6 shares,\n        UFixed6 deposit,\n        UFixed6 redemption\n    ) internal pure {\n        self.current = currentId;\n        (self.assets, self.shares) = (self.assets.sub(assets), self.shares.sub(shares));\n        (self.deposit, self.redemption) = (self.deposit.add(deposit), self.redemption.add(redemption));\n    }\n}\n\n/// @dev (external-safe): this library is safe to externalize\nlibrary AccountStorageLib {\n    // sig: 0xb8a09499\n    error AccountStorageInvalidError();\n\n    function read(AccountStorage storage self) internal view returns (Account memory) {\n        StoredAccount memory storedValue = self.value;\n        return Account(\n            uint256(storedValue.current),\n            uint256(storedValue.latest),\n            UFixed6.wrap(uint256(storedValue.shares)),\n            UFixed6.wrap(uint256(storedValue.assets)),\n            UFixed6.wrap(uint256(storedValue.deposit)),\n            UFixed6.wrap(uint256(storedValue.redemption))\n        );\n    }\n\n    function store(AccountStorage storage self, Account memory newValue) internal {\n        if (newValue.current > uint256(type(uint32).max)) revert AccountStorageInvalidError();\n        if (newValue.latest > uint256(type(uint32).max)) revert AccountStorageInvalidError();\n        if (newValue.shares.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n        if (newValue.assets.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n        if (newValue.deposit.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n        if (newValue.redemption.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n\n        self.value = StoredAccount(\n            uint32(newValue.current),\n            uint32(newValue.latest),\n            bytes24(0),\n\n            uint64(UFixed6.unwrap(newValue.shares)),\n            uint64(UFixed6.unwrap(newValue.assets)),\n            uint64(UFixed6.unwrap(newValue.deposit)),\n            uint64(UFixed6.unwrap(newValue.redemption))\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/types/Checkpoint.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Checkpoint as PerennialCheckpoint } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Account } from \"./Account.sol\";\n\n/// @dev Checkpoint type\nstruct Checkpoint {\n    /// @dev The total amount of pending deposits\n    UFixed6 deposit;\n\n    /// @dev The total amount of pending redemptions\n    UFixed6 redemption;\n\n    /// @dev The total shares at the checkpoint\n    UFixed6 shares;\n\n    /// @dev The total assets at the checkpoint\n    Fixed6 assets;\n\n    /// @dev The total fee at the checkpoint\n    Fixed6 tradeFee;\n\n    /// @dev The total settlement fee at the checkpoint\n    UFixed6 settlementFee;\n\n    /// @dev The number of deposits and redemptions during the checkpoint\n    uint256 deposits;\n\n    /// @dev The number of deposits and redemptions during the checkpoint\n    uint256 redemptions;\n\n    // @dev The timestamp of of the checkpoint\n    uint256 timestamp;\n}\nusing CheckpointLib for Checkpoint global;\nstruct StoredCheckpoint {\n    /* slot 0 */\n    uint64 deposit;         // <= 18.44t\n    uint64 redemption;      // <= 18.44t\n    uint64 shares;          // <= 18.44t\n    int64 assets;           // <= 9.22t\n\n    /* slot 1 */\n    int64 tradeFee;         // <= 9.22t\n    uint64 settlementFee;   // <= 18.44t\n    uint32 deposits;        // <= 4.29b\n    uint32 timestamp;       // <= 4.29b\n    uint32 redemptions;\n    bytes4 __unallocated0__;\n}\nstruct CheckpointStorage { StoredCheckpoint value; }\nusing CheckpointStorageLib for CheckpointStorage global;\n\n/// @title Checkpoint\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the state for the checkpoint type\nlibrary CheckpointLib {\n    /// @notice Initializes the checkpoint\n    /// @dev Saves the current shares, and the assets + liabilities in the vault itself (not in the markets)\n    /// @param self The checkpoint to initialize\n    /// @param timestamp The timestamp of the checkpoint\n    /// @param global The global account\n    function next(Checkpoint memory self, uint256 timestamp, Account memory global) internal pure {\n        (self.timestamp, self.shares, self.assets) =\n            (timestamp, global.shares, Fixed6Lib.from(-1, global.deposit.add(global.assets)));\n        (self.deposit, self.redemption, self.tradeFee, self.settlementFee, self.deposits, self.redemptions) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, Fixed6Lib.ZERO, UFixed6Lib.ZERO, 0, 0);\n    }\n\n    /// @notice Updates the checkpoint with a new deposit or redemption\n    /// @param self The checkpoint to update\n    /// @param deposit The amount of new deposits\n    /// @param redemption The amount of new redemptions\n    function update(Checkpoint memory self, UFixed6 deposit, UFixed6 redemption) internal pure {\n        (self.deposit, self.redemption) =\n            (self.deposit.add(deposit), self.redemption.add(redemption));\n        if (!deposit.isZero()) self.deposits++;\n        if (!redemption.isZero()) self.redemptions++;\n    }\n\n    /// @notice Completes the checkpoint\n    /// @dev Increments the assets by the snapshotted amount of collateral in the underlying markets\n    /// @param self The checkpoint to complete\n    /// @param marketCheckpoint The checkpoint to complete with\n    function complete(Checkpoint memory self, PerennialCheckpoint memory marketCheckpoint) internal pure {\n        self.assets = self.assets.add(marketCheckpoint.collateral);\n        self.tradeFee = marketCheckpoint.tradeFee;\n        self.settlementFee = marketCheckpoint.settlementFee;\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the global context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesGlobal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        UFixed6 settlementFee = _settlementFeeForOrders(self, self.deposits);\n        return self.assets.lte(Fixed6Lib.ZERO) ?\n            assets.unsafeSub(settlementFee) :\n            _toShares(self, assets).unsafeSub(_toSharesExact(self, settlementFee));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsGlobal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        UFixed6 settlementFee = _settlementFeeForOrders(self, self.redemptions);\n        return (self.shares.isZero() ? shares : _toAssets(self, shares)).unsafeSub(settlementFee);\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the local context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesLocal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        UFixed6 settlementFee = _settlementFeeForOrders(self, 1);\n        return self.assets.lte(Fixed6Lib.ZERO) ?\n            assets.unsafeSub(settlementFee) :\n            _toShares(self, assets).unsafeSub(_toSharesExact(self, settlementFee));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the local context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsLocal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        UFixed6 settlementFee = _settlementFeeForOrders(self, 1);\n        return (self.shares.isZero() ? shares : _toAssets(self, shares)).unsafeSub(settlementFee);\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @dev Dev used in limit calculations when no settlement fee is available\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssets(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return (self.shares.isZero() ? shares : _toAssets(self, shares));\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function _toShares(Checkpoint memory self, UFixed6 assets) private pure returns (UFixed6) {\n        return _withSpread(self, _toSharesExact(self, assets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function _toAssets(Checkpoint memory self, UFixed6 shares) private pure returns (UFixed6) {\n        return _withSpread(self, _toAssetsExact(self, shares));\n    }\n\n    /// @notice Applies a spread to a given amount from the relative fee amount of the checkpoint\n    /// @param self The checkpoint to apply the spread to\n    /// @param amount The amount to apply the spread to\n    function _withSpread(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        UFixed6 totalAmount = self.deposit.add(_toAssetsExact(self, self.redemption));\n        UFixed6 totalAmountIncludingFee = UFixed6Lib.unsafeFrom(Fixed6Lib.from(totalAmount).sub(self.tradeFee));\n\n        return totalAmount.isZero() ?\n            amount :\n            amount.muldiv(totalAmountIncludingFee, totalAmount);\n    }\n\n    function _settlementFeeForOrders(Checkpoint memory self, uint256 orders) private pure returns (UFixed6) {\n        UFixed6 totalOrders = UFixed6Lib.from(self.deposits + self.redemptions);\n        return totalOrders.isZero() ?\n            UFixed6Lib.ZERO :\n            self.settlementFee.muldivOut(UFixed6Lib.from(orders), totalOrders);\n    }\n\n    function _toAssetsExact(Checkpoint memory self, UFixed6 shares) private pure returns (UFixed6) {\n        return shares.muldiv(UFixed6Lib.unsafeFrom(self.assets), self.shares);\n    }\n\n    function _toSharesExact(Checkpoint memory self, UFixed6 assets) private pure returns (UFixed6) {\n        return assets.muldiv(self.shares, UFixed6Lib.unsafeFrom(self.assets));\n    }\n\n    /// @notice Returns if the checkpoint is healthy\n    /// @dev A checkpoint is unhealthy when it has shares but no assets, since this cannot be recovered from\n    /// @param self The checkpoint to check\n    /// @return Whether the checkpoint is healthy\n    function unhealthy(Checkpoint memory self) internal pure returns (bool) {\n        return !self.shares.isZero() && self.assets.lte(Fixed6Lib.ZERO);\n    }\n}\n\n/// @dev (external-safe): this library is safe to externalize\nlibrary CheckpointStorageLib {\n    // sig: 0xba85116a\n    error CheckpointStorageInvalidError();\n\n    function read(CheckpointStorage storage self) internal view returns (Checkpoint memory) {\n        StoredCheckpoint memory storedValue = self.value;\n        return Checkpoint(\n            UFixed6.wrap(uint256(storedValue.deposit)),\n            UFixed6.wrap(uint256(storedValue.redemption)),\n            UFixed6.wrap(uint256(storedValue.shares)),\n            Fixed6.wrap(int256(storedValue.assets)),\n            Fixed6.wrap(int256(storedValue.tradeFee)),\n            UFixed6.wrap(uint256(storedValue.settlementFee)),\n            uint256(storedValue.deposits),\n            uint256(storedValue.redemptions),\n            uint256(storedValue.timestamp)\n        );\n    }\n\n    function store(CheckpointStorage storage self, Checkpoint memory newValue) internal {\n        if (newValue.deposit.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.redemption.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.shares.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.assets.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.assets.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.settlementFee.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.deposits > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n        if (newValue.redemptions > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n        if (newValue.timestamp > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n\n        self.value = StoredCheckpoint(\n            uint64(UFixed6.unwrap(newValue.deposit)),\n            uint64(UFixed6.unwrap(newValue.redemption)),\n            uint64(UFixed6.unwrap(newValue.shares)),\n            int64(Fixed6.unwrap(newValue.assets)),\n\n            int64(Fixed6.unwrap(newValue.tradeFee)),\n            uint64(UFixed6.unwrap(newValue.settlementFee)),\n            uint32(newValue.deposits),\n            uint32(newValue.timestamp),\n            uint32(newValue.redemptions),\n            bytes4(0)\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/types/Registration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IMarket } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev Registration type\nstruct Registration {\n    /// @dev The underlying market\n    IMarket market;\n\n    /// @dev The weight of the market\n    UFixed6 weight;\n\n    /// @dev The leverage of the market\n    UFixed6 leverage;\n}\nstruct StoredRegistration {\n    /* slot 0 */\n    address market;\n    uint32 weight;          // <= 4.29b\n    uint32 leverage;        // <= 4290x\n    bytes4 __unallocated0__;\n}\nstruct RegistrationStorage { StoredRegistration value; }\nusing RegistrationStorageLib for RegistrationStorage global;\n\n/// @dev (external-safe): this library is safe to externalize\nlibrary RegistrationStorageLib {\n    // sig: 0x92f03c86\n    error RegistrationStorageInvalidError();\n\n    function read(RegistrationStorage storage self) internal view returns (Registration memory) {\n        StoredRegistration memory storedValue = self.value;\n        return Registration(\n            IMarket(storedValue.market),\n            UFixed6.wrap(uint256(storedValue.weight)),\n            UFixed6.wrap(uint256(storedValue.leverage))\n        );\n    }\n\n    function store(RegistrationStorage storage self, Registration memory newValue) internal {\n        if (newValue.weight.gt(UFixed6.wrap(type(uint32).max))) revert RegistrationStorageInvalidError();\n        if (newValue.leverage.gt(UFixed6.wrap(type(uint32).max))) revert RegistrationStorageInvalidError();\n\n        self.value = StoredRegistration(\n            address(newValue.market),\n            uint32(UFixed6.unwrap(newValue.weight)),\n            uint32(UFixed6.unwrap(newValue.leverage)),\n            bytes4(0)\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/types/VaultParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev VaultParameter type\nstruct VaultParameter {\n    /// @dev The maximum total that can be deposited into the vault\n    UFixed6 maxDeposit;\n\n    /// @dev The minimum amount that can be deposited into the vault at one time\n    UFixed6 minDeposit;\n}\nstruct StoredVaultParameter {\n    /* slot 0 */\n    uint64 maxDeposit;\n    uint64 minDeposit;\n    bytes16 __unallocated0__;\n}\nstruct VaultParameterStorage { StoredVaultParameter value; } // SECURITY: must remain at (1) slots\nusing VaultParameterStorageLib for VaultParameterStorage global;\n\n/// @dev (external-safe): this library is safe to externalize\nlibrary VaultParameterStorageLib {\n    // sig: 0x0f9f8b19\n    error VaultParameterStorageInvalidError();\n\n    function read(VaultParameterStorage storage self) internal view returns (VaultParameter memory) {\n        StoredVaultParameter memory storedValue = self.value;\n\n        return VaultParameter(\n            UFixed6.wrap(uint256(storedValue.maxDeposit)),\n            UFixed6.wrap(uint256(storedValue.minDeposit))\n        );\n    }\n\n    function store(VaultParameterStorage storage self, VaultParameter memory newValue) internal {\n        if (newValue.maxDeposit.gt(UFixed6.wrap(type(uint64).max))) revert VaultParameterStorageInvalidError();\n        if (newValue.minDeposit.gt(UFixed6.wrap(type(uint64).max))) revert VaultParameterStorageInvalidError();\n\n        self.value = StoredVaultParameter(\n            uint64(UFixed6.unwrap(newValue.maxDeposit)),\n            uint64(UFixed6.unwrap(newValue.minDeposit)),\n            bytes16(0)\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/Vault.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IVaultFactory.sol\";\nimport \"./types/Account.sol\";\nimport \"./types/Checkpoint.sol\";\nimport \"./types/Registration.sol\";\nimport \"./types/VaultParameter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./libs/StrategyLib.sol\";\n\n/// @title Vault\n/// @notice Deploys underlying capital by weight in maker positions across registered markets\n/// @dev Vault deploys and rebalances collateral between the registered markets, while attempting to\n///      maintain `targetLeverage` with its open maker positions at any given time. Deposits are only gated in so much\n///      as to cap the maximum amount of assets in the vault.\n///\n///      All registered markets are expected to be on the same \"clock\", i.e. their oracle.current() is always equal.\n///\n///      The vault has a \"delayed settlement\" mechanism. After depositing to or redeeming from the vault, a user must\n///      wait until the next settlement of all underlying markets in order for vault settlement to be available.\ncontract Vault is IVault, Instance {\n    /// @dev The vault's name\n    string private _name;\n\n    /// @dev The underlying asset\n    Token18 public asset;\n\n    /// @dev The vault parameter set\n    VaultParameterStorage private _parameter;\n\n    /// @dev The total number of registered markets\n    uint256 public totalMarkets;\n\n    /// @dev Per-market registration state variables\n    mapping(uint256 => RegistrationStorage) private _registrations;\n\n    /// @dev Per-account accounting state variables\n    mapping(address => AccountStorage) private _accounts;\n\n    /// @dev Per-id accounting state variables\n    mapping(uint256 => CheckpointStorage) private _checkpoints;\n\n    /// @dev DEPRECATED SLOT -- previously the mappings\n    bytes32 private __unused0__;\n\n    /// @notice Initializes the vault\n    /// @param asset_ The underlying asset\n    /// @param initialMarket The initial market to register\n    /// @param initialDeposit The initial deposit amount\n    /// @param name_ The vault's name\n    function initialize(\n        Token18 asset_,\n        IMarket initialMarket,\n        UFixed6 initialDeposit,\n        string calldata name_\n    ) external initializer(1) {\n        __Instance__initialize();\n\n        asset = asset_;\n        _name = name_;\n        _register(initialMarket);\n        _updateParameter(VaultParameter(initialDeposit, UFixed6Lib.ZERO));\n    }\n\n    /// @notice Returns the vault parameter set\n    /// @return The vault parameter set\n    function parameter() external view returns (VaultParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the registration for a given market\n    /// @param marketId The market id\n    /// @return The registration for the given market\n    function registrations(uint256 marketId) external view returns (Registration memory) {\n        return _registrations[marketId].read();\n    }\n\n    /// @notice Returns the account state for a account\n    /// @param account The account to query\n    /// @return The account state for the given account\n    function accounts(address account) external view returns (Account memory) {\n        return _accounts[account].read();\n    }\n\n    /// @notice Returns the checkpoint for a given id\n    /// @param id The id to query\n    /// @return The checkpoint for the given id\n    function checkpoints(uint256 id) external view returns (Checkpoint memory) {\n        return _checkpoints[id].read();\n    }\n\n    /// @notice Returns the name of the vault\n    /// @return The name of the vault\n    function name() external view returns (string memory) {\n        return string(abi.encodePacked(\"Perennial V2 Vault: \", _name));\n    }\n\n    /// @notice Returns the total number of underlying assets at the last checkpoint\n    /// @return The total number of underlying assets at the last checkpoint\n    function totalAssets() public view returns (Fixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.assets\n            .add(Fixed6Lib.from(checkpoint.deposit))\n            .sub(Fixed6Lib.from(checkpoint.toAssetsGlobal(checkpoint.redemption)));\n    }\n\n    /// @notice Returns the total number of shares at the last checkpoint\n    /// @return The total number of shares at the last checkpoint\n    function totalShares() public view returns (UFixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.shares\n            .add(checkpoint.toSharesGlobal(checkpoint.deposit))\n            .sub(checkpoint.redemption);\n    }\n\n    /// @notice Converts a given amount of assets to shares\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets\n    function convertToShares(UFixed6 assets) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.unsafeFrom(totalAssets()), totalShares());\n        return _totalShares.isZero() ? assets : assets.muldiv(_totalShares, _totalAssets);\n    }\n\n    /// @notice Converts a given amount of shares to assets\n    /// @param shares Number of shares to convert to assets\n    /// @return Amount of assets for the given shares\n    function convertToAssets(UFixed6 shares) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.unsafeFrom(totalAssets()), totalShares());\n        return _totalShares.isZero() ? shares : shares.muldiv(_totalAssets, _totalShares);\n    }\n\n    /// @notice Registers a new market\n    /// @param market The market to register\n    function register(IMarket market) external onlyOwner {\n        rebalance(address(0));\n\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            if (_registrations[marketId].read().market == market) revert VaultMarketExistsError();\n        }\n\n        _register(market);\n    }\n\n    /// @notice Handles the registration for a new market\n    /// @param market The market to register\n    function _register(IMarket market) private {\n        if (!IVaultFactory(address(factory())).marketFactory().instances(market)) revert VaultNotMarketError();\n        if (!market.token().eq(asset)) revert VaultIncorrectAssetError();\n\n        asset.approve(address(market));\n\n        uint256 newMarketId = _registerMarket(market);\n        _updateMarket(newMarketId, newMarketId == 0 ? UFixed6Lib.ONE : UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Processes the state changes for a market registration\n    /// @param market The market to register\n    /// @return newMarketId The new market id\n    function _registerMarket(IMarket market) private returns (uint256 newMarketId) {\n        newMarketId = totalMarkets++;\n        _registrations[newMarketId].store(Registration(market, UFixed6Lib.ZERO, UFixed6Lib.ZERO));\n        emit MarketRegistered(newMarketId, market);\n    }\n\n    /// @notice Processes the state changes for a market update\n    /// @param marketId The market id\n    /// @param newWeight The new weight for the market\n    /// @param newLeverage The new leverage for the market\n    function _updateMarket(uint256 marketId, UFixed6 newWeight, UFixed6 newLeverage) private {\n        Registration memory registration = _registrations[marketId].read();\n        registration.weight = newWeight.eq(UFixed6Lib.MAX) ? registration.weight : newWeight;\n        registration.leverage = newLeverage.eq(UFixed6Lib.MAX) ? registration.leverage : newLeverage;\n        _registrations[marketId].store(registration);\n        emit MarketUpdated(marketId, registration.weight, registration.leverage);\n    }\n\n    /// @notice Settles, then updates the registration parameters for a given market\n    /// @param marketId The market id\n    /// @param newLeverage The new leverage\n    function updateLeverage(uint256 marketId, UFixed6 newLeverage) external onlyOwner {\n        rebalance(address(0));\n\n        if (marketId >= totalMarkets) revert VaultMarketDoesNotExistError();\n\n        _updateMarket(marketId, UFixed6Lib.MAX, newLeverage);\n    }\n\n    /// @notice Updates the set of market weights for the vault\n    /// @param newWeights The new set of market weights\n    function updateWeights(UFixed6[] calldata newWeights) external onlyOwner {\n        rebalance(address(0));\n\n        if (newWeights.length != totalMarkets) revert VaultMarketDoesNotExistError();\n\n        UFixed6 totalWeight;\n        for(uint256 i; i < totalMarkets; i++) {\n            _updateMarket(i, newWeights[i], UFixed6Lib.MAX);\n            totalWeight = totalWeight.add(newWeights[i]);\n        }\n\n        if (!totalWeight.eq(UFixed6Lib.ONE)) revert VaultAggregateWeightError();\n    }\n\n    /// @notice Settles, then updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function updateParameter(VaultParameter memory newParameter) external onlyOwner {\n        rebalance(address(0));\n        _updateParameter(newParameter);\n    }\n\n    /// @notice Updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function _updateParameter(VaultParameter memory newParameter) private {\n        _parameter.store(newParameter);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Syncs `account`'s state up to current\n    /// @param account The account that should be synced\n    function settle(address account) public whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _saveContext(context, account);\n    }\n\n    /// @notice Syncs `account`'s state up to current\n    /// @dev Rebalances only the collateral of the vault\n    /// @param account The account that should be synced\n    function rebalance(address account) public whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _manage(context, UFixed6Lib.ZERO, UFixed6Lib.ZERO, false);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates `account`, depositing `depositAssets` assets, redeeming `redeemShares` shares, and claiming `claimAssets` assets\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function update(\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) external whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _checkpoint(context);\n        _update(context, account, depositAssets, redeemShares, claimAssets);\n        _saveContext(context, account);\n    }\n\n    /// @notice Loads or initializes the current checkpoint\n    /// @param context The context to use\n    function _checkpoint(Context memory context) private view {\n        context.currentId = context.global.current;\n        context.currentCheckpoint = _checkpoints[context.currentId].read();\n\n        if (context.currentTimestamp > context.currentCheckpoint.timestamp) {\n            context.currentId++;\n            context.currentCheckpoint.next(context.currentTimestamp, context.global);\n        }\n    }\n\n    /// @notice Handles updating the account's position\n    /// @param context The context to use\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) private {\n        // magic values\n        if (claimAssets.eq(UFixed6Lib.MAX)) claimAssets = context.local.assets;\n        if (redeemShares.eq(UFixed6Lib.MAX)) redeemShares = context.local.shares;\n\n        // invariant\n        if (msg.sender != account && !IVaultFactory(address(factory())).operators(account, msg.sender))\n            revert VaultNotOperatorError();\n        if (!depositAssets.add(redeemShares).add(claimAssets).eq(depositAssets.max(redeemShares).max(claimAssets)))\n            revert VaultNotSingleSidedError();\n        if (depositAssets.gt(_maxDeposit(context)))\n            revert VaultDepositLimitExceededError();\n        if (!depositAssets.isZero() && depositAssets.lt(context.parameter.minDeposit))\n            revert VaultInsufficientMinimumError();\n        if (!redeemShares.isZero() && context.latestCheckpoint.toAssets(redeemShares).lt(context.parameter.minDeposit))\n            revert VaultInsufficientMinimumError();\n        if (context.local.current != context.local.latest) revert VaultExistingOrderError();\n\n        // asses socialization\n        UFixed6 claimAmount = _socialize(context, claimAssets);\n\n        // update positions\n        context.global.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.local.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.currentCheckpoint.update(depositAssets, redeemShares);\n\n        // manage assets\n        asset.pull(msg.sender, UFixed18Lib.from(depositAssets));\n        _manage(context, depositAssets, claimAmount, !depositAssets.isZero() || !redeemShares.isZero());\n        asset.push(msg.sender, UFixed18Lib.from(claimAmount));\n\n        emit Updated(msg.sender, account, context.currentId, depositAssets, redeemShares, claimAssets);\n    }\n\n    /// @notice Returns the claim amount after socialization\n    /// @param context The context to use\n    /// @param claimAssets The amount of assets to claim\n    function _socialize(Context memory context, UFixed6 claimAssets) private pure returns (UFixed6) {\n        return context.global.assets.isZero() ?\n            UFixed6Lib.ZERO :\n            claimAssets.muldiv(\n                UFixed6Lib.unsafeFrom(context.totalCollateral).min(context.global.assets),\n                context.global.assets\n            );\n    }\n\n    /// @notice Handles settling the vault's underlying markets\n    function _settleUnderlying() private {\n        for (uint256 marketId; marketId < totalMarkets; marketId++)\n            _registrations[marketId].read().market.settle(address(this));\n    }\n\n    /// @notice Handles settling the vault state\n    /// @dev Run before every stateful operation to settle up the latest global state of the vault\n    /// @param context The context to use\n    function _settle(Context memory context, address account) private {\n        Checkpoint memory nextCheckpoint;\n\n        // settle global positions\n        while (\n            context.global.current > context.global.latest &&\n            context.latestTimestamp >= (nextCheckpoint = _checkpoints[context.global.latest + 1].read()).timestamp\n        ) {\n            nextCheckpoint.complete(_checkpointAtId(context, nextCheckpoint.timestamp));\n            context.global.processGlobal(\n                context.global.latest + 1,\n                nextCheckpoint,\n                nextCheckpoint.deposit,\n                nextCheckpoint.redemption\n            );\n            _checkpoints[context.global.latest].store(nextCheckpoint);\n            context.latestCheckpoint = nextCheckpoint;\n        }\n\n        if (account == address(0)) return;\n\n        // settle local position\n        if (\n            context.local.current > context.local.latest &&\n            context.latestTimestamp >= (nextCheckpoint = _checkpoints[context.local.current].read()).timestamp\n        )\n            context.local.processLocal(\n                context.local.current,\n                nextCheckpoint,\n                context.local.deposit,\n                context.local.redemption\n            );\n    }\n\n    /// @notice Manages the internal collateral and position strategy of the vault\n    /// @param deposit The amount of assets that are being deposited into the vault\n    /// @param withdrawal The amount of assets that need to be withdrawn from the markets into the vault\n    /// @param shouldRebalance Whether to rebalance the vault's position\n    function _manage(Context memory context, UFixed6 deposit, UFixed6 withdrawal, bool shouldRebalance) private {\n        if (context.totalCollateral.lt(Fixed6Lib.ZERO)) return;\n\n        StrategyLib.MarketTarget[] memory targets = StrategyLib\n            .load(context.registrations)\n            .allocate(\n                deposit,\n                withdrawal,\n                _ineligible(context, withdrawal)\n            );\n\n        for (uint256 marketId; marketId < context.registrations.length; marketId++)\n            if (targets[marketId].collateral.lt(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId], shouldRebalance);\n        for (uint256 marketId; marketId < context.registrations.length; marketId++)\n            if (targets[marketId].collateral.gte(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId], shouldRebalance);\n    }\n\n    /// @notice Returns the amount of collateral is ineligible for allocation\n    /// @param context The context to use\n    /// @param withdrawal The amount of assets that need to be withdrawn from the markets into the vault\n    /// @return The amount of assets that are ineligible from being allocated\n    function _ineligible(Context memory context, UFixed6 withdrawal) private pure returns (UFixed6) {\n        // assets eligible for redemption\n        UFixed6 redemptionEligible = UFixed6Lib.unsafeFrom(context.totalCollateral)\n            // assets pending claim (use latest global assets before withdrawal for redeemability)\n            .unsafeSub(context.global.assets.add(withdrawal))\n            // assets pending deposit\n            .unsafeSub(context.global.deposit);\n\n        return redemptionEligible\n            // approximate assets up for redemption\n            .mul(context.global.redemption.unsafeDiv(context.global.shares.add(context.global.redemption)))\n            // assets pending claim (use new global assets after withdrawal for eligability)\n            .add(context.global.assets);\n            // assets pending deposit are eligible for allocation\n    }\n\n    /// @notice Adjusts the position on `market` to `targetPosition`\n    /// @param registration The registration of the market to use\n    /// @param target The new state to target\n    /// @param shouldRebalance Whether to rebalance the vault's position\n    function _retarget(\n        Registration memory registration,\n        StrategyLib.MarketTarget memory target,\n        bool shouldRebalance\n    ) private {\n        registration.market.update(\n            address(this),\n            shouldRebalance ? target.position : UFixed6Lib.MAX,\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            target.collateral,\n            false\n        );\n    }\n\n    /// @notice Loads the context for the given `account`\n    /// @param account Account to load the context for\n    /// @return context The context\n    function _loadContext(address account) private view returns (Context memory context) {\n        context.parameter = _parameter.read();\n\n        context.latestTimestamp = type(uint256).max;\n        context.currentTimestamp = type(uint256).max;\n        context.registrations = new Registration[](totalMarkets);\n        context.collaterals = new Fixed6[](totalMarkets);\n\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            // parameter\n            Registration memory registration = _registrations[marketId].read();\n            context.registrations[marketId] = registration;\n\n            // version\n            (OracleVersion memory oracleVersion, uint256 currentTimestamp) = registration.market.oracle().status();\n            context.latestTimestamp = Math.min(context.latestTimestamp, oracleVersion.timestamp);\n            if (context.currentTimestamp == type(uint256).max) context.currentTimestamp = currentTimestamp;\n            else if (currentTimestamp != context.currentTimestamp) revert VaultCurrentOutOfSyncError();\n\n            // local\n            Local memory local = registration.market.locals(address(this));\n            context.collaterals[marketId] = local.collateral;\n            context.totalCollateral = context.totalCollateral.add(local.collateral);\n        }\n\n        if (account != address(0)) context.local = _accounts[account].read();\n        context.global = _accounts[address(0)].read();\n        context.latestCheckpoint = _checkpoints[context.global.latest].read();\n    }\n\n    /// @notice Saves the context into storage\n    /// @param context Context to use\n    /// @param account Account to save the context for\n    function _saveContext(Context memory context, address account) private {\n        if (account != address(0)) _accounts[account].store(context.local);\n        _accounts[address(0)].store(context.global);\n        _checkpoints[context.currentId].store(context.currentCheckpoint);\n    }\n\n    /// @notice The maximum available deposit amount\n    /// @param context Context to use in calculation\n    /// @return Maximum available deposit amount\n    function _maxDeposit(Context memory context) private view returns (UFixed6) {\n        return context.latestCheckpoint.unhealthy() ?\n            UFixed6Lib.ZERO :\n            context.parameter.maxDeposit.unsafeSub(UFixed6Lib.unsafeFrom(totalAssets()).add(context.global.deposit));\n    }\n\n    /// @notice Returns the aggregate perennial checkpoint for the vault at position\n    /// @param context Context to use\n    /// @param timestamp The timestamp to use\n    /// @return checkpoint The checkpoint at the given position\n    function _checkpointAtId(\n        Context memory context,\n        uint256 timestamp\n    ) public view returns (PerennialCheckpoint memory checkpoint) {\n        for (uint256 marketId; marketId < context.registrations.length; marketId++) {\n            PerennialCheckpoint memory marketCheckpoint = context.registrations[marketId].market\n                .checkpoints(address(this), timestamp);\n\n            (checkpoint.collateral, checkpoint.tradeFee, checkpoint.settlementFee) = (\n                checkpoint.collateral.add(marketCheckpoint.collateral),\n                checkpoint.tradeFee.add(marketCheckpoint.tradeFee),\n                checkpoint.settlementFee.add(marketCheckpoint.settlementFee)\n            );\n        }\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Ownable.sol\";\nimport \"@equilibria/root/attribute/Factory.sol\";\nimport \"@equilibria/root/attribute/Pausable.sol\";\nimport \"./interfaces/IVaultFactory.sol\";\nimport { VaultParameter } from \"./types/VaultParameter.sol\";\n\n/// @title VaultFactory\n/// @notice Manages creating new markets and global protocol parameters.\ncontract VaultFactory is IVaultFactory, Factory {\n    UFixed6 public immutable initialAmount;\n\n    /// @dev The market factory\n    IMarketFactory public immutable marketFactory;\n\n    /// @dev Mapping of allowed operators for each account\n    mapping(address => mapping(address => bool)) public operators;\n\n    /// @notice Constructs the contract\n    /// @param marketFactory_ The market factory\n    /// @param implementation_ The initial vault implementation contract\n    /// @param initialAmount_ The initial amount of the underlying asset to deposit and lock\n    constructor(\n        IMarketFactory marketFactory_,\n        address implementation_,\n        UFixed6 initialAmount_\n    ) Factory(implementation_) {\n        marketFactory = marketFactory_;\n        initialAmount = initialAmount_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Factory__initialize();\n    }\n\n    /// @notice Creates a new vault\n    /// @param asset The underlying asset of the vault\n    /// @param initialMarket The initial market of the vault\n    /// @param name The name of the vault\n    /// @return newVault The new vault\n    function create(\n        Token18 asset,\n        IMarket initialMarket,\n        string calldata name\n    ) external onlyOwner returns (IVault newVault) {\n        // create vault\n        newVault = IVault(address(\n            _create(abi.encodeCall(IVault.initialize, (asset, initialMarket, initialAmount, name)))));\n\n        // deposit and lock initial amount of the underlying asset to prevent inflation attacks\n        asset.pull(msg.sender, UFixed18Lib.from(initialAmount));\n        asset.approve(address(newVault), UFixed18Lib.from(initialAmount));\n        newVault.update(address(this), initialAmount, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n\n        emit VaultCreated(newVault, asset, initialMarket);\n    }\n\n    /// @notice Updates the status of an operator for the caller\n    /// @param operator The operator to update\n    /// @param newEnabled The new status of the operator\n    function updateOperator(address operator, bool newEnabled) external {\n        operators[msg.sender][operator] = newEnabled;\n        emit OperatorUpdated(msg.sender, operator, newEnabled);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-verifier/contracts/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IVerifierBase } from \"@equilibria/root/verifier/interfaces/IVerifierBase.sol\";\nimport { Common } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { Intent } from \"../types/Intent.sol\";\nimport { OperatorUpdate } from \"../types/OperatorUpdate.sol\";\nimport { SignerUpdate } from \"../types/SignerUpdate.sol\";\nimport { AccessUpdateBatch } from \"../types/AccessUpdateBatch.sol\";\n\ninterface IVerifier is IVerifierBase {\n    function verifyIntent(Intent calldata intent, bytes calldata signature) external;\n    function verifyOperatorUpdate(OperatorUpdate calldata operatorUpdate, bytes calldata signature) external;\n    function verifySignerUpdate(SignerUpdate calldata signerUpdate, bytes calldata signature) external;\n    function verifyAccessUpdateBatch(AccessUpdateBatch calldata accessUpdateBatch, bytes calldata signature) external;\n}"
    },
    "@equilibria/perennial-v2-verifier/contracts/types/AccessUpdate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\n\nstruct AccessUpdate {\n    /// @dev The generic signer or operator to approve for the signing account\n    address accessor;\n\n    /// @dev The new status of the signer or operator\n    bool approved;\n}\nusing AccessUpdateLib for AccessUpdate global;\n\n/// @title AccessUpdateLib\n/// @notice Library for AccessUpdate logic and data.\nlibrary AccessUpdateLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\"AccessUpdate(address accessor,bool approved)\");\n\n    function hash(AccessUpdate memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.accessor, self.approved));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-verifier/contracts/types/AccessUpdateBatch.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { AccessUpdate, AccessUpdateLib } from \"../types/AccessUpdate.sol\";\n\nstruct AccessUpdateBatch {\n    /// @dev The operator access update messages\n    AccessUpdate[] operators;\n\n    /// @dev The signer access update messages\n    AccessUpdate[] signers;\n\n    /// @dev The common information for the intent\n    Common common;\n}\nusing AccessUpdateBatchLib for AccessUpdateBatch global;\n\n/// @title AccessUpdateBatchLib\n/// @notice Library for AccessUpdateBatch logic and data.\nlibrary AccessUpdateBatchLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"AccessUpdateBatch(AccessUpdate[] operators,AccessUpdate[] signers,Common common)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    function hash(AccessUpdateBatch memory self) internal pure returns (bytes32) {\n        bytes32[] memory operatorHashes = new bytes32[](self.operators.length);\n        bytes32[] memory signerHashes = new bytes32[](self.signers.length);\n\n        for (uint256 i = 0; i < self.operators.length; i++)\n            operatorHashes[i] = AccessUpdateLib.hash(self.operators[i]);\n        for (uint256 i = 0; i < self.signers.length; i++)\n            signerHashes[i] = AccessUpdateLib.hash(self.signers[i]);\n\n        return keccak256(\n            abi.encode(\n                STRUCT_HASH,\n                keccak256(abi.encodePacked(operatorHashes)),\n                keccak256(abi.encodePacked(signerHashes)),\n                CommonLib.hash(self.common)\n            )\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-verifier/contracts/types/Intent.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\n\nstruct Intent {\n    /// @dev The size and direction of the order being opened by the taker\n    ///       - Positive opens long / Negative opens short\n    ///       - The maker will open the opposite side of the order\n    ///       - To close, open an order in the opposite direction\n    Fixed6 amount;\n\n    /// @dev The price to execute the order at\n    Fixed6 price;\n\n    /// @dev The solver fee, a percentage of the substractive interface fee\n    UFixed6 fee;\n\n    /// @dev The referral address of the originator of the order (ex. the interface)\n    address originator;\n\n    /// @dev The referral address of the solver of the order (ex. the router)\n    address solver;\n\n    /// @dev The minimium collateralization ratio that must be maintained after the order is executed\n    UFixed6 collateralization;\n\n    /// @dev The common information for the intent\n    Common common;\n}\nusing IntentLib for Intent global;\n\n/// @title IntentLib\n/// @notice Library for Intent logic and data.\nlibrary IntentLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"Intent(int256 amount,int256 price,uint256 fee,address originator,address solver,uint256 collateralization,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    function hash(Intent memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.amount, self.price, self.fee, self.originator, self.solver, self.collateralization, CommonLib.hash(self.common)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-verifier/contracts/types/OperatorUpdate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { AccessUpdate, AccessUpdateLib } from \"./AccessUpdate.sol\";\n\nstruct OperatorUpdate {\n    /// @dev The operator access to update\n    AccessUpdate access;\n\n    /// @dev The common information for the intent\n    Common common;\n}\nusing OperatorUpdateLib for OperatorUpdate global;\n\n/// @title OperatorUpdateLib\n/// @notice Library for OperatorUpdate logic and data.\nlibrary OperatorUpdateLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"OperatorUpdate(AccessUpdate access,Common common)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    function hash(OperatorUpdate memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, AccessUpdateLib.hash(self.access), CommonLib.hash(self.common)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-verifier/contracts/types/SignerUpdate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { AccessUpdate, AccessUpdateLib } from \"./AccessUpdate.sol\";\n\nstruct SignerUpdate {\n    /// @dev The signer access to update\n    AccessUpdate access;\n\n    /// @dev The common information for the intent\n    Common common;\n}\nusing SignerUpdateLib for SignerUpdate global;\n\n/// @title SignerUpdateLib\n/// @notice Library for SignerUpdate logic and data.\nlibrary SignerUpdateLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"SignerUpdate(AccessUpdate access,Common common)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    function hash(SignerUpdate memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, AccessUpdateLib.hash(self.access), CommonLib.hash(self.common)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-verifier/contracts/Verifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { VerifierBase } from \"@equilibria/root/verifier/VerifierBase.sol\";\n\nimport { IVerifier } from \"./interfaces/IVerifier.sol\";\nimport { Intent, IntentLib } from \"./types/Intent.sol\";\nimport { OperatorUpdate, OperatorUpdateLib } from \"./types/OperatorUpdate.sol\";\nimport { SignerUpdate, SignerUpdateLib } from \"./types/SignerUpdate.sol\";\nimport { AccessUpdateBatch, AccessUpdateBatchLib } from \"./types/AccessUpdateBatch.sol\";\n\n/// @title Verifier\n/// @notice Singleton ERC712 signed message verifier for the Perennial protocol.\n/// @dev Handles nonce management for verified messages.\n///       - nonce is a single use unique value per message that is invalidated after use\n///       - group allows for an entire set of messages to be invalidated via a single cancel operation\n///\n///      Messages verification request must come from the domain address if it is set.\n///       - In the case of intent / fills, this means that the market should be set as the domain.\n///\ncontract Verifier is VerifierBase, IVerifier {\n    /// @dev Initializes the domain separator and parameter caches\n    constructor() EIP712(\"Perennial\", \"1.0.0\") { }\n\n    /// @notice Verifies the signature of an intent order type\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param intent The intent order to verify\n    /// @param signature The signature of the taker for the intent order\n    function verifyIntent(Intent calldata intent, bytes calldata signature)\n        external\n        validateAndCancel(intent.common, signature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            intent.common.signer,\n            _hashTypedDataV4(IntentLib.hash(intent)),\n            signature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @notice Verifies the signature of a operator update type\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param operatorUpdate The operator update message to verify\n    /// @param signature The signature of the account for the operator update\n    function verifyOperatorUpdate(OperatorUpdate calldata operatorUpdate, bytes calldata signature)\n        external\n        validateAndCancel(operatorUpdate.common, signature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            operatorUpdate.common.signer,\n            _hashTypedDataV4(OperatorUpdateLib.hash(operatorUpdate)),\n            signature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @notice Verifies the signature of a signer update type\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param signerUpdate The signer update message to verify\n    /// @param signature The signature of the account for the signer update\n    function verifySignerUpdate(SignerUpdate calldata signerUpdate, bytes calldata signature)\n        external\n        validateAndCancel(signerUpdate.common, signature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            signerUpdate.common.signer,\n            _hashTypedDataV4(SignerUpdateLib.hash(signerUpdate)),\n            signature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @notice Verifies the signature of an access update batch type\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param accessUpdateBatch The batch access update (operator and signer) message to verify\n    /// @param signature The signature of the account for the batch access update\n    function verifyAccessUpdateBatch(AccessUpdateBatch calldata accessUpdateBatch, bytes calldata signature)\n        external\n        validateAndCancel(accessUpdateBatch.common, signature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            accessUpdateBatch.common.signer,\n            _hashTypedDataV4(AccessUpdateBatchLib.hash(accessUpdateBatch)),\n            signature\n        )) revert VerifierInvalidSignerError();\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/interfaces/IMarket.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/perennial-v2-verifier/contracts/types/Intent.sol\";\nimport \"./IOracleProvider.sol\";\nimport \"../types/OracleVersion.sol\";\nimport \"../types/MarketParameter.sol\";\nimport \"../types/RiskParameter.sol\";\nimport \"../types/Version.sol\";\nimport \"../types/Local.sol\";\nimport \"../types/Global.sol\";\nimport \"../types/Position.sol\";\nimport \"../types/Checkpoint.sol\";\nimport \"../types/Guarantee.sol\";\nimport \"../libs/VersionLib.sol\";\n\ninterface IMarket is IInstance {\n    struct MarketDefinition {\n        Token18 token;\n        IOracleProvider oracle;\n    }\n\n    struct Context {\n        address account;\n        MarketParameter marketParameter;\n        RiskParameter riskParameter;\n        OracleVersion latestOracleVersion;\n        uint256 currentTimestamp;\n        Global global;\n        Local local;\n        Position latestPositionGlobal;\n        Position latestPositionLocal;\n        Order pendingGlobal;\n        Order pendingLocal;\n    }\n\n    struct SettlementContext {\n        Version latestVersion;\n        Checkpoint latestCheckpoint;\n        OracleVersion orderOracleVersion;\n    }\n\n    struct UpdateContext {\n        bool operator;\n        bool signer;\n        address liquidator;\n        address orderReferrer;\n        UFixed6 orderReferralFee;\n        address guaranteeReferrer;\n        UFixed6 guaranteeReferralFee;\n        Order orderGlobal;\n        Order orderLocal;\n        Position currentPositionGlobal;\n        Position currentPositionLocal;\n        Guarantee guaranteeGlobal;\n        Guarantee guaranteeLocal;\n        UFixed6 collateralization;\n    }\n\n    event Updated(address indexed sender, address indexed account, uint256 version, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect, address referrer);\n    event OrderCreated(address indexed account, Order order, Guarantee guarantee, address liquidator, address orderReferrer, address guaranteeReferrer);\n    event PositionProcessed(uint256 orderId, Order order, VersionAccumulationResult accumulationResult);\n    event AccountPositionProcessed(address indexed account, uint256 orderId, Order order, CheckpointAccumulationResult accumulationResult);\n    event BeneficiaryUpdated(address newBeneficiary);\n    event CoordinatorUpdated(address newCoordinator);\n    /// @notice Fee earned by an account was transferred from market to a receiver\n    /// @param account User who earned the fee\n    /// @param receiver Delegated operator of the account, or the account itself\n    /// @param amount Collateral transferred from market to receiver\n    event FeeClaimed(address indexed account, address indexed receiver, UFixed6 amount);\n    event ExposureClaimed(address indexed account, Fixed6 amount);\n    event ParameterUpdated(MarketParameter newParameter);\n    event RiskParameterUpdated(RiskParameter newRiskParameter);\n\n    // sig: 0x0fe90964\n    error MarketInsufficientLiquidityError();\n    // sig: 0x00e2b6a8\n    error MarketInsufficientMarginError();\n    // sig: 0x442145e5\n    error MarketInsufficientCollateralError();\n    // sig: 0xba555da7\n    error MarketProtectedError();\n    // sig: 0x6ed43d8e\n    error MarketMakerOverLimitError();\n    // sig: 0x29ab4c44\n    error MarketClosedError();\n    // sig: 0x07732aee\n    error MarketCollateralBelowLimitError();\n    // sig: 0x5bdace60\n    error MarketOperatorNotAllowedError();\n    // sig: 0x8a68c1dc\n    error MarketNotSingleSidedError();\n    // sig: 0x736f9fda\n    error MarketOverCloseError();\n    // sig: 0x935bdc21\n    error MarketExceedsPendingIdLimitError();\n    // sig: 0x9bca0625\n    error MarketNotCoordinatorError();\n    // sig: 0xb602d086\n    error MarketNotBeneficiaryError();\n    // sig: 0x3222db45\n    /// @custom:error Sender is not authorized to interact with markets on behalf of the account\n    error MarketNotOperatorError();\n    // sig: 0x534f7fe6\n    error MarketInvalidProtectionError();\n    // sig: 0xab1e3a00\n    error MarketStalePriceError();\n    // sig: 0x15f9ae70\n    error MarketEfficiencyUnderLimitError();\n    // sig: 0x7302d51a\n    error MarketInvalidMarketParameterError(uint256 code);\n    // sig: 0xc5f0e98a\n    error MarketInvalidRiskParameterError(uint256 code);\n    // sig: 0x9dbdc5fd\n    error MarketInvalidReferrerError();\n    // sig: 0x5c5cb438\n    error MarketSettleOnlyError();\n    // sig: 0x1e9d2296\n    error MarketInvalidIntentFeeError();\n\n    // sig: 0x2142bc27\n    error GlobalStorageInvalidError();\n    // sig: 0xc83d08ec\n    error LocalStorageInvalidError();\n    // sig: 0x7c53e926\n    error MarketParameterStorageInvalidError();\n    // sig: 0x98eb4898\n    error PositionStorageLocalInvalidError();\n    // sig: 0x7ecd083f\n    error RiskParameterStorageInvalidError();\n    // sig: 0xd2777e72\n    error VersionStorageInvalidError();\n\n    function initialize(MarketDefinition calldata definition_) external;\n    function migrate() external;\n    function token() external view returns (Token18);\n    function oracle() external view returns (IOracleProvider);\n    function beneficiary() external view returns (address);\n    function coordinator() external view returns (address);\n    function positions(address account) external view returns (Position memory);\n    function pendingOrders(address account, uint256 id) external view returns (Order memory);\n    function guarantees(address account, uint256 id) external view returns (Guarantee memory);\n    function pendings(address account) external view returns (Order memory);\n    function locals(address account) external view returns (Local memory);\n    function versions(uint256 timestamp) external view returns (Version memory);\n    function position() external view returns (Position memory);\n    function pendingOrder(uint256 id) external view returns (Order memory);\n    function guarantee(uint256 id) external view returns (Guarantee memory);\n    function pending() external view returns (Order memory);\n    function global() external view returns (Global memory);\n    function checkpoints(address account, uint256 version) external view returns (Checkpoint memory);\n    function liquidators(address account, uint256 id) external view returns (address);\n    function orderReferrers(address account, uint256 id) external view returns (address);\n    function guaranteeReferrers(address account, uint256 id) external view returns (address);\n    function settle(address account) external;\n    function update(address account, Intent calldata intent, bytes memory signature) external;\n    function update(address account, Fixed6 amount, Fixed6 collateral, address referrer) external;\n    function update(address account, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect) external;\n    function update(address account, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect, address referrer) external;\n    function parameter() external view returns (MarketParameter memory);\n    function riskParameter() external view returns (RiskParameter memory);\n    function updateBeneficiary(address newBeneficiary) external;\n    function updateCoordinator(address newCoordinator) external;\n    function updateParameter(MarketParameter memory newParameter) external;\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external;\n    function claimFee(address account) external returns (UFixed6);\n}\n"
    },
    "@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport \"@equilibria/perennial-v2-verifier/contracts/interfaces/IVerifier.sol\";\nimport \"@equilibria/perennial-v2-verifier/contracts/types/OperatorUpdate.sol\";\nimport \"@equilibria/perennial-v2-verifier/contracts/types/SignerUpdate.sol\";\nimport \"@equilibria/perennial-v2-verifier/contracts/types/AccessUpdate.sol\";\nimport \"@equilibria/perennial-v2-verifier/contracts/types/AccessUpdateBatch.sol\";\nimport \"../types/ProtocolParameter.sol\";\nimport \"./IMarket.sol\";\n\ninterface IMarketFactory is IFactory {\n    event ParameterUpdated(ProtocolParameter newParameter);\n    event ExtensionUpdated(address indexed operator, bool newEnabled);\n    event OperatorUpdated(address indexed account, address indexed operator, bool newEnabled);\n    event SignerUpdated(address indexed account, address indexed signer, bool newEnabled);\n    event ReferralFeeUpdated(address indexed referrer, UFixed6 newFee);\n    event MarketCreated(IMarket indexed market, IMarket.MarketDefinition definition);\n\n    // sig: 0x0a37dc74\n    error FactoryInvalidPayoffError();\n    // sig: 0x5116bce5\n    error FactoryInvalidOracleError();\n    // sig: 0x213e2260\n    error FactoryAlreadyRegisteredError();\n    // sig: 0x6928a80f\n    error MarketFactoryInvalidSignerError();\n    // sig: 0x199d4b3e\n    error MarketFactoryInvalidReferralFeeError();\n\n    // sig: 0x4dc1bc59\n    error ProtocolParameterStorageInvalidError();\n\n    function oracleFactory() external view returns (IFactory);\n    function verifier() external view returns (IVerifier);\n    function parameter() external view returns (ProtocolParameter memory);\n    function extensions(address extension) external view returns (bool);\n    function operators(address account, address operator) external view returns (bool);\n    function signers(address signer, address operator) external view returns (bool);\n    function referralFees(address referrer) external view returns (UFixed6);\n    function markets(IOracleProvider oracle) external view returns (IMarket);\n    function authorization(address account, address sender, address signer, address orderReferrer) external view returns (bool, bool, UFixed6);\n    function initialize() external;\n    function updateParameter(ProtocolParameter memory newParameter) external;\n    function updateExtension(address extension, bool newEnabled) external;\n    function updateOperator(address operator, bool newEnabled) external;\n    function updateOperatorWithSignature(OperatorUpdate calldata operatorUpdate, bytes calldata signature) external;\n    function updateSigner(address signer, bool newEnabled) external;\n    function updateSignerWithSignature(SignerUpdate calldata signerUpdate, bytes calldata signature) external;\n    function updateAccessBatch(AccessUpdate[] calldata operators, AccessUpdate[] calldata signers) external;\n    function updateAccessBatchWithSignature(AccessUpdateBatch calldata accessUpdateBatch, bytes calldata signature) external;\n    function updateReferralFee(address referrer, UFixed6 newReferralFee) external;\n    function create(IMarket.MarketDefinition calldata definition) external returns (IMarket);\n}\n"
    },
    "@equilibria/perennial-v2/contracts/interfaces/IOracleProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { OracleReceipt } from \"../types/OracleReceipt.sol\";\nimport { OracleVersion } from \"../types/OracleVersion.sol\";\nimport { IMarket } from \"./IMarket.sol\";\n\n/// @dev OracleVersion Invariants\n///       - Version are requested at a timestamp, the current timestamp is determined by the oracle\n///         - The current timestamp may not be equal to block.timestamp, for example when batching timestamps\n///       - Versions are allowed to \"fail\" and will be marked as .valid = false\n///         - Invalid versions will always include the latest valid price as its price field\n///       - Versions must be committed in order, i.e. all requested versions prior to latestVersion must be available\n///       - Non-requested versions may be committed, but will not receive a settlement fee\n///         - This is useful for immediately liquidating an account with a valid off-chain price in between orders\n///         - Satisfying the above constraints, only versions more recent than the latest version may be committed\n///       - Current must always be greater than Latest, never equal\ninterface IOracleProvider {\n    // sig: 0x652fafab\n    error OracleProviderUnauthorizedError();\n\n    event OracleProviderVersionRequested(uint256 indexed version, bool newPrice);\n    event OracleProviderVersionFulfilled(OracleVersion version);\n\n    function request(IMarket market, address account) external;\n    function status() external view returns (OracleVersion memory, uint256);\n    function latest() external view returns (OracleVersion memory);\n    function current() external view returns (uint256);\n    function at(uint256 timestamp) external view returns (OracleVersion memory, OracleReceipt memory);\n}"
    },
    "@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../types/OracleVersion.sol\";\nimport \"./IOracleProvider.sol\";\n\ninterface IOracleProviderFactory {\n    event OracleCreated(IOracleProvider indexed oracle, bytes32 indexed id);\n\n    function oracles(bytes32 id) external view returns (IOracleProvider);\n    function ids(IOracleProvider oracleProvider) external view returns (bytes32 id);\n}"
    },
    "@equilibria/perennial-v2/contracts/libs/CheckpointLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"../interfaces/IMarket.sol\";\nimport \"../types/OracleVersion.sol\";\nimport \"../types/RiskParameter.sol\";\nimport \"../types/Global.sol\";\nimport \"../types/Local.sol\";\nimport \"../types/Order.sol\";\nimport \"../types/Version.sol\";\nimport \"../types/Checkpoint.sol\";\nimport \"../types/Guarantee.sol\";\n\n\nstruct CheckpointAccumulationResponse {\n    /// @dev Total Collateral change due to collateral, price override, and trade fee and offset\n    Fixed6 collateral;\n\n    /// @dev Liquidation fee accumulated for this checkpoint (only if the order is protected)\n    UFixed6 liquidationFee;\n\n    /// @dev Subtractive fee accumulated from the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 subtractiveFee;\n\n    /// @dev Solver fee accumulated the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 solverFee;\n}\n\nstruct CheckpointAccumulationResult {\n    /// @dev Total Collateral change due to pnl, funding, and interest from the previous position to the next position\n    Fixed6 collateral;\n\n    /// @dev Collateral change from the difference between the price override and underlying market price\n    Fixed6 priceOverride;\n\n    /// @dev Trade fee accumulated for this checkpoint\n    UFixed6 tradeFee;\n\n    /// @dev Trade price impact accumulated for this checkpoint\n    Fixed6 offset;\n\n    /// @dev Settlement fee charged for this checkpoint\n    UFixed6 settlementFee;\n\n    /// @dev Liquidation fee accumulated for this checkpoint (only if the order is protected)\n    UFixed6 liquidationFee;\n\n    /// @dev Subtractive fee accumulated from the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 subtractiveFee;\n\n    /// @dev Solver fee accumulated the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 solverFee;\n}\n\n/// @title CheckpointLib\n/// @dev (external-safe): this library is safe to externalize\n/// @notice Manages the logic for the local order accumulation\nlibrary CheckpointLib {\n    /// @notice Accumulate pnl and fees from the latest position to next position\n    /// @param order The next order\n    /// @param fromVersion The previous latest version\n    /// @param toVersion The next latest version\n    /// @return next The next checkpoint\n    /// @return response The accumulated pnl and fees\n    function accumulate(\n        IMarket.Context memory context,\n        IMarket.SettlementContext memory settlementContext,\n        uint256 orderId,\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory fromVersion,\n        Version memory toVersion\n    ) external returns (Checkpoint memory next, CheckpointAccumulationResponse memory) {\n        CheckpointAccumulationResult memory result;\n\n        // accumulate\n        result.collateral = _accumulateCollateral(context.latestPositionLocal, fromVersion, toVersion);\n        result.priceOverride = _accumulatePriceOverride(guarantee, toVersion);\n        (result.tradeFee, result.subtractiveFee, result.solverFee) = _accumulateFee(order, guarantee, toVersion);\n        result.offset = _accumulateOffset(order, guarantee, toVersion);\n        result.settlementFee = _accumulateSettlementFee(order, guarantee, toVersion);\n        result.liquidationFee = _accumulateLiquidationFee(order, toVersion);\n\n        // update checkpoint\n        next.collateral = settlementContext.latestCheckpoint.collateral\n            .sub(settlementContext.latestCheckpoint.tradeFee)                       // trade fee processed post settlement\n            .sub(Fixed6Lib.from(settlementContext.latestCheckpoint.settlementFee)); // settlement / liquidation fee processed post settlement\n        next.collateral = next.collateral\n            .add(settlementContext.latestCheckpoint.transfer)                       // deposit / withdrawal processed post settlement\n            .add(result.collateral)                                                 // incorporate collateral change at this settlement\n            .add(result.priceOverride);                                             // incorporate price override pnl at this settlement\n        next.transfer = order.collateral;\n        next.tradeFee = Fixed6Lib.from(result.tradeFee).add(result.offset);\n        next.settlementFee = result.settlementFee.add(result.liquidationFee);\n\n        emit IMarket.AccountPositionProcessed(context.account, orderId, order, result);\n\n        return (next, _response(result));\n    }\n\n    /// @notice Converts the accumulation result into a response\n    /// @param result The accumulation result\n    /// @return response The accumulation response\n    function _response(\n        CheckpointAccumulationResult memory result\n    ) private pure returns (CheckpointAccumulationResponse memory response) {\n        response.collateral = result.collateral\n            .add(result.priceOverride)\n            .sub(Fixed6Lib.from(result.tradeFee))\n            .sub(result.offset)\n            .sub(Fixed6Lib.from(result.settlementFee));\n        response.liquidationFee = result.liquidationFee;\n        response.subtractiveFee = result.subtractiveFee;\n        response.solverFee = result.solverFee;\n    }\n\n    /// @notice Accumulate pnl, funding, and interest from the latest position to next position\n    /// @param fromPosition The previous latest position\n    /// @param fromVersion The previous latest version\n    /// @param toVersion The next version\n    function _accumulateCollateral(\n        Position memory fromPosition,\n        Version memory fromVersion,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        return toVersion.makerValue.accumulated(fromVersion.makerValue, fromPosition.maker)\n            .add(toVersion.longValue.accumulated(fromVersion.longValue, fromPosition.long))\n            .add(toVersion.shortValue.accumulated(fromVersion.shortValue, fromPosition.short));\n    }\n\n    /// @notice Accumulate trade fees for the next position\n    /// @param order The next order\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulateFee(\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (UFixed6 tradeFee, UFixed6 subtractiveFee, UFixed6 solverFee) {\n        UFixed6 takerTotal = order.takerTotal().sub(guarantee.takerFee);\n\n        // accumulate total trade fees on maker and taker orders\n        UFixed6 makerFee = Fixed6Lib.ZERO\n            .sub(toVersion.makerFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()))\n            .abs();\n        UFixed6 takerFee = Fixed6Lib.ZERO\n            .sub(toVersion.takerFee.accumulated(Accumulator6(Fixed6Lib.ZERO), takerTotal))\n            .abs();\n\n        // compute portion of trade fees that are subtractive\n        UFixed6 makerSubtractiveFee = order.makerTotal().isZero() ?\n            UFixed6Lib.ZERO :\n            makerFee.muldiv(order.makerReferral, order.makerTotal());\n        UFixed6 takerSubtractiveFee = takerTotal.isZero() ?\n            UFixed6Lib.ZERO :\n            takerFee.muldiv(order.takerReferral, takerTotal);\n\n        // compute portion of subtractive fees that are solver fees\n        solverFee = takerTotal.isZero() ?\n            UFixed6Lib.ZERO :\n            takerFee.muldiv(guarantee.referral, takerTotal); // guarantee.referral is instantiated as a subset of order.takerReferral\n\n        tradeFee = makerFee.add(takerFee);\n        subtractiveFee = makerSubtractiveFee.add(takerSubtractiveFee).sub(solverFee);\n\n    }\n\n    /// @notice Accumulate price offset for the next position\n    /// @dev This includes adjustment for linear, proportional, and adiabatic order fees\n    /// @param order The next order\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulateOffset(\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        (UFixed6 takerPos, UFixed6 takerNeg) =\n            (order.takerPos().sub(guarantee.takerPos), order.takerNeg().sub(guarantee.takerNeg));\n\n        return Fixed6Lib.ZERO\n            .sub(toVersion.makerOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()))\n            .sub(toVersion.takerPosOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), takerPos))\n            .sub(toVersion.takerNegOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), takerNeg));\n    }\n\n\n    /// @notice Accumulate settlement fees for the next position\n    /// @param order The next order\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulateSettlementFee(\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (UFixed6) {\n        uint256 orders = order.orders - guarantee.orders;\n\n        return toVersion.settlementFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.from(orders)).abs();\n    }\n\n    /// @notice Accumulate liquidation fees for the next position\n    /// @param order The next order\n    /// @param toVersion The next version\n    function _accumulateLiquidationFee(\n        Order memory order,\n        Version memory toVersion\n    ) private pure returns (UFixed6) {\n        if (!order.protected()) return UFixed6Lib.ZERO;\n        return toVersion.liquidationFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.ONE).abs();\n    }\n\n    /// @notice Accumulate price override pnl for the next position\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulatePriceOverride(\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        if (!toVersion.valid) return Fixed6Lib.ZERO;\n        return guarantee.taker().mul(toVersion.price).sub(guarantee.notional);\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/libs/InvariantLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"../interfaces/IMarket.sol\";\nimport \"../types/OracleVersion.sol\";\nimport \"../types/RiskParameter.sol\";\nimport \"../types/Global.sol\";\nimport \"../types/Local.sol\";\nimport \"../types/Order.sol\";\nimport \"../types/Version.sol\";\nimport \"../types/Checkpoint.sol\";\n\n/// @title InvariantLib\n/// @dev (external-safe): this library is safe to externalize\n/// @notice Manages the logic for the system invariant\nlibrary InvariantLib {\n    /// @notice Verifies the invariant of the market\n    /// @param context The context to use\n    /// @param updateContext The update context to use\n    /// @param newOrder The order to verify the invariant for\n    /// @param newGuarantee The guarantee to verify the invariant for\n    function validate(\n        IMarket.Context memory context,\n        IMarket.UpdateContext memory updateContext,\n        Order memory newOrder,\n        Guarantee memory newGuarantee\n    ) external {\n        // emit created event first due to early return\n        emit IMarket.OrderCreated(\n            context.account,\n            newOrder,\n            newGuarantee,\n            updateContext.liquidator,\n            updateContext.orderReferrer,\n            updateContext.guaranteeReferrer\n        );\n\n        if (context.pendingLocal.neg().gt(context.latestPositionLocal.magnitude())) // total pending close is greater than latest position\n            revert IMarket.MarketOverCloseError();\n\n        if (newOrder.protected() && (\n            !context.pendingLocal.neg().eq(context.latestPositionLocal.magnitude()) ||  // total pending close is not equal to latest position\n            context.latestPositionLocal.maintained(                                     // latest position is properly maintained\n                context.latestOracleVersion,\n                context.riskParameter,\n                context.local.collateral\n            ) ||\n            !newOrder.collateral.eq(Fixed6Lib.ZERO)                                     // the order is modifying collateral\n        )) revert IMarket.MarketInvalidProtectionError();\n\n        if (\n            !(updateContext.currentPositionLocal.magnitude().isZero() && context.latestPositionLocal.magnitude().isZero()) &&       // sender has no position\n            !(newOrder.isEmpty() && newOrder.collateral.gte(Fixed6Lib.ZERO)) &&                                                     // sender is depositing zero or more into account, without position change\n            (\n                !context.latestOracleVersion.valid ||\n                context.currentTimestamp - context.latestOracleVersion.timestamp >= context.riskParameter.staleAfter\n            )                                                                                                                       // price is not stale\n        ) revert IMarket.MarketStalePriceError();\n\n        if (context.marketParameter.closed && newOrder.increasesPosition())\n            revert IMarket.MarketClosedError();\n\n        if (\n            updateContext.currentPositionGlobal.maker.gt(context.riskParameter.makerLimit) &&\n            newOrder.increasesMaker()\n        ) revert IMarket.MarketMakerOverLimitError();\n\n        if (\n            !updateContext.currentPositionLocal.singleSided() || (                                              // current position is not single-sided with order applied\n                context.latestPositionLocal.direction() != updateContext.currentPositionLocal.direction() &&    // latest and current positions are not in the same direction\n                (!context.latestPositionLocal.empty() && !updateContext.currentPositionLocal.empty())           // both latest and current positions are non-empty\n            )\n        ) revert IMarket.MarketNotSingleSidedError();\n\n        if (newOrder.protected()) return; // The following invariants do not apply to protected position updates (liquidations)\n\n        if (\n            !updateContext.signer &&                                            // sender is relaying the account's signed intention\n            !updateContext.operator &&                                          // sender is operator approved for account\n            !(newOrder.isEmpty() && newOrder.collateral.gte(Fixed6Lib.ZERO))    // sender is depositing zero or more into account, without position change\n        ) revert IMarket.MarketOperatorNotAllowedError();\n\n        if (\n            context.global.currentId > context.global.latestId + context.marketParameter.maxPendingGlobal ||\n            context.local.currentId > context.local.latestId + context.marketParameter.maxPendingLocal\n        ) revert IMarket.MarketExceedsPendingIdLimitError();\n\n        if (\n            !PositionLib.margined(\n                context.latestPositionLocal.magnitude().add(context.pendingLocal.pos()),\n                context.latestOracleVersion,\n                context.riskParameter,\n                updateContext.collateralization,\n                context.local.collateral\n            )\n        ) revert IMarket.MarketInsufficientMarginError();\n\n        if (\n            context.pendingLocal.protected() && // total pending position is protected\n            !newOrder.protected()               // protection did not occur in this order (semphore already handles double-protection case)\n        ) revert IMarket.MarketProtectedError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            newOrder.decreasesEfficiency(updateContext.currentPositionGlobal) &&\n            updateContext.currentPositionGlobal.efficiency().lt(context.riskParameter.efficiencyLimit)\n        ) revert IMarket.MarketEfficiencyUnderLimitError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            updateContext.currentPositionGlobal.socialized() &&\n            newOrder.decreasesLiquidity(updateContext.currentPositionGlobal)\n        ) revert IMarket.MarketInsufficientLiquidityError();\n\n        if (context.local.collateral.lt(Fixed6Lib.ZERO))\n            revert IMarket.MarketInsufficientCollateralError();\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/libs/MagicValueLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"../interfaces/IMarket.sol\";\nimport \"../types/OracleVersion.sol\";\nimport \"../types/RiskParameter.sol\";\nimport \"../types/Global.sol\";\nimport \"../types/Local.sol\";\nimport \"../types/Order.sol\";\nimport \"../types/Version.sol\";\nimport \"../types/Checkpoint.sol\";\n\n/// @title MagicValueLib\n/// @dev (external-safe): this library is safe to externalize\n/// @notice Manages the logic for the update parameter magic values\nlibrary MagicValueLib {\n    Fixed6 private constant MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL = Fixed6.wrap(type(int256).min);\n    UFixed6 private constant MAGIC_VALUE_UNCHANGED_POSITION = UFixed6.wrap(type(uint256).max);\n    UFixed6 private constant MAGIC_VALUE_FULLY_CLOSED_POSITION = UFixed6.wrap(type(uint256).max - 1);\n\n    function process(\n        IMarket.Context memory context,\n        IMarket.UpdateContext memory updateContext,\n        Fixed6 collateral,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort\n    ) external pure returns (Fixed6, UFixed6, UFixed6, UFixed6) {\n        return (\n            _processCollateralMagicValue(context, collateral),\n            _processPositionMagicValue(context, updateContext.currentPositionLocal.maker, newMaker),\n            _processPositionMagicValue(context, updateContext.currentPositionLocal.long, newLong),\n            _processPositionMagicValue(context, updateContext.currentPositionLocal.short, newShort)\n        );\n    }\n\n    /// @notice Modifies the collateral input per magic values\n    /// @param context The context to use\n    /// @param collateral The collateral to process\n    /// @return The resulting collateral value\n    function _processCollateralMagicValue(\n        IMarket.Context memory context,\n        Fixed6 collateral\n    ) private pure returns (Fixed6) {\n        return collateral.eq(MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL) ?\n            context.local.collateral.mul(Fixed6Lib.NEG_ONE) :\n            collateral;\n    }\n\n    /// @notice Modifies the position input per magic values\n    /// @param context The context to use\n    /// @param currentPosition The current position prior to update\n    /// @param newPosition The position to process\n    /// @return The resulting position value\n    function _processPositionMagicValue(\n        IMarket.Context memory context,\n        UFixed6 currentPosition,\n        UFixed6 newPosition\n    ) private pure returns (UFixed6) {\n        if (newPosition.eq(MAGIC_VALUE_UNCHANGED_POSITION))\n            return currentPosition;\n        if (newPosition.eq(MAGIC_VALUE_FULLY_CLOSED_POSITION)) {\n            if (currentPosition.isZero()) return currentPosition;\n            return currentPosition.sub(context.latestPositionLocal.magnitude().sub(context.pendingLocal.neg()));\n        }\n        return newPosition;\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/libs/VersionLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"@equilibria/root/accumulator/types/UAccumulator6.sol\";\nimport \"../interfaces/IMarket.sol\";\nimport \"../types/ProtocolParameter.sol\";\nimport \"../types/MarketParameter.sol\";\nimport \"../types/RiskParameter.sol\";\nimport \"../types/Global.sol\";\nimport \"../types/Position.sol\";\nimport \"../types/Version.sol\";\nimport \"../types/OracleVersion.sol\";\nimport \"../types/OracleReceipt.sol\";\n\n/// @dev The response of the version accumulation\n///      Contains only select fee information needed for the downstream market contract\n///      Returned by the accumulate function\nstruct VersionAccumulationResponse {\n    /// @dev The total market fee charged including (tradeFee, tradeOffsetMarket, fundingFee, interestFee)\n    UFixed6 marketFee;\n\n    /// @dev The settlement fee charged\n    UFixed6 settlementFee;\n\n    /// @dev The market's adiabatic exposure\n    Fixed6 marketExposure;\n}\n\n/// @dev The result of the version accumulation\n///      Contains all the accumulated values for the version\n///      Emitted via the PositionProcessed event\nstruct VersionAccumulationResult {\n    /// @dev The trade fee charged\n    UFixed6 tradeFee;\n\n    /// @dev The subtractive fee charged\n    UFixed6 subtractiveFee;\n\n    /// @dev The total price impact of the trade (including linear, proportional, and adiabatic)\n    Fixed6 tradeOffset;\n\n    /// @dev The portion of the trade offset that the makers receive\n    Fixed6 tradeOffsetMaker;\n\n    /// @dev The portion of the trade offset that the market receives (if there are no makers)\n    UFixed6 tradeOffsetMarket;\n\n    /// @dev The adiabatic exposure accrued\n    Fixed6 adiabaticExposure;\n\n    /// @dev The adiabatic exposure accrued by makers\n    Fixed6 adiabaticExposureMaker;\n\n    /// @dev The adiabatic exposure accrued by the market\n    Fixed6 adiabaticExposureMarket;\n\n    /// @dev Funding accrued by makers\n    Fixed6 fundingMaker;\n\n    /// @dev Funding accrued by longs\n    Fixed6 fundingLong;\n\n    /// @dev Funding accrued by shorts\n    Fixed6 fundingShort;\n\n    /// @dev Funding received by the protocol\n    UFixed6 fundingFee;\n\n    /// @dev Interest accrued by makers\n    Fixed6 interestMaker;\n\n    /// @dev Interest accrued by longs\n    Fixed6 interestLong;\n\n    /// @dev Interest accrued by shorts\n    Fixed6 interestShort;\n\n    /// @dev Interest received by the protocol\n    UFixed6 interestFee;\n\n    /// @dev Price-based profit/loss accrued by makers\n    Fixed6 pnlMaker;\n\n    /// @dev Price-based profit/loss accrued by longs\n    Fixed6 pnlLong;\n\n    /// @dev Price-based profit/loss accrued by shorts\n    Fixed6 pnlShort;\n\n    /// @dev Total settlement fee charged\n    UFixed6 settlementFee;\n\n    /// @dev Snapshot of the riskParameter.liquidationFee at the version (0 if not valid)\n    UFixed6 liquidationFee;\n}\n\n/// @dev The in-memory context for the version accumulation\nstruct VersionAccumulationContext {\n    Global global;\n    Position fromPosition;\n    uint256 orderId;\n    Order order;\n    Guarantee guarantee;\n    OracleVersion fromOracleVersion;\n    OracleVersion toOracleVersion;\n    OracleReceipt toOracleReceipt;\n    MarketParameter marketParameter;\n    RiskParameter riskParameter;\n}\n\n/// @title VersionLib\n/// @dev (external-safe): this library is safe to externalize\n/// @notice Manages the logic for the global order accumulation\nlibrary VersionLib {\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\n    function accumulate(\n        IMarket.Context memory context,\n        IMarket.SettlementContext memory settlementContext,\n        uint256 newOrderId,\n        Order memory newOrder,\n        Guarantee memory newGuarantee,\n        OracleVersion memory oracleVersion,\n        OracleReceipt memory oracleReceipt\n    ) external returns (Version memory next, Global memory nextGlobal, VersionAccumulationResponse memory response) {\n        VersionAccumulationContext memory accumulationContext = VersionAccumulationContext(\n            context.global,\n            context.latestPositionGlobal,\n            newOrderId,\n            newOrder,\n            newGuarantee,\n            settlementContext.orderOracleVersion,\n            oracleVersion,\n            oracleReceipt,\n            context.marketParameter,\n            context.riskParameter\n        );\n\n        return _accumulate(settlementContext.latestVersion, accumulationContext);\n    }\n\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\n    /// @param self The Version object to update\n    /// @param context The accumulation context\n    /// @return next The accumulated version\n    /// @return nextGlobal The next global state\n    /// @return response The accumulation response\n    function _accumulate(\n        Version memory self,\n        VersionAccumulationContext memory context\n    ) private returns (Version memory next, Global memory nextGlobal, VersionAccumulationResponse memory response) {\n        VersionAccumulationResult memory result;\n\n        // setup next accumulators\n        _next(self, next);\n\n        // record oracle version\n        (next.valid, next.price) = (context.toOracleVersion.valid, context.toOracleVersion.price);\n        context.global.latestPrice = context.toOracleVersion.price;\n\n        // accumulate settlement fee\n        result.settlementFee = _accumulateSettlementFee(next, context);\n\n        // accumulate liquidation fee\n        result.liquidationFee = _accumulateLiquidationFee(next, context);\n\n        // accumulate fee\n        _accumulateFee(next, context, result);\n\n        // accumulate linear fee\n        _accumulateLinearFee(next, context, result);\n\n        // accumulate proportional fee\n        _accumulateProportionalFee(next, context, result);\n\n        // accumulate adiabatic exposure\n        _accumulateAdiabaticExposure(next, context, result);\n\n        // accumulate adiabatic fee\n        _accumulateAdiabaticFee(next, context, result);\n\n        // if closed, don't accrue anything else\n        if (context.marketParameter.closed) return _return(context, result, next);\n\n        // accumulate funding\n        (result.fundingMaker, result.fundingLong, result.fundingShort, result.fundingFee) =\n            _accumulateFunding(next, context);\n\n        // accumulate interest\n        (result.interestMaker, result.interestLong, result.interestShort, result.interestFee) =\n            _accumulateInterest(next, context);\n\n        // accumulate P&L\n        (result.pnlMaker, result.pnlLong, result.pnlShort) = _accumulatePNL(next, context);\n\n        return _return(context, result, next);\n    }\n\n    function _return(\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result,\n        Version memory next\n    ) private returns (Version memory, Global memory, VersionAccumulationResponse memory) {\n        emit IMarket.PositionProcessed(context.orderId, context.order, result);\n\n        return (next, context.global, _response(result));\n    }\n\n    /// @notice Converts the accumulation result into a response\n    /// @param result The accumulation result\n    /// @return response The accumulation response\n    function _response(\n        VersionAccumulationResult memory result\n    ) private pure returns (VersionAccumulationResponse memory response) {\n        response.marketFee = result.tradeFee\n            .add(result.tradeOffsetMarket)\n            .add(result.fundingFee)\n            .add(result.interestFee);\n        response.settlementFee = result.settlementFee;\n        response.marketExposure = result.adiabaticExposureMarket;\n    }\n\n    /// @notice Copies over the version-over-version accumulators to prepare the next version\n    /// @param self The Version object to update\n    function _next(Version memory self, Version memory next) internal pure {\n        next.makerValue._value = self.makerValue._value;\n        next.longValue._value = self.longValue._value;\n        next.shortValue._value = self.shortValue._value;\n    }\n\n    /// @notice Globally accumulates settlement fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateSettlementFee(\n        Version memory next,\n        VersionAccumulationContext memory context\n    ) private pure returns (UFixed6 settlementFee) {\n        uint256 orders = context.order.orders - context.guarantee.orders;\n        settlementFee = orders == 0 ? UFixed6Lib.ZERO : context.toOracleReceipt.settlementFee;\n        next.settlementFee.decrement(Fixed6Lib.from(settlementFee), UFixed6Lib.from(orders));\n    }\n\n    /// @notice Globally accumulates hypothetical liquidation fee since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateLiquidationFee(\n        Version memory next,\n        VersionAccumulationContext memory context\n    ) private pure returns (UFixed6 liquidationFee) {\n        liquidationFee = context.toOracleVersion.valid ?\n            context.toOracleReceipt.settlementFee.mul(context.riskParameter.liquidationFee) :\n            UFixed6Lib.ZERO;\n        next.liquidationFee.decrement(Fixed6Lib.from(liquidationFee), UFixed6Lib.ONE);\n    }\n\n    /// @notice Globally accumulates linear fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateFee(\n        Version memory next,\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        UFixed6 makerFee = context.order.makerTotal()\n            .mul(context.toOracleVersion.price.abs())\n            .mul(context.marketParameter.makerFee);\n        next.makerFee.decrement(Fixed6Lib.from(makerFee), context.order.makerTotal());\n        UFixed6 makerSubtractiveFee = context.order.makerTotal().isZero() ?\n            UFixed6Lib.ZERO :\n            makerFee.muldiv(context.order.makerReferral, context.order.makerTotal());\n\n        UFixed6 takerTotal = context.order.takerTotal().sub(context.guarantee.takerFee);\n        UFixed6 takerFee = takerTotal\n            .mul(context.toOracleVersion.price.abs())\n            .mul(context.marketParameter.takerFee);\n        next.takerFee.decrement(Fixed6Lib.from(takerFee), takerTotal);\n        UFixed6 takerSubtractiveFee = takerTotal.isZero() ?\n            UFixed6Lib.ZERO :\n            takerFee.muldiv(context.order.takerReferral, takerTotal);\n\n        result.tradeFee = result.tradeFee.add(makerFee).add(takerFee).sub(makerSubtractiveFee).sub(takerSubtractiveFee);\n        result.subtractiveFee = result.subtractiveFee.add(makerSubtractiveFee).add(takerSubtractiveFee);\n    }\n\n    /// @notice Globally accumulates linear fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateLinearFee(\n        Version memory next,\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        UFixed6 makerLinearFee = context.riskParameter.makerFee.linear(\n            Fixed6Lib.from(context.order.makerTotal()),\n            context.toOracleVersion.price.abs()\n        );\n        next.makerOffset.decrement(Fixed6Lib.from(makerLinearFee), context.order.makerTotal());\n\n        UFixed6 takerPosTotal = context.order.takerPos().sub(context.guarantee.takerPos);\n        UFixed6 takerPosLinearFee = context.riskParameter.takerFee.linear(\n            Fixed6Lib.from(takerPosTotal),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerPosOffset.decrement(Fixed6Lib.from(takerPosLinearFee), takerPosTotal);\n\n        UFixed6 takerNegTotal = context.order.takerNeg().sub(context.guarantee.takerNeg);\n        UFixed6 takerNegLinearFee = context.riskParameter.takerFee.linear(\n            Fixed6Lib.from(takerNegTotal),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerNegOffset.decrement(Fixed6Lib.from(takerNegLinearFee), takerNegTotal);\n\n        UFixed6 linearFee = makerLinearFee.add(takerPosLinearFee).add(takerNegLinearFee);\n        UFixed6 marketFee = context.fromPosition.maker.isZero() ? linearFee : UFixed6Lib.ZERO;\n        UFixed6 makerFee = linearFee.sub(marketFee);\n        next.makerValue.increment(Fixed6Lib.from(makerFee), context.fromPosition.maker);\n\n        result.tradeOffset = result.tradeOffset.add(Fixed6Lib.from(linearFee));\n        result.tradeOffsetMaker = result.tradeOffsetMaker.add(Fixed6Lib.from(makerFee));\n        result.tradeOffsetMarket = result.tradeOffsetMarket.add(marketFee);\n    }\n\n    /// @notice Globally accumulates proportional fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateProportionalFee(\n        Version memory next,\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        UFixed6 makerProportionalFee = context.riskParameter.makerFee.proportional(\n            Fixed6Lib.from(context.order.makerTotal()),\n            context.toOracleVersion.price.abs()\n        );\n        next.makerOffset.decrement(Fixed6Lib.from(makerProportionalFee), context.order.makerTotal());\n\n        UFixed6 takerPos = context.order.takerPos().sub(context.guarantee.takerPos);\n        UFixed6 takerPosProportionalFee = context.riskParameter.takerFee.proportional(\n            Fixed6Lib.from(takerPos),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerPosOffset.decrement(Fixed6Lib.from(takerPosProportionalFee), takerPos);\n\n        UFixed6 takerNeg = context.order.takerNeg().sub(context.guarantee.takerNeg);\n        UFixed6 takerNegProportionalFee = context.riskParameter.takerFee.proportional(\n            Fixed6Lib.from(takerNeg),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerNegOffset.decrement(Fixed6Lib.from(takerNegProportionalFee), takerNeg);\n\n        UFixed6 proportionalFee = makerProportionalFee.add(takerPosProportionalFee).add(takerNegProportionalFee);\n        UFixed6 marketFee = context.fromPosition.maker.isZero() ? proportionalFee : UFixed6Lib.ZERO;\n        UFixed6 makerFee = proportionalFee.sub(marketFee);\n        next.makerValue.increment(Fixed6Lib.from(makerFee), context.fromPosition.maker);\n\n        result.tradeOffset = result.tradeOffset.add(Fixed6Lib.from(proportionalFee));\n        result.tradeOffsetMaker = result.tradeOffsetMaker.add(Fixed6Lib.from(makerFee));\n        result.tradeOffsetMarket = result.tradeOffsetMarket.add(marketFee);\n    }\n\n    /// @notice Globally accumulates adiabatic fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateAdiabaticFee(\n        Version memory next,\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        Fixed6 adiabaticFee;\n\n        // position fee from positive skew taker orders\n        UFixed6 takerPos = context.order.takerPos().sub(context.guarantee.takerPos);\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\n            context.fromPosition.skew(),\n            Fixed6Lib.from(takerPos),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerPosOffset.decrement(adiabaticFee, takerPos);\n        result.tradeOffset = result.tradeOffset.add(adiabaticFee);\n\n        // position fee from negative skew taker orders\n        UFixed6 takerNeg = context.order.takerNeg().sub(context.guarantee.takerNeg);\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\n            context.fromPosition.skew().add(Fixed6Lib.from(takerPos)),\n            Fixed6Lib.from(-1, takerNeg),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerNegOffset.decrement(adiabaticFee, takerNeg);\n        result.tradeOffset = result.tradeOffset.add(adiabaticFee);\n    }\n\n    /// @notice Globally accumulates single component of the position fees exposure since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @param result The accumulation result\n    function _accumulateAdiabaticExposure(\n        Version memory next,\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        Fixed6 exposure = context.riskParameter.takerFee.exposure(context.fromPosition.skew());\n\n        Fixed6 adiabaticExposure = context.toOracleVersion.price.sub(context.fromOracleVersion.price).mul(exposure);\n        Fixed6 adiabaticExposureMaker = adiabaticExposure.mul(Fixed6Lib.NEG_ONE);\n        Fixed6 adiabaticExposureMarket = context.fromPosition.maker.isZero() ? adiabaticExposureMaker : Fixed6Lib.ZERO;\n        adiabaticExposureMaker = adiabaticExposureMaker.sub(adiabaticExposureMarket);\n        next.makerValue.increment(adiabaticExposureMaker, context.fromPosition.maker);\n\n        result.adiabaticExposure = adiabaticExposure;\n        result.adiabaticExposureMarket = adiabaticExposureMarket;\n        result.adiabaticExposureMaker = adiabaticExposureMaker;\n    }\n\n    /// @notice Globally accumulates all long-short funding since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return fundingMaker The total funding accrued by makers\n    /// @return fundingLong The total funding accrued by longs\n    /// @return fundingShort The total funding accrued by shorts\n    /// @return fundingFee The total fee accrued from funding accumulation\n    function _accumulateFunding(Version memory next, VersionAccumulationContext memory context) private pure returns (\n        Fixed6 fundingMaker,\n        Fixed6 fundingLong,\n        Fixed6 fundingShort,\n        UFixed6 fundingFee\n    ) {\n        Fixed6 toSkew = context.toOracleVersion.valid ?\n            context.fromPosition.skew().add(context.order.long()).sub(context.order.short()) :\n            context.fromPosition.skew();\n\n        // Compute long-short funding rate\n        Fixed6 funding = context.global.pAccumulator.accumulate(\n            context.riskParameter.pController,\n            toSkew.unsafeDiv(Fixed6Lib.from(context.riskParameter.takerFee.scale)).min(Fixed6Lib.ONE).max(Fixed6Lib.NEG_ONE),\n            context.fromOracleVersion.timestamp,\n            context.toOracleVersion.timestamp,\n            context.fromPosition.takerSocialized().mul(context.fromOracleVersion.price.abs())\n        );\n\n        // Handle maker receive-only status\n        if (context.riskParameter.makerReceiveOnly && funding.sign() != context.fromPosition.skew().sign())\n            funding = funding.mul(Fixed6Lib.NEG_ONE);\n\n        // Initialize long and short funding\n        (fundingLong, fundingShort) = (Fixed6Lib.NEG_ONE.mul(funding), funding);\n\n        // Compute fee spread\n        fundingFee = funding.abs().mul(context.marketParameter.fundingFee);\n        Fixed6 fundingSpread = Fixed6Lib.from(fundingFee).div(Fixed6Lib.from(2));\n\n        // Adjust funding with spread\n        (fundingLong, fundingShort) = (\n            fundingLong.sub(Fixed6Lib.from(fundingFee)).add(fundingSpread),\n            fundingShort.sub(fundingSpread)\n        );\n\n        // Redirect net portion of minor's side to maker\n        if (context.fromPosition.long.gt(context.fromPosition.short)) {\n            fundingMaker = fundingShort.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\n            fundingShort = fundingShort.sub(fundingMaker);\n        }\n        if (context.fromPosition.short.gt(context.fromPosition.long)) {\n            fundingMaker = fundingLong.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\n            fundingLong = fundingLong.sub(fundingMaker);\n        }\n\n        next.makerValue.increment(fundingMaker, context.fromPosition.maker);\n        next.longValue.increment(fundingLong, context.fromPosition.long);\n        next.shortValue.increment(fundingShort, context.fromPosition.short);\n    }\n\n    /// @notice Globally accumulates all maker interest since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return interestMaker The total interest accrued by makers\n    /// @return interestLong The total interest accrued by longs\n    /// @return interestShort The total interest accrued by shorts\n    /// @return interestFee The total fee accrued from interest accumulation\n    function _accumulateInterest(\n        Version memory next,\n        VersionAccumulationContext memory context\n    ) private pure returns (Fixed6 interestMaker, Fixed6 interestLong, Fixed6 interestShort, UFixed6 interestFee) {\n        UFixed6 notional = context.fromPosition.long.add(context.fromPosition.short).min(context.fromPosition.maker).mul(context.fromOracleVersion.price.abs());\n\n        // Compute maker interest\n        UFixed6 interest = context.riskParameter.utilizationCurve.accumulate(\n            context.fromPosition.utilization(context.riskParameter),\n            context.fromOracleVersion.timestamp,\n            context.toOracleVersion.timestamp,\n            notional\n        );\n\n        // Compute fee\n        interestFee = interest.mul(context.marketParameter.interestFee);\n\n        // Adjust long and short funding with spread\n        interestLong = Fixed6Lib.from(\n            context.fromPosition.major().isZero() ?\n            interest :\n            interest.muldiv(context.fromPosition.long, context.fromPosition.long.add(context.fromPosition.short))\n        );\n        interestShort = Fixed6Lib.from(interest).sub(interestLong);\n        interestMaker = Fixed6Lib.from(interest.sub(interestFee));\n\n        interestLong = interestLong.mul(Fixed6Lib.NEG_ONE);\n        interestShort = interestShort.mul(Fixed6Lib.NEG_ONE);\n        next.makerValue.increment(interestMaker, context.fromPosition.maker);\n        next.longValue.increment(interestLong, context.fromPosition.long);\n        next.shortValue.increment(interestShort, context.fromPosition.short);\n    }\n\n    /// @notice Globally accumulates position profit & loss since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return pnlMaker The total pnl accrued by makers\n    /// @return pnlLong The total pnl accrued by longs\n    /// @return pnlShort The total pnl accrued by shorts\n    function _accumulatePNL(\n        Version memory next,\n        VersionAccumulationContext memory context\n    ) private pure returns (Fixed6 pnlMaker, Fixed6 pnlLong, Fixed6 pnlShort) {\n        pnlLong = context.toOracleVersion.price.sub(context.fromOracleVersion.price)\n            .mul(Fixed6Lib.from(context.fromPosition.longSocialized()));\n        pnlShort = context.fromOracleVersion.price.sub(context.toOracleVersion.price)\n            .mul(Fixed6Lib.from(context.fromPosition.shortSocialized()));\n        pnlMaker = pnlLong.add(pnlShort).mul(Fixed6Lib.NEG_ONE);\n\n        next.longValue.increment(pnlLong, context.fromPosition.long);\n        next.shortValue.increment(pnlShort, context.fromPosition.short);\n        next.makerValue.increment(pnlMaker, context.fromPosition.maker);\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/Market.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport \"@equilibria/perennial-v2-verifier/contracts/interfaces/IVerifier.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\nimport \"./libs/InvariantLib.sol\";\nimport \"./libs/MagicValueLib.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    IVerifier public immutable verifier;\n\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev DEPRECATED SLOT -- previously the reward token\n    bytes32 private __unused0__;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev DEPRECATED SLOT -- previously the payoff provider\n    bytes32 private __unused1__;\n\n    /// @dev Beneficiary of the market, receives donations\n    address public beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address public coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev DEPRECATED SLOT -- previously the global pending positions\n    bytes32 private __unused2__;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev DEPRECATED SLOT -- previously the local pending positions\n    bytes32 private __unused3__;\n\n    /// @dev The historical version accumulator data for each accessed version\n    mapping(uint256 => VersionStorage) private _versions;\n\n    /// @dev The global pending order for each id\n    mapping(uint256 => OrderStorageGlobal) private _pendingOrder;\n\n    /// @dev The local pending order for each id for each account\n    mapping(address => mapping(uint256 => OrderStorageLocal)) private _pendingOrders;\n\n    /// @dev The global aggregate pending order\n    OrderStorageGlobal private _pending;\n\n    /// @dev The local aggregate pending order for each account\n    mapping(address => OrderStorageLocal) private _pendings;\n\n    /// @dev The local checkpoint for each version for each account\n    mapping(address => mapping(uint256 => CheckpointStorage)) private _checkpoints;\n\n    /// @dev The liquidator for each id for each account\n    mapping(address => mapping(uint256 => address)) public liquidators;\n\n    /// @dev The referrer for each id for each account\n    mapping(address => mapping(uint256 => address)) public orderReferrers;\n\n    /// @dev The referrer for each id for each account\n    mapping(address => mapping(uint256 => address)) public guaranteeReferrers;\n\n    /// @dev The global pending guarantee for each id\n    mapping(uint256 => GuaranteeStorageGlobal) private _guarantee;\n\n    /// @dev The local pending guarantee for each id for each account\n    mapping(address => mapping(uint256 => GuaranteeStorageLocal)) private _guarantees;\n\n    /// @dev Construct the contract implementation\n    /// @param verifier_ The verifier contract to use\n    constructor(IVerifier verifier_) {\n        verifier = verifier_;\n    }\n\n    /// @notice Initializes the contract state\n    /// @param definition_ The market definition\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __ReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n    }\n\n    /// @notice Performs logic related to the v2.3 migration for this market\n    /// @dev Must be called atomically at the time of implementation change\n    function migrate() external onlyOwner {\n        _position.migrate();\n    }\n\n    /// @notice Settles the account's position and collateral\n    /// @param account The account to operate on\n    function settle(address account) external nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n\n        _settle(context);\n\n        _storeContext(context);\n    }\n\n    /// @notice Updates both the long and short positions of an intent order\n    /// @dev - One side is specified in the signed intent, while the sender is assumed to be the counterparty\n    ///      - The sender is charged the settlement fee\n    /// @param account The account that is filling this intent (maker)\n    /// @param intent The intent that is being filled\n    /// @param signature The signature of the intent that is being filled\n    function update(address account, Intent calldata intent, bytes memory signature) external nonReentrant whenNotPaused {\n        if (intent.fee.gt(UFixed6Lib.ONE)) revert MarketInvalidIntentFeeError();\n\n        verifier.verifyIntent(intent, signature);\n\n        _updateIntent(\n            account,\n            address(0),\n            intent.amount.mul(Fixed6Lib.NEG_ONE),\n            intent.price,\n            address(0),\n            address(0),\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            true,\n            false\n        ); // account\n        _updateIntent(\n            intent.common.account,\n            intent.common.signer,\n            intent.amount,\n            intent.price,\n            intent.originator,\n            intent.solver,\n            intent.fee,\n            intent.collateralization,\n            false,\n            true\n        ); // signer\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param amount The position delta of the order (positive for long, negative for short)\n    /// @param collateral The collateral delta of the order (positive for deposit, negative for withdrawal)\n    /// @param referrer The referrer of the order\n    function update(\n        address account,\n        Fixed6 amount,\n        Fixed6 collateral,\n        address referrer\n    ) external nonReentrant whenNotPaused {\n        (Context memory context, UpdateContext memory updateContext) =\n            _loadForUpdate(account, address(0), referrer, address(0), UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n\n        // create new order & guarantee\n        Order memory newOrder = OrderLib.from(\n            context.currentTimestamp,\n            updateContext.currentPositionLocal,\n            amount,\n            collateral,\n            updateContext.orderReferralFee\n        );\n        Guarantee memory newGuarantee; // no guarantee is created for a market order\n\n        // process update\n        _updateAndStore(context, updateContext, newOrder, newGuarantee, referrer, address(0));\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external {\n        update(account, newMaker, newLong, newShort, collateral, protect, address(0));\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    /// @param referrer The referrer of the order\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect,\n        address referrer\n    ) public nonReentrant whenNotPaused {\n        (Context memory context, UpdateContext memory updateContext) =\n            _loadForUpdate(account, address(0), referrer, address(0), UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n\n        // magic values\n        (collateral, newMaker, newLong, newShort) =\n            MagicValueLib.process(context, updateContext, collateral, newMaker, newLong, newShort);\n\n        // create new order & guarantee\n        Order memory newOrder = OrderLib.from(\n            context.currentTimestamp,\n            updateContext.currentPositionLocal,\n            collateral,\n            newMaker,\n            newLong,\n            newShort,\n            protect,\n            updateContext.orderReferralFee\n        );\n        Guarantee memory newGuarantee; // no guarantee is created for a market order\n\n        // process update\n        _updateAndStore(context, updateContext, newOrder, newGuarantee, referrer, address(0));\n    }\n\n    /// @notice Updates the beneficiary of the market\n    /// @param newBeneficiary The new beneficiary address\n    function updateBeneficiary(address newBeneficiary) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n    }\n\n    /// @notice Updates the coordinator of the market\n    /// @param newCoordinator The new coordinator address\n    function updateCoordinator(address newCoordinator) external onlyOwner {\n        coordinator = newCoordinator;\n        emit CoordinatorUpdated(newCoordinator);\n    }\n\n    /// @notice Updates the parameter set of the market\n    /// @param newParameter The new parameter set\n    function updateParameter(MarketParameter memory newParameter) external onlyOwner {\n        _parameter.validateAndStore(newParameter, IMarketFactory(address(factory())).parameter());\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the risk parameter set of the market\n    /// @param newRiskParameter The new risk parameter set\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external onlyCoordinator {\n        // load latest state\n        Global memory newGlobal = _global.read();\n        Position memory latestPosition = _position.read();\n        RiskParameter memory latestRiskParameter = _riskParameter.read();\n\n        // update risk parameter (first to capture truncation)\n        _riskParameter.validateAndStore(newRiskParameter, IMarketFactory(address(factory())).parameter());\n        newRiskParameter = _riskParameter.read();\n\n        // update global exposure\n        newGlobal.update(latestRiskParameter, newRiskParameter, latestPosition);\n        _global.store(newGlobal);\n\n        emit RiskParameterUpdated(newRiskParameter);\n    }\n\n    /// @notice Claims any available fee that the sender has accrued\n    /// @dev Applicable fees include: protocol, oracle, risk, donation, and claimable\n    /// @return feeReceived The amount of the fee claimed\n    function claimFee(address account) external onlyOperator(account) returns (UFixed6 feeReceived) {\n        Global memory newGlobal = _global.read();\n        Local memory newLocal = _locals[account].read();\n\n        // protocol fee\n        if (account == factory().owner()) {\n            feeReceived = feeReceived.add(newGlobal.protocolFee);\n            newGlobal.protocolFee = UFixed6Lib.ZERO;\n        }\n\n        // oracle fee\n        if (account == address(oracle)) {\n            feeReceived = feeReceived.add(newGlobal.oracleFee);\n            newGlobal.oracleFee = UFixed6Lib.ZERO;\n        }\n\n        // risk fee\n        if (account == coordinator) {\n            feeReceived = feeReceived.add(newGlobal.riskFee);\n            newGlobal.riskFee = UFixed6Lib.ZERO;\n        }\n\n        // claimable\n        feeReceived = feeReceived.add(newLocal.claimable);\n        newLocal.claimable = UFixed6Lib.ZERO;\n\n        _global.store(newGlobal);\n        _locals[account].store(newLocal);\n\n        if (!feeReceived.isZero()) {\n            token.push(msg.sender, UFixed18Lib.from(feeReceived));\n            emit FeeClaimed(account, msg.sender, feeReceived);\n        }\n    }\n\n    /// @notice Settles any exposure that has accrued to the market\n    /// @dev Resets exposure to zero, caller pays or receives to net out the exposure\n    function claimExposure() external onlyOwner {\n        Global memory newGlobal = _global.read();\n\n        if (newGlobal.exposure.sign() == 1) token.push(msg.sender, UFixed18Lib.from(newGlobal.exposure.abs()));\n        if (newGlobal.exposure.sign() == -1) token.pull(msg.sender, UFixed18Lib.from(newGlobal.exposure.abs()));\n\n        emit ExposureClaimed(msg.sender, newGlobal.exposure);\n\n        newGlobal.exposure = Fixed6Lib.ZERO;\n        _global.store(newGlobal);\n    }\n\n    /// @notice Returns the current parameter set\n    function parameter() external view returns (MarketParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the current risk parameter set\n    function riskParameter() external view returns (RiskParameter memory) {\n        return _riskParameter.read();\n    }\n\n    /// @notice Returns the current global position\n    function position() external view returns (Position memory) {\n        return _position.read();\n    }\n\n    /// @notice Returns the current local position for the account\n    /// @param account The account to query\n    function positions(address account) external view returns (Position memory) {\n        return _positions[account].read();\n    }\n\n    /// @notice Returns the current global state\n    function global() external view returns (Global memory) {\n        return _global.read();\n    }\n\n    /// @notice Returns the historical version snapshot at the given timestamp\n    /// @param timestamp The timestamp to query\n    function versions(uint256 timestamp) external view returns (Version memory) {\n        return _versions[timestamp].read();\n    }\n\n    /// @notice Returns the local state for the given account\n    /// @param account The account to query\n    function locals(address account) external view returns (Local memory) {\n        return _locals[account].read();\n    }\n\n    /// @notice Returns the global pending order for the given id\n    /// @param id The id to query\n    function pendingOrder(uint256 id) external view returns (Order memory) {\n        return _pendingOrder[id].read();\n    }\n\n    /// @notice Returns the local pending order for the given account and id\n    /// @param account The account to query\n    /// @param id The id to query\n    function pendingOrders(address account, uint256 id) external view returns (Order memory) {\n        return _pendingOrders[account][id].read();\n    }\n\n    /// @notice Returns the global pending guarantee for the given id\n    /// @param id The id to query\n    function guarantee(uint256 id) external view returns (Guarantee memory) {\n        return _guarantee[id].read();\n    }\n\n    /// @notice Returns the local pending guarantee for the given account and id\n    /// @param account The account to query\n    /// @param id The id to query\n    function guarantees(address account, uint256 id) external view returns (Guarantee memory) {\n        return _guarantees[account][id].read();\n    }\n\n    /// @notice Returns the aggregate global pending order\n    function pending() external view returns (Order memory) {\n        return _pending.read();\n    }\n\n    /// @notice Returns the aggregate local pending order for the given account\n    /// @param account The account to query\n    function pendings(address account) external view returns (Order memory) {\n        return _pendings[account].read();\n    }\n\n    /// @notice Returns the local checkpoint for the given account and version\n    /// @param account The account to query\n    /// @param version The version to query\n    function checkpoints(address account, uint256 version) external view returns (Checkpoint memory) {\n        return _checkpoints[account][version].read();\n    }\n\n    /// @notice Loads the transaction context\n    /// @param account The account to load for\n    /// @return context The transaction context\n    function _loadContext(address account) private view returns (Context memory context) {\n        // account\n        context.account = account;\n\n        // parameters\n        context.marketParameter = _parameter.read();\n        context.riskParameter = _riskParameter.read();\n\n        // oracle\n        (context.latestOracleVersion, context.currentTimestamp) = oracle.status();\n\n        // state\n        context.global = _global.read();\n        context.local = _locals[account].read();\n\n        // latest positions\n        context.latestPositionGlobal = _position.read();\n        context.latestPositionLocal = _positions[account].read();\n\n        // aggregate pending orders\n        context.pendingGlobal = _pending.read();\n        context.pendingLocal = _pendings[account].read();\n    }\n\n    /// @notice Stores the context for the transaction\n    /// @param context The context to store\n    function _storeContext(Context memory context) private {\n        // state\n        _global.store(context.global);\n        _locals[context.account].store(context.local);\n\n        // latest positions\n        _position.store(context.latestPositionGlobal);\n        _positions[context.account].store(context.latestPositionLocal);\n\n        // aggregate pending orders\n        _pending.store(context.pendingGlobal);\n        _pendings[context.account].store(context.pendingLocal);\n    }\n\n    /// @notice Loads the context for the update process\n    /// @param context The context to load to\n    /// @param signer The signer of the update order, if one exists\n    /// @param orderReferrer The order referrer to load for\n    /// @param guaranteeReferrer The guarantee referrer to load for\n    /// @param guaranteeReferralFee The guarantee referral fee to load for\n    /// @param collateralization The collateralization to load for\n    /// @return updateContext The update context\n    function _loadUpdateContext(\n        Context memory context,\n        address signer,\n        address orderReferrer,\n        address guaranteeReferrer,\n        UFixed6 guaranteeReferralFee,\n        UFixed6 collateralization\n    ) private view returns (UpdateContext memory updateContext) {\n        // load current position\n        updateContext.currentPositionGlobal = context.latestPositionGlobal.clone();\n        updateContext.currentPositionGlobal.update(context.pendingGlobal);\n        updateContext.currentPositionLocal = context.latestPositionLocal.clone();\n        updateContext.currentPositionLocal.update(context.pendingLocal);\n\n        // load current order\n        updateContext.orderGlobal = _pendingOrder[context.global.currentId].read();\n        updateContext.orderLocal = _pendingOrders[context.account][context.local.currentId].read();\n        updateContext.guaranteeGlobal = _guarantee[context.global.currentId].read();\n        updateContext.guaranteeLocal = _guarantees[context.account][context.local.currentId].read();\n\n        // load order metadata\n        updateContext.liquidator = liquidators[context.account][context.local.currentId];\n        updateContext.orderReferrer = orderReferrers[context.account][context.local.currentId];\n        updateContext.guaranteeReferrer = guaranteeReferrers[context.account][context.local.currentId];\n        updateContext.collateralization = collateralization;\n\n        // load factory metadata\n        (updateContext.operator, updateContext.signer, updateContext.orderReferralFee) =\n            IMarketFactory(address(factory())).authorization(context.account, msg.sender, signer, orderReferrer);\n        if (guaranteeReferrer != address(0)) updateContext.guaranteeReferralFee = guaranteeReferralFee;\n    }\n\n    /// @notice Stores the context for the update process\n    /// @param context The transaction context\n    /// @param updateContext The update context to store\n    function _storeUpdateContext(Context memory context, UpdateContext memory updateContext) private {\n        // current orders\n        _pendingOrder[context.global.currentId].store(updateContext.orderGlobal);\n        _pendingOrders[context.account][context.local.currentId].store(updateContext.orderLocal);\n        _guarantee[context.global.currentId].store(updateContext.guaranteeGlobal);\n        _guarantees[context.account][context.local.currentId].store(updateContext.guaranteeLocal);\n\n        // external actors\n        liquidators[context.account][context.local.currentId] = updateContext.liquidator;\n        orderReferrers[context.account][context.local.currentId] = updateContext.orderReferrer;\n        guaranteeReferrers[context.account][context.local.currentId] = updateContext.guaranteeReferrer;\n    }\n\n    /// @notice Loads the both context and update context, and settles the account\n    /// @param account The account to load the context for\n    /// @param signer The signer of the update order, if one exists\n    /// @param orderReferrer The order referrer, if one exists\n    /// @param guaranteeReferrer The guarantee referrer, if one exists\n    /// @param guaranteeReferralFee The guarantee referral fee, if one exists\n    /// @param collateralization The collateralization override for the order, if one exists\n    function _loadForUpdate(\n        address account,\n        address signer,\n        address orderReferrer,\n        address guaranteeReferrer,\n        UFixed6 guaranteeReferralFee,\n        UFixed6 collateralization\n    ) private returns (Context memory context, UpdateContext memory updateContext) {\n        // settle market & account\n        context = _loadContext(account);\n        _settle(context);\n\n        // load update context\n        updateContext =\n            _loadUpdateContext(context, signer, orderReferrer, guaranteeReferrer, guaranteeReferralFee, collateralization);\n    }\n\n    /// @notice Updates the account's position and collateral, and stores the resulting context in state\n    /// @param context The context to use\n    /// @param updateContext The update context to use\n    /// @param newOrder The new order to apply\n    /// @param newGuarantee The new guarantee to apply\n    /// @param orderReferrer The referrer of the order\n    /// @param guaranteeReferrer The referrer of the guarantee\n    function _updateAndStore(\n        Context memory context,\n        UpdateContext memory updateContext,\n        Order memory newOrder,\n        Guarantee memory newGuarantee,\n        address orderReferrer,\n        address guaranteeReferrer\n    ) private {\n        // process update\n        _update(context, updateContext, newOrder, newGuarantee, orderReferrer, guaranteeReferrer);\n\n        // store updated state\n        _storeContext(context);\n    }\n\n    /// @notice Updates the account's position for an intent order\n    /// @param account The account to operate on\n    /// @param signer The signer of the order\n    /// @param amount The size and direction of the order being opened\n    /// @param price The price to execute the order at\n    /// @param orderReferrer The referrer of the order\n    /// @param guaranteeReferrer The referrer of the guarantee\n    /// @param guaranteeReferralFee The referral fee for the guarantee\n    /// @param collateralization The minimum collateralization ratio that must be maintained after the order is executed\n    /// @param chargeSettlementFee Whether to charge the settlement fee\n    /// @param chargeTradeFee Whether to charge the trade fee\n    function _updateIntent(\n        address account,\n        address signer,\n        Fixed6 amount,\n        Fixed6 price,\n        address orderReferrer,\n        address guaranteeReferrer,\n        UFixed6 guaranteeReferralFee,\n        UFixed6 collateralization,\n        bool chargeSettlementFee,\n        bool chargeTradeFee\n    ) private {\n        (Context memory context, UpdateContext memory updateContext) =\n            _loadForUpdate(account, signer, orderReferrer, guaranteeReferrer, guaranteeReferralFee, collateralization);\n\n        // create new order & guarantee\n        Order memory newOrder = OrderLib.from(\n            context.currentTimestamp,\n            updateContext.currentPositionLocal,\n            amount,\n            Fixed6Lib.ZERO,\n            updateContext.orderReferralFee\n        );\n        Guarantee memory newGuarantee = GuaranteeLib.from(\n            newOrder,\n            price,\n            updateContext.guaranteeReferralFee,\n            chargeSettlementFee,\n            chargeTradeFee\n        );\n\n        _updateAndStore(context, updateContext, newOrder, newGuarantee, orderReferrer, guaranteeReferrer);\n    }\n\n    /// @notice Updates the current position with a new order\n    /// @param context The context to use\n    /// @param updateContext The update context to use\n    /// @param newOrder The new order to apply\n    /// @param newGuarantee The new guarantee to apply\n    /// @param orderReferrer The referrer of the order\n    /// @param guaranteeReferrer The referrer of the guarantee\n    function _update(\n        Context memory context,\n        UpdateContext memory updateContext,\n        Order memory newOrder,\n        Guarantee memory newGuarantee,\n        address orderReferrer,\n        address guaranteeReferrer\n    ) private notSettleOnly(context) {\n        // advance to next id if applicable\n        if (context.currentTimestamp > updateContext.orderLocal.timestamp) {\n            updateContext.orderLocal.next(context.currentTimestamp);\n            updateContext.guaranteeLocal.next();\n            updateContext.liquidator = address(0);\n            updateContext.orderReferrer = address(0);\n            updateContext.guaranteeReferrer = address(0);\n            context.local.currentId++;\n        }\n        if (context.currentTimestamp > updateContext.orderGlobal.timestamp) {\n            updateContext.orderGlobal.next(context.currentTimestamp);\n            updateContext.guaranteeGlobal.next();\n            context.global.currentId++;\n        }\n\n        // update current position\n        updateContext.currentPositionGlobal.update(newOrder);\n        updateContext.currentPositionLocal.update(newOrder);\n\n        // apply new order\n        updateContext.orderLocal.add(newOrder);\n        updateContext.orderGlobal.add(newOrder);\n        context.pendingGlobal.add(newOrder);\n        context.pendingLocal.add(newOrder);\n        updateContext.guaranteeGlobal.add(newGuarantee);\n        updateContext.guaranteeLocal.add(newGuarantee);\n\n        // update collateral\n        context.local.update(newOrder.collateral);\n\n        // protect account\n        if (newOrder.protected()) updateContext.liquidator = msg.sender;\n\n        // apply referrer\n        _processReferrer(updateContext, newOrder, newGuarantee, orderReferrer, guaranteeReferrer);\n\n        // request version, only request new price on position change\n        if (!newOrder.isEmpty()) oracle.request(IMarket(this), context.account);\n\n        // after\n        InvariantLib.validate(context, updateContext, newOrder, newGuarantee);\n\n        // store\n        _storeUpdateContext(context, updateContext);\n\n        // fund\n        if (newOrder.collateral.sign() == 1) token.pull(msg.sender, UFixed18Lib.from(newOrder.collateral.abs()));\n        if (newOrder.collateral.sign() == -1) token.push(msg.sender, UFixed18Lib.from(newOrder.collateral.abs()));\n\n        // events\n    }\n\n    /// @notice Processes the referrer for the given order\n    /// @param updateContext The update context to use\n    /// @param newOrder The order to process\n    /// @param newGuarantee The guarantee to process\n    /// @param orderReferrer The referrer of the order\n    /// @param guaranteeReferrer The referrer of the guarantee\n    function _processReferrer(\n        UpdateContext memory updateContext,\n        Order memory newOrder,\n        Guarantee memory newGuarantee,\n        address orderReferrer,\n        address guaranteeReferrer\n    ) private pure {\n        if (!newOrder.makerReferral.isZero() || !newOrder.takerReferral.isZero()) {\n            if (updateContext.orderReferrer == address(0)) updateContext.orderReferrer = orderReferrer;\n            if (updateContext.orderReferrer != orderReferrer) revert MarketInvalidReferrerError();\n        }\n        if (!newGuarantee.referral.isZero()) {\n            if (updateContext.guaranteeReferrer == address(0)) updateContext.guaranteeReferrer = guaranteeReferrer;\n            if (updateContext.guaranteeReferrer != guaranteeReferrer) revert MarketInvalidReferrerError();\n        }\n    }\n\n    /// @notice Loads the settlement context\n    /// @param context The transaction context\n    /// @return settlementContext The settlement context\n    function _loadSettlementContext(\n        Context memory context\n    ) private view returns (SettlementContext memory settlementContext) {\n        settlementContext.latestVersion = _versions[context.latestPositionGlobal.timestamp].read();\n        settlementContext.latestCheckpoint = _checkpoints[context.account][context.latestPositionLocal.timestamp].read();\n\n        (settlementContext.orderOracleVersion, ) = oracle.at(context.latestPositionGlobal.timestamp);\n        context.global.overrideIfZero(settlementContext.orderOracleVersion);\n    }\n\n    /// @notice Settles the account position up to the latest version\n    /// @param context The context to use\n    function _settle(Context memory context) private {\n        SettlementContext memory settlementContext = _loadSettlementContext(context);\n\n        Order memory nextOrder;\n\n        // settle - process orders whose requested prices are now available from oracle\n        //        - all requested prices are guaranteed to be present in the oracle, but could be stale\n        while (\n            context.global.currentId != context.global.latestId &&\n            (nextOrder = _pendingOrder[context.global.latestId + 1].read()).ready(context.latestOracleVersion)\n        ) _processOrderGlobal(context, settlementContext, context.global.latestId + 1, nextOrder.timestamp, nextOrder);\n\n        while (\n            context.local.currentId != context.local.latestId &&\n            (nextOrder = _pendingOrders[context.account][context.local.latestId + 1].read()).ready(context.latestOracleVersion)\n        ) _processOrderLocal(context, settlementContext, context.local.latestId + 1, nextOrder.timestamp, nextOrder);\n\n        // don't sync in settle-only mode\n        if (context.marketParameter.settle) return;\n\n        // sync - advance position timestamps to the latest oracle version\n        //      - latest versions are guaranteed to have present prices in the oracle, but could be stale\n        if (context.latestOracleVersion.timestamp > context.latestPositionGlobal.timestamp)\n            _processOrderGlobal(\n                context,\n                settlementContext,\n                context.global.latestId,\n                context.latestOracleVersion.timestamp,\n                _pendingOrder[context.global.latestId].read()\n            );\n\n        if (context.latestOracleVersion.timestamp > context.latestPositionLocal.timestamp)\n            _processOrderLocal(\n                context,\n                settlementContext,\n                context.local.latestId,\n                context.latestOracleVersion.timestamp,\n                _pendingOrders[context.account][context.local.latestId].read()\n            );\n    }\n\n    /// @notice Processes the given global pending position into the latest position\n    /// @param context The context to use\n    /// @param newOrderId The id of the pending position to process\n    /// @param newOrderTimestamp The timestamp of the pending position to process\n    /// @param newOrder The pending position to process\n    function _processOrderGlobal(\n        Context memory context,\n        SettlementContext memory settlementContext,\n        uint256 newOrderId,\n        uint256 newOrderTimestamp,\n        Order memory newOrder\n    ) private {\n        (OracleVersion memory oracleVersion, OracleReceipt memory oracleReceipt) = oracle.at(newOrderTimestamp);\n        context.global.overrideIfZero(oracleVersion);\n        Guarantee memory newGuarantee = _guarantee[newOrderId].read();\n\n        // if latest timestamp is more recent than order timestamp, sync the order data\n        if (newOrderTimestamp > newOrder.timestamp) {\n            newOrder.next(newOrderTimestamp);\n            newGuarantee.next();\n        }\n\n        context.pendingGlobal.sub(newOrder);\n\n        // if version is not valid, invalidate order data\n        if (!oracleVersion.valid) {\n            newOrder.invalidate();\n            newGuarantee.invalidate();\n        }\n\n        VersionAccumulationResponse memory accumulationResponse;\n        (settlementContext.latestVersion, context.global, accumulationResponse) = VersionLib.accumulate(\n            context,\n            settlementContext,\n            newOrderId,\n            newOrder,\n            newGuarantee,\n            oracleVersion,\n            oracleReceipt\n        );\n\n        context.global.update(newOrderId, accumulationResponse, context.marketParameter, oracleReceipt);\n        context.latestPositionGlobal.update(newOrder);\n\n        settlementContext.orderOracleVersion = oracleVersion;\n        _versions[newOrder.timestamp].store(settlementContext.latestVersion);\n    }\n\n    /// @notice Processes the given local pending position into the latest position\n    /// @param context The context to use\n    /// @param newOrderId The id of the pending position to process\n    /// @param newOrderTimestamp The timestamp of the pending position to process\n    /// @param newOrder The pending order to process\n    function _processOrderLocal(\n        Context memory context,\n        SettlementContext memory settlementContext,\n        uint256 newOrderId,\n        uint256 newOrderTimestamp,\n        Order memory newOrder\n    ) private {\n        Version memory versionFrom = _versions[context.latestPositionLocal.timestamp].read();\n        Version memory versionTo = _versions[newOrderTimestamp].read();\n        Guarantee memory newGuarantee = _guarantees[context.account][newOrderId].read();\n\n        // if latest timestamp is more recent than order timestamp, sync the order data\n        if (newOrderTimestamp > newOrder.timestamp) {\n            newOrder.next(newOrderTimestamp);\n            newGuarantee.next();\n        }\n\n        context.pendingLocal.sub(newOrder);\n\n        // if version is not valid, invalidate order data\n        if (!versionTo.valid) {\n            newOrder.invalidate();\n            newGuarantee.invalidate();\n        }\n\n        CheckpointAccumulationResponse memory accumulationResponse;\n        (settlementContext.latestCheckpoint, accumulationResponse) = CheckpointLib.accumulate(\n            context,\n            settlementContext,\n            newOrderId,\n            newOrder,\n            newGuarantee,\n            versionFrom,\n            versionTo\n        );\n\n        context.local.update(newOrderId, accumulationResponse);\n        context.latestPositionLocal.update(newOrder);\n\n        _checkpoints[context.account][newOrder.timestamp].store(settlementContext.latestCheckpoint);\n\n        _credit(context, liquidators[context.account][newOrderId], accumulationResponse.liquidationFee);\n        _credit(context, orderReferrers[context.account][newOrderId], accumulationResponse.subtractiveFee);\n        _credit(context, guaranteeReferrers[context.account][newOrderId], accumulationResponse.solverFee);\n    }\n\n    /// @notice Credits an account's claimable\n    /// @dev The amount must have already come from a corresponding debit in the settlement flow.\n    ///      If the receiver is the context's account, the amount is instead credited in-memory.\n    /// @param context The context to use\n    /// @param receiver The account to credit\n    /// @param amount The amount to credit\n    function _credit(Context memory context, address receiver, UFixed6 amount) private {\n        if (amount.isZero()) return;\n\n        if (receiver == context.account) context.local.credit(amount);\n        else {\n            Local memory receiverLocal = _locals[receiver].read();\n            receiverLocal.credit(amount);\n            _locals[receiver].store(receiverLocal);\n        }\n    }\n\n    /// @notice Only the coordinator or the owner can call\n    modifier onlyCoordinator {\n        if (msg.sender != coordinator && msg.sender != factory().owner()) revert MarketNotCoordinatorError();\n        _;\n    }\n\n    /// @notice Only the account or an operator can call\n    modifier onlyOperator(address account) {\n        if (msg.sender != account && !IMarketFactory(address(factory())).operators(account, msg.sender))\n            revert MarketNotOperatorError();\n        _;\n    }\n\n    /// @notice Only when the market is not in settle-only mode\n    modifier notSettleOnly(Context memory context) {\n        if (context.marketParameter.settle) revert MarketSettleOnlyError();\n        _;\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/MarketFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport \"@equilibria/perennial-v2-verifier/contracts/interfaces/IVerifier.sol\";\nimport \"@equilibria/root/attribute/Factory.sol\";\nimport \"./interfaces/IOracleProvider.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\n\n/// @title MarketFactory\n/// @notice Manages creating new markets and global protocol parameters.\ncontract MarketFactory is IMarketFactory, Factory {\n    /// @dev The oracle factory\n    IFactory public immutable oracleFactory;\n\n    /// @dev The verifier contract\n    IVerifier public immutable verifier;\n\n    /// @dev The global protocol parameters\n    ProtocolParameterStorage private _parameter;\n\n    /// @dev Mapping of allowed operators per account\n    mapping(address => mapping(address => bool)) public operators;\n\n    /// @dev Registry of created markets by oracle and payoff\n    ///      Note: address(0) is used in place of the deprecated payoff provider field\n    mapping(IOracleProvider => mapping(address => IMarket)) private _markets;\n\n    /// @dev The referreral fee level for each referrer for orders\n    mapping(address => UFixed6) private _referralFees;\n\n    /// @dev Mapping of allowed signers for each account\n    mapping(address => mapping(address => bool)) public signers;\n\n    /// @dev Mapping of allowed protocol-wide operators\n    mapping(address => bool) public extensions;\n\n    /// @notice Constructs the contract\n    /// @param oracleFactory_ The oracle factory\n    /// @param verifier_ The verifier contract\n    /// @param implementation_ The initial market implementation contract\n    constructor(IFactory oracleFactory_, IVerifier verifier_, address implementation_) Factory(implementation_) {\n        oracleFactory = oracleFactory_;\n        verifier = verifier_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Factory__initialize();\n    }\n\n    /// @notice Returns the global protocol parameters\n    function parameter() public view returns (ProtocolParameter memory) {\n        return _parameter.read();\n    }\n\n    function markets(IOracleProvider oracle) external view returns (IMarket) {\n        return _markets[oracle][address(0)];\n    }\n\n    /// @notice Returns the referral fee for a referrer\n    /// @dev If the referrer has no fee set, the default protocol fee is returned\n    /// @param referrer The referrer to query\n    /// @return The referral fee for the referrer\n    function referralFees(address referrer) public view returns (UFixed6) {\n        if (referrer == address(0)) return UFixed6Lib.ZERO;\n        return _referralFees[referrer].isZero() ? parameter().referralFee : _referralFees[referrer];\n    }\n\n    /// @notice Returns authorizaton information for a market order\n    /// @param account The account the order is operating on\n    /// @param sender The sender of the order\n    /// @param signer The signer of the order\n    /// @param orderReferrer The referrer of the order\n    /// @return isOperator True if the sender is a valid operator for the account\n    /// @return isSigner True if the signer is a valid signer for the account\n    /// @return orderReferralFee The referral fee for the order\n    function authorization(\n        address account,\n        address sender,\n        address signer,\n        address orderReferrer\n    ) external view returns (bool isOperator, bool isSigner, UFixed6 orderReferralFee) {\n        return (\n            account == sender || extensions[sender] || operators[account][sender],\n            account == signer || signers[account][signer],\n            referralFees(orderReferrer)\n        );\n    }\n\n    /// @notice Updates the global protocol parameters\n    /// @param newParameter The new protocol parameters\n    function updateParameter(ProtocolParameter memory newParameter) public onlyOwner {\n        _parameter.validateAndStore(newParameter);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the status of an operator for the caller\n    /// @param extension The operator to update to enable protocol-wide\n    /// @param newEnabled The new status of the operator\n    function updateExtension(address extension, bool newEnabled) external {\n        extensions[extension] = newEnabled;\n        emit ExtensionUpdated(extension, newEnabled);\n    }\n\n    /// @notice Updates the status of an operator for the caller\n    /// @param operator The operator to update\n    /// @param newEnabled The new status of the operator\n    function updateOperator(address operator, bool newEnabled) external {\n        _updateOperator(msg.sender, operator, newEnabled);\n    }\n\n    /// @notice Updates the status of an operator for the signer verified via a signed message\n    /// @param operatorUpdate The operator update message to process\n    /// @param signature The signature of the operator update message\n    function updateOperatorWithSignature(OperatorUpdate calldata operatorUpdate, bytes calldata signature) external {\n        verifier.verifyOperatorUpdate(operatorUpdate, signature);\n        if (operatorUpdate.common.signer != operatorUpdate.common.account) revert MarketFactoryInvalidSignerError();\n\n        _updateOperator(operatorUpdate.common.account, operatorUpdate.access.accessor, operatorUpdate.access.approved);\n    }\n\n    /// @notice Updates the status of an operator for the account\n    /// @param account The account to update the operator for\n    /// @param operator The operator to update\n    /// @param newEnabled The new status of the operator\n    function _updateOperator(address account, address operator, bool newEnabled) private {\n        operators[account][operator] = newEnabled;\n        emit OperatorUpdated(account, operator, newEnabled);\n    }\n\n    /// @notice Updates the status of a signer for the caller\n    /// @param signer The signer to update\n    /// @param newEnabled The new status of the opersignerator\n    function updateSigner(address signer, bool newEnabled) external {\n        _updateSigner(msg.sender, signer, newEnabled);\n    }\n\n    /// @notice Updates the status of a signer for the caller verified via a signed message\n    /// @param signerUpdate The signer update message to process\n    /// @param signature The signature of the signer update message\n    function updateSignerWithSignature(SignerUpdate calldata signerUpdate, bytes calldata signature) external {\n        verifier.verifySignerUpdate(signerUpdate, signature);\n        if (signerUpdate.common.signer != signerUpdate.common.account) revert MarketFactoryInvalidSignerError();\n\n        _updateSigner(signerUpdate.common.account, signerUpdate.access.accessor, signerUpdate.access.approved);\n    }\n\n    /// @notice Updates the status of a signer for the caller\n    /// @param account The account to update the operator for\n    /// @param signer The signer to update\n    /// @param newEnabled The new status of the opersignerator\n    function _updateSigner(address account, address signer, bool newEnabled) private {\n        signers[account][signer] = newEnabled;\n        emit SignerUpdated(account, signer, newEnabled);\n    }\n\n    /// @notice Updates the status of the list of operators and signers for the caller\n    /// @param newOperators The list of operators to update\n    /// @param newSigners The list of signers to update\n    function updateAccessBatch(AccessUpdate[] calldata newOperators, AccessUpdate[] calldata newSigners) external {\n        _updateAccessBatch(msg.sender, newOperators, newSigners);\n    }\n\n    /// @notice Updates the status of the list of operators and signers for the caller verified via a signed message\n    /// @param accessUpdateBatch The batch access update message to process\n    /// @param signature The signature of the batch access update message\n    function updateAccessBatchWithSignature(\n        AccessUpdateBatch calldata accessUpdateBatch,\n        bytes calldata signature\n    ) external {\n        verifier.verifyAccessUpdateBatch(accessUpdateBatch, signature);\n        if (accessUpdateBatch.common.signer != accessUpdateBatch.common.account) revert MarketFactoryInvalidSignerError();\n\n        _updateAccessBatch(accessUpdateBatch.common.account, accessUpdateBatch.operators, accessUpdateBatch.signers);\n    }\n\n    /// @notice Updates the status of the list of operators and signers for the caller\n    /// @param account The account to update the operators and signers for\n    /// @param newOperators The list of operators to update\n    /// @param newSigners The list of signers to update\n    function _updateAccessBatch(\n        address account,\n        AccessUpdate[] calldata newOperators,\n        AccessUpdate[] calldata newSigners\n    ) private {\n        for (uint256 i = 0; i < newOperators.length; i++)\n            _updateOperator(account, newOperators[i].accessor, newOperators[i].approved);\n        for (uint256 i = 0; i < newSigners.length; i++)\n            _updateSigner(account, newSigners[i].accessor, newSigners[i].approved);\n    }\n\n    /// @notice Updates the referral fee for orders\n    /// @param referrer The referrer to update\n    /// @param newReferralFee The new referral fee\n    function updateReferralFee(address referrer, UFixed6 newReferralFee) external onlyOwner {\n        if (newReferralFee.gt(UFixed6Lib.ONE)) revert MarketFactoryInvalidReferralFeeError();\n\n        _referralFees[referrer] = newReferralFee;\n        emit ReferralFeeUpdated(referrer, newReferralFee);\n    }\n\n    /// @notice Creates a new market market with the given definition\n    /// @param definition The market definition\n    /// @return newMarket New market contract address\n    function create(IMarket.MarketDefinition calldata definition) external onlyOwner returns (IMarket newMarket) {\n        // verify oracle\n        if (!oracleFactory.instances(IInstance(address(definition.oracle)))) revert FactoryInvalidOracleError();\n\n        // verify invariants\n        if (_markets[definition.oracle][address(0)] != IMarket(address(0)))\n            revert FactoryAlreadyRegisteredError();\n\n        // create and register market\n        newMarket = IMarket(address(_create(abi.encodeCall(IMarket.initialize, (definition)))));\n        _markets[definition.oracle][address(0)] = newMarket;\n\n        emit MarketCreated(newMarket, definition);\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/types/Checkpoint.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"./OracleVersion.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./Global.sol\";\nimport \"./Local.sol\";\nimport \"./Order.sol\";\nimport \"./Version.sol\";\n\n/// @dev Checkpoint type\nstruct Checkpoint {\n    /// @dev The trade fee that the order incurred at the checkpoint settlement\n    Fixed6 tradeFee;\n\n    // @dev The settlement and liquidation fee that the order incurred at the checkpoint settlement\n    UFixed6 settlementFee;\n\n    /// @dev The amount deposited or withdrawn at the checkpoint settlement\n    Fixed6 transfer;\n\n    /// @dev The collateral at the time of the checkpoint settlement\n    Fixed6 collateral;\n}\nstruct CheckpointStorage { uint256 slot0; }\nusing CheckpointStorageLib for CheckpointStorage global;\n\n/// @dev Manually encodes and decodes the Checkpoint struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredCheckpoint {\n///         /* slot 0 */\n///         int48 tradeFee;\n///         uint48 settlementFee;\n///         int64 transfer;\n///         int64 collateral;\n///     }\n///\nlibrary CheckpointStorageLib {\n    // sig: 0xba85116a\n    error CheckpointStorageInvalidError();\n\n    function read(CheckpointStorage storage self) internal view returns (Checkpoint memory) {\n        uint256 slot0 = self.slot0;\n        return Checkpoint(\n            Fixed6.wrap(int256(slot0 << (256 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(slot0 << (256 - 48 - 48)) >> (256 - 48)),\n            Fixed6.wrap(int256(slot0 << (256 - 48 - 48 - 64)) >> (256 - 64)),\n            Fixed6.wrap(int256(slot0 << (256 - 48 - 48 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(CheckpointStorage storage self, Checkpoint memory newValue) external {\n        if (newValue.tradeFee.gt(Fixed6.wrap(type(int48).max))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.lt(Fixed6.wrap(type(int48).min))) revert CheckpointStorageInvalidError();\n        if (newValue.settlementFee.gt(UFixed6.wrap(type(uint48).max))) revert CheckpointStorageInvalidError();\n        if (newValue.transfer.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.transfer.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(Fixed6.unwrap(newValue.tradeFee)        << (256 - 48)) >> (256 - 48) |\n            uint256(UFixed6.unwrap(newValue.settlementFee)  << (256 - 48)) >> (256 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.transfer)        << (256 - 64)) >> (256 - 48 - 48 - 64) |\n            uint256(Fixed6.unwrap(newValue.collateral)      << (256 - 64)) >> (256 - 48 - 48 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/types/Global.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/pid/types/PAccumulator6.sol\";\nimport \"./ProtocolParameter.sol\";\nimport \"./MarketParameter.sol\";\nimport \"../libs/VersionLib.sol\";\n\n/// @dev Global type\nstruct Global {\n    /// @dev The current position ID\n    uint256 currentId;\n\n    /// @dev The latest position id\n    uint256 latestId;\n\n    /// @dev The accrued protocol fee\n    UFixed6 protocolFee;\n\n    /// @dev The accrued oracle fee\n    UFixed6 oracleFee;\n\n    /// @dev The accrued risk fee\n    UFixed6 riskFee;\n\n    /// @dev The latest valid price in the market\n    Fixed6 latestPrice;\n\n    /// @dev The accumulated market exposure\n    Fixed6 exposure;\n\n    /// @dev The current PAccumulator state\n    PAccumulator6 pAccumulator;\n}\nusing GlobalLib for Global global;\nstruct GlobalStorage { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing GlobalStorageLib for GlobalStorage global;\n\n/// @title Global\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the global market state\nlibrary GlobalLib {\n    /// @notice Updates market exposure based on a change in the risk parameter configuration\n    /// @param self The Global object to update\n    /// @param latestRiskParameter The latest risk parameter configuration\n    /// @param newRiskParameter The new risk parameter configuration\n    /// @param latestPosition The latest position\n    function update(\n        Global memory self,\n        RiskParameter memory latestRiskParameter,\n        RiskParameter memory newRiskParameter,\n        Position memory latestPosition\n    ) internal pure {\n        Fixed6 exposureChange = latestRiskParameter.takerFee\n            .exposure(newRiskParameter.takerFee, latestPosition.skew(), self.latestPrice.abs());\n        self.exposure = self.exposure.sub(exposureChange);\n    }\n\n    /// @notice Increments the fees by `amount` using current parameters\n    /// @dev Computes the fees based on the current market parameters\n    ///      market fee -> trade fee + market's trade offset + funding fee + interest fee\n    ///        1. oracle fee taken out as a percentage of what's left of market fee\n    ///        2. risk fee taken out as a percentage of what's left of market fee\n    ///        3. protocol fee is what's left of market fee\n    /// @param self The Global object to update\n    /// @param newLatestId The new latest position id\n    /// @param accumulation The accumulation result\n    /// @param marketParameter The current market parameters\n    /// @param oracleReceipt The receipt of the corresponding oracle version\n    function update(\n        Global memory self,\n        uint256 newLatestId,\n        VersionAccumulationResponse memory accumulation,\n        MarketParameter memory marketParameter,\n        OracleReceipt memory oracleReceipt\n    ) internal pure {\n        UFixed6 marketFee = accumulation.marketFee;\n\n        UFixed6 oracleFee = marketFee.mul(oracleReceipt.oracleFee);\n        marketFee = marketFee.sub(oracleFee);\n\n        UFixed6 riskFee = marketFee.mul(marketParameter.riskFee);\n        marketFee = marketFee.sub(riskFee);\n\n        self.latestId = newLatestId;\n        self.protocolFee = self.protocolFee.add(marketFee);\n        self.oracleFee = self.oracleFee.add(accumulation.settlementFee).add(oracleFee);\n        self.riskFee = self.riskFee.add(riskFee);\n        self.exposure = self.exposure.add(accumulation.marketExposure);\n    }\n\n    /// @notice Overrides the price of the oracle with the latest global version if it is empty\n    /// @param self The Global object to read from\n    /// @param oracleVersion The oracle version to update\n    function overrideIfZero(Global memory self, OracleVersion memory oracleVersion) internal pure {\n        if (oracleVersion.price.isZero()) oracleVersion.price = self.latestPrice;\n    }\n}\n\n/// @dev Manually encodes and decodes the Global struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredGlobal {\n///         /* slot 0 */\n///         uint32 currentId;           // <= 4.29b\n///         uint32 latestId;            // <= 4.29b\n///         uint48 protocolFee;         // <= 281m\n///         uint48 oracleFee;           // <= 281m\n///         uint48 riskFee;             // <= 281m\n///\n///         /* slot 1 */\n///         int32 pAccumulator.value;   // <= 214000%\n///         int24 pAccumulator.skew;    // <= 838%\n///         int64 latestPrice;          // <= 9.22t\n///         int64 exposure;             // <= 9.22t\n///     }\n///\nlibrary GlobalStorageLib {\n    // sig: 0x2142bc27\n    error GlobalStorageInvalidError();\n\n    function read(GlobalStorage storage self) internal view returns (Global memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n        return Global(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48 - 48)) >> (256 - 48)),\n            Fixed6.wrap(int256(slot1 << (256 - 32 - 24 - 64)) >> (256 - 64)),\n            Fixed6.wrap(int256(slot1 << (256 - 32 - 24 - 64 - 64)) >> (256 - 64)),\n            PAccumulator6(\n                Fixed6.wrap(int256(slot1 << (256 - 32)) >> (256 - 32)),\n                Fixed6.wrap(int256(slot1 << (256 - 32 - 24)) >> (256 - 24))\n            )\n        );\n    }\n\n    function store(GlobalStorage storage self, Global memory newValue) external {\n        if (newValue.currentId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\n        if (newValue.latestId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\n        if (newValue.protocolFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\n        if (newValue.oracleFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\n        if (newValue.riskFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\n        if (newValue.latestPrice.gt(Fixed6.wrap(type(int64).max))) revert GlobalStorageInvalidError();\n        if (newValue.latestPrice.lt(Fixed6.wrap(type(int64).min))) revert GlobalStorageInvalidError();\n        if (newValue.exposure.gt(Fixed6.wrap(type(int64).max))) revert GlobalStorageInvalidError();\n        if (newValue.exposure.lt(Fixed6.wrap(type(int64).min))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._value.gt(Fixed6.wrap(type(int32).max))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._value.lt(Fixed6.wrap(type(int32).min))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._skew.gt(Fixed6.wrap(type(int24).max))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._skew.lt(Fixed6.wrap(type(int24).min))) revert GlobalStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(UFixed6.unwrap(newValue.protocolFee) << (256 - 48)) >> (256 - 32 - 32 - 48) |\n            uint256(UFixed6.unwrap(newValue.oracleFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48) |\n            uint256(UFixed6.unwrap(newValue.riskFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48 - 48);\n\n        uint256 encoded1 =\n            uint256(Fixed6.unwrap(newValue.pAccumulator._value) << (256 - 32)) >> (256 - 32) |\n            uint256(Fixed6.unwrap(newValue.pAccumulator._skew) << (256 - 24)) >> (256 - 32 - 24) |\n            uint256(Fixed6.unwrap(newValue.latestPrice) << (256 - 64)) >> (256 - 32 - 24 - 64) |\n            uint256(Fixed6.unwrap(newValue.exposure) << (256 - 64)) >> (256 - 32 - 24 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/types/Guarantee.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Order.sol\";\n\n/// @dev Guarantee type\nstruct Guarantee {\n    /// @dev The quantity of guarantees that that will be exempt from the settlement fee\n    uint256 orders;\n\n    /// @dev The notional of the magnitude with the price override (local only)\n    Fixed6 notional;\n\n    /// @dev The positive skew (open long / close short) guarantee size\n    UFixed6 takerPos;\n\n    /// @dev The negative skew (close long / open short) guarantee size\n    UFixed6 takerNeg;\n\n    /// @dev The magnitude of the guarantee that be exempt from the trade fee\n    UFixed6 takerFee;\n\n    /// @dev The referral fee multiplied by the size applicable to the referral (local only)\n    UFixed6 referral;\n}\nusing GuaranteeLib for Guarantee global;\nstruct GuaranteeStorageGlobal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing GuaranteeStorageGlobalLib for GuaranteeStorageGlobal global;\nstruct GuaranteeStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing GuaranteeStorageLocalLib for GuaranteeStorageLocal global;\n\n/// @title Guarantee\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the state for an account's update guarantee\nlibrary GuaranteeLib {\n    /// @notice Prepares the next guarantee from the current guarantee\n    /// @param self The guarantee object to update\n    function next(Guarantee memory self) internal pure  {\n        invalidate(self);\n        self.orders = 0;\n    }\n\n    /// @notice Invalidates the guarantee\n    /// @param self The guarantee object to update\n    function invalidate(Guarantee memory self) internal pure {\n        (self.takerPos, self.takerNeg, self.notional, self.takerFee, self.referral) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, Fixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Creates a new guarantee from an order\n    /// @param order The order to create the guarantee from\n    /// @param priceOverride The price override\n    /// @param referralFee The the percentage of the subtractive fee to take as a solver referral fee\n    /// @param chargeSettlementFee Whether the order will still be charged the settlement fee\n    /// @param chargeTradeFee Whether the order will still be charged the trade fee\n    /// @return newGuarantee The resulting guarantee\n    function from(\n        Order memory order,\n        Fixed6 priceOverride,\n        UFixed6 referralFee,\n        bool chargeSettlementFee,\n        bool chargeTradeFee\n    ) internal pure returns (Guarantee memory newGuarantee) {\n        // maker orders and one intent order per fill will be required to pay the settlement fee\n        if (!order.takerTotal().isZero() && !chargeSettlementFee) newGuarantee.orders = order.orders;\n\n        (newGuarantee.takerPos, newGuarantee.takerNeg) =\n            (order.longPos.add(order.shortNeg), order.longNeg.add(order.shortPos));\n        newGuarantee.takerFee = chargeTradeFee ? UFixed6Lib.ZERO : order.takerTotal();\n\n        newGuarantee.notional = taker(newGuarantee).mul(priceOverride);\n        newGuarantee.referral = order.takerReferral.mul(referralFee);\n    }\n\n    /// @notice Returns the taker delta of the guarantee\n    /// @param self The guarantee object to check\n    /// @return The taker delta of the guarantee\n    function taker(Guarantee memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.takerPos).sub(Fixed6Lib.from(self.takerNeg));\n    }\n\n    /// @notice Returns the total taker delta of the guarantee\n    /// @param self The guarantee object to check\n    /// @return The total taker delta of the guarantee\n    function takerTotal(Guarantee memory self) internal pure returns (UFixed6) {\n        return self.takerPos.add(self.takerNeg);\n    }\n\n    /// @notice Updates the current global guarantee with a new local guarantee\n    /// @param self The guarantee object to update\n    /// @param guarantee The new guarantee\n    function add(Guarantee memory self, Guarantee memory guarantee) internal pure {\n        self.orders = self.orders + guarantee.orders;\n        (self.notional, self.takerPos, self.takerNeg, self.takerFee, self.referral) = (\n            self.notional.add(guarantee.notional),\n            self.takerPos.add(guarantee.takerPos),\n            self.takerNeg.add(guarantee.takerNeg),\n            self.takerFee.add(guarantee.takerFee),\n            self.referral.add(guarantee.referral)\n        );\n    }\n}\n\n/// @dev Manually encodes and decodes the global Guarantee struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredGuaranteeGlobal {\n///         /* slot 0 */\n///         uint32 orders;\n///         uint64 takerPos;\n///         uint64 takerNeg;\n///         uint64 takerFee;\n///     }\n///\nlibrary GuaranteeStorageGlobalLib {\n    function read(GuaranteeStorageGlobal storage self) internal view returns (Guarantee memory) {\n        uint256 slot0 = self.slot0;\n        return Guarantee(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            Fixed6Lib.ZERO,\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6Lib.ZERO\n        );\n    }\n\n    function store(GuaranteeStorageGlobal storage self, Guarantee memory newValue) internal {\n        GuaranteeStorageLib.validate(newValue);\n\n        uint256 encoded0 =\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32) |\n            uint256(UFixed6.unwrap(newValue.takerPos) << (256 - 64)) >> (256 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerNeg) << (256 - 64)) >> (256 - 32 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 64)) >> (256 - 32 - 64 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}\n\n/// @dev Manually encodes and decodes the local Guarantee struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredGuaranteeLocal {\n///         /* slot 0 */\n///         uint32 orders;\n///         int64 notional;\n///         uint64 takerPos;\n///         uint64 takerNeg;\n///\n///         /* slot 1 */\n///         uint64 takerFee;\n///         uint64 referral;\n///     }\n///\nlibrary GuaranteeStorageLocalLib {\n    function read(GuaranteeStorageLocal storage self) internal view returns (Guarantee memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n        return Guarantee(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(GuaranteeStorageLocal storage self, Guarantee memory newValue) internal {\n        GuaranteeStorageLib.validate(newValue);\n\n        if (newValue.notional.gt(Fixed6.wrap(type(int64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.notional.lt(Fixed6.wrap(type(int64).min))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.referral.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32) |\n            uint256(Fixed6.unwrap(newValue.notional) << (256 - 64)) >> (256 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerPos) << (256 - 64)) >> (256 - 32 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerNeg) << (256 - 64)) >> (256 - 32 - 64 - 64 - 64);\n        uint256 encode1 =\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.referral) << (256 - 64)) >> (256 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encode1)\n        }\n    }\n}\n\nlibrary GuaranteeStorageLib {\n    // sig: 0xfd030f36\n    error GuaranteeStorageInvalidError();\n\n    function validate(Guarantee memory newValue) internal pure {\n        if (newValue.orders > type(uint32).max) revert GuaranteeStorageInvalidError();\n        if (newValue.takerPos.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.takerNeg.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.takerFee.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/Local.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/Fixed6.sol\";\nimport \"@equilibria/root/accumulator/types/UAccumulator6.sol\";\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"./Version.sol\";\nimport \"./Position.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./OracleVersion.sol\";\nimport \"./Order.sol\";\nimport \"./Checkpoint.sol\";\nimport \"../libs/CheckpointLib.sol\";\n\n/// @dev Local type\nstruct Local {\n    /// @dev The current position id\n    uint256 currentId;\n\n    /// @dev The latest position id\n    uint256 latestId;\n\n    /// @dev The collateral balance\n    Fixed6 collateral;\n\n    /// @dev The claimable balance\n    UFixed6 claimable;\n}\nusing LocalLib for Local global;\nstruct LocalStorage { uint256 slot0; uint256 slot1; }\nusing LocalStorageLib for LocalStorage global;\n\n/// @title Local\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the local account state\nlibrary LocalLib {\n    /// @notice Updates the collateral with the new deposit or withdrwal\n    /// @param self The Local object to update\n    /// @param transfer The amount to update the collateral by\n    function update(Local memory self, Fixed6 transfer) internal pure {\n        self.collateral = self.collateral.add(transfer);\n    }\n\n    /// @notice Updates the collateral with the new collateral change\n    /// @param self The Local object to update\n    /// @param accumulation The accumulation result\n    function update(\n        Local memory self,\n        uint256 newId,\n        CheckpointAccumulationResponse memory accumulation\n    ) internal pure {\n        self.collateral = self.collateral.add(accumulation.collateral).sub(Fixed6Lib.from(accumulation.liquidationFee));\n        self.latestId = newId;\n    }\n\n    /// @notice Updates the claimable with the new amount\n    /// @param self The Local object to update\n    /// @param amount The amount to update the claimable by\n    function credit(Local memory self, UFixed6 amount) internal pure {\n        self.claimable = self.claimable.add(amount);\n    }\n}\n\n/// @dev Manually encodes and decodes the Local struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredLocal {\n///         /* slot 0 */\n///         uint32 currentId;       // <= 4.29b\n///         uint32 latestId;        // <= 4.29b\n///         int64 collateral;       // <= 9.22t\n///         uint64 claimable;       // <= 18.44t\n///         bytes4 __DEPRECATED;    // UNSAFE UNTIL RESET\n///     }\n///\nlibrary LocalStorageLib {\n    // sig: 0xc83d08ec\n    error LocalStorageInvalidError();\n\n    function read(LocalStorage storage self) internal view returns (Local memory) {\n        uint256 slot0 = self.slot0;\n        return Local(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(LocalStorage storage self, Local memory newValue) internal {\n        if (newValue.currentId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\n        if (newValue.latestId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert LocalStorageInvalidError();\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert LocalStorageInvalidError();\n        if (newValue.claimable.gt(UFixed6.wrap(type(uint64).max))) revert LocalStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.claimable) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/MarketParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"./ProtocolParameter.sol\";\n\n/// @dev MarketParameter type\nstruct MarketParameter {\n    /// @dev The fee that is taken out of funding\n    UFixed6 fundingFee;\n\n    /// @dev The fee that is taken out of interest\n    UFixed6 interestFee;\n\n    /// @dev The fee that is taken out of maker and taker fees\n    UFixed6 makerFee;\n\n    /// @dev The fee that is taken out of maker and taker fees\n    UFixed6 takerFee;\n\n    /// @dev The share of the collected fees that is paid to the risk coordinator\n    UFixed6 riskFee;\n\n    /// @dev The maximum amount of orders that can be pending at one time globally\n    uint256 maxPendingGlobal;\n\n    /// @dev The maximum amount of orders that can be pending at one time per account\n    uint256 maxPendingLocal;\n\n    /// @dev Whether the market is in close-only mode\n    bool closed;\n\n     /// @dev Whether the market is in settle-only mode\n    bool settle;\n}\nstruct MarketParameterStorage { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing MarketParameterStorageLib for MarketParameterStorage global;\n\n/// @dev Manually encodes and decodes the MarketParameter struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///    struct StoredMarketParameter {\n///        /* slot 0 */\n///        uint24 fundingFee;          // <= 1677%\n///        uint24 interestFee;         // <= 1677%\n///        uint24 makerFee;            // <= 1677%\n///        uint24 takerFee;            // <= 1677%\n///        uint24 __unallocated__;     // <= 1677%\n///        uint24 riskFee;             // <= 1677%\n///        uint16 maxPendingGlobal;    // <= 65k\n///        uint16 maxPendingLocal;     // <= 65k\n///        uint48 __unallocated__;     // <= 281m\n///        uint8 flags;\n///    }\n///\nlibrary MarketParameterStorageLib {\n    // sig: 0x7c53e926\n    error MarketParameterStorageInvalidError();\n\n    function read(MarketParameterStorage storage self) internal view returns (MarketParameter memory) {\n        uint256 slot0 = self.slot0;\n\n        uint256 flags = uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 48 - 8)) >> (256 - 8);\n        (bool closed, bool settle) =\n            (flags & 0x04 == 0x04, flags & 0x08 == 0x08);\n\n        return MarketParameter(\n            UFixed6.wrap(uint256(slot0 << (256 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n            uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16)) >> (256 - 16),\n            uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16 - 16)) >> (256 - 16),\n            closed,\n            settle\n        );\n    }\n\n    function validate(MarketParameter memory self, ProtocolParameter memory protocolParameter) private pure {\n        if (self.fundingFee.max(self.interestFee).max(self.makerFee).max(self.takerFee).gt(protocolParameter.maxCut))\n            revert MarketParameterStorageInvalidError();\n\n        if (self.riskFee.gt(UFixed6Lib.ONE))\n            revert MarketParameterStorageInvalidError();\n    }\n\n    function validateAndStore(\n        MarketParameterStorage storage self,\n        MarketParameter memory newValue,\n        ProtocolParameter memory protocolParameter\n    ) external {\n        validate(newValue, protocolParameter);\n\n        if (newValue.maxPendingGlobal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\n        if (newValue.maxPendingLocal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\n\n        _store(self, newValue);\n    }\n\n    function _store(MarketParameterStorage storage self, MarketParameter memory newValue) private {\n        uint256 flags = (newValue.closed ? 0x04 : 0x00) |\n            (newValue.settle ? 0x08 : 0x00);\n\n        uint256 encoded0 =\n            uint256(UFixed6.unwrap(newValue.fundingFee) << (256 - 24)) >> (256 - 24) |\n            uint256(UFixed6.unwrap(newValue.interestFee) << (256 - 24)) >> (256 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.makerFee) << (256 - 24)) >> (256 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.riskFee) << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24) |\n            uint256(newValue.maxPendingGlobal << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16) |\n            uint256(newValue.maxPendingLocal << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16 - 16) |\n            uint256(flags << (256 - 8)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 48 - 8);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/OracleReceipt.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev The cost receipt of for a corresponding oracle version\nstruct OracleReceipt {\n    /// @dev The fixed settlement fee of the request\n    UFixed6 settlementFee;\n\n    /// @dev The relative oracle fee percentage of the request\n    UFixed6 oracleFee;\n}\n"
    },
    "@equilibria/perennial-v2/contracts/types/OracleVersion.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/Fixed6.sol\";\n\n/// @dev A singular oracle version with its corresponding data\nstruct OracleVersion {\n    /// @dev the timestamp of the oracle update\n    uint256 timestamp;\n\n    /// @dev The oracle price of the corresponding version\n    Fixed6 price;\n\n    /// @dev Whether the version is valid\n    bool valid;\n}\n"
    },
    "@equilibria/perennial-v2/contracts/types/Order.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./OracleVersion.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./Global.sol\";\nimport \"./Local.sol\";\nimport \"./Position.sol\";\nimport \"./MarketParameter.sol\";\n\n/// @dev Order type\nstruct Order {\n    /// @dev The timestamp of the order\n    uint256 timestamp;\n\n    /// @dev The quantity of orders that are included in this order\n    uint256 orders;\n\n    /// @dev The change in the collateral\n    Fixed6 collateral;\n\n    /// @dev The positive skew maker order size\n    UFixed6 makerPos;\n\n    /// @dev The negative skew maker order size\n    UFixed6 makerNeg;\n\n    /// @dev The positive skew long order size\n    UFixed6 longPos;\n\n    /// @dev The negative skew long order size\n    UFixed6 longNeg;\n\n    /// @dev The positive skew short order size\n    UFixed6 shortPos;\n\n    /// @dev The negative skew short order size\n    UFixed6 shortNeg;\n\n    /// @dev The protection status semaphore (local only)\n    uint256 protection;\n\n    /// @dev The referral fee multiplied by the size applicable to the referral\n    UFixed6 makerReferral;\n\n    /// @dev The referral fee multiplied by the size applicable to the referral\n    UFixed6 takerReferral;\n}\nusing OrderLib for Order global;\nstruct OrderStorageGlobal { uint256 slot0; uint256 slot1; uint256 slot2; } // SECURITY: must remain at (3) slots\nusing OrderStorageGlobalLib for OrderStorageGlobal global;\nstruct OrderStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing OrderStorageLocalLib for OrderStorageLocal global;\n\n/// @title Order\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the state for an account's update order\nlibrary OrderLib {\n    /// @notice Returns whether the order is ready to be settled\n    /// @param self The order object to check\n    /// @param latestVersion The latest oracle version\n    /// @return Whether the order is ready to be settled\n    function ready(Order memory self, OracleVersion memory latestVersion) internal pure returns (bool) {\n        return latestVersion.timestamp >= self.timestamp;\n    }\n\n    /// @notice Prepares the next order from the current order\n    /// @param self The order object to update\n    /// @param timestamp The current timestamp\n    function next(Order memory self, uint256 timestamp) internal pure  {\n        invalidate(self);\n        (self.timestamp, self.orders, self.collateral, self.protection) = (timestamp, 0, Fixed6Lib.ZERO, 0);\n    }\n\n    /// @notice Invalidates the order\n    /// @param self The order object to update\n    function invalidate(Order memory self) internal pure {\n        (self.makerReferral, self.takerReferral) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Creates a new order from the an intent order request\n    /// @param timestamp The current timestamp\n    /// @param position The current position\n    /// @param amount The magnitude and direction of the order\n    /// @param collateral The change in the collateral\n    /// @param referralFee The referral fee\n    /// @return newOrder The resulting order\n    function from(\n        uint256 timestamp,\n        Position memory position,\n        Fixed6 amount,\n        Fixed6 collateral,\n        UFixed6 referralFee\n    ) internal pure returns (Order memory newOrder) {\n        newOrder.timestamp = timestamp;\n        newOrder.collateral = collateral;\n        newOrder.orders = amount.isZero() ? 0 : 1;\n        newOrder.takerReferral = amount.abs().mul(referralFee);\n\n        // If the order is not counter to the current position, it is opening\n        if (amount.sign() == 0 || position.skew().sign() == 0 || position.skew().sign() == amount.sign()) {\n            newOrder.longPos = amount.max(Fixed6Lib.ZERO).abs();\n            newOrder.shortPos = amount.min(Fixed6Lib.ZERO).abs();\n\n        // If the order is counter to the current position, it is closing\n        } else {\n            newOrder.shortNeg = amount.max(Fixed6Lib.ZERO).abs();\n            newOrder.longNeg = amount.min(Fixed6Lib.ZERO).abs();\n        }\n    }\n\n    /// @notice Creates a new order from the current position and an update request\n    /// @param timestamp The current timestamp\n    /// @param position The current position\n    /// @param collateral The change in the collateral\n    /// @param newMaker The new maker\n    /// @param newLong The new long\n    /// @param newShort The new short\n    /// @param protect Whether to protect the order\n    /// @param referralFee The referral fee\n    /// @return newOrder The resulting order\n    function from(\n        uint256 timestamp,\n        Position memory position,\n        Fixed6 collateral,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        bool protect,\n        UFixed6 referralFee\n    ) internal pure returns (Order memory newOrder) {\n        (Fixed6 makerAmount, Fixed6 longAmount, Fixed6 shortAmount) = (\n            Fixed6Lib.from(newMaker).sub(Fixed6Lib.from(position.maker)),\n            Fixed6Lib.from(newLong).sub(Fixed6Lib.from(position.long)),\n            Fixed6Lib.from(newShort).sub(Fixed6Lib.from(position.short))\n        );\n\n        UFixed6 referral = makerAmount.abs().add(longAmount.abs()).add(shortAmount.abs()).mul(referralFee);\n\n        newOrder = Order(\n            timestamp,\n            0,\n            collateral,\n            makerAmount.max(Fixed6Lib.ZERO).abs(),\n            makerAmount.min(Fixed6Lib.ZERO).abs(),\n            longAmount.max(Fixed6Lib.ZERO).abs(),\n            longAmount.min(Fixed6Lib.ZERO).abs(),\n            shortAmount.max(Fixed6Lib.ZERO).abs(),\n            shortAmount.min(Fixed6Lib.ZERO).abs(),\n            protect ? 1 : 0,\n            makerAmount.isZero() ? UFixed6Lib.ZERO : referral,\n            makerAmount.isZero() ? referral : UFixed6Lib.ZERO\n        );\n        if (!isEmpty(newOrder)) newOrder.orders = 1;\n    }\n\n    /// @notice Returns whether the order increases any of the account's positions\n    /// @return Whether the order increases any of the account's positions\n    function increasesPosition(Order memory self) internal pure returns (bool) {\n        return increasesMaker(self) || increasesTaker(self);\n    }\n\n    /// @notice Returns whether the order increases the account's long or short positions\n    /// @return Whether the order increases the account's long or short positions\n    function increasesTaker(Order memory self) internal pure returns (bool) {\n        return !self.longPos.isZero() || !self.shortPos.isZero();\n    }\n\n    /// @notice Returns whether the order increases the account's maker position\n    /// @return Whether the order increases the account's maker positions\n    function increasesMaker(Order memory self) internal pure returns (bool) {\n        return !self.makerPos.isZero();\n    }\n\n    /// @notice Returns whether the order decreases the liquidity of the market\n    /// @return Whether the order decreases the liquidity of the market\n    function decreasesLiquidity(Order memory self, Position memory currentPosition) internal pure returns (bool) {\n        Fixed6 currentSkew = currentPosition.skew();\n        Fixed6 latestSkew = currentSkew.sub(long(self)).add(short(self));\n        return !self.makerNeg.isZero() || currentSkew.abs().gt(latestSkew.abs());\n    }\n\n    /// @notice Returns whether the order decreases the efficieny of the market\n    /// @dev Decreased efficiency ratio intuitively means that the market is \"more efficient\" on an OI to LP basis.\n    /// @return Whether the order decreases the liquidity of the market\n    function decreasesEfficiency(Order memory self, Position memory currentPosition) internal pure returns (bool) {\n        UFixed6 currentMajor = currentPosition.major();\n        UFixed6 latestMajor = UFixed6Lib.from(Fixed6Lib.from(currentPosition.long).sub(long(self)))\n            .max(UFixed6Lib.from(Fixed6Lib.from(currentPosition.short).sub(short(self))));\n        return !self.makerNeg.isZero() || currentMajor.gt(latestMajor);\n    }\n\n    /// @notice Returns whether the order is applicable for liquidity checks\n    /// @param self The Order object to check\n    /// @param marketParameter The market parameter\n    /// @return Whether the order is applicable for liquidity checks\n    function liquidityCheckApplicable(\n        Order memory self,\n        MarketParameter memory marketParameter\n    ) internal pure returns (bool) {\n        return !marketParameter.closed &&\n        // not \"a taker order that is increasing\" ->\n        // not (any of the following)\n        //  - taker is empty (not a taker order)\n        //  - taker is increasing (position going more long or short)\n            ((long(self).isZero() && short(self).isZero()) || increasesTaker(self));\n    }\n\n    /// @notice Returns whether the order is protected\n    /// @param self The order object to check\n    /// @return Whether the order is protected\n    function protected(Order memory self) internal pure returns (bool) {\n        return self.protection != 0;\n    }\n\n    /// @notice Returns whether the order is empty\n    /// @param self The order object to check\n    /// @return Whether the order is empty\n    function isEmpty(Order memory self) internal pure returns (bool) {\n        return pos(self).isZero() && neg(self).isZero();\n    }\n\n     /// @notice Returns the direction of the order\n    /// @dev 0 = maker, 1 = long, 2 = short\n    /// @param self The position object to check\n    /// @return The direction of the position\n    function direction(Order memory self) internal pure returns (uint256) {\n        if (!self.longPos.isZero() || !self.longNeg.isZero()) return 1;\n        if (!self.shortPos.isZero() || !self.shortNeg.isZero()) return 2;\n\n        return 0;\n    }\n\n    /// @notice Returns the magnitude of the order\n    /// @param self The order object to check\n    /// @return The magnitude of the order\n    function magnitude(Order memory self) internal pure returns (Fixed6) {\n        return maker(self).add(long(self)).add(short(self));\n    }\n\n    /// @notice Returns the maker delta of the order\n    /// @param self The order object to check\n    /// @return The maker delta of the order\n    function maker(Order memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.makerPos).sub(Fixed6Lib.from(self.makerNeg));\n    }\n\n    /// @notice Returns the long delta of the order\n    /// @param self The order object to check\n    /// @return The long delta of the order\n    function long(Order memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.longPos).sub(Fixed6Lib.from(self.longNeg));\n    }\n\n    /// @notice Returns the short delta of the order\n    /// @param self The order object to check\n    /// @return The short delta of the order\n    function short(Order memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.shortPos).sub(Fixed6Lib.from(self.shortNeg));\n    }\n\n    /// @notice Returns the positive taker delta of the order\n    /// @param self The order object to check\n    /// @return The positive taker delta of the order\n    function takerPos(Order memory self) internal pure returns (UFixed6) {\n        return self.longPos.add(self.shortNeg);\n    }\n\n    /// @notice Returns the negative taker delta of the order\n    /// @param self The order object to check\n    /// @return The negative taker delta of the order\n    function takerNeg(Order memory self) internal pure returns (UFixed6) {\n        return self.shortPos.add(self.longNeg);\n    }\n\n    /// @notice Returns the total maker delta of the order\n    /// @param self The order object to check\n    /// @return The total maker delta of the order\n    function makerTotal(Order memory self) internal pure returns (UFixed6) {\n        return self.makerPos.add(self.makerNeg);\n    }\n\n    /// @notice Returns the total taker delta of the order\n    /// @param self The order object to check\n    /// @return The total taker delta of the order\n    function takerTotal(Order memory self) internal pure returns (UFixed6) {\n        return self.takerPos().add(self.takerNeg());\n    }\n\n    /// @notice Returns the positive delta of the order\n    /// @param self The order object to check\n    /// @return The positive delta of the order\n    function pos(Order memory self) internal pure returns (UFixed6) {\n        return self.makerPos.add(self.longPos).add(self.shortPos);\n    }\n\n    /// @notice Returns the positive delta of the order\n    /// @param self The order object to check\n    /// @return The positive delta of the order\n    function neg(Order memory self) internal pure returns (UFixed6) {\n        return self.makerNeg.add(self.longNeg).add(self.shortNeg);\n    }\n\n    /// @notice Updates the current global order with a new local order\n    /// @param self The order object to update\n    /// @param order The new order\n    function add(Order memory self, Order memory order) internal pure {\n        (self.orders, self.collateral, self.protection, self.makerReferral, self.takerReferral) = (\n            self.orders + order.orders,\n            self.collateral.add(order.collateral),\n            self.protection + order.protection,\n            self.makerReferral.add(order.makerReferral),\n            self.takerReferral.add(order.takerReferral)\n        );\n\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) = (\n            self.makerPos.add(order.makerPos),\n            self.makerNeg.add(order.makerNeg),\n            self.longPos.add(order.longPos),\n            self.longNeg.add(order.longNeg),\n            self.shortPos.add(order.shortPos),\n            self.shortNeg.add(order.shortNeg)\n        );\n    }\n\n    /// @notice Subtracts the latest local order from current global order\n    /// @param self The order object to update\n    /// @param order The latest order\n    function sub(Order memory self, Order memory order) internal pure {\n        (self.orders, self.collateral, self.protection, self.makerReferral, self.takerReferral) = (\n            self.orders - order.orders,\n            self.collateral.sub(order.collateral),\n            self.protection - order.protection,\n            self.makerReferral.sub(order.makerReferral),\n            self.takerReferral.sub(order.takerReferral)\n        );\n\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) = (\n            self.makerPos.sub(order.makerPos),\n            self.makerNeg.sub(order.makerNeg),\n            self.longPos.sub(order.longPos),\n            self.longNeg.sub(order.longNeg),\n            self.shortPos.sub(order.shortPos),\n            self.shortNeg.sub(order.shortNeg)\n        );\n    }\n}\n\n/// @dev Manually encodes and decodes the global Order struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredOrderGlobal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint32 orders;\n///         int64 collateral;\n///         uint64 makerPos;\n///         uint64 makerNeg;\n///\n///         /* slot 1 */\n///         uint64 longPos;\n///         uint64 longNeg;\n///         uint64 shortPos;\n///         uint64 shortNeg;\n///\n///         /* slot 2 */\n///         uint64 takerReferral;\n///         uint64 makerReferral;\n///     }\n///\nlibrary OrderStorageGlobalLib {\n    function read(OrderStorageGlobal storage self) internal view returns (Order memory) {\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\n\n        return Order(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64 - 64)) >> (256 - 64)),\n            0,\n            UFixed6.wrap(uint256(slot2 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot2 << (256 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(OrderStorageGlobal storage self, Order memory newValue) internal {\n        OrderStorageLib.validate(newValue);\n\n        if (newValue.makerPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.makerNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.longPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.longNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.shortPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.shortNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.makerPos) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.makerNeg) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64 - 64);\n        uint256 encoded1 =\n            uint256(UFixed6.unwrap(newValue.longPos) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.longNeg) << (256 - 64)) >> (256 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.shortPos) << (256 - 64)) >> (256 - 64 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.shortNeg) << (256 - 64)) >> (256 - 64 - 64 - 64 - 64);\n        uint256 encoded2 =\n            uint256(UFixed6.unwrap(newValue.makerReferral) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerReferral) << (256 - 64)) >> (256 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n            sstore(add(self.slot, 2), encoded2)\n        }\n    }\n}\n\n/// @dev Manually encodes and decodes the local Order struct into storage.\n///\n///     struct StoredOrderLocal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint32 orders;\n///         int64 collateral;\n///         uint2 direction;\n///         uint62 magnitudePos;\n///         uint62 magnitudeNeg;\n///         uint1 protection;\n///\n///         /* slot 1 */\n///         uint64 takerReferral;\n///         uint64 makerReferral;\n///     }\n///\nlibrary OrderStorageLocalLib {\n    function read(OrderStorageLocal storage self) internal view returns (Order memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n\n        uint256 direction = uint256(slot0 << (256 - 32 - 32 - 64 - 2)) >> (256 - 2);\n        UFixed6 magnitudePos = UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62)) >> (256 - 62));\n        UFixed6 magnitudeNeg = UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62 - 62)) >> (256 - 62));\n\n        return Order(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\n            direction == 0 ? magnitudePos : UFixed6Lib.ZERO,\n            direction == 0 ? magnitudeNeg : UFixed6Lib.ZERO,\n            direction == 1 ? magnitudePos : UFixed6Lib.ZERO,\n            direction == 1 ? magnitudeNeg : UFixed6Lib.ZERO,\n            direction == 2 ? magnitudePos : UFixed6Lib.ZERO,\n            direction == 2 ? magnitudeNeg : UFixed6Lib.ZERO,\n            uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62 - 62 - 1)) >> (256 - 1),\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(OrderStorageLocal storage self, Order memory newValue) internal {\n        OrderStorageLib.validate(newValue);\n\n        (UFixed6 magnitudePos, UFixed6 magnitudeNeg) = (newValue.pos(), newValue.neg());\n\n        if (magnitudePos.gt(UFixed6.wrap(2 ** 62 - 1))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (magnitudeNeg.gt(UFixed6.wrap(2 ** 62 - 1))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.protection > 1) revert OrderStorageLib.OrderStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\n            uint256(newValue.direction() << (256 - 2)) >> (256 - 32 - 32 - 64 - 2) |\n            uint256(UFixed6.unwrap(magnitudePos) << (256 - 62)) >> (256 - 32 - 32 - 64 - 2 - 62) |\n            uint256(UFixed6.unwrap(magnitudeNeg) << (256 - 62)) >> (256 - 32 - 32 - 64 - 2 - 62 - 62) |\n            uint256(newValue.protection << (256 - 1)) >> (256 - 32 - 32 - 64 - 2 - 62 - 62 - 1);\n        uint256 encoded1 =\n            uint256(UFixed6.unwrap(newValue.makerReferral) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerReferral) << (256 - 64)) >> (256 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}\n\nlibrary OrderStorageLib {\n    // sig: 0x67e45965\n    error OrderStorageInvalidError();\n\n    function validate(Order memory newValue) internal pure {\n        if (newValue.timestamp > type(uint32).max) revert OrderStorageInvalidError();\n        if (newValue.orders > type(uint32).max) revert OrderStorageInvalidError();\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert OrderStorageInvalidError();\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert OrderStorageInvalidError();\n        if (newValue.makerReferral.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageInvalidError();\n        if (newValue.takerReferral.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageInvalidError();\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/Position.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./OracleVersion.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./Global.sol\";\nimport \"./Local.sol\";\nimport \"./Order.sol\";\n\n/// @dev Order type\nstruct Position {\n    /// @dev The timestamp of the position\n    uint256 timestamp;\n\n    /// @dev The maker position size\n    UFixed6 maker;\n\n    /// @dev The long position size\n    UFixed6 long;\n\n    /// @dev The short position size\n    UFixed6 short;\n}\nusing PositionLib for Position global;\nstruct PositionStorageGlobal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing PositionStorageGlobalLib for PositionStorageGlobal global;\nstruct PositionStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing PositionStorageLocalLib for PositionStorageLocal global;\n\n/// @title Position\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the state for a position\nlibrary PositionLib {\n    /// @notice Returns a cloned copy of the position\n    /// @param self The position object to clone\n    /// @return A cloned copy of the position\n    function clone(Position memory self) internal pure returns (Position memory) {\n        return Position(self.timestamp, self.maker, self.long, self.short);\n    }\n\n    /// @notice Updates the position with a new order\n    /// @param self The position object to update\n    /// @param order The new order\n    function update(Position memory self, Order memory order) internal pure {\n        self.timestamp = order.timestamp;\n\n        (self.maker, self.long, self.short) = (\n            UFixed6Lib.from(Fixed6Lib.from(self.maker).add(order.maker())),\n            UFixed6Lib.from(Fixed6Lib.from(self.long).add(order.long())),\n            UFixed6Lib.from(Fixed6Lib.from(self.short).add(order.short()))\n        );\n    }\n\n    /// @notice Returns the direction of the position\n    /// @dev 0 = maker, 1 = long, 2 = short\n    /// @param self The position object to check\n    /// @return The direction of the position\n    function direction(Position memory self) internal pure returns (uint256) {\n        return self.long.isZero() ? (self.short.isZero() ? 0 : 2) : 1;\n    }\n\n    /// @notice Returns the maximum position size\n    /// @param self The position object to check\n    /// @return The maximum position size\n    function magnitude(Position memory self) internal pure returns (UFixed6) {\n        return self.long.max(self.short).max(self.maker);\n    }\n\n    /// @notice Returns the maximum taker position size\n    /// @param self The position object to check\n    /// @return The maximum taker position size\n    function major(Position memory self) internal pure returns (UFixed6) {\n        return self.long.max(self.short);\n    }\n\n    /// @notice Returns the minimum maker position size\n    /// @param self The position object to check\n    /// @return The minimum maker position size\n    function minor(Position memory self) internal pure returns (UFixed6) {\n        return self.long.min(self.short);\n    }\n\n    /// @notice Returns the skew of the position\n    /// @param self The position object to check\n    /// @return The skew of the position\n    function skew(Position memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.long).sub(Fixed6Lib.from(self.short));\n    }\n\n    /// @notice Returns the utilization of the position\n    /// @dev utilization = major / (maker + minor)\n    /// @param self The position object to check\n    /// @param riskParameter The current risk parameter\n    /// @return The utilization of the position\n    function utilization(Position memory self, RiskParameter memory riskParameter) internal pure returns (UFixed6) {\n        // long-short net utilization of the maker position\n        UFixed6 netUtilization = major(self).unsafeDiv(self.maker.add(minor(self)));\n\n        // efficiency limit utilization of the maker position\n        UFixed6 efficiencyUtilization = major(self).mul(riskParameter.efficiencyLimit).unsafeDiv(self.maker);\n\n        // maximum of the two utilizations, capped at 100%\n        return netUtilization.max(efficiencyUtilization).min(UFixed6Lib.ONE);\n    }\n\n    /// @notice Returns the portion of the position that is covered by the maker\n    /// @param self The position object to check\n    /// @return The portion of the position that is covered by the maker\n    function socializedMakerPortion(Position memory self) internal pure returns (UFixed6) {\n        return takerSocialized(self).isZero() ?\n            UFixed6Lib.ZERO :\n            takerSocialized(self).sub(minor(self)).div(takerSocialized(self));\n    }\n\n    /// @notice Returns the long position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The long position with socialization taken into account\n    function longSocialized(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.add(self.short).min(self.long);\n    }\n\n    /// @notice Returns the short position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The short position with socialization taken into account\n    function shortSocialized(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.add(self.long).min(self.short);\n    }\n\n    /// @notice Returns the major position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The major position with socialization taken into account\n    function takerSocialized(Position memory self) internal pure returns (UFixed6) {\n        return major(self).min(minor(self).add(self.maker));\n    }\n\n    /// @notice Returns the efficiency of the position\n    /// @dev efficiency = maker / major\n    /// @param self The position object to check\n    /// @return The efficiency of the position\n    function efficiency(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.unsafeDiv(major(self)).min(UFixed6Lib.ONE);\n    }\n\n    /// @notice Returns the whether the position is socialized\n    /// @param self The position object to check\n    /// @return Whether the position is socialized\n    function socialized(Position memory self) internal pure returns (bool) {\n        return self.maker.add(self.short).lt(self.long) || self.maker.add(self.long).lt(self.short);\n    }\n\n    /// @notice Returns the whether the position is single-sided\n    /// @param self The position object to check\n    /// @return Whether the position is single-sided\n    function singleSided(Position memory self) internal pure returns (bool) {\n        return magnitude(self).eq(self.long.add(self.short).add(self.maker));\n    }\n\n    /// @notice Returns the whether the position is empty\n    /// @param self The position object to check\n    /// @return Whether the position is empty\n    function empty(Position memory self) internal pure returns (bool) {\n        return magnitude(self).isZero();\n    }\n\n    /// @notice Returns the maintenance requirement of the position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The maintenance requirement of the position\n    function maintenance(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.maintenance, riskParameter.minMaintenance);\n    }\n\n    /// @notice Returns the margin requirement of the position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateralization The collateralization requirement override provided by the caller\n    /// @return The margin requirement of the position\n    function margin(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        UFixed6 collateralization\n    ) internal pure returns (UFixed6) {\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.margin.max(collateralization), riskParameter.minMargin);\n    }\n\n    /// @notice Returns the maintenance requirement of the position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The maintenance requirement of the position\n    function maintenance(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        return maintenance(magnitude(self), latestVersion, riskParameter);\n    }\n\n    /// @notice Returns the margin requirement of the position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The margin requirement of the position\n    function margin(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        return margin(magnitude(self), latestVersion, riskParameter, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Returns the collateral requirement of the position magnitude\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param requirementRatio The ratio requirement to the notional\n    /// @param requirementFixed The fixed requirement\n    /// @return The collateral requirement of the position magnitude\n    function _collateralRequirement(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        UFixed6 requirementRatio,\n        UFixed6 requirementFixed\n    ) private pure returns (UFixed6) {\n        if (positionMagnitude.isZero()) return UFixed6Lib.ZERO;\n        return positionMagnitude.mul(latestVersion.price.abs()).mul(requirementRatio).max(requirementFixed);\n    }\n\n    /// @notice Returns the whether the position is maintained\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is maintained\n    function maintained(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return UFixed6Lib.unsafeFrom(collateral).gte(maintenance(positionMagnitude, latestVersion, riskParameter));\n    }\n\n    /// @notice Returns the whether the position is margined\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateralization The collateralization requirement override provided by the caller\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is margined\n    function margined(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        UFixed6 collateralization,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return UFixed6Lib.unsafeFrom(collateral).gte(margin(positionMagnitude, latestVersion, riskParameter, collateralization));\n    }\n\n    /// @notice Returns the whether the position is maintained\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is maintained\n    function maintained(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return maintained(magnitude(self), latestVersion, riskParameter, collateral);\n    }\n\n    /// @notice Returns the whether the position is margined\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateralization The collateralization requirement override provided by the caller\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is margined\n    function margined(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        UFixed6 collateralization,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return margined(magnitude(self), latestVersion, riskParameter, collateralization, collateral);\n    }\n}\n\n/// @dev Manually encodes and decodes the global Position struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredPositionGlobal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint32 __unallocated__;\n///         uint64 maker;\n///         uint64 long;\n///         uint64 short;\n///\n///         /* slot 1 */\n///         uint64 maker (deprecated);\n///         uint192 __unallocated__;\n///     }\n///\nlibrary PositionStorageGlobalLib {\n    function read(PositionStorageGlobal storage self) internal view returns (Position memory) {\n        uint256 slot0 = self.slot0;\n        return Position(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(PositionStorageGlobal storage self, Position memory newValue) public {\n        PositionStorageLib.validate(newValue);\n\n        if (newValue.maker.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\n        if (newValue.long.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\n        if (newValue.short.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(UFixed6.unwrap(newValue.maker) << (256 - 64)) >> (256 - 32 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.long) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.short) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n\n    function migrate(PositionStorageGlobal storage self) external {\n        Position memory position = read(self);\n        uint256 slot1 = self.slot1;\n        UFixed6 deprecatedMaker = UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64));\n\n        // only migrate if the deprecated maker is set and new maker is unset to avoid double-migration\n        if (!position.maker.isZero())\n            revert PositionStorageLib.PositionStorageInvalidMigrationError();\n\n        position.maker = deprecatedMaker;\n        store(self, position);\n        assembly {\n            sstore(add(self.slot, 1), 0) // Part of the v2.3 migration. Can be removed once migration is complete.\n        }\n    }\n}\n\n/// @dev Manually encodes and decodes the local Position struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredPositionLocal (v0) {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint216 __unallocated__;\n///         uint8 layout;\n///\n///         /* slot 1 */\n///         uint2 direction;\n///         uint62 magnitude;\n///         uint192 __unallocated__;\n///     }\n///\n///     note: fresh Positions will still default to v0 until they are saved to, but this is safe because\n///           slot1 is still reserved and will return correct default values.\n///\n///     struct StoredPositionLocal (v1) {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint2 direction;\n///         uint62 magnitude;\n///         uint152 __unallocated__;\n///         uint8 layout; // v2.3 migration -- can remove once all accounts have been migrated\n///     }\n///\nlibrary PositionStorageLocalLib {\n    function read(PositionStorageLocal storage self) internal view returns (Position memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n        uint256 layout = uint256(slot0 << (256 - 32 - 216 - 8)) >> (256 - 8);\n\n        uint256 direction = layout == 0 ?\n            uint256(slot1 << (256 - 2)) >> (256 - 2) :\n            uint256(slot0 << (256 - 32 - 2)) >> (256 - 2);\n        UFixed6 magnitude = layout == 0 ?\n            UFixed6.wrap(uint256(slot1 << (256 - 2 - 62)) >> (256 - 62)) :\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 2 - 62)) >> (256 - 62));\n\n        return Position(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            direction == 0 ? magnitude : UFixed6Lib.ZERO,\n            direction == 1 ? magnitude : UFixed6Lib.ZERO,\n            direction == 2 ? magnitude : UFixed6Lib.ZERO\n        );\n    }\n\n    function store(PositionStorageLocal storage self, Position memory newValue) external {\n        PositionStorageLib.validate(newValue);\n\n        uint256 layout = 1;\n        UFixed6 magnitude = newValue.magnitude();\n\n        if (magnitude.gt(UFixed6.wrap(2 ** 62 - 1))) revert PositionStorageLib.PositionStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.direction() << (256 - 2)) >> (256 - 32 - 2) |\n            uint256(UFixed6.unwrap(magnitude) << (256 - 62)) >> (256 - 32 - 2 - 62) |\n            uint256(layout << (256 - 8)) >> (256 - 32 - 2 - 62 - 152 - 8);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), 0) // Part of the v2.3 migration. Can be removed once migration is complete.\n        }\n    }\n}\n\nlibrary PositionStorageLib {\n    // sig: 0x52a8a97f\n    error PositionStorageInvalidError();\n    // sig: 0x1bacb3a2\n    error PositionStorageInvalidMigrationError();\n\n    function validate(Position memory newValue) internal pure {\n        if (newValue.timestamp > type(uint32).max) revert PositionStorageInvalidError();\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/ProtocolParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev ProtocolParameter type\nstruct ProtocolParameter {\n    /// @dev The maximum for market fee parameters\n    UFixed6 maxFee;\n\n    /// @dev The maximum for market absolute fee parameters\n    UFixed6 maxFeeAbsolute;\n\n    /// @dev The maximum for market cut parameters\n    UFixed6 maxCut;\n\n    /// @dev The maximum for market rate parameters\n    UFixed6 maxRate;\n\n    /// @dev The minimum for market maintenance parameters\n    UFixed6 minMaintenance;\n\n    /// @dev The minimum for market efficiency parameters\n    UFixed6 minEfficiency;\n\n    /// @dev The default referrer fee percentage for orders\n    UFixed6 referralFee;\n\n    /// @dev The minimum ratio between scale vs makerLimit / efficiencyLimit\n    UFixed6 minScale;\n}\nstruct StoredProtocolParameter {\n    /* slot 0 (28) */\n    uint24 maxFee;                  // <= 1677%\n    uint48 maxFeeAbsolute;          // <= 281m\n    uint24 maxCut;                  // <= 1677%\n    uint32 maxRate;                 // <= 214748% (capped at 31 bits to accommodate int32 rates)\n    uint24 minMaintenance;          // <= 1677%\n    uint24 minEfficiency;           // <= 1677%\n    uint24 referralFee;             // <= 1677%\n    uint24 minScale;                // <= 1677%\n}\nstruct ProtocolParameterStorage { StoredProtocolParameter value; } // SECURITY: must remain at (1) slots\nusing ProtocolParameterStorageLib for ProtocolParameterStorage global;\n\n/// @dev (external-safe): this library is safe to externalize\nlibrary ProtocolParameterStorageLib {\n    // sig: 0x4dc1bc59\n    error ProtocolParameterStorageInvalidError();\n\n    function read(ProtocolParameterStorage storage self) internal view returns (ProtocolParameter memory) {\n        StoredProtocolParameter memory value = self.value;\n        return ProtocolParameter(\n            UFixed6.wrap(uint256(value.maxFee)),\n            UFixed6.wrap(uint256(value.maxFeeAbsolute)),\n            UFixed6.wrap(uint256(value.maxCut)),\n            UFixed6.wrap(uint256(value.maxRate)),\n            UFixed6.wrap(uint256(value.minMaintenance)),\n            UFixed6.wrap(uint256(value.minEfficiency)),\n            UFixed6.wrap(uint256(value.referralFee)),\n            UFixed6.wrap(uint256(value.minScale))\n        );\n    }\n\n    function validate(ProtocolParameter memory self) internal pure {\n        if (self.maxCut.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\n        if (self.referralFee.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\n        if (self.minScale.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\n    }\n\n    function validateAndStore(ProtocolParameterStorage storage self, ProtocolParameter memory newValue) internal {\n        validate(newValue);\n\n        if (newValue.maxFee.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.maxFeeAbsolute.gt(UFixed6.wrap(type(uint48).max))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.maxRate.gt(UFixed6.wrap(type(uint32).max / 2))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.minMaintenance.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.minEfficiency.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\n\n        self.value = StoredProtocolParameter(\n            uint24(UFixed6.unwrap(newValue.maxFee)),\n            uint48(UFixed6.unwrap(newValue.maxFeeAbsolute)),\n            uint24(UFixed6.unwrap(newValue.maxCut)),\n            uint32(UFixed6.unwrap(newValue.maxRate)),\n            uint24(UFixed6.unwrap(newValue.minMaintenance)),\n            uint24(UFixed6.unwrap(newValue.minEfficiency)),\n            uint24(UFixed6.unwrap(newValue.referralFee)),\n            uint24(UFixed6.unwrap(newValue.minScale))\n        );\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/RiskParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol\";\nimport \"@equilibria/root/pid/types/PController6.sol\";\nimport \"@equilibria/root/adiabatic/types/LinearAdiabatic6.sol\";\nimport \"@equilibria/root/adiabatic/types/NoopAdiabatic6.sol\";\nimport \"../interfaces/IOracleProvider.sol\";\nimport \"./ProtocolParameter.sol\";\n\n/// @dev RiskParameter type\nstruct RiskParameter {\n    /// @dev The minimum amount of collateral required to open a new position as a percentage of notional\n    UFixed6 margin;\n\n    /// @dev The minimum amount of collateral that must be maintained as a percentage of notional\n    UFixed6 maintenance;\n\n    /// @dev The taker impact fee\n    LinearAdiabatic6 takerFee;\n\n    /// @dev The maker fee configuration\n    NoopAdiabatic6 makerFee;\n\n    /// @dev The maximum amount of maker positions that opened\n    UFixed6 makerLimit;\n\n    /// @dev The minimum limit of the efficiency metric\n    UFixed6 efficiencyLimit;\n\n    /// @dev The percentage fee on the notional that is charged when a position is liquidated\n    UFixed6 liquidationFee;\n\n    /// @dev The utilization curve that is used to compute maker interest\n    UJumpRateUtilizationCurve6 utilizationCurve;\n\n    /// @dev The p controller that is used to compute long-short funding\n    PController6 pController;\n\n    /// @dev The minimum fixed amount that is required to open a position\n    UFixed6 minMargin;\n\n    /// @dev The minimum fixed amount that is required for maintenance\n    UFixed6 minMaintenance;\n\n    /// @dev The maximum amount of time since the latest oracle version that update may still be called\n    uint256 staleAfter;\n\n    /// @dev Whether or not the maker should always receive positive funding\n    bool makerReceiveOnly;\n}\nstruct RiskParameterStorage { uint256 slot0; uint256 slot1; uint256 slot2; } // SECURITY: must remain at (3) slots\nusing RiskParameterStorageLib for RiskParameterStorage global;\n\n/// @dev Manually encodes and decodes the local Position struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///    struct StoredRiskParameter {\n///        /* slot 0 */ (30)\n///        uint24 margin;                              // <= 1677%\n///        uint24 maintenance;                         // <= 1677%\n///        uint24 takerLinearFee;                      // <= 1677%\n///        uint24 takerProportionalFee;                // <= 1677%\n///        uint24 takerAdiabaticFee;                   // <= 1677% (must maintain location due to updateRiskParameter)\n///        uint24 makerLinearFee;                      // <= 1677%\n///        uint24 makerProportionalFee;                // <= 1677%\n///        uint48 makerLimit;                          // <= 281t (no decimals)\n///        uint24 efficiencyLimit;                     // <= 1677%\n///\n///        /* slot 1 */ (28)\n///        bytes3 __unallocated__;\n///        uint48 takerSkewScale;                      // <= 281t (no decimals) (must maintain location due to updateRiskParameter)\n///        uint24 utilizationCurveMinRate;             // <= 1677%\n///        uint24 utilizationCurveMaxRate;             // <= 1677%\n///        uint24 utilizationCurveTargetRate;          // <= 1677%\n///        uint24 utilizationCurveTargetUtilization;   // <= 1677%\n///        int32 pControllerMin;                       // <= 214748%\n///\n///        /* slot 2 */ (32)\n///        uint48 pControllerK;                        // <= 281m\n///        int32 pControllerMax;                       // <= 214748%\n///        uint48 minMargin;                           // <= 281m\n///        uint48 minMaintenance;                      // <= 281m\n///        uint48 liquidationFee;                      // <= 281m\n///        uint24 staleAfter;                          // <= 16m s\n///        bool makerReceiveOnly;\n///    }\nlibrary RiskParameterStorageLib {\n    // sig: 0x7ecd083f\n    error RiskParameterStorageInvalidError();\n\n    function read(RiskParameterStorage storage self) internal view returns (RiskParameter memory) {\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\n        return RiskParameter(\n            UFixed6.wrap(uint256(       slot0 << (256 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24)) >> (256 - 24)),\n            LinearAdiabatic6(\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6Lib.from(uint256(slot1 << (256 - 24 - 48 - 48)) >> (256 - 48))\n            ),\n            NoopAdiabatic6(\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6Lib.from(uint256(slot1 << (256 - 24 - 48)) >> (256 - 48))\n            ),\n            UFixed6Lib.from(uint256(    slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48 - 24)) >> (256 - 24)),\n\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48)) >> (256 - 48)),\n            UJumpRateUtilizationCurve6(\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24)) >> (256 - 24))\n            ),\n\n            PController6(\n                UFixed6.wrap(uint256(   slot2 << (256 - 48)) >> (256 - 48)),\n                Fixed6.wrap(int256(     slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24 - 32)) >> (256 - 32)),\n                Fixed6.wrap(int256(     slot2 << (256 - 48 - 32)) >> (256 - 32))\n            ),\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48)) >> (256 - 48)),\n                         uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48 - 24)) >> (256 - 24),\n            0 !=        (uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48 - 24 - 8)) >> (256 - 8))\n        );\n    }\n\n    function validate(RiskParameter memory self, ProtocolParameter memory protocolParameter) private pure {\n        if (\n            self.takerFee.linearFee.max(self.takerFee.proportionalFee).max(self.takerFee.adiabaticFee)\n                .max(self.makerFee.linearFee).max(self.makerFee.proportionalFee)\n                .gt(protocolParameter.maxFee)\n        ) revert RiskParameterStorageInvalidError();\n\n        if (self.liquidationFee.gt(protocolParameter.maxFeeAbsolute)) revert RiskParameterStorageInvalidError();\n\n        if (\n            self.utilizationCurve.minRate.max(self.utilizationCurve.maxRate).max(self.utilizationCurve.targetRate)\n                .max(self.pController.max.abs()).max(self.pController.min.abs())\n                .gt(protocolParameter.maxRate)\n        ) revert RiskParameterStorageInvalidError();\n\n        if (self.maintenance.lt(protocolParameter.minMaintenance)) revert RiskParameterStorageInvalidError();\n\n        if (self.margin.lt(self.maintenance)) revert RiskParameterStorageInvalidError();\n\n        if (self.efficiencyLimit.lt(protocolParameter.minEfficiency)) revert RiskParameterStorageInvalidError();\n\n        if (self.utilizationCurve.targetUtilization.gt(UFixed6Lib.ONE)) revert RiskParameterStorageInvalidError();\n\n        if (self.minMaintenance.lt(self.liquidationFee)) revert RiskParameterStorageInvalidError();\n\n        if (self.minMargin.lt(self.minMaintenance)) revert RiskParameterStorageInvalidError();\n\n        UFixed6 scaleLimit = self.makerLimit.div(self.efficiencyLimit).mul(protocolParameter.minScale);\n        if (self.takerFee.scale.lt(scaleLimit) || self.makerFee.scale.lt(scaleLimit))\n            revert RiskParameterStorageInvalidError();\n    }\n\n    function validateAndStore(\n        RiskParameterStorage storage self,\n        RiskParameter memory newValue,\n        ProtocolParameter memory protocolParameter\n    ) external {\n        validate(newValue, protocolParameter);\n\n        if (newValue.margin.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.minMargin.gt(UFixed6.wrap(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.efficiencyLimit.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.makerLimit.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.pController.k.gt(UFixed6.wrap(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.takerFee.scale.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.makerFee.scale.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.staleAfter > uint256(type(uint24).max)) revert RiskParameterStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(UFixed6.unwrap(newValue.margin)                    << (256 - 24)) >> (256 - 24) |\n            uint256(UFixed6.unwrap(newValue.maintenance)               << (256 - 24)) >> (256 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.takerFee.linearFee)        << (256 - 24)) >> (256 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.takerFee.proportionalFee)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.takerFee.adiabaticFee)     << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.makerFee.linearFee)        << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.makerFee.proportionalFee)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24) |\n            uint256(newValue.makerLimit.truncate()                     << (256 - 48)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48) |\n            uint256(UFixed6.unwrap(newValue.efficiencyLimit)           << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48 - 24);\n\n        uint256 encoded1 =\n            uint256(newValue.makerFee.scale.truncate()                          << (256 - 48)) >> (256 - 24 - 48) |\n            uint256(newValue.takerFee.scale.truncate()                          << (256 - 48)) >> (256 - 24 - 48 - 48) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.minRate)           << (256 - 24)) >> (256 - 24 - 48 - 48 - 24) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.maxRate)           << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetRate)        << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetUtilization) << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24) |\n            uint256(Fixed6.unwrap(newValue.pController.min)                     << (256 - 32)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24 - 32);\n\n        uint256 encoded2 =\n            uint256(UFixed6.unwrap(newValue.pController.k)                  << (256 - 48)) >> (256 - 48) |\n            uint256(Fixed6.unwrap(newValue.pController.max)                 << (256 - 32)) >> (256 - 48 - 32) |\n            uint256(UFixed6.unwrap(newValue.minMargin)                      << (256 - 48)) >> (256 - 48 - 32 - 48) |\n            uint256(UFixed6.unwrap(newValue.minMaintenance)                 << (256 - 48)) >> (256 - 48 - 32 - 48 - 48) |\n            uint256(UFixed6.unwrap(newValue.liquidationFee)                 << (256 - 48)) >> (256 - 48 - 32 - 48 - 48 - 48) |\n            uint256(newValue.staleAfter                                     << (256 - 24)) >> (256 - 48 - 32 - 48 - 48 - 48 - 24) |\n            uint256((newValue.makerReceiveOnly ? uint256(1) : uint256(0))   << (256 - 8))  >> (256 - 48 - 32 - 48 - 48 - 48 - 24 - 8);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n            sstore(add(self.slot, 2), encoded2)\n        }\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/Version.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"./ProtocolParameter.sol\";\nimport \"./MarketParameter.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./Global.sol\";\nimport \"./Position.sol\";\nimport \"./Order.sol\";\n\n/// @dev Version type\nstruct Version {\n    /// @dev whether this version had a valid oracle price\n    bool valid;\n\n    /// @dev The price of the version\n    Fixed6 price;\n\n    /// @dev The maker accumulator value\n    Accumulator6 makerValue;\n\n    /// @dev The long accumulator value\n    Accumulator6 longValue;\n\n    /// @dev The short accumulator value\n    Accumulator6 shortValue;\n\n    /// @dev The accumulated fee for maker orders\n    Accumulator6 makerFee;\n\n    /// @dev The accumulated fee for taker orders\n    Accumulator6 takerFee;\n\n    /// @dev The accumulated offset for maker orders\n    Accumulator6 makerOffset;\n\n    /// @dev The accumulated offset for positive taker orders (open long / close short)\n    Accumulator6 takerPosOffset;\n\n    /// @dev The accumulated offset for negative taker orders (close long / open short)\n    Accumulator6 takerNegOffset;\n\n    /// @dev The accumulated settlement fee for each individual order\n    Accumulator6 settlementFee;\n\n    /// @dev The accumulated liquidation fee for each individual order\n    Accumulator6 liquidationFee;\n}\nstruct VersionStorage { uint256 slot0; uint256 slot1; uint256 slot2; }\nusing VersionStorageLib for VersionStorage global;\n\n/// @dev Manually encodes and decodes the Version struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredVersion {\n///         /* slot 0 */\n///         bool valid;\n///         int64 makerValue;\n///         int64 longValue;\n///         int64 shortValue;\n///         uint48 liquidationFee;\n///\n///         /* slot 1 */\n///         int64 price;\n///         int48 makerOffset;\n///         int48 takerPosOffset;\n///         int48 takerNegOffset;\n///         uint48 settlementFee;\n///\n///         /* slot 2 */\n///         int48 makerFee;\n///         int48 takerFee;\n///     }\n///\nlibrary VersionStorageLib {\n    // sig: 0xd2777e72\n    error VersionStorageInvalidError();\n\n    function read(VersionStorage storage self) internal view returns (Version memory) {\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\n        return Version(\n            (uint256(slot0 << (256 - 8)) >> (256 - 8)) != 0,\n            Fixed6.wrap(int256(slot1 << (256 - 64)) >> (256 - 64)),\n\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64)) >> (256 - 64))),\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64)) >> (256 - 64))),\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64)) >> (256 - 64))),\n\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48 - 48)) >> (256 - 48))),\n\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48 - 48)) >> (256 - 48))),\n\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48 - 48 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64 - 48)) >> (256 - 48)))\n        );\n    }\n\n    function store(VersionStorage storage self, Version memory newValue) external {\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.makerValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.makerValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.longValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.longValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.shortValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.shortValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.makerFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.makerFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.takerFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.takerFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.makerOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.makerOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.takerPosOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.takerPosOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.takerNegOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.takerNegOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.settlementFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.settlementFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.liquidationFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.liquidationFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256((newValue.valid ? uint256(1) : uint256(0)) << (256 - 8)) >> (256 - 8) |\n            uint256(Fixed6.unwrap(newValue.makerValue._value) << (256 - 64)) >> (256 - 8 - 64) |\n            uint256(Fixed6.unwrap(newValue.longValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64) |\n            uint256(Fixed6.unwrap(newValue.shortValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64 - 64) |\n            uint256(Fixed6.unwrap(newValue.liquidationFee._value) << (256 - 48)) >> (256 - 8 - 64 - 64 - 64 - 48);\n        uint256 encoded1 =\n            uint256(Fixed6.unwrap(newValue.price) << (256 - 64)) >> (256 - 64) |\n            uint256(Fixed6.unwrap(newValue.makerOffset._value) << (256 - 48)) >> (256 - 64 - 48) |\n            uint256(Fixed6.unwrap(newValue.takerPosOffset._value) << (256 - 48)) >> (256 - 64 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.takerNegOffset._value) << (256 - 48)) >> (256 - 64 - 48 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.settlementFee._value) << (256 - 48)) >> (256 - 64 - 48 - 48 - 48 - 48);\n        uint256 encoded2 =\n            uint256(Fixed6.unwrap(newValue.makerFee._value) << (256 - 48)) >> (256 - 48) |\n            uint256(Fixed6.unwrap(newValue.takerFee._value) << (256 - 48)) >> (256 - 48 - 48);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n            sstore(add(self.slot, 2), encoded2)\n        }\n    }\n}\n"
    },
    "@equilibria/root/accumulator/types/Accumulator6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"../../number/types/UFixed6.sol\";\n\n/// @dev Accumulator6 type\nstruct Accumulator6 {\n    Fixed6 _value;\n}\n\nusing Accumulator6Lib for Accumulator6 global;\nstruct StoredAccumulator6 {\n    int256 _value;\n}\nstruct Accumulator6Storage { StoredAccumulator6 value; }\nusing Accumulator6StorageLib for Accumulator6Storage global;\n\n\n/**\n * @title Accumulator6Lib\n * @notice Library that surfaces math operations for the signed Accumulator type.\n * @dev This accumulator tracks cumulative changes to a value over time. Using the `accumulated` function, one\n * can determine how much a value has changed between two points in time. The `increment` and `decrement` functions\n * can be used to update the accumulator.\n */\nlibrary Accumulator6Lib {\n    /**\n     * Returns how much has been accumulated between two accumulators\n     * @param self The current point of the accumulation to compare with `from`\n     * @param from The starting point of the accumulation\n     * @param total Demoninator of the ratio (see `increment` and `decrement` functions)\n     */\n    function accumulated(Accumulator6 memory self, Accumulator6 memory from, UFixed6 total) internal pure returns (Fixed6) {\n        return _mul(self._value.sub(from._value), total);\n    }\n\n    /**\n     * @notice Increments an accumulator by a given ratio\n     * @dev Always rounds down in order to prevent overstating the accumulated value\n     * @param self The accumulator to increment\n     * @param amount Numerator of the ratio\n     * @param total Denominator of the ratio\n     */\n    function increment(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\n        if (amount.isZero()) return;\n        self._value = self._value.add(_div(amount, total));\n    }\n\n    /**\n     * @notice Decrements an accumulator by a given ratio\n     * @dev Always rounds down in order to prevent overstating the accumulated value\n     * @param self The accumulator to decrement\n     * @param amount Numerator of the ratio\n     * @param total Denominator of the ratio\n     */\n    function decrement(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\n        if (amount.isZero()) return;\n        self._value = self._value.add(_div(amount.mul(Fixed6Lib.NEG_ONE), total));\n    }\n\n    function _div(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\n        return amount.sign() == -1 ? amount.divOut(Fixed6Lib.from(total)) : amount.div(Fixed6Lib.from(total));\n    }\n\n    function _mul(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\n        return amount.sign() == -1 ? amount.mulOut(Fixed6Lib.from(total)) : amount.mul(Fixed6Lib.from(total));\n    }\n}\n\nlibrary Accumulator6StorageLib {\n    function read(Accumulator6Storage storage self) internal view returns (Accumulator6 memory) {\n        StoredAccumulator6 memory storedValue = self.value;\n        return Accumulator6(Fixed6.wrap(int256(storedValue._value)));\n    }\n\n    function store(Accumulator6Storage storage self, Accumulator6 memory newValue) internal {\n        self.value = StoredAccumulator6(Fixed6.unwrap(newValue._value));\n    }\n}\n"
    },
    "@equilibria/root/accumulator/types/UAccumulator6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/UFixed6.sol\";\n\n/// @dev UAccumulator6 type\nstruct UAccumulator6 {\n    UFixed6 _value;\n}\n\nusing UAccumulator6Lib for UAccumulator6 global;\nstruct StoredUAccumulator6 {\n    uint256 _value;\n}\nstruct UAccumulator6Storage { StoredUAccumulator6 value; }\nusing UAccumulator6StorageLib for UAccumulator6Storage global;\n\n\n/**\n * @title UAccumulator6Lib\n * @notice Library that surfaces math operations for the unsigned Accumulator type.\n * @dev This accumulator tracks cumulative changes to a monotonically increasing value over time. Using the `accumulated` function, one\n * can determine how much a value has changed between two points in time. The `increment` function can be used to update the accumulator.\n */\nlibrary UAccumulator6Lib {\n    /**\n     * Returns how much has been accumulated between two accumulators\n     * @param self The current point of the accumulation to compare with `from`\n     * @param from The starting point of the accumulation\n     * @param total Demoninator of the ratio (see `increment` function)\n     */\n    function accumulated(UAccumulator6 memory self, UAccumulator6 memory from, UFixed6 total) internal pure returns (UFixed6) {\n        return self._value.sub(from._value).mul(total);\n    }\n\n    /**\n     * @notice Increments an accumulator by a given ratio\n     * @dev Always rounds down in order to prevent overstating the accumulated value\n     * @param self The accumulator to increment\n     * @param amount Numerator of the ratio\n     * @param total Denominator of the ratio\n     */\n    function increment(UAccumulator6 memory self, UFixed6 amount, UFixed6 total) internal pure {\n        if (amount.isZero()) return;\n        self._value = self._value.add(amount.div(total));\n    }\n}\n\nlibrary UAccumulator6StorageLib {\n    function read(UAccumulator6Storage storage self) internal view returns (UAccumulator6 memory) {\n        StoredUAccumulator6 memory storedValue = self.value;\n        return UAccumulator6(UFixed6.wrap(uint256(storedValue._value)));\n    }\n\n    function store(UAccumulator6Storage storage self, UAccumulator6 memory newValue) internal {\n        self.value = StoredUAccumulator6(UFixed6.unwrap(newValue._value));\n    }\n}\n"
    },
    "@equilibria/root/adiabatic/AdiabaticMath6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../number/types/UFixed6.sol\";\nimport \"../number/types/Fixed6.sol\";\n\n/**\n * @title AdiabaticMath6\n * @notice Library for managing math operations for adiabatic fees.\n */\nlibrary AdiabaticMath6 {\n    error Adiabatic6ZeroScaleError();\n\n    /// @notice Computes the base fees for an order\n    /// @param fee The linear fee percentage\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The linear fee in underlying terms\n    function linearFee(UFixed6 fee, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return change.abs().mul(price).mul(fee);\n    }\n\n    /// @notice Computes the base fees for an order\n    /// @param scale The scale of the skew\n    /// @param fee The proportional fee percentage\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The proportional fee in underlying terms\n    function proportionalFee(UFixed6 scale, UFixed6 fee, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return change.abs().mul(price).muldiv(change.abs(), scale).mul(fee);\n    }\n\n    /// @notice Computes the adiabatic fee from a latest skew and change in skew over a linear function\n    /// @param scale The scale of the skew\n    /// @param adiabaticFee The adiabatic fee percentage\n    /// @param latest The latest skew in asset terms\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The adiabatic fee in underlying terms\n    function linearCompute(\n        UFixed6 scale,\n        UFixed6 adiabaticFee,\n        Fixed6 latest,\n        Fixed6 change,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        if (latest.isZero() && change.isZero()) return Fixed6Lib.ZERO;\n        if (scale.isZero()) revert Adiabatic6ZeroScaleError();\n\n        // normalize for skew scale\n        (Fixed6 latestScaled, Fixed6 changeScaled) =\n            (latest.div(Fixed6Lib.from(scale)), change.div(Fixed6Lib.from(scale)));\n\n        // adiabatic fee = notional * fee percentage * mean of skew range\n        return change.mul(Fixed6Lib.from(price)).mul(Fixed6Lib.from(adiabaticFee))\n            .mul(_linearMean(latestScaled, latestScaled.add(changeScaled)));\n    }\n\n    /// @notice Finds the mean value of the function f(x) = x over `from` to `to`\n    /// @param from The lower bound\n    /// @param to The upper bound\n    /// @return The mean value\n    function _linearMean(Fixed6 from, Fixed6 to) private pure returns (Fixed6) {\n        return from.add(to).div(Fixed6Lib.from(2));\n    }\n}\n"
    },
    "@equilibria/root/adiabatic/types/LinearAdiabatic6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"../../number/types/UFixed6.sol\";\nimport \"../AdiabaticMath6.sol\";\n\n/// @dev LinearAdiabatic6 type\nstruct LinearAdiabatic6 {\n    UFixed6 linearFee;\n    UFixed6 proportionalFee;\n    UFixed6 adiabaticFee;\n    UFixed6 scale;\n}\nusing LinearAdiabatic6Lib for LinearAdiabatic6 global;\n\n/**\n * @title LinearAdiabatic6Lib\n * @notice Library that that manages the linear adiabatic fee algorithm\n * @dev This algorithm specifies an adiatatic fee over the function:\n *\n *      f(skew) = adiabaticFee * skew\n *\n *      This is used to reward or penalize actions that move skew up or down this curve accordingly with net-zero\n *      value to the system with respect to the underlying asset.\n */\nlibrary LinearAdiabatic6Lib {\n    /// @notice Computes the adiabatic fee from a latest skew and change in skew\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The adiabatic fee in underlying terms\n    function compute(\n        LinearAdiabatic6 memory self,\n        Fixed6 latest,\n        Fixed6 change,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        return AdiabaticMath6.linearCompute(\n            self.scale,\n            self.adiabaticFee,\n            latest,\n            change,\n            price\n        );\n    }\n\n    /// @notice Computes the latest exposure along with all fees\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @return The latest total exposure in asset terms\n    function exposure(LinearAdiabatic6 memory self, Fixed6 latest) internal pure returns (Fixed6) {\n        return compute(self, Fixed6Lib.ZERO, latest, UFixed6Lib.ONE);\n    }\n\n    /// @dev Computes the change in exposure from a new configuration\n    /// @param self The latest fee configuration\n    /// @param newConfig The new fee configuration\n    /// @param latest The latest skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The update fee in underlying terms\n    function exposure(\n        LinearAdiabatic6 memory self,\n        LinearAdiabatic6 memory newConfig,\n        Fixed6 latest,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        return compute(newConfig, Fixed6Lib.ZERO, latest, price).sub(compute(self, Fixed6Lib.ZERO, latest, price));\n    }\n\n    /// @notice Computes the linear fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The linear fee in underlying terms\n    function linear(LinearAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.linearFee(self.linearFee, change, price);\n    }\n\n    /// @notice Computes the proportional fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The proportional fee in underlying terms\n    function proportional(LinearAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.proportionalFee(self.scale, self.proportionalFee, change, price);\n    }\n\n    /// @notice Computes the adiabatic fee\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The adiabatic fee in underlying terms\n    function adiabatic(\n        LinearAdiabatic6 memory self,\n        Fixed6 latest,\n        Fixed6 change,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        return compute(self, latest, change, price);\n    }\n}\n"
    },
    "@equilibria/root/adiabatic/types/NoopAdiabatic6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"../../number/types/UFixed6.sol\";\nimport \"../AdiabaticMath6.sol\";\n\n/// @dev NoopAdiabatic6 type\nstruct NoopAdiabatic6 {\n    UFixed6 linearFee;\n    UFixed6 proportionalFee;\n    UFixed6 scale;\n}\nusing NoopAdiabatic6Lib for NoopAdiabatic6 global;\n\n/**\n * @title NoopAdiabatic6Lib\n * @notice Library that that manages the no-op adiabatic fee algorithm\n * @dev This algorithm specifies a fee schedule without an adiabatic fee. This is used for fees that need unsigned\n *      fee impact without a signed shift fee based on skew.\n */\nlibrary NoopAdiabatic6Lib {\n    /// @notice Computes the linear fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The linear fee in underlying terms\n    function linear(NoopAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.linearFee(self.linearFee, change, price);\n    }\n\n    /// @notice Computes the proportional fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The proportional fee in underlying terms\n    function proportional(NoopAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.proportionalFee(self.scale, self.proportionalFee, change, price);\n    }\n}\n"
    },
    "@equilibria/root/attribute/Factory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"./interfaces/IInstance.sol\";\nimport \"./Pausable.sol\";\n\n/// @title Factory\n/// @notice An abstract factory that manages creates and manages instances\n/// @dev Ownable and Pausable, and satisfies the IBeacon interface by default.\nabstract contract Factory is IFactory, Ownable, Pausable {\n    /// @notice The instances mapping storage slot\n    bytes32 private constant INSTANCE_MAP_SLOT = keccak256(\"equilibria.root.Factory.instances\");\n\n    /// @notice The instance implementation address\n    address public immutable implementation;\n\n    /// @notice Constructs the contract\n    /// @param implementation_ The instance implementation address\n    constructor(address implementation_) { implementation = implementation_; }\n\n    /// @notice Initializes the contract state\n    function __Factory__initialize() internal onlyInitializer {\n        __Ownable__initialize();\n    }\n\n    /// @notice Returns whether the instance is valid\n    /// @param instance The instance to check\n    /// @return Whether the instance is valid\n    function instances(IInstance instance) public view returns (bool) {\n        return _instances()[instance];\n    }\n\n    /// @notice Creates a new instance\n    /// @dev Deploys a BeaconProxy with the this contract as the beacon\n    /// @param data The initialization data\n    /// @return newInstance The new instance\n    function _create(bytes memory data) internal returns (IInstance newInstance) {\n        newInstance = IInstance(address(new BeaconProxy(address(this), data)));\n        _register(newInstance);\n    }\n    /// @notice Creates a new instance at a deterministic address\n    /// @dev Deploys a BeaconProxy with the this contract as the beacon\n    /// @param data The initialization data\n    /// @param salt Used along with initialization data to determine a unique BeaconProxy address\n    /// @return newInstance The new instance\n    function _create2(bytes memory data, bytes32 salt) internal returns (IInstance newInstance) {\n        newInstance = IInstance(address(new BeaconProxy{salt: salt}(address(this), data)));\n        _register(newInstance);\n    }\n\n    // @notice Calculates the address at which the instance will be deployed\n    // @dev Passes the proxy's creation code along with this factory's address\n    // @param data The same initialization data used in the _create2 call\n    // @param salt Used along with initialization data to determine a unique BeaconProxy address\n    function _computeCreate2Address(bytes memory data, bytes32 salt) internal view returns (address) {\n        bytes memory bytecode = abi.encodePacked(\n            type(BeaconProxy).creationCode,\n            abi.encode(address(this), data)\n        );\n        return Create2.computeAddress(salt, keccak256(bytecode));\n    }\n\n    /// @notice Registers a new instance\n    /// @dev Called by _create automatically, or can be called manually in an extending implementation\n    /// @param newInstance The new instance\n    function _register(IInstance newInstance) internal {\n        _instances()[newInstance] = true;\n        emit InstanceRegistered(newInstance);\n    }\n\n    /// @notice Returns the storage mapping for instances\n    /// @return r The storage mapping for instances\n    function _instances() private pure returns (mapping(IInstance => bool) storage r) {\n        bytes32 slot = INSTANCE_MAP_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly { r.slot := slot }\n    }\n\n    /// @notice Only allow the function by a valid instance\n    modifier onlyInstance {\n        if (!instances(IInstance(msg.sender))) revert FactoryNotInstanceError();\n        _;\n    }\n}\n"
    },
    "@equilibria/root/attribute/Initializable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/IInitializable.sol\";\nimport \"../storage/Storage.sol\";\n\n/**\n * @title Initializable\n * @notice Library to manage the initialization lifecycle of upgradeable contracts\n * @dev `Initializable.sol` allows the creation of pseudo-constructors for upgradeable contracts. One\n *      `initializer` should be declared per top-level contract. Child contracts can use the `onlyInitializer`\n *      modifier to tag their internal initialization functions to ensure that they can only be called\n *      from a top-level `initializer` or a constructor.\n */\nabstract contract Initializable is IInitializable {\n    /// @dev The initialized flag\n    Uint256Storage private constant _version = Uint256Storage.wrap(keccak256(\"equilibria.root.Initializable.version\"));\n\n    /// @dev The initializing flag\n    BoolStorage private constant _initializing = BoolStorage.wrap(keccak256(\"equilibria.root.Initializable.initializing\"));\n\n    /// @dev Can only be called once per version, `version` is 1-indexed\n    modifier initializer(uint256 version) {\n        if (version == 0) revert InitializableZeroVersionError();\n        if (_version.read() >= version) revert InitializableAlreadyInitializedError(version);\n\n        _version.store(version);\n        _initializing.store(true);\n\n        _;\n\n        _initializing.store(false);\n        emit Initialized(version);\n    }\n\n    /// @dev Can only be called from an initializer or constructor\n    modifier onlyInitializer() {\n        if (!_constructing() && !_initializing.read()) revert InitializableNotInitializingError();\n        _;\n    }\n\n    /**\n     * @notice Returns whether the contract is currently being constructed\n     * @dev {Address.isContract} returns false for contracts currently in the process of being constructed\n     * @return Whether the contract is currently being constructed\n     */\n    function _constructing() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "@equilibria/root/attribute/Instance.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../storage/Storage.sol\";\nimport \"./interfaces/IInstance.sol\";\nimport \"./Initializable.sol\";\n\n/// @title Instance\n/// @notice An abstract contract that is created and managed by a factory\nabstract contract Instance is IInstance, Initializable {\n    /// @dev The factory address storage slot\n    AddressStorage private constant _factory = AddressStorage.wrap(keccak256(\"equilibria.root.Instance.factory\"));\n\n    /// @notice Returns the factory that created this instance\n    /// @return The factory that created this instance\n    function factory() public view returns (IFactory) { return IFactory(_factory.read()); }\n\n    /// @notice Initializes the contract setting `msg.sender` as the factory\n    function __Instance__initialize() internal onlyInitializer {\n        _factory.store(msg.sender);\n    }\n\n    /// @notice Only allow the owner defined by the factory to call the function\n    modifier onlyOwner {\n        if (msg.sender != factory().owner()) revert InstanceNotOwnerError(msg.sender);\n        _;\n    }\n\n    /// @notice Only allow the factory to call the function\n    modifier onlyFactory {\n        if (msg.sender != address(factory())) revert InstanceNotFactoryError(msg.sender);\n        _;\n    }\n\n    /// @notice Only allow the function to be called when the factory is not paused\n    modifier whenNotPaused {\n        if (factory().paused()) revert InstancePausedError();\n        _;\n    }\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"./IPausable.sol\";\nimport \"./IInstance.sol\";\n\ninterface IFactory is IBeacon, IOwnable, IPausable {\n    event InstanceRegistered(IInstance indexed instance);\n\n    error FactoryNotInstanceError();\n\n    function instances(IInstance instance) external view returns (bool);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IInitializable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\ninterface IInitializable {\n    error InitializableZeroVersionError();\n    error InitializableAlreadyInitializedError(uint256 version);\n    error InitializableNotInitializingError();\n\n    event Initialized(uint256 version);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IInstance.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IFactory.sol\";\nimport \"./IInitializable.sol\";\n\ninterface IInstance is IInitializable {\n    error InstanceNotOwnerError(address sender);\n    error InstanceNotFactoryError(address sender);\n    error InstancePausedError();\n\n    function factory() external view returns (IFactory);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IKept.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../interfaces/IInitializable.sol\";\nimport \"../../number/types/UFixed18.sol\";\nimport \"../../token/types/Token18.sol\";\n\ninterface IKept is IInitializable {\n    struct KeepConfig {\n        UFixed18 multiplierBase;\n        uint256 bufferBase;\n        UFixed18 multiplierCalldata;\n        uint256 bufferCalldata;\n    }\n\n    event KeeperCall(address indexed sender, uint256 applicableGas, uint256 applicableValue, UFixed18 baseFee, UFixed18 calldataFee, UFixed18 keeperFee);\n\n    function ethTokenOracleFeed() external view returns (AggregatorV3Interface);\n    function keeperToken() external view returns (Token18);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IInitializable.sol\";\n\ninterface IOwnable is IInitializable {\n    event OwnerUpdated(address indexed newOwner);\n    event PendingOwnerUpdated(address indexed newPendingOwner);\n\n    error OwnableNotOwnerError(address sender);\n    error OwnableNotPendingOwnerError(address sender);\n    error OwnableAlreadyInitializedError();\n\n    function owner() external view returns (address);\n    function pendingOwner() external view returns (address);\n    function updatePendingOwner(address newPendingOwner) external;\n    function acceptOwner() external;\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IInitializable.sol\";\nimport \"./IOwnable.sol\";\n\ninterface IPausable is IInitializable, IOwnable {\n    event PauserUpdated(address indexed newPauser);\n    event Paused();\n    event Unpaused();\n\n    error PausablePausedError();\n    error PausableNotPauserError(address sender);\n\n    function pauser() external view returns (address);\n    function paused() external view returns (bool);\n    function updatePauser(address newPauser) external;\n    function pause() external;\n    function unpause() external;\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IInitializable.sol\";\n\ninterface IReentrancyGuard is IInitializable {\n    error ReentrancyGuardReentrantCallError();\n}\n"
    },
    "@equilibria/root/attribute/Kept/Kept_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Kept.sol\";\nimport { ArbGasInfo } from \"../../gas/GasOracle_Arbitrum.sol\";\n\n/// @dev Arbitrum Kept implementation\nabstract contract Kept_Arbitrum is Kept {\n    ArbGasInfo constant ARB_GAS = ArbGasInfo(0x000000000000000000000000000000000000006C);\n    uint256 public constant ARB_GAS_MULTIPLIER = 16;\n    uint256 public constant ARB_FIXED_OVERHEAD = 140;\n\n    // https://docs.arbitrum.io/devs-how-tos/how-to-estimate-gas#breaking-down-the-formula\n    // Tx Fee = block.baseFee * l2GasUsed + ArbGasInfo.getL1BaseFeeEstimate() * 16 * (calldataLength + fixedOverhead)\n    // Dynamic buffer = (ArbGasInfo.getL1BaseFeeEstimate() * 16 * (calldataLength + fixedOverhead))\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view virtual override returns (UFixed18) {\n        return _fee(\n            ARB_GAS_MULTIPLIER * (applicableCalldata.length + ARB_FIXED_OVERHEAD),\n            multiplierCalldata,\n            bufferCalldata,\n            ARB_GAS.getL1BaseFeeEstimate()\n        );\n    }\n}\n"
    },
    "@equilibria/root/attribute/Kept/Kept_Optimism.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Kept.sol\";\nimport { OptGasInfo } from \"../../gas/GasOracle_Optimism.sol\";\n\n/// @dev Optimism Kept implementation\nabstract contract Kept_Optimism is Kept {\n    // https://community.optimism.io/docs/developers/build/transaction-fees/#the-l1-data-fee\n    OptGasInfo constant OPT_GAS = OptGasInfo(0x420000000000000000000000000000000000000F);\n    uint256 public constant OPT_BASE_FEE_MULTIPLIER = 16;\n\n    // https://docs.optimism.io/stack/transactions/fees#ecotone\n    // Adds a buffer to the L1 gas used to account for the overhead of the transaction\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view virtual override returns (UFixed18) {\n        return _fee(\n            OPT_GAS.getL1GasUsed(applicableCalldata),\n            multiplierCalldata,\n            bufferCalldata,\n            // https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/GasPriceOracle.sol#L138\n            (\n                OPT_BASE_FEE_MULTIPLIER * OPT_GAS.baseFeeScalar() * OPT_GAS.l1BaseFee() +\n                OPT_GAS.blobBaseFeeScalar() * OPT_GAS.blobBaseFee()\n            ) / (OPT_BASE_FEE_MULTIPLIER * 10 ** OPT_GAS.decimals())\n        );\n    }\n}\n"
    },
    "@equilibria/root/attribute/Kept/Kept.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../Initializable.sol\";\nimport \"../interfaces/IKept.sol\";\nimport \"../../storage/Storage.sol\";\n\n/// @title Kept\n/// @notice Library to manage keeper incentivization.\n/// @dev Surfaces a keep() modifier that handles measuring job gas costs and paying out rewards the keeper.\nabstract contract Kept is IKept, Initializable {\n    /// @dev The legacy Chainlink feed that is used to convert price ETH relative to the keeper token\n    AddressStorage private constant _ethTokenOracleFeed = AddressStorage.wrap(keccak256(\"equilibria.root.Kept.ethTokenOracleFeed\"));\n    function ethTokenOracleFeed() public view returns (AggregatorV3Interface) { return AggregatorV3Interface(_ethTokenOracleFeed.read()); }\n\n    /// @dev The token that the keeper is paid in\n    Token18Storage private constant _keeperToken = Token18Storage.wrap(keccak256(\"equilibria.root.Kept.keeperToken\"));\n    function keeperToken() public view returns (Token18) { return _keeperToken.read(); }\n\n    /// @notice Initializes the contract\n    /// @param ethTokenOracleFeed_ The legacy Chainlink feed that is used to convert price ETH relative to the keeper token\n    /// @param keeperToken_ The token that the keeper is paid in\n    function __Kept__initialize(\n        AggregatorV3Interface ethTokenOracleFeed_,\n        Token18 keeperToken_\n    ) internal onlyInitializer {\n        _ethTokenOracleFeed.store(address(ethTokenOracleFeed_));\n        _keeperToken.store(keeperToken_);\n    }\n\n    /// @notice Called by the keep modifier to raise the optionally raise the keeper fee\n    /// @param amount The amount of keeper fee to raise\n    /// @param data Arbitrary data passed in from the keep modifier\n    /// @return The amount of keeper fee that was actually raised\n    function _raiseKeeperFee(UFixed18 amount, bytes memory data) internal virtual returns (UFixed18) { return amount; }\n\n    /// @notice Computes the calldata portion of the keeper fee\n    /// @dev Used for L2 implementation with significant calldata costs\n    /// @param applicableCalldata The applicable calldata\n    /// @param multiplierCalldata The multiplier to apply to the calldata cost\n    /// @param bufferCalldata The buffer to apply to the calldata cost\n    /// @return The calldata portion of the keeper fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view virtual returns (UFixed18) { return UFixed18Lib.ZERO; }\n\n    /// @notice Computes the base gas portion of the keeper fee\n    /// @param applicableGas The applicable gas cost\n    /// @param multiplierBase The multiplier to apply to the gas cost\n    /// @param bufferBase The buffer to apply to the gas cost\n    /// @return The gas cost portion of the keeper fee\n    function _baseFee(\n        uint256 applicableGas,\n        UFixed18 multiplierBase,\n        uint256 bufferBase\n    ) internal view returns (UFixed18) {\n        return _fee(applicableGas, multiplierBase, bufferBase, block.basefee);\n    }\n\n    /// @notice Computes a generic keeper fee based on parameters\n    /// @dev Helper function to consolidate keeper fee computation logic\n    /// @param gas The gas cost\n    /// @param multiplier The multiplier to apply to the gas cost\n    /// @param buffer The buffer to apply to the gas cost\n    /// @return The resulting keeper fee\n    function _fee(uint256 gas, UFixed18 multiplier, uint256 buffer, uint256 baseFee) internal pure returns (UFixed18) {\n        return UFixed18Lib.from(gas).mul(multiplier).add(UFixed18Lib.from(buffer)).mul(UFixed18.wrap(baseFee));\n    }\n\n    /// @notice Placed on a function to incentivize keepers to call it\n    /// @param config The multiplier and buffer configuration to apply\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\n    /// @param applicableCalldata The applicable calldata\n    /// @param applicableValue The applicable value\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\n    modifier keep(\n        KeepConfig memory config,\n        bytes memory applicableCalldata,\n        uint256 applicableValue,\n        bytes memory data\n    ) {\n        uint256 startGas = gasleft();\n\n        _;\n\n        uint256 applicableGas = startGas - gasleft();\n\n        _handleKeeperFee(config, applicableGas, applicableCalldata, applicableValue, data);\n    }\n\n    /// @notice Called by the keep modifier to handle keeper fee computation and payment\n    /// @param config The multiplier and buffer configuration to apply\n    /// @param applicableGas The applicable gas cost\n    /// @param applicableCalldata The applicable calldata\n    /// @param applicableValue The applicable value\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\n    function _handleKeeperFee(\n        KeepConfig memory config,\n        uint256 applicableGas,\n        bytes memory applicableCalldata,\n        uint256 applicableValue,\n        bytes memory data\n    ) internal {\n        (UFixed18 baseFee, UFixed18 calldataFee) = (\n            _baseFee(applicableGas, config.multiplierBase, config.bufferBase),\n            _calldataFee(applicableCalldata, config.multiplierCalldata, config.bufferCalldata)\n        );\n\n        UFixed18 keeperFee = UFixed18.wrap(applicableValue).add(baseFee).add(calldataFee).mul(_etherPrice());\n        keeperFee = _raiseKeeperFee(keeperFee, data);\n        keeperToken().push(msg.sender, keeperFee);\n\n        emit KeeperCall(msg.sender, applicableGas, applicableValue, baseFee, calldataFee, keeperFee);\n    }\n\n    /// @notice Returns the price of ETH in terms of the keeper token\n    /// @return The price of ETH in terms of the keeper token\n    function _etherPrice() private view returns (UFixed18) {\n        (, int256 answer, , ,) = ethTokenOracleFeed().latestRoundData();\n        return UFixed18Lib.from(Fixed18Lib.ratio(answer, 1e8)); // chainlink eth-usd feed uses 8 decimals\n    }\n}\n"
    },
    "@equilibria/root/attribute/Ownable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Initializable.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"../storage/Storage.sol\";\n\n/**\n * @title Ownable\n * @notice Library to manage the ownership lifecycle of upgradeable contracts.\n * @dev This contract has been extended from the Open Zeppelin library to include an\n *      unstructured storage pattern so that it can be safely mixed in with upgradeable\n *      contracts without affecting their storage patterns through inheritance.\n */\nabstract contract Ownable is IOwnable, Initializable {\n    /// @dev The owner address\n    AddressStorage private constant _owner = AddressStorage.wrap(keccak256(\"equilibria.root.Ownable.owner\"));\n    function owner() public view returns (address) { return _owner.read(); }\n\n    /// @dev The pending owner address\n    AddressStorage private constant _pendingOwner = AddressStorage.wrap(keccak256(\"equilibria.root.Ownable.pendingOwner\"));\n    function pendingOwner() public view returns (address) { return _pendingOwner.read(); }\n\n    /**\n     * @notice Initializes the contract setting `msg.sender` as the initial owner\n     */\n    function __Ownable__initialize() internal onlyInitializer {\n        if (owner() != address(0)) revert OwnableAlreadyInitializedError();\n        _updateOwner(_sender());\n    }\n\n    /**\n     * @notice Updates the new pending owner\n     * @dev Can only be called by the current owner\n     *      New owner does not take affect until that address calls `acceptOwner()`\n     * @param newPendingOwner New pending owner address\n     */\n    function updatePendingOwner(address newPendingOwner) public onlyOwner {\n        _pendingOwner.store(newPendingOwner);\n        emit PendingOwnerUpdated(newPendingOwner);\n    }\n\n    /**\n     * @notice Accepts and transfers the ownership of the contract to the pending owner\n     * @dev Can only be called by the pending owner to ensure correctness. Calls to the `_beforeAcceptOwner` hook\n     *      to perform logic before updating ownership.\n     */\n    function acceptOwner() public {\n        _beforeAcceptOwner();\n\n        if (_sender() != pendingOwner()) revert OwnableNotPendingOwnerError(_sender());\n\n        _updateOwner(pendingOwner());\n        updatePendingOwner(address(0));\n    }\n\n\n    /// @dev Hook for inheriting contracts to perform logic before accepting ownership\n    function _beforeAcceptOwner() internal virtual {}\n\n    /**\n     * @notice Updates the owner address\n     * @param newOwner New owner address\n     */\n    function _updateOwner(address newOwner) private {\n        _owner.store(newOwner);\n        emit OwnerUpdated(newOwner);\n    }\n\n    function _sender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    /// @dev Throws if called by any account other than the owner\n    modifier onlyOwner {\n        if (owner() != _sender()) revert OwnableNotOwnerError(_sender());\n        _;\n    }\n}\n"
    },
    "@equilibria/root/attribute/Pausable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Initializable.sol\";\nimport \"./Ownable.sol\";\nimport \"./interfaces/IPausable.sol\";\nimport \"../storage/Storage.sol\";\n\n/**\n * @title Pausable\n * @notice Library to allow for the emergency pausing and unpausing of contract functions\n *         by an authorized account.\n * @dev This contract has been extended from the Open Zeppelin library to include an\n *      unstructured storage pattern so that it can be safely mixed in with upgradeable\n *      contracts without affecting their storage patterns through inheritance.\n */\nabstract contract Pausable is IPausable, Ownable {\n    /// @dev The pauser address\n    AddressStorage private constant _pauser = AddressStorage.wrap(keccak256(\"equilibria.root.Pausable.pauser\"));\n    function pauser() public view returns (address) { return _pauser.read(); }\n\n    /// @dev Whether the contract is paused\n    BoolStorage private constant _paused = BoolStorage.wrap(keccak256(\"equilibria.root.Pausable.paused\"));\n    function paused() public view returns (bool) { return _paused.read(); }\n\n    /**\n     * @notice Initializes the contract setting `msg.sender` as the initial pauser\n     */\n    function __Pausable__initialize() internal onlyInitializer {\n        __Ownable__initialize();\n        updatePauser(_sender());\n    }\n\n    /**\n     * @notice Updates the new pauser\n     * @dev Can only be called by the current owner\n     * @param newPauser New pauser address\n     */\n    function updatePauser(address newPauser) public onlyOwner {\n        _pauser.store(newPauser);\n        emit PauserUpdated(newPauser);\n    }\n\n    /**\n     * @notice Pauses the contract\n     * @dev Can only be called by the pauser\n     */\n    function pause() external onlyPauser {\n        _paused.store(true);\n        emit Paused();\n    }\n\n    /**\n     * @notice Unpauses the contract\n     * @dev Can only be called by the pauser\n     */\n    function unpause() external onlyPauser {\n        _paused.store(false);\n        emit Unpaused();\n    }\n\n    /// @dev Throws if called by any account other than the pauser\n    modifier onlyPauser {\n        if (_sender() != pauser() && _sender() != owner()) revert PausableNotPauserError(_sender());\n        _;\n    }\n\n    /// @dev Throws if called when the contract is paused\n    modifier whenNotPaused {\n        if (paused()) revert PausablePausedError();\n        _;\n    }\n}\n"
    },
    "@equilibria/root/attribute/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Initializable.sol\";\nimport \"./interfaces/IReentrancyGuard.sol\";\nimport \"../storage/Storage.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * NOTE: This contract has been extended from the Open Zeppelin library to include an\n *       unstructured storage pattern, so that it can be safely mixed in with upgradeable\n *       contracts without affecting their storage patterns through inheritance.\n */\nabstract contract ReentrancyGuard is IReentrancyGuard, Initializable {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    /**\n     * @dev unstructured storage slot for the reentrancy status\n     */\n    Uint256Storage private constant _status = Uint256Storage.wrap(keccak256(\"equilibria.root.ReentrancyGuard.status\"));\n\n    /**\n     * @dev Initializes the contract setting the status to _NOT_ENTERED.\n     */\n    function __ReentrancyGuard__initialize() internal onlyInitializer {\n        _status.store(_NOT_ENTERED);\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        if (_status.read() == _ENTERED) revert ReentrancyGuardReentrantCallError();\n\n        // Any calls to nonReentrant after this point will fail\n        _status.store(_ENTERED);\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status.store(_NOT_ENTERED);\n    }\n}\n"
    },
    "@equilibria/root/gas/GasOracle_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { UFixed18, UFixed18Lib } from \"../number/types/UFixed18.sol\";\nimport { Fixed18Lib } from \"../number/types/Fixed18.sol\";\nimport { GasOracle } from \"./GasOracle.sol\";\n\n// https://github.com/OffchainLabs/nitro/blob/v2.0.14/contracts/src/precompiles/ArbGasInfo.sol#L93\ninterface ArbGasInfo {\n    /// @notice Get ArbOS's estimate of the L1 basefee in wei\n    function getL1BaseFeeEstimate() external view returns (uint256);\n}\n\ncontract GasOracle_Arbitrum is GasOracle {\n    ArbGasInfo constant ARB_GAS = ArbGasInfo(0x000000000000000000000000000000000000006C);\n\n    constructor(\n        AggregatorV3Interface feed,\n        uint256 decimals,\n        uint256 computeGas,\n        UFixed18 computeMultiplier,\n        uint256 computeBase,\n        uint256 calldataGas,\n        UFixed18 calldataMultiplier,\n        uint256 calldataBase\n    ) GasOracle(feed, decimals, computeGas, computeMultiplier, computeBase, calldataGas, calldataMultiplier, calldataBase) { }\n\n    function _calldataBaseFee() internal override view returns (uint256) { return ARB_GAS.getL1BaseFeeEstimate(); }\n}\n"
    },
    "@equilibria/root/gas/GasOracle_Optimism.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { UFixed18, UFixed18Lib } from \"../number/types/UFixed18.sol\";\nimport { Fixed18Lib } from \"../number/types/Fixed18.sol\";\nimport { GasOracle } from \"./GasOracle.sol\";\n\ninterface OptGasInfo {\n    function getL1GasUsed(bytes memory) external view returns (uint256);\n    function l1BaseFee() external view returns (uint256);\n    function baseFeeScalar() external view returns (uint256);\n    function blobBaseFee() external view returns (uint256);\n    function blobBaseFeeScalar() external view returns (uint256);\n    function decimals() external view returns (uint256);\n}\n\ncontract GasOracle_Optimism is GasOracle {\n    OptGasInfo constant OPT_GAS = OptGasInfo(0x420000000000000000000000000000000000000F);\n    uint256 public constant OPT_BASE_FEE_MULTIPLIER = 16;\n\n    constructor(\n        AggregatorV3Interface feed,\n        uint256 decimals,\n        uint256 computeGas,\n        UFixed18 computeMultiplier,\n        uint256 computeBase,\n        uint256 calldataGas,\n        UFixed18 calldataMultiplier,\n        uint256 calldataBase\n    ) GasOracle(feed, decimals, computeGas, computeMultiplier, computeBase, calldataGas, calldataMultiplier, calldataBase) { }\n\n    // https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/GasPriceOracle.sol#L138\n    // applicable to only the ecotone hardfork\n    function _calldataBaseFee() internal override view returns (uint256) {\n        return (\n            OPT_BASE_FEE_MULTIPLIER * OPT_GAS.baseFeeScalar() * OPT_GAS.l1BaseFee() +\n            OPT_GAS.blobBaseFeeScalar() * OPT_GAS.blobBaseFee()\n        ) / (OPT_BASE_FEE_MULTIPLIER * 10 ** OPT_GAS.decimals());\n    }\n}\n"
    },
    "@equilibria/root/gas/GasOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { UFixed18, UFixed18Lib } from \"../number/types/UFixed18.sol\";\nimport { Fixed18Lib } from \"../number/types/Fixed18.sol\";\nimport { IGasOracle } from \"./interfaces/IGasOracle.sol\";\n\n/// @title GasOracle\n/// @notice Standalone gas oracle for externally computing keeper rewards based on ether gas costs\ncontract GasOracle is IGasOracle {\n    /// @notice The total compute gas rewarded\n    UFixed18 public immutable COMPUTE_GAS;\n\n    /// @notice The total calldata gas rewarded\n    UFixed18 public immutable CALLDATA_GAS;\n\n    /// @notice Chainlink ETH-Token feed, where cost is expressed in terms of Token\n    AggregatorV3Interface public immutable FEED;\n\n    /// @notice The precomputed offset of the Chainlink feed (10 ^ decimals)\n    int256 public immutable FEED_OFFSET;\n\n    constructor(\n        AggregatorV3Interface feed,\n        uint256 decimals,\n        uint256 computeGas,\n        UFixed18 computeMultiplier,\n        uint256 computeBase,\n        uint256 calldataGas,\n        UFixed18 calldataMultiplier,\n        uint256 calldataBase\n    ) {\n        FEED = feed;\n        FEED_OFFSET = int256(10 ** decimals);\n        COMPUTE_GAS = _precompute(computeGas, computeMultiplier, computeBase);\n        CALLDATA_GAS = _precompute(calldataGas, calldataMultiplier, calldataBase);\n    }\n\n   /// @inheritdoc IGasOracle\n    function cost(uint256 value) external view returns (UFixed18) {\n        (UFixed18 baseFee, UFixed18 calldataFee) =\n            (UFixed18.wrap(block.basefee).mul(COMPUTE_GAS), UFixed18.wrap(_calldataBaseFee()).mul(CALLDATA_GAS));\n\n        return UFixed18.wrap(value).add(baseFee).add(calldataFee).mul(_etherPrice());\n    }\n\n    /// @notice Precomputes the total rewarded gas cost\n    /// @param gas The applicable gas cost\n    /// @param multiplier The reward multiplier to apply to the gas cost\n    /// @param base The base gas reward to add on to the gas cost\n    /// @return The total rewarded gas cost\n    function _precompute(uint256 gas, UFixed18 multiplier, uint256 base) private pure returns (UFixed18) {\n        return UFixed18Lib.from(gas).mul(multiplier).add(UFixed18Lib.from(base));\n    }\n\n    /// @notice Returns the price of ether in terms of the underlying token\n    /// @return The price of ether in terms of the underlyingtoken\n    function _etherPrice() private view returns (UFixed18) {\n        (, int256 answer, , ,) = FEED.latestRoundData();\n        return UFixed18Lib.from(Fixed18Lib.ratio(answer, FEED_OFFSET));\n    }\n\n    /// @notice Returns the base fee of the calldata\n    /// @dev Can be overridden to provide a non-zero calldata base fee for L2 implementations\n    /// @return The base fee of the calldata\n    function _calldataBaseFee() internal virtual view returns (uint256) { return 0; }\n}\n"
    },
    "@equilibria/root/gas/interfaces/IGasOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { UFixed18 } from \"../../number/types/UFixed18.sol\";\n\ninterface IGasOracle {\n    function COMPUTE_GAS() external view returns (UFixed18);\n    function CALLDATA_GAS() external view returns (UFixed18);\n    function FEED() external view returns (AggregatorV3Interface);\n    function FEED_OFFSET() external view returns (int256);\n\n    /// @notice Computes the reward of a transaction\n    /// @param value The ether value of the transaction in addition to the gas cost rewarded\n    /// @return The reward of the transaction\n    function cost(uint256 value) external view returns (UFixed18);\n}\n"
    },
    "@equilibria/root/number/NumberMath.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\n/**\n * @title NumberMath\n * @notice Library for additional math functions that are not included in the OpenZeppelin libraries.\n */\nlibrary NumberMath {\n    error DivisionByZero();\n\n    /**\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Dividend\n     * @param b Divisor\n     * @return Resulting quotient\n     */\n    function divOut(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) revert DivisionByZero();\n        return Math.ceilDiv(a, b);\n    }\n\n    /**\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Dividend\n     * @param b Divisor\n     * @return Resulting quotient\n     */\n    function divOut(int256 a, int256 b) internal pure returns (int256) {\n        return sign(a) * sign(b) * int256(divOut(SignedMath.abs(a), SignedMath.abs(b)));\n    }\n\n    /**\n     * @notice Returns the sign of an int256\n     * @dev Returns: -1 for negative\n     *                0 for zero\n     *                1 for positive\n     * @param a int256 to find the sign of\n     * @return Sign of the int256\n     */\n    function sign(int256 a) internal pure returns (int256) {\n        if (a > 0) return 1;\n        if (a < 0) return -1;\n        return 0;\n    }\n}\n"
    },
    "@equilibria/root/number/types/Fixed18.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed6.sol\";\nimport \"./UFixed18.sol\";\n\n/// @dev Fixed18 type\ntype Fixed18 is int256;\nusing Fixed18Lib for Fixed18 global;\ntype Fixed18Storage is bytes32;\nusing Fixed18StorageLib for Fixed18Storage global;\n\n/**\n * @title Fixed18Lib\n * @notice Library for the signed fixed-decimal type.\n */\nlibrary Fixed18Lib {\n    error Fixed18OverflowError(uint256 value);\n\n    int256 private constant BASE = 1e18;\n    Fixed18 public constant ZERO = Fixed18.wrap(0);\n    Fixed18 public constant ONE = Fixed18.wrap(BASE);\n    Fixed18 public constant NEG_ONE = Fixed18.wrap(-1 * BASE);\n    Fixed18 public constant MAX = Fixed18.wrap(type(int256).max);\n    Fixed18 public constant MIN = Fixed18.wrap(type(int256).min);\n\n    /**\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\n     * @param a Unsigned fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(UFixed18 a) internal pure returns (Fixed18) {\n        uint256 value = UFixed18.unwrap(a);\n        if (value > uint256(type(int256).max)) revert Fixed18OverflowError(value);\n        return Fixed18.wrap(int256(value));\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\n     * @param s Sign\n     * @param m Unsigned fixed-decimal magnitude\n     * @return New signed fixed-decimal\n     */\n    function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {\n        if (s > 0) return from(m);\n        if (s < 0) {\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\n            // which is the only value that would overflow when negated. Therefore,\n            // we can safely negate from(m) without checking for overflow.\n            unchecked { return Fixed18.wrap(-1 * Fixed18.unwrap(from(m))); }\n        }\n        return ZERO;\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a signed integer\n     * @param a Signed number\n     * @return New signed fixed-decimal\n     */\n    function from(int256 a) internal pure returns (Fixed18) {\n        return Fixed18.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\n     * @param a Base-6 signed fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(Fixed6 a) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed6.unwrap(a) * 1e12);\n    }\n\n    /**\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\n     * @param a Signed fixed-decimal\n     * @return Whether the signed fixed-decimal is zero.\n     */\n    function isZero(Fixed18 a) internal pure returns (bool) {\n        return Fixed18.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting summed signed fixed-decimal\n     */\n    function add(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) + Fixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts signed fixed-decimal `b` from `a`\n     * @param a Signed fixed-decimal to subtract from\n     * @param b Signed fixed-decimal to subtract\n     * @return Resulting subtracted signed fixed-decimal\n     */\n    function sub(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) - Fixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mul(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mulOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function div(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) * BASE / Fixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function divOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\n        return muldiv(a, Fixed18.wrap(b), Fixed18.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\n        return muldivOut(a, Fixed18.wrap(b), Fixed18.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / Fixed18.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), Fixed18.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the signed fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(Fixed18 a, Fixed18 b) internal pure returns (uint256) {\n        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\n     * @param a First signed number\n     * @param b Second signed number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(int256 a, int256 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(SignedMath.min(Fixed18.unwrap(a), Fixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(SignedMath.max(Fixed18.unwrap(a), Fixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\n     * @param a Signed fixed-decimal\n     * @return Truncated signed number\n     */\n    function truncate(Fixed18 a) internal pure returns (int256) {\n        return Fixed18.unwrap(a) / BASE;\n    }\n\n    /**\n     * @notice Returns the sign of the signed fixed-decimal\n     * @dev Returns: -1 for negative\n     *                0 for zero\n     *                1 for positive\n     * @param a Signed fixed-decimal\n     * @return Sign of the signed fixed-decimal\n     */\n    function sign(Fixed18 a) internal pure returns (int256) {\n        if (Fixed18.unwrap(a) > 0) return 1;\n        if (Fixed18.unwrap(a) < 0) return -1;\n        return 0;\n    }\n\n    /**\n     * @notice Returns the absolute value of the signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return Absolute value of the signed fixed-decimal\n     */\n    function abs(Fixed18 a) internal pure returns (UFixed18) {\n        return UFixed18.wrap(SignedMath.abs(Fixed18.unwrap(a)));\n    }\n}\n\nlibrary Fixed18StorageLib {\n    function read(Fixed18Storage self) internal view returns (Fixed18 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Fixed18Storage self, Fixed18 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/number/types/Fixed6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed18.sol\";\nimport \"./UFixed6.sol\";\n\n/// @dev Fixed6 type\ntype Fixed6 is int256;\nusing Fixed6Lib for Fixed6 global;\ntype Fixed6Storage is bytes32;\nusing Fixed6StorageLib for Fixed6Storage global;\n\n/**\n * @title Fixed6Lib\n * @notice Library for the signed fixed-decimal type.\n */\nlibrary Fixed6Lib {\n    error Fixed6OverflowError(uint256 value);\n\n    int256 private constant BASE = 1e6;\n    Fixed6 public constant ZERO = Fixed6.wrap(0);\n    Fixed6 public constant ONE = Fixed6.wrap(BASE);\n    Fixed6 public constant NEG_ONE = Fixed6.wrap(-1 * BASE);\n    Fixed6 public constant MAX = Fixed6.wrap(type(int256).max);\n    Fixed6 public constant MIN = Fixed6.wrap(type(int256).min);\n\n    /**\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\n     * @param a Unsigned fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(UFixed6 a) internal pure returns (Fixed6) {\n        uint256 value = UFixed6.unwrap(a);\n        if (value > uint256(type(int256).max)) revert Fixed6OverflowError(value);\n        return Fixed6.wrap(int256(value));\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\n     * @param s Sign\n     * @param m Unsigned fixed-decimal magnitude\n     * @return New signed fixed-decimal\n     */\n    function from(int256 s, UFixed6 m) internal pure returns (Fixed6) {\n        if (s > 0) return from(m);\n        if (s < 0) {\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\n            // which is the only value that would overflow when negated. Therefore,\n            // we can safely negate from(m) without checking for overflow.\n            unchecked { return Fixed6.wrap(-1 * Fixed6.unwrap(from(m))); }\n        }\n        return ZERO;\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a signed integer\n     * @param a Signed number\n     * @return New signed fixed-decimal\n     */\n    function from(int256 a) internal pure returns (Fixed6) {\n        return Fixed6.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\n     * @param a Base-18 signed fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(Fixed18 a) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed18.unwrap(a) / 1e12);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\n     * @param a Base-18 signed fixed-decimal\n     * @param roundOut Whether to round the result away from zero if there is a remainder\n     * @return New signed fixed-decimal\n     */\n    function from(Fixed18 a, bool roundOut) internal pure returns (Fixed6) {\n        return roundOut ? Fixed6.wrap(NumberMath.divOut(Fixed18.unwrap(a), 1e12)): from(a);\n    }\n\n    /**\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\n     * @param a Signed fixed-decimal\n     * @return Whether the signed fixed-decimal is zero.\n     */\n    function isZero(Fixed6 a) internal pure returns (bool) {\n        return Fixed6.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting summed signed fixed-decimal\n     */\n    function add(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) + Fixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts signed fixed-decimal `b` from `a`\n     * @param a Signed fixed-decimal to subtract from\n     * @param b Signed fixed-decimal to subtract\n     * @return Resulting subtracted signed fixed-decimal\n     */\n    function sub(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) - Fixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mul(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mulOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function div(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) * BASE / Fixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function divOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\n        return muldiv(a, Fixed6.wrap(b), Fixed6.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\n        return muldivOut(a, Fixed6.wrap(b), Fixed6.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / Fixed6.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), Fixed6.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the signed fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(Fixed6 a, Fixed6 b) internal pure returns (uint256) {\n        (int256 au, int256 bu) = (Fixed6.unwrap(a), Fixed6.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\n     * @param a First signed number\n     * @param b Second signed number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(int256 a, int256 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(SignedMath.min(Fixed6.unwrap(a), Fixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(SignedMath.max(Fixed6.unwrap(a), Fixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\n     * @param a Signed fixed-decimal\n     * @return Truncated signed number\n     */\n    function truncate(Fixed6 a) internal pure returns (int256) {\n        return Fixed6.unwrap(a) / BASE;\n    }\n\n    /**\n     * @notice Returns the sign of the signed fixed-decimal\n     * @dev Returns: -1 for negative\n     *                0 for zero\n     *                1 for positive\n     * @param a Signed fixed-decimal\n     * @return Sign of the signed fixed-decimal\n     */\n    function sign(Fixed6 a) internal pure returns (int256) {\n        if (Fixed6.unwrap(a) > 0) return 1;\n        if (Fixed6.unwrap(a) < 0) return -1;\n        return 0;\n    }\n\n    /**\n     * @notice Returns the absolute value of the signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return Absolute value of the signed fixed-decimal\n     */\n    function abs(Fixed6 a) internal pure returns (UFixed6) {\n        return UFixed6.wrap(SignedMath.abs(Fixed6.unwrap(a)));\n    }\n}\n\nlibrary Fixed6StorageLib {\n    function read(Fixed6Storage self) internal view returns (Fixed6 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Fixed6Storage self, Fixed6 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/number/types/UFixed18.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed18.sol\";\nimport \"./UFixed6.sol\";\n\n/// @dev UFixed18 type\ntype UFixed18 is uint256;\nusing UFixed18Lib for UFixed18 global;\ntype UFixed18Storage is bytes32;\nusing UFixed18StorageLib for UFixed18Storage global;\n\n/**\n * @title UFixed18Lib\n * @notice Library for the unsigned fixed-decimal type.\n */\nlibrary UFixed18Lib {\n    error UFixed18UnderflowError(int256 value);\n\n    uint256 private constant BASE = 1e18;\n    UFixed18 public constant ZERO = UFixed18.wrap(0);\n    UFixed18 public constant ONE = UFixed18.wrap(BASE);\n    UFixed18 public constant MAX = UFixed18.wrap(type(uint256).max);\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function from(Fixed18 a) internal pure returns (UFixed18) {\n        int256 value = Fixed18.unwrap(a);\n        if (value < 0) revert UFixed18UnderflowError(value);\n        return UFixed18.wrap(uint256(value));\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function unsafeFrom(Fixed18 a) internal pure returns (UFixed18) {\n        return a.lt(Fixed18Lib.ZERO) ? ZERO : from(a);\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\n     * @param a Unsigned number\n     * @return New unsigned fixed-decimal\n     */\n    function from(uint256 a) internal pure returns (UFixed18) {\n        return UFixed18.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\n     * @param a Base-6 signed fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(UFixed6 a) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed6.unwrap(a) * 1e12);\n    }\n\n    /**\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\n     * @param a Unsigned fixed-decimal\n     * @return Whether the unsigned fixed-decimal is zero.\n     */\n    function isZero(UFixed18 a) internal pure returns (bool) {\n        return UFixed18.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting summed unsigned fixed-decimal\n     */\n    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function unsafeSub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return gt(b, a) ? ZERO : sub(a, b);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mul(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mulOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function div(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) * BASE / UFixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function divOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * BASE, UFixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\n        return muldiv(a, UFixed18.wrap(b), UFixed18.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\n        return muldivOut(a, UFixed18.wrap(b), UFixed18.wrap(c));\n    }\n\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / UFixed18.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), UFixed18.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(UFixed18 a, UFixed18 b) internal pure returns (uint256) {\n        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\n     * @param a First unsigned number\n     * @param b Second unsigned number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(Math.min(UFixed18.unwrap(a), UFixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(Math.max(UFixed18.unwrap(a), UFixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\n     * @param a Unsigned fixed-decimal\n     * @return Truncated unsigned number\n     */\n    function truncate(UFixed18 a) internal pure returns (uint256) {\n        return UFixed18.unwrap(a) / BASE;\n    }\n}\n\nlibrary UFixed18StorageLib {\n    function read(UFixed18Storage self) internal view returns (UFixed18 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(UFixed18Storage self, UFixed18 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/number/types/UFixed6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed6.sol\";\nimport \"./UFixed18.sol\";\n\n/// @dev UFixed6 type\ntype UFixed6 is uint256;\nusing UFixed6Lib for UFixed6 global;\ntype UFixed6Storage is bytes32;\nusing UFixed6StorageLib for UFixed6Storage global;\n\n/**\n * @title UFixed6Lib\n * @notice Library for the unsigned fixed-decimal type.\n */\nlibrary UFixed6Lib {\n    error UFixed6UnderflowError(int256 value);\n\n    uint256 private constant BASE = 1e6;\n    UFixed6 public constant ZERO = UFixed6.wrap(0);\n    UFixed6 public constant ONE = UFixed6.wrap(BASE);\n    UFixed6 public constant MAX = UFixed6.wrap(type(uint256).max);\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function from(Fixed6 a) internal pure returns (UFixed6) {\n        int256 value = Fixed6.unwrap(a);\n        if (value < 0) revert UFixed6UnderflowError(value);\n        return UFixed6.wrap(uint256(value));\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function unsafeFrom(Fixed6 a) internal pure returns (UFixed6) {\n        return a.lt(Fixed6Lib.ZERO) ? ZERO : from(a);\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\n     * @param a Unsigned number\n     * @return New unsigned fixed-decimal\n     */\n    function from(uint256 a) internal pure returns (UFixed6) {\n        return UFixed6.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\n     * @param a Base-18 unsigned fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function from(UFixed18 a) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed18.unwrap(a) / 1e12);\n    }\n\n    /**\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\n     * @param a Base-18 unsigned fixed-decimal\n     * @param roundOut Whether to round the result away from zero if there is a remainder\n     * @return New unsigned fixed-decimal\n     */\n    function from(UFixed18 a, bool roundOut) internal pure returns (UFixed6) {\n        return roundOut ? UFixed6.wrap(NumberMath.divOut(UFixed18.unwrap(a), 1e12)): from(a);\n    }\n\n    /**\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\n     * @param a Unsigned fixed-decimal\n     * @return Whether the unsigned fixed-decimal is zero.\n     */\n    function isZero(UFixed6 a) internal pure returns (bool) {\n        return UFixed6.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting summed unsigned fixed-decimal\n     */\n    function add(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) + UFixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function sub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) - UFixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function unsafeSub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return gt(b, a) ? ZERO : sub(a, b);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mul(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mulOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function div(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) * BASE / UFixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function divOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * BASE, UFixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\n        return muldiv(a, UFixed6.wrap(b), UFixed6.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\n        return muldivOut(a, UFixed6.wrap(b), UFixed6.wrap(c));\n    }\n\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / UFixed6.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), UFixed6.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(UFixed6 a, UFixed6 b) internal pure returns (uint256) {\n        (uint256 au, uint256 bu) = (UFixed6.unwrap(a), UFixed6.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\n     * @param a First unsigned number\n     * @param b Second unsigned number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(Math.min(UFixed6.unwrap(a), UFixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(Math.max(UFixed6.unwrap(a), UFixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\n     * @param a Unsigned fixed-decimal\n     * @return Truncated unsigned number\n     */\n    function truncate(UFixed6 a) internal pure returns (uint256) {\n        return UFixed6.unwrap(a) / BASE;\n    }\n}\n\nlibrary UFixed6StorageLib {\n    function read(UFixed6Storage self) internal view returns (UFixed6 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(UFixed6Storage self, UFixed6 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/pid/types/PAccumulator6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"./PController6.sol\";\n\n/// @dev PAccumulator6 type\nstruct PAccumulator6 {\n    Fixed6 _value;\n    Fixed6 _skew;\n}\nusing PAccumulator6Lib for PAccumulator6 global;\n\n/// @title PAccumulator6Lib\n/// @notice Accumulator for a the fixed 6-decimal PID controller. This holds the \"last seen state\" of the PID controller\n///         and works in conjunction with the PController6 to compute the current rate.\n/// @dev This implementation is specifically a P controller, with I_k and D_k both set to 0. In between updates, it\n///      continues to accumulate at a linear rate based on the previous skew, but the rate is capped at the max value.\n///      Once the rate hits the max value, it will continue to accumulate at the max value until the next update.\nlibrary PAccumulator6Lib {\n    /// @notice Accumulates the rate against notional given the prior and current state\n    /// @param self The controller accumulator\n    /// @param controller The controller configuration\n    /// @param skew The current skew\n    /// @param fromTimestamp The timestamp of the prior accumulation\n    /// @param toTimestamp The current timestamp\n    /// @param notional The notional to accumulate against\n    /// @return accumulated The total accumulated amount\n    function accumulate(\n        PAccumulator6 memory self,\n        PController6 memory controller,\n        Fixed6 skew,\n        uint256 fromTimestamp,\n        uint256 toTimestamp,\n        UFixed6 notional\n    ) internal pure returns (Fixed6 accumulated) {\n        // compute new value and intercept\n        (Fixed6 newValue, UFixed6 interceptTimestamp) =\n            controller.compute(self._value, self._skew, fromTimestamp, toTimestamp);\n\n        // accumulate rate within max\n        accumulated = _accumulate(\n            self._value.add(newValue),\n            UFixed6Lib.from(fromTimestamp),\n            interceptTimestamp,\n            notional\n        ).div(Fixed6Lib.from(2)); // rate = self._value + newValue / 2 -> divide here for added precision\n\n        // accumulate rate outside of max\n        accumulated = _accumulate(\n            newValue,\n            interceptTimestamp,\n            UFixed6Lib.from(toTimestamp),\n            notional\n        ).add(accumulated);\n\n        // update values\n        self._value = newValue;\n        self._skew = skew;\n    }\n\n    /// @notice Helper function to accumulate a singular rate against notional\n    /// @param rate The rate to accumulate\n    /// @param fromTimestamp The timestamp to accumulate from\n    /// @param toTimestamp The timestamp to accumulate to\n    /// @param notional The notional to accumulate against\n    /// @return The accumulated amount\n    function _accumulate(\n        Fixed6 rate,\n        UFixed6 fromTimestamp,\n        UFixed6 toTimestamp,\n        UFixed6 notional\n    ) private pure returns (Fixed6) {\n        return rate\n            .mul(Fixed6Lib.from(toTimestamp.sub(fromTimestamp)))\n            .mul(Fixed6Lib.from(notional))\n            .div(Fixed6Lib.from(365 days));\n    }\n}\n"
    },
    "@equilibria/root/pid/types/PController6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\n\n/// @dev PController6 type\nstruct PController6 {\n    UFixed6 k;\n    Fixed6 min;\n    Fixed6 max;\n}\nusing PController6Lib for PController6 global;\n\n/// @title PController6Lib\n/// @notice Configuration for a the fixed 6-decimal PID controller.\n/// @dev Each second, the PID controller's value is incremented by `skew / k`, with `max` as the maximum value.\nlibrary PController6Lib {\n    /// @notice compute the new value and intercept timestamp based on the prior controller state\n    /// @dev `interceptTimestamp` will never exceed `toTimestamp`\n    /// @param self the controller configuration\n    /// @param value the prior value\n    /// @param skew The prior skew\n    /// @param fromTimestamp The prior timestamp\n    /// @param toTimestamp The current timestamp\n    /// @return newValue the new value\n    /// @return interceptTimestamp the timestamp at which the value will be at the max\n    function compute(\n        PController6 memory self,\n        Fixed6 value,\n        Fixed6 skew,\n        uint256 fromTimestamp,\n        uint256 toTimestamp\n    ) internal pure returns (Fixed6 newValue, UFixed6 interceptTimestamp) {\n        // compute the new value without considering the max\n        Fixed6 newValueUncapped = value.add(\n            Fixed6Lib.from(int256(toTimestamp - fromTimestamp))\n                .mul(skew)\n                .div(Fixed6Lib.from(self.k))\n        );\n\n        // cap the new value between min and max\n        newValue = newValueUncapped.min(self.max).max(self.min);\n\n        // compute distance and range to the resultant value\n        (UFixed6 distance, Fixed6 range) = (UFixed6Lib.from(toTimestamp - fromTimestamp), newValueUncapped.sub(value));\n\n        // compute the amount of buffer until the value is outside the max\n        UFixed6 buffer = value.gt(self.max) || value.lt(self.min) ?\n            UFixed6Lib.ZERO :\n            (range.sign() > 0 ? self.max : self.min).sub(value).abs();\n\n        // compute the timestamp at which the value will be at the max\n        interceptTimestamp = range.isZero() ?\n            UFixed6Lib.from(toTimestamp) :\n            UFixed6Lib.from(fromTimestamp).add(distance.muldiv(buffer, range.abs())).min(UFixed6Lib.from(toTimestamp));\n    }\n}\n"
    },
    "@equilibria/root/storage/Storage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../number/types/UFixed18.sol\";\n\n/// @dev Stored boolean slot\ntype BoolStorage is bytes32;\nusing BoolStorageLib for BoolStorage global;\n\n/// @dev Stored uint256 slot\ntype Uint256Storage is bytes32;\nusing Uint256StorageLib for Uint256Storage global;\n\n/// @dev Stored int256 slot\ntype Int256Storage is bytes32;\nusing Int256StorageLib for Int256Storage global;\n\n/// @dev Stored address slot\ntype AddressStorage is bytes32;\nusing AddressStorageLib for AddressStorage global;\n\n/// @dev Stored bytes32 slot\ntype Bytes32Storage is bytes32;\nusing Bytes32StorageLib for Bytes32Storage global;\n\n/**\n * @title BoolStorageLib\n * @notice Library to manage storage and retrieval of a boolean at a fixed storage slot\n */\nlibrary BoolStorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored bool value\n     */\n    function read(BoolStorage self) internal view returns (bool value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value boolean value to store\n     */\n    function store(BoolStorage self, bool value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title Uint256StorageLib\n * @notice Library to manage storage and retrieval of an uint256 at a fixed storage slot\n */\nlibrary Uint256StorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored uint256 value\n     */\n    function read(Uint256Storage self) internal view returns (uint256 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value uint256 value to store\n     */\n    function store(Uint256Storage self, uint256 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title Int256StorageLib\n * @notice Library to manage storage and retrieval of an int256 at a fixed storage slot\n */\nlibrary Int256StorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored int256 value\n     */\n    function read(Int256Storage self) internal view returns (int256 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value int256 value to store\n     */\n    function store(Int256Storage self, int256 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title AddressStorageLib\n * @notice Library to manage storage and retrieval of an address at a fixed storage slot\n */\nlibrary AddressStorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored address value\n     */\n    function read(AddressStorage self) internal view returns (address value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value address value to store\n     */\n    function store(AddressStorage self, address value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title Bytes32StorageLib\n * @notice Library to manage storage and retrieval of a bytes32 at a fixed storage slot\n */\nlibrary Bytes32StorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored bytes32 value\n     */\n    function read(Bytes32Storage self) internal view returns (bytes32 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value bytes32 value to store\n     */\n    function store(Bytes32Storage self, bytes32 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/token/types/Token18.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../number/types/UFixed18.sol\";\n\n/// @dev Token18\ntype Token18 is address;\nusing Token18Lib for Token18 global;\ntype Token18Storage is bytes32;\nusing Token18StorageLib for Token18Storage global;\n\n/**\n * @title Token18Lib\n * @notice Library to manage 18-decimal ERC20s that is compliant with the fixed-decimal types.\n * @dev Maintains significant gas savings over other Token implementations since no conversion take place\n */\nlibrary Token18Lib {\n    using SafeERC20 for IERC20;\n\n    Token18 public constant ZERO = Token18.wrap(address(0));\n\n    /**\n     * @notice Returns whether a token is the zero address\n     * @param self Token to check for\n     * @return Whether the token is the zero address\n     */\n    function isZero(Token18 self) internal pure returns (bool) {\n        return Token18.unwrap(self) == Token18.unwrap(ZERO);\n    }\n\n    /**\n     * @notice Returns whether the two tokens are equal\n     * @param a First token to compare\n     * @param b Second token to compare\n     * @return Whether the two tokens are equal\n     */\n    function eq(Token18 a, Token18 b) internal pure returns (bool) {\n        return Token18.unwrap(a) ==  Token18.unwrap(b);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend infinite tokens from the caller\n     * @dev Uses `approve` rather than `safeApprove` since the race condition\n     *      in safeApprove does not apply when going to an infinite approval\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     */\n    function approve(Token18 self, address grantee) internal {\n        IERC20(Token18.unwrap(self)).approve(grantee, type(uint256).max);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend `amount` tokens from the caller\n     * @dev There are important race conditions to be aware of when using this function\n            with values other than 0. This will revert if moving from non-zero to non-zero amounts\n            See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a55b7d13722e7ce850b626da2313f3e66ca1d101/contracts/token/ERC20/IERC20.sol#L57\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     * @param amount Amount of tokens to approve to spend\n     */\n    function approve(Token18 self, address grantee, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeApprove(grantee, UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers all held tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to receive the tokens\n     */\n    function push(Token18 self, address recipient) internal {\n        push(self, recipient, balanceOf(self, address(this)));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function push(Token18 self, address recipient, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeTransfer(recipient, UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to the caller\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param amount Amount of tokens to transfer\n     */\n    function pull(Token18 self, address benefactor, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, address(this), UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function pullTo(Token18 self, address benefactor, address recipient, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, recipient, UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Returns the name of the token\n     * @param self Token to check for\n     * @return Token name\n     */\n    function name(Token18 self) internal view returns (string memory) {\n        return IERC20Metadata(Token18.unwrap(self)).name();\n    }\n\n    /**\n     * @notice Returns the symbol of the token\n     * @param self Token to check for\n     * @return Token symbol\n     */\n    function symbol(Token18 self) internal view returns (string memory) {\n        return IERC20Metadata(Token18.unwrap(self)).symbol();\n    }\n\n    /**\n     * @notice Returns the `self` token balance of the caller\n     * @param self Token to check for\n     * @return Token balance of the caller\n     */\n    function balanceOf(Token18 self) internal view returns (UFixed18) {\n        return balanceOf(self, address(this));\n    }\n\n    /**\n     * @notice Returns the `self` token balance of `account`\n     * @param self Token to check for\n     * @param account Account to check\n     * @return Token balance of the account\n     */\n    function balanceOf(Token18 self, address account) internal view returns (UFixed18) {\n        return UFixed18.wrap(IERC20(Token18.unwrap(self)).balanceOf(account));\n    }\n\n    /**\n     * @notice Returns the `self` total supply\n     * @param self Token to check for\n     * @return The total supply of the token\n     */\n    function totalSupply(Token18 self) internal view returns (UFixed18) {\n        return UFixed18.wrap(IERC20(Token18.unwrap(self)).totalSupply());\n    }\n}\n\nlibrary Token18StorageLib {\n    function read(Token18Storage self) internal view returns (Token18 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Token18Storage self, Token18 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/token/types/Token6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../number/types/UFixed6.sol\";\n\n/// @dev Token6\ntype Token6 is address;\nusing Token6Lib for Token6 global;\ntype Token6Storage is bytes32;\nusing Token6StorageLib for Token6Storage global;\n\n/**\n * @title Token6Lib\n * @notice Library to manage 6-decimal ERC20s that is compliant with the fixed-decimal types.\n */\nlibrary Token6Lib {\n    using SafeERC20 for IERC20;\n\n    Token6 public constant ZERO = Token6.wrap(address(0));\n\n    /**\n     * @notice Returns whether a token is the zero address\n     * @param self Token to check for\n     * @return Whether the token is the zero address\n     */\n    function isZero(Token6 self) internal pure returns (bool) {\n        return Token6.unwrap(self) == Token6.unwrap(ZERO);\n    }\n\n    /**\n     * @notice Returns whether the two tokens are equal\n     * @param a First token to compare\n     * @param b Second token to compare\n     * @return Whether the two tokens are equal\n     */\n    function eq(Token6 a, Token6 b) internal pure returns (bool) {\n        return Token6.unwrap(a) ==  Token6.unwrap(b);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend infinite tokens from the caller\n     * @dev Uses `approve` rather than `safeApprove` since the race condition\n     *      in safeApprove does not apply when going to an infinite approval\n     * @param self Token to grant approval\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     */\n    function approve(Token6 self, address grantee) internal {\n        IERC20(Token6.unwrap(self)).approve(grantee, type(uint256).max);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend `amount` tokens from the caller\n     * @dev There are important race conditions to be aware of when using this function\n            with values other than 0. This will revert if moving from non-zero to non-zero amounts\n            See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a55b7d13722e7ce850b626da2313f3e66ca1d101/contracts/token/ERC20/IERC20.sol#L57\n     * @param self Token to grant approval\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     * @param amount Amount of tokens to approve to spend\n     */\n    function approve(Token6 self, address grantee, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeApprove(grantee, UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers all held tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to receive the tokens\n     */\n    function push(Token6 self, address recipient) internal {\n        push(self, recipient, balanceOf(self, address(this)));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function push(Token6 self, address recipient, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeTransfer(recipient, UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to the caller\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param amount Amount of tokens to transfer\n     */\n    function pull(Token6 self, address benefactor, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeTransferFrom(benefactor, address(this), UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function pullTo(Token6 self, address benefactor, address recipient, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeTransferFrom(benefactor, recipient, UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Returns the name of the token\n     * @param self Token to check for\n     * @return Token name\n     */\n    function name(Token6 self) internal view returns (string memory) {\n        return IERC20Metadata(Token6.unwrap(self)).name();\n    }\n\n    /**\n     * @notice Returns the symbol of the token\n     * @param self Token to check for\n     * @return Token symbol\n     */\n    function symbol(Token6 self) internal view returns (string memory) {\n        return IERC20Metadata(Token6.unwrap(self)).symbol();\n    }\n\n    /**\n     * @notice Returns the `self` token balance of the caller\n     * @param self Token to check for\n     * @return Token balance of the caller\n     */\n    function balanceOf(Token6 self) internal view returns (UFixed6) {\n        return balanceOf(self, address(this));\n    }\n\n    /**\n     * @notice Returns the `self` token balance of `account`\n     * @param self Token to check for\n     * @param account Account to check\n     * @return Token balance of the account\n     */\n    function balanceOf(Token6 self, address account) internal view returns (UFixed6) {\n        return UFixed6.wrap(IERC20(Token6.unwrap(self)).balanceOf(account));\n    }\n\n    /**\n     * @notice Returns the `self` total supply\n     * @param self Token to check for\n     * @return The total supply of the token\n     */\n    function totalSupply(Token6 self) internal view returns (UFixed6) {\n        return UFixed6.wrap(IERC20(Token6.unwrap(self)).totalSupply());\n    }\n}\n\nlibrary Token6StorageLib {\n    function read(Token6Storage self) internal view returns (Token6 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Token6Storage self, Token6 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/utilization/CurveMath6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../number/types/UFixed6.sol\";\nimport \"../number/types/Fixed6.sol\";\n\n/**\n * @title CurveMath6\n * @notice Library for managing math operations for utilization curves.\n */\nlibrary CurveMath6 {\n    error CurveMath6OutOfBoundsError();\n\n    /**\n     * @notice Computes a linear interpolation between two points\n     * @param startX First point's x-coordinate\n     * @param startY First point's y-coordinate\n     * @param endX Second point's x-coordinate\n     * @param endY Second point's y-coordinate\n     * @param targetX x-coordinate to interpolate\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\n     */\n    function linearInterpolation(\n        UFixed6 startX,\n        Fixed6 startY,\n        UFixed6 endX,\n        Fixed6 endY,\n        UFixed6 targetX\n    ) internal pure returns (Fixed6) {\n        if (targetX.lt(startX) || targetX.gt(endX)) revert CurveMath6OutOfBoundsError();\n\n        UFixed6 xRange = endX.sub(startX);\n        Fixed6 yRange = endY.sub(startY);\n        UFixed6 xRatio = targetX.sub(startX).div(xRange);\n        return yRange.mul(Fixed6Lib.from(xRatio)).add(startY);\n    }\n\n    /**\n     * @notice Computes a linear interpolation between two points\n     * @param startX First point's x-coordinate\n     * @param startY First point's y-coordinate\n     * @param endX Second point's x-coordinate\n     * @param endY Second point's y-coordinate\n     * @param targetX x-coordinate to interpolate\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\n     */\n    function linearInterpolation(\n        UFixed6 startX,\n        UFixed6 startY,\n        UFixed6 endX,\n        UFixed6 endY,\n        UFixed6 targetX\n    ) internal pure returns (UFixed6) {\n        return UFixed6Lib.from(linearInterpolation(startX, Fixed6Lib.from(startY), endX, Fixed6Lib.from(endY), targetX));\n    }\n}\n"
    },
    "@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../CurveMath6.sol\";\nimport \"../../number/types/UFixed6.sol\";\n\n/// @dev UJumpRateUtilizationCurve6 type\nstruct UJumpRateUtilizationCurve6 {\n    UFixed6 minRate;\n    UFixed6 maxRate;\n    UFixed6 targetRate;\n    UFixed6 targetUtilization;\n}\nusing UJumpRateUtilizationCurve6Lib for UJumpRateUtilizationCurve6 global;\n\n/**\n * @title UJumpRateUtilizationCurve6Lib\n * @notice Library for the unsigned base-6 Jump Rate utilization curve type\n */\nlibrary UJumpRateUtilizationCurve6Lib {\n    /**\n     * @notice Computes the corresponding rate for a utilization ratio\n     * @param utilization The utilization ratio\n     * @return The corresponding rate\n     */\n    function compute(UJumpRateUtilizationCurve6 memory self, UFixed6 utilization) internal pure returns (UFixed6) {\n        if (utilization.lt(self.targetUtilization)) {\n            return CurveMath6.linearInterpolation(\n                UFixed6Lib.ZERO,\n                self.minRate,\n                self.targetUtilization,\n                self.targetRate,\n                utilization\n            );\n        }\n        if (utilization.lt(UFixed6Lib.ONE)) {\n            return CurveMath6.linearInterpolation(\n                self.targetUtilization,\n                self.targetRate,\n                UFixed6Lib.ONE,\n                self.maxRate,\n                utilization\n            );\n        }\n        return self.maxRate;\n    }\n\n    function accumulate(\n        UJumpRateUtilizationCurve6 memory self,\n        UFixed6 utilization,\n        uint256 fromTimestamp,\n        uint256 toTimestamp,\n        UFixed6 notional\n    ) internal pure returns (UFixed6) {\n        return compute(self, utilization)\n            .mul(UFixed6Lib.from(toTimestamp - fromTimestamp))\n            .mul(notional)\n            .div(UFixed6Lib.from(365 days));\n    }\n}\n"
    },
    "@equilibria/root/verifier/interfaces/IVerifierBase.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common } from \"../types/Common.sol\";\nimport { GroupCancellation } from \"../types/GroupCancellation.sol\";\n\ninterface IVerifierBase {\n    // sig: 0xfec563a0\n    /// @custom:error Signer is trying to cancel a nonce for another user\n    error VerifierInvalidSignerError();\n    // sig: 0xa568ee00\n    /// @custom:error Message was meant for another protocol, version, or chain\n    error VerifierInvalidDomainError();\n    // sig: 0xb09262f6\n    /// @custom:error Signature length was unexpected\n    error VerifierInvalidSignatureError();\n    // sig: 0xe6784f14\n    /// @custom:error Nonce has already been used\n    error VerifierInvalidNonceError();\n    // sig: 0x79998279\n    /// @custom:error Group nonce has already been used\n    error VerifierInvalidGroupError();\n    // sig: 0x27661908\n    /// @custom:error Block timestamp has exceeded user-assigned expiration\n    error VerifierInvalidExpiryError();\n\n    /// @notice Emitted when a nonce is cancelled\n    event NonceCancelled(address indexed account, uint256 nonce);\n    /// @notice Emitted when a group nonce is cancelled\n    event GroupCancelled(address indexed account, uint256 group);\n\n    /// @notice Returns whether the nonce has been cancelled\n    /// @param account The account to check the nonce for\n    /// @param nonce The nonce to check\n    /// @return True if the nonce has been cancelled\n    function nonces(address account, uint256 nonce) external view returns (bool);\n\n    /// @notice Returns whether the group nonce has been cancelled\n    /// @param account The account to check the group nonce for\n    /// @param nonce The group nonce to check\n    /// @return True if the group nonce has been cancelled\n    function groups(address account, uint256 nonce) external view returns (bool);\n\n    /// @notice Verifies the signature of no-op common message\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param common The common data of the message\n    /// @param signature The signature of the account for the message\n    function verifyCommon(Common calldata common, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a group cancellation type\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param groupCancellation The group cancellation to verify\n    /// @param signature The signature of the account for the group cancellation\n    function verifyGroupCancellation(GroupCancellation calldata groupCancellation, bytes calldata signature) external;\n\n    /// @notice Cancels a nonce\n    /// @param nonce The nonce to cancel\n    function cancelNonce(uint256 nonce) external;\n\n    /// @notice Cancels a nonce for an account via a signed message\n    /// @dev Process a no-op message that will invalidate the specified nonce\n    /// @param common The common data of the message\n    /// @param signature The signature of the account for the message\n    function cancelNonceWithSignature(Common calldata common, bytes calldata signature) external;\n\n    /// @notice Cancels a group nonce\n    /// @param group The group nonce to cancel\n    function cancelGroup(uint256 group) external;\n\n    /// @notice Cancels a group for an account via a signed message\n    /// @param groupCancellation The group cancellation message\n    /// @param signature The signature of the account for the group cancellation\n    function cancelGroupWithSignature(GroupCancellation calldata groupCancellation, bytes calldata signature) external;\n}\n"
    },
    "@equilibria/root/verifier/types/Common.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\n/// @notice Fields which need to be hashed in any EIP712 action\nstruct Common {\n    /// @dev The target account of the message (usually the account on behalf of which the action is being performed)\n    address account;\n    /// @dev EOA signing the message (usually either the account or a delegate of the account)\n    address signer;\n    /// @dev ensures the message is unique to a particular protocol version, chain, and verifier\n    address domain;\n    /// @dev per-sender nonce which is automatically cancelled upon validation\n    uint256 nonce;\n    /// @dev per-sender nonce which must be manually cancelled with a GroupCancellation message\n    uint256 group;\n    /// @dev prevents this message from having the intended effect after a specified timestamp\n    uint256 expiry;\n}\nusing CommonLib for Common global;\n\n/// @title CommonLib\n/// @notice Library collecting fields which need to be hashed in any EIP712 message\nlibrary CommonLib {\n    /// @dev used to verify a signed message\n    bytes32 constant public STRUCT_HASH =\n        keccak256(\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\");\n\n    /// @dev used to create a signed message\n    function hash(Common memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.account, self.signer, self.domain, self.nonce, self.group, self.expiry));\n    }\n}\n"
    },
    "@equilibria/root/verifier/types/GroupCancellation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common, CommonLib } from \"./Common.sol\";\n\nstruct GroupCancellation {\n    /// @dev The group to cancel\n    uint256 group;\n\n    /// @dev The common information for EIP712 actions\n    Common common;\n}\nusing GroupCancellationLib for GroupCancellation global;\n\n/// @title GroupCancellationLib\n/// @notice Library used to hash and verify action to cancel a group nonce.\nlibrary GroupCancellationLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"GroupCancellation(uint256 group,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    function hash(GroupCancellation memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.group, CommonLib.hash(self.common)));\n    }\n}\n"
    },
    "@equilibria/root/verifier/VerifierBase.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { EIP712 } from \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\nimport { SignatureChecker } from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport { Common, CommonLib } from \"./types/Common.sol\";\nimport { GroupCancellation, GroupCancellationLib } from \"./types/GroupCancellation.sol\";\nimport { IVerifierBase } from \"./interfaces/IVerifierBase.sol\";\n\nabstract contract VerifierBase is IVerifierBase, EIP712 {\n    /// @inheritdoc IVerifierBase\n    mapping(address => mapping(uint256 => bool)) public nonces;\n\n    /// @inheritdoc IVerifierBase\n    mapping(address => mapping(uint256 => bool)) public groups;\n\n    /// @inheritdoc IVerifierBase\n    function verifyCommon(Common calldata common, bytes calldata signature)\n        external\n        validateAndCancel(common, signature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(common.signer, _hashTypedDataV4(CommonLib.hash(common)), signature))\n            revert VerifierInvalidSignerError();\n    }\n\n    /// @inheritdoc IVerifierBase\n    function verifyGroupCancellation(GroupCancellation calldata groupCancellation, bytes calldata signature)\n        external\n        validateAndCancel(groupCancellation.common, signature)\n    {\n        if (!SignatureChecker.isValidSignatureNow(\n            groupCancellation.common.signer,\n            _hashTypedDataV4(GroupCancellationLib.hash(groupCancellation)),\n            signature\n        )) revert VerifierInvalidSignerError();\n    }\n\n    /// @inheritdoc IVerifierBase\n    function cancelNonce(uint256 nonce) external {\n        _cancelNonce(msg.sender, nonce);\n    }\n\n    /// @inheritdoc IVerifierBase\n    function cancelGroup(uint256 group) external {\n        _cancelGroup(msg.sender, group);\n    }\n\n    /// @inheritdoc IVerifierBase\n    function cancelNonceWithSignature(Common calldata common, bytes calldata signature) external {\n        IVerifierBase(this).verifyCommon(common, signature); // cancels nonce\n    }\n\n    /// @inheritdoc IVerifierBase\n    function cancelGroupWithSignature(GroupCancellation calldata groupCancellation, bytes calldata signature) external {\n        IVerifierBase(this).verifyGroupCancellation(groupCancellation, signature);\n        _cancelGroup(groupCancellation.common.account, groupCancellation.group);\n    }\n\n    /// @notice Cancels a nonce\n    /// @param account The account to cancel the nonce for\n    /// @param nonce The nonce to cancel\n    function _cancelNonce(address account, uint256 nonce) private {\n        nonces[account][nonce] = true;\n        emit NonceCancelled(account, nonce);\n    }\n\n    /// @notice Cancels a group nonce\n    /// @param account The account to cancel the group nonce for\n    /// @param group The group nonce to cancel\n    function _cancelGroup(address account, uint256 group) private {\n        groups[account][group] = true;\n        emit GroupCancelled(account, group);\n    }\n\n    /// @dev Validates the common data of a message\n    modifier validateAndCancel(Common calldata common, bytes calldata signature) {\n        if (common.domain != msg.sender) revert VerifierInvalidDomainError();\n        if (signature.length != 65) revert VerifierInvalidSignatureError();\n        if (nonces[common.account][common.nonce]) revert VerifierInvalidNonceError();\n        if (groups[common.account][common.group]) revert VerifierInvalidGroupError();\n        if (block.timestamp >= common.expiry) revert VerifierInvalidExpiryError();\n\n        _cancelNonce(common.account, common.nonce);\n\n        _;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../token/ERC721/IERC721Receiver.sol\";\nimport \"../token/ERC1155/IERC1155Receiver.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl, IERC721Receiver, IERC1155Receiver {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with the following parameters:\n     *\n     * - `minDelay`: initial minimum delay for operations\n     * - `proposers`: accounts to be granted proposer and canceller roles\n     * - `executors`: accounts to be granted executor role\n     * - `admin`: optional account to be granted admin role; disable with zero address\n     *\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\n     * without being subject to delay, but this role should be subsequently renounced in favor of\n     * administration through timelocked proposals. Previous versions of this contract would assign\n     * this admin to the deployer automatically and should be renounced as well.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors,\n        address admin\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _setupRole(TIMELOCK_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n            _setupRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, AccessControl) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool registered) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) internal virtual {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   |  ptr ...   ptr + 0x0B (start) ...   ptr + 0x20 ...   ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |             |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../Address.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        if (error == ECDSA.RecoverError.NoError && recovered == signer) {\n            return true;\n        }\n\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length == 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPyth.sol\";\nimport \"./PythErrors.sol\";\n\nabstract contract AbstractPyth is IPyth {\n    /// @notice Returns the price feed with given id.\n    /// @dev Reverts if the price does not exist.\n    /// @param id The Pyth Price Feed ID of which to fetch the PriceFeed.\n    function queryPriceFeed(\n        bytes32 id\n    ) public view virtual returns (PythStructs.PriceFeed memory priceFeed);\n\n    /// @notice Returns true if a price feed with the given id exists.\n    /// @param id The Pyth Price Feed ID of which to check its existence.\n    function priceFeedExists(\n        bytes32 id\n    ) public view virtual returns (bool exists);\n\n    function getValidTimePeriod()\n        public\n        view\n        virtual\n        override\n        returns (uint validTimePeriod);\n\n    function getPrice(\n        bytes32 id\n    ) external view virtual override returns (PythStructs.Price memory price) {\n        return getPriceNoOlderThan(id, getValidTimePeriod());\n    }\n\n    function getEmaPrice(\n        bytes32 id\n    ) external view virtual override returns (PythStructs.Price memory price) {\n        return getEmaPriceNoOlderThan(id, getValidTimePeriod());\n    }\n\n    function getPriceUnsafe(\n        bytes32 id\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        PythStructs.PriceFeed memory priceFeed = queryPriceFeed(id);\n        return priceFeed.price;\n    }\n\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        price = getPriceUnsafe(id);\n\n        if (diff(block.timestamp, price.publishTime) > age)\n            revert PythErrors.StalePrice();\n\n        return price;\n    }\n\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        PythStructs.PriceFeed memory priceFeed = queryPriceFeed(id);\n        return priceFeed.emaPrice;\n    }\n\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        price = getEmaPriceUnsafe(id);\n\n        if (diff(block.timestamp, price.publishTime) > age)\n            revert PythErrors.StalePrice();\n\n        return price;\n    }\n\n    function diff(uint x, uint y) internal pure returns (uint) {\n        if (x > y) {\n            return x - y;\n        } else {\n            return y - x;\n        }\n    }\n\n    // Access modifier is overridden to public to be able to call it locally.\n    function updatePriceFeeds(\n        bytes[] calldata updateData\n    ) public payable virtual override;\n\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable virtual override {\n        if (priceIds.length != publishTimes.length)\n            revert PythErrors.InvalidArgument();\n\n        for (uint i = 0; i < priceIds.length; i++) {\n            if (\n                !priceFeedExists(priceIds[i]) ||\n                queryPriceFeed(priceIds[i]).price.publishTime < publishTimes[i]\n            ) {\n                updatePriceFeeds(updateData);\n                return;\n            }\n        }\n\n        revert PythErrors.NoFreshUpdate();\n    }\n\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    )\n        external\n        payable\n        virtual\n        override\n        returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/consumers/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\n\n    /// @notice Returns the price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\n    /// @dev Reverts if the EMA price is not available.\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method does not store the price updates on-chain.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n\n    /// @dev Emitted when a batch price update is processed successfully.\n    /// @param chainId ID of the source chain that the batch price update comes from.\n    /// @param sequenceNumber Sequence number of the batch price update.\n    event BatchPriceFeedUpdate(uint16 chainId, uint64 sequenceNumber);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythErrors.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nlibrary PythErrors {\n    // Function arguments are invalid (e.g., the arguments lengths mismatch)\n    error InvalidArgument();\n    // Update data is coming from an invalid data source.\n    error InvalidUpdateDataSource();\n    // Update data is invalid (e.g., deserialization error)\n    error InvalidUpdateData();\n    // Insufficient fee is paid to the method.\n    error InsufficientFee();\n    // There is no fresh update, whereas expected fresh updates.\n    error NoFreshUpdate();\n    // There is no price feed found within the given range or it does not exists.\n    error PriceFeedNotFoundWithinRange();\n    // Price feed not found or it is not pushed on-chain yet.\n    error PriceFeedNotFound();\n    // Requested price is stale.\n    error StalePrice();\n    // Given message is not a valid Wormhole VAA.\n    error InvalidWormholeVaa();\n    // Governance message is invalid (e.g., deserialization error).\n    error InvalidGovernanceMessage();\n    // Governance message is not for this contract.\n    error InvalidGovernanceTarget();\n    // Governance message is coming from an invalid data source.\n    error InvalidGovernanceDataSource();\n    // Governance message is old.\n    error OldGovernanceMessage();\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/consumers/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-account/contracts/Account.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-account/contracts/Account.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-account/contracts/AccountVerifier.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-account/contracts/AccountVerifier.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-account/contracts/Controller_Arbitrum.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-extensions/contracts/Coordinator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-extensions/contracts/Coordinator.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Arbitrum.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Optimism.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Optimism.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-extensions/contracts/MultiInvoker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-extensions/contracts/MultiInvoker.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/keeper/KeeperFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/keeper/KeeperFactory.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle_Migration.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle_Migration.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/metaquants/MetaQuantsFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/metaquants/MetaQuantsFactory.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/Oracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/Oracle.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/OracleFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/OracleFactory.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/payoff/Inverse.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/payoff/Inverse.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/payoff/PowerHalf.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/payoff/PowerHalf.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/payoff/PowerTwo.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/payoff/PowerTwo.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-order/contracts/Manager_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-order/contracts/Manager_Arbitrum.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-order/contracts/OrderVerifier.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-order/contracts/OrderVerifier.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-vault/contracts/Vault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-vault/contracts/Vault.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-vault/contracts/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-vault/contracts/VaultFactory.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-verifier/contracts/Verifier.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-verifier/contracts/Verifier.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2/contracts/Market.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2/contracts/Market.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2/contracts/MarketFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2/contracts/MarketFactory.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/root/gas/GasOracle_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/root/gas/GasOracle_Arbitrum.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/root/gas/GasOracle_Optimism.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/root/gas/GasOracle_Optimism.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/root/gas/GasOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/root/gas/GasOracle.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/governance/TimelockController.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "viaIR": true,
    "metadata": {
      "useLiteralContent": true
    }
  }
}
