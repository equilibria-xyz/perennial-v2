{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@equilibria/emptyset-batcher/interfaces/IBatcher.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed18.sol\";\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/token/types/Token6.sol\";\nimport \"../interfaces/IEmptySetReserve.sol\";\n\ninterface IBatcher {\n    event Wrap(address indexed to, UFixed18 amount);\n    event Unwrap(address indexed to, UFixed18 amount);\n    event Rebalance(UFixed18 newMinted, UFixed18 newRedeemed);\n    event Close(UFixed18 amount);\n\n    error BatcherNotImplementedError();\n    error BatcherBalanceMismatchError(UFixed18 oldBalance, UFixed18 newBalance);\n\n    function RESERVE() external view returns (IEmptySetReserve); // solhint-disable-line func-name-mixedcase\n    function USDC() external view returns (Token6); // solhint-disable-line func-name-mixedcase\n    function DSU() external view returns (Token18); // solhint-disable-line func-name-mixedcase\n    function totalBalance() external view returns (UFixed18);\n    function wrap(UFixed18 amount, address to) external;\n    function unwrap(UFixed18 amount, address to) external;\n    function rebalance() external;\n}\n"
    },
    "@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed18.sol\";\n\ninterface IEmptySetReserve {\n    event Redeem(address indexed account, uint256 costAmount, uint256 redeemAmount);\n    event Mint(address indexed account, uint256 mintAmount, uint256 costAmount);\n    event Repay(address indexed account, uint256 repayAmount);\n\n    function debt(address borrower) external view returns (UFixed18);\n    function repay(address borrower, UFixed18 amount) external;\n    function mint(UFixed18 amount) external;\n    function redeem(UFixed18 amount) external;\n}\n"
    },
    "@equilibria/perennial-v2-extensions/contracts/Coordinator.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { Ownable } from \"@equilibria/root/attribute/Ownable.sol\";\nimport { ICoordinator, IMarket, RiskParameter, Token18 } from \"./interfaces/ICoordinator.sol\";\n\n/// @title Coordinator\n/// @notice Manages claiming fees and updating risk parameters for markets\ncontract Coordinator is ICoordinator, Ownable {\n    /// @dev The address of the comptroller (who can claim the fee)\n    address public comptroller;\n\n    /// @dev The address of the coordinator (who can update risk parameters)\n    address public coordinator;\n\n    /// @notice Constructs the contract\n    constructor() {\n        __Ownable__initialize();\n    }\n\n    /// @notice Updates the comptroller\n    /// @param comptroller_ The address of the new comptroller\n    function setComptroller(address comptroller_) external onlyOwner {\n        comptroller = comptroller_;\n        emit ComptrollerSet(comptroller_);\n    }\n\n    /// @notice Updates the coordinator\n    /// @param coordinator_ The address of the new coordinator\n    function setCoordinator(address coordinator_) external onlyOwner {\n        coordinator = coordinator_;\n        emit CoordinatorSet(coordinator_);\n    }\n\n    /// @notice Claims the fee for a market\n    /// @param market The market to claim the fee for\n    function claimFee(IMarket market) external {\n        if (msg.sender != comptroller) revert NotComptroller();\n        market.claimFee();\n        market.token().push(comptroller);\n    }\n\n    /// @notice Updates the risk parameter for a market\n    /// @param market The market to update the risk parameter for\n    /// @param riskParameter The new risk parameter\n    function updateRiskParameter(IMarket market, RiskParameter calldata riskParameter) external {\n        if (msg.sender != coordinator) revert NotCoordinator();\n        market.updateRiskParameter(riskParameter);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-extensions/contracts/interfaces/ICoordinator.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { IMarket, RiskParameter } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\n\ninterface ICoordinator {\n    function setComptroller(address comptroller) external;\n    function setCoordinator(address coordinator) external;\n    function claimFee(IMarket market) external;\n    function updateRiskParameter(IMarket market, RiskParameter calldata riskParameter) external;\n\n    event ComptrollerSet(address comptroller);\n    event CoordinatorSet(address coordinator);\n\n    error NotComptroller();\n    error NotCoordinator();\n    error NotFeeWithdrawer();\n}\n"
    },
    "@equilibria/perennial-v2-extensions/contracts/interfaces/IMultiInvoker.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\nimport {\n    IFactory,\n    IMarket,\n    Position,\n    Local,\n    UFixed18Lib,\n    UFixed18,\n    OracleVersion,\n    RiskParameter\n} from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { IBatcher } from \"@equilibria/emptyset-batcher/interfaces/IBatcher.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { TriggerOrder } from \"../types/TriggerOrder.sol\";\nimport { InterfaceFee } from \"../types/InterfaceFee.sol\";\n\ninterface IMultiInvoker {\n    enum PerennialAction {\n        NO_OP,           // 0\n        UPDATE_POSITION, // 1\n        UPDATE_VAULT,    // 2\n        PLACE_ORDER,     // 3\n        CANCEL_ORDER,    // 4\n        EXEC_ORDER,      // 5\n        COMMIT_PRICE,    // 6\n        __LIQUIDATE__DEPRECATED,\n        APPROVE          // 8\n    }\n\n    struct Invocation {\n        PerennialAction action;\n        bytes args;\n    }\n\n    event KeeperFeeCharged(address indexed account, address indexed market, address indexed to, UFixed6 fee);\n    event OrderPlaced(address indexed account, IMarket indexed market, uint256 indexed nonce, TriggerOrder order);\n    event OrderExecuted(address indexed account, IMarket indexed market, uint256 nonce);\n    event OrderCancelled(address indexed account, IMarket indexed market, uint256 nonce);\n    event InterfaceFeeCharged(address indexed account, IMarket indexed market, InterfaceFee fee);\n\n    // sig: 0x217b1699\n    error MultiInvokerBadSenderError();\n    // sig: 0x88d67968\n    error MultiInvokerOrderMustBeSingleSidedError();\n    // sig: 0xbccd78e7\n    error MultiInvokerMaxFeeExceededError();\n    // sig: 0x47b7c1b0\n    error MultiInvokerInvalidInstanceError();\n    // sig: 0xb6befb58\n    error MultiInvokerInvalidOrderError();\n    // sig: 0x6f462962\n    error MultiInvokerCantExecuteError();\n\n    function invoke(Invocation[] calldata invocations) external payable;\n    function marketFactory() external view returns (IFactory);\n    function vaultFactory() external view returns (IFactory);\n    function batcher() external view returns (IBatcher);\n    function reserve() external view returns (IEmptySetReserve);\n    function keepBufferBase() external view returns (uint256);\n    function keepBufferCalldata() external view returns (uint256);\n    function latestNonce() external view returns (uint256);\n    function orders(address account, IMarket market, uint256 nonce) external view returns (TriggerOrder memory);\n    function canExecuteOrder(address account, IMarket market, uint256 nonce) external view returns (bool);\n}"
    },
    "@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Kept/Kept_Arbitrum.sol\";\nimport \"./MultiInvoker.sol\";\n\n/// @title MultiInvoker_Arbitrum\n/// @notice Arbitrum Kept MultiInvoker implementation.\n/// @dev Additionally incentivizes keepers with L1 rollup fees according to the Arbitrum spec\ncontract MultiInvoker_Arbitrum is MultiInvoker, Kept_Arbitrum {\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        uint256 keepBufferBase_,\n        uint256 keepBufferCalldata_\n    ) MultiInvoker(\n        usdc_,\n        dsu_,\n        marketFactory_,\n        vaultFactory_,\n        batcher_,\n        reserve_,\n        keepBufferBase_,\n        keepBufferCalldata_\n    ) { }\n\n    /// @dev Use the Kept_Arbitrum implementation for calculating the dynamic fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view override(Kept_Arbitrum, Kept) returns (UFixed18) {\n        return Kept_Arbitrum._calldataFee(applicableCalldata, multiplierCalldata, bufferCalldata);\n    }\n\n    /// @dev Use the PythOracle implementation for raising the keeper fee\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal override(MultiInvoker, Kept) returns (UFixed18) {\n        return MultiInvoker._raiseKeeperFee(amount, data);\n    }\n}"
    },
    "@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Optimism.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Kept/Kept_Optimism.sol\";\nimport \"./MultiInvoker.sol\";\n\n/// @title MultiInvoker_Optimism\n/// @notice Optimism Kept MultiInvoker implementation.\n/// @dev Additionally incentivizes keepers with L1 rollup fees according to the Optimism spec\ncontract MultiInvoker_Optimism is MultiInvoker, Kept_Optimism {\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        uint256 keepBufferBase_,\n        uint256 keepBufferCalldata_\n    ) MultiInvoker(\n        usdc_,\n        dsu_,\n        marketFactory_,\n        vaultFactory_,\n        batcher_,\n        reserve_,\n        keepBufferBase_,\n        keepBufferCalldata_\n    ) { }\n\n    /// @dev Use the Kept_Optimism implementation for calculating the dynamic fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view override(Kept_Optimism, Kept) returns (UFixed18) {\n        return Kept_Optimism._calldataFee(applicableCalldata, multiplierCalldata, bufferCalldata);\n    }\n\n    /// @dev Use the PythOracle implementation for raising the keeper fee\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal override(MultiInvoker, Kept) returns (UFixed18) {\n        return MultiInvoker._raiseKeeperFee(amount, data);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-extensions/contracts/MultiInvoker.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { IFactory } from \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport { IBatcher } from \"@equilibria/emptyset-batcher/interfaces/IBatcher.sol\";\nimport { IInstance } from \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport { IPythFactory } from \"@equilibria/perennial-v2-oracle/contracts/interfaces/IPythFactory.sol\";\nimport { IVault } from \"@equilibria/perennial-v2-vault/contracts/interfaces/IVault.sol\";\nimport \"./interfaces/IMultiInvoker.sol\";\nimport \"./types/TriggerOrder.sol\";\nimport \"./types/InterfaceFee.sol\";\nimport \"@equilibria/root/attribute/Kept/Kept.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/// @title MultiInvoker\n/// @notice Extension to handle batched calls to the Perennial protocol\ncontract MultiInvoker is IMultiInvoker, Kept {\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @dev Protocol factory to validate market approvals\n    IFactory public immutable marketFactory;\n\n    /// @dev Vault factory to validate vault approvals\n    IFactory public immutable vaultFactory;\n\n    /// @dev Batcher address\n    IBatcher public immutable batcher;\n\n    /// @dev Reserve address\n    IEmptySetReserve public immutable reserve;\n\n    /// @dev The fixed gas buffer that is added to the keeper fee\n    uint256 public immutable keepBufferBase;\n\n    /// @dev The fixed gas buffer that is added to the calldata portion of the keeper fee\n    uint256 public immutable keepBufferCalldata;\n\n    /// @dev UID for an order\n    uint256 public latestNonce;\n\n    /// @dev State for the order data\n    mapping(address => mapping(IMarket => mapping(uint256 => TriggerOrderStorage))) private _orders;\n\n    /// @notice Constructs the MultiInvoker contract\n    /// @param usdc_ USDC stablecoin address\n    /// @param dsu_ DSU address\n    /// @param marketFactory_ Protocol factory to validate market approvals\n    /// @param vaultFactory_ Protocol factory to validate vault approvals\n    /// @param batcher_ Batcher address\n    /// @param reserve_ Reserve address\n    /// @param keepBufferBase_ The fixed gas buffer that is added to the keeper fee\n    /// @param keepBufferCalldata_ The fixed calldata buffer that is added to the keeper fee\n    constructor(\n        Token6 usdc_,\n        Token18 dsu_,\n        IFactory marketFactory_,\n        IFactory vaultFactory_,\n        IBatcher batcher_,\n        IEmptySetReserve reserve_,\n        uint256 keepBufferBase_,\n        uint256 keepBufferCalldata_\n    ) {\n        USDC = usdc_;\n        DSU = dsu_;\n        marketFactory = marketFactory_;\n        vaultFactory = vaultFactory_;\n        batcher = batcher_;\n        reserve = reserve_;\n        keepBufferBase = keepBufferBase_;\n        keepBufferCalldata = keepBufferCalldata_;\n    }\n\n    /// @notice Initialize the contract\n    /// @param ethOracle_ Chainlink ETH/USD oracle address\n    function initialize(AggregatorV3Interface ethOracle_) external initializer(1) {\n        __Kept__initialize(ethOracle_, DSU);\n\n        if (address(batcher) != address(0)) {\n            DSU.approve(address(batcher));\n            USDC.approve(address(batcher));\n        }\n\n        DSU.approve(address(reserve));\n        USDC.approve(address(reserve));\n    }\n\n    /// @notice View function to get order state\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    function orders(address account, IMarket market, uint256 nonce) public view returns (TriggerOrder memory) {\n        return _orders[account][market][nonce].read();\n    }\n\n    /// @notice Returns whether an order can be executed\n    /// @param account Account to get open oder of\n    /// @param market Market to get open order in\n    /// @param nonce UID of order\n    /// @return canFill Whether the order can be executed\n    function canExecuteOrder(address account, IMarket market, uint256 nonce) public view returns (bool) {\n        TriggerOrder memory order = orders(account, market, nonce);\n        if (order.fee.isZero()) return false;\n\n        return order.fillable(market.oracle().latest());\n    }\n\n    /// @notice entry to perform invocations\n    /// @param invocations List of actions to execute in order\n    function invoke(Invocation[] calldata invocations) external payable {\n        for(uint i = 0; i < invocations.length; ++i) {\n            Invocation memory invocation = invocations[i];\n\n            if (invocation.action == PerennialAction.UPDATE_POSITION) {\n                (\n                    // update data\n                    IMarket market,\n                    UFixed6 newMaker,\n                    UFixed6 newLong,\n                    UFixed6 newShort,\n                    Fixed6 collateral,\n                    bool wrap,\n                    InterfaceFee memory interfaceFee1,\n                    InterfaceFee memory interfaceFee2\n                ) = abi.decode(invocation.args, (IMarket, UFixed6, UFixed6, UFixed6, Fixed6, bool, InterfaceFee, InterfaceFee));\n\n                _update(msg.sender, market, newMaker, newLong, newShort, collateral, wrap, interfaceFee1, interfaceFee2);\n            } else if (invocation.action == PerennialAction.UPDATE_VAULT) {\n                (IVault vault, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets, bool wrap)\n                    = abi.decode(invocation.args, (IVault, UFixed6, UFixed6, UFixed6, bool));\n\n                _vaultUpdate(vault, depositAssets, redeemShares, claimAssets, wrap);\n            } else if (invocation.action == PerennialAction.PLACE_ORDER) {\n                (IMarket market, TriggerOrder memory order) = abi.decode(invocation.args, (IMarket, TriggerOrder));\n\n                _placeOrder(msg.sender, market, order);\n            } else if (invocation.action == PerennialAction.CANCEL_ORDER) {\n                (IMarket market, uint256 nonce) = abi.decode(invocation.args, (IMarket, uint256));\n\n                _cancelOrder(msg.sender, market, nonce);\n            } else if (invocation.action == PerennialAction.EXEC_ORDER) {\n                (address account, IMarket market, uint256 nonce)\n                    = abi.decode(invocation.args, (address, IMarket, uint256));\n\n                _executeOrder(account, market, nonce);\n            } else if (invocation.action == PerennialAction.COMMIT_PRICE) {\n                (address oracleProviderFactory, uint256 value, bytes32[] memory ids, uint256 version, bytes memory data, bool revertOnFailure) =\n                    abi.decode(invocation.args, (address, uint256, bytes32[], uint256, bytes, bool));\n\n                _commitPrice(oracleProviderFactory, value, ids, version, data, revertOnFailure);\n            } else if (invocation.action == PerennialAction.APPROVE) {\n                (address target) = abi.decode(invocation.args, (address));\n\n                _approve(target);\n            }\n        }\n        // ETH must not remain in this contract at rest\n        Address.sendValue(payable(msg.sender), address(this).balance);\n    }\n\n    /// @notice Updates market on behalf of account\n    /// @param account Address of account to update\n    /// @param market Address of market up update\n    /// @param newMaker New maker position for account in `market`\n    /// @param newLong New long position for account in `market`\n    /// @param newShort New short position for account in `market`\n    /// @param collateral Net change in collateral for account in `market`\n    /// @param wrap Wheather to wrap/unwrap collateral on deposit/withdrawal\n    /// @param interfaceFee1 Primary interface fee to charge\n    /// @param interfaceFee2 Secondary interface fee to charge\n    function _update(\n        address account,\n        IMarket market,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool wrap,\n        InterfaceFee memory interfaceFee1,\n        InterfaceFee memory interfaceFee2\n    ) internal isMarketInstance(market) {\n        Fixed18 balanceBefore =  Fixed18Lib.from(DSU.balanceOf());\n\n        // collateral is transferred here as DSU then an optional interface fee is charged from it\n        if (collateral.sign() == 1) _deposit(collateral.abs(), wrap);\n\n        market.update(account, newMaker, newLong, newShort, collateral, false);\n\n        Fixed6 withdrawAmount = Fixed6Lib.from(Fixed18Lib.from(DSU.balanceOf()).sub(balanceBefore));\n        if (!withdrawAmount.isZero()) _withdraw(account, withdrawAmount.abs(), wrap);\n\n        // charge interface fee\n        _chargeFee(account, market, interfaceFee1);\n        _chargeFee(account, market, interfaceFee2);\n    }\n\n    /// @notice Update vault on behalf of msg.sender\n    /// @param vault Address of vault to update\n    /// @param depositAssets Amount of assets to deposit into vault\n    /// @param redeemShares Amount of shares to redeem from vault\n    /// @param claimAssets Amount of assets to claim from vault\n    /// @param wrap Whether to wrap assets before depositing\n    function _vaultUpdate(\n        IVault vault,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets,\n        bool wrap\n    ) internal isVaultInstance(vault) {\n        if (!depositAssets.isZero()) {\n            _deposit(depositAssets, wrap);\n        }\n\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        vault.update(msg.sender, depositAssets, redeemShares, claimAssets);\n\n        // handle socialization, settlement fees, and magic values\n        UFixed6 claimAmount = claimAssets.isZero() ?\n            UFixed6Lib.ZERO :\n            UFixed6Lib.from(DSU.balanceOf().sub(balanceBefore));\n\n        if (!claimAmount.isZero()) {\n            _withdraw(msg.sender, claimAmount, wrap);\n        }\n    }\n\n    /// @notice Helper to max approve DSU for usage in a market or vault deployed by the registered factories\n    /// @param target Market or Vault to approve\n    function _approve(address target) internal {\n        if (\n            !marketFactory.instances(IInstance(target)) &&\n            !vaultFactory.instances(IInstance(target))\n        ) revert MultiInvokerInvalidInstanceError();\n\n        DSU.approve(target);\n    }\n\n    /// @notice Charges an interface fee from collateral in this address during an update to a receiver\n    /// @param account Account to charge fee from\n    /// @param market Market to charge fee from\n    /// @param interfaceFee Interface fee to charge\n    function _chargeFee(address account, IMarket market, InterfaceFee memory interfaceFee) internal {\n        if (interfaceFee.amount.isZero()) return;\n        _marketWithdraw(market, account, interfaceFee.amount);\n\n        if (interfaceFee.unwrap) _unwrap(interfaceFee.receiver, UFixed18Lib.from(interfaceFee.amount));\n        else DSU.push(interfaceFee.receiver, UFixed18Lib.from(interfaceFee.amount));\n\n        emit InterfaceFeeCharged(account, market, interfaceFee);\n    }\n\n    /// @notice Pull DSU or wrap and deposit USDC from msg.sender to this address for market usage\n    /// @param amount Amount to transfer\n    /// @param wrap Flag to wrap USDC to DSU\n    function _deposit(UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            USDC.pull(msg.sender, amount);\n            _wrap(address(this), UFixed18Lib.from(amount));\n        } else {\n            DSU.pull(msg.sender, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Push DSU or unwrap DSU to push USDC from this address to `account`\n    /// @param account Account to push DSU or USDC to\n    /// @param amount Amount to transfer\n    /// @param wrap flag to unwrap DSU to USDC\n    function _withdraw(address account, UFixed6 amount, bool wrap) internal {\n        if (wrap) {\n            _unwrap(account, UFixed18Lib.from(amount));\n        } else {\n            DSU.push(account, UFixed18Lib.from(amount));\n        }\n    }\n\n    /// @notice Helper function to wrap `amount` USDC from `address(this)` into DSU using the batcher or reserve\n    /// @param receiver Address to receive the DSU\n    /// @param amount Amount of USDC to wrap\n    function _wrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or  doesn't have enough for this wrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(DSU.balanceOf(address(batcher)))) {\n            reserve.mint(amount);\n            if (receiver != address(this)) DSU.push(receiver, amount);\n        } else {\n            // Wrap the USDC into DSU and return to the receiver\n            batcher.wrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to unwrap `amount` DSU into USDC and send to `receiver`\n    /// @param receiver Address to receive the USDC\n    /// @param amount Amount of DSU to unwrap\n    function _unwrap(address receiver, UFixed18 amount) internal {\n        // If the batcher is 0 or doesn't have enough for this unwrap, go directly to the reserve\n        if (address(batcher) == address(0) || amount.gt(UFixed18Lib.from(USDC.balanceOf(address(batcher))))) {\n            reserve.redeem(amount);\n            if (receiver != address(this)) USDC.push(receiver, UFixed6Lib.from(amount));\n        } else {\n            // Unwrap the DSU into USDC and return to the receiver\n            batcher.unwrap(amount, receiver);\n        }\n    }\n\n    /// @notice Helper function to commit a price to an oracle\n    /// @param oracleProviderFactory Address of oracle provider factory\n    /// @param value The ether value to pass on with the commit sub-call\n    /// @param version Version of oracle to commit to\n    /// @param data Data to commit to oracle\n    /// @param revertOnFailure Whether to revert on sub-call failure\n    function _commitPrice(\n        address oracleProviderFactory,\n        uint256 value,\n        bytes32[] memory ids,\n        uint256 version,\n        bytes memory data,\n        bool revertOnFailure\n    ) internal {\n        UFixed18 balanceBefore = DSU.balanceOf();\n\n        try IPythFactory(oracleProviderFactory).commit{value: value}(ids, version, data) {\n            // Return through keeper fee if any\n            DSU.push(msg.sender, DSU.balanceOf().sub(balanceBefore));\n        } catch (bytes memory reason) {\n            if (revertOnFailure) Address.verifyCallResult(false, reason, \"\");\n        }\n    }\n\n    /// @notice executes an `account's` open order for a `market` and pays a fee to `msg.sender`\n    /// @param account Account to execute order of\n    /// @param market Market to execute order for\n    /// @param nonce Id of open order to index\n    function _executeOrder(address account, IMarket market, uint256 nonce) internal {\n        if (!canExecuteOrder(account, market, nonce)) revert MultiInvokerCantExecuteError();\n\n        TriggerOrder memory order = orders(account, market, nonce);\n\n        _handleKeeperFee(\n            KeepConfig(\n                UFixed18Lib.ZERO,\n                keepBufferBase,\n                UFixed18Lib.ZERO,\n                keepBufferCalldata\n            ),\n            0,\n            msg.data[0:0],\n            0,\n            abi.encode(account, market, order.fee)\n        );\n\n        _marketSettle(market, account);\n\n        Order memory pending = market.pendings(account);\n        Position memory currentPosition = market.positions(account);\n        currentPosition.update(pending);\n\n        Fixed6 collateral = order.execute(currentPosition);\n\n        _update(\n            account,\n            market,\n            currentPosition.maker,\n            currentPosition.long,\n            currentPosition.short,\n            collateral,\n            true,\n            order.interfaceFee1,\n            order.interfaceFee2\n        );\n\n        delete _orders[account][market][nonce];\n        emit OrderExecuted(account, market, nonce);\n    }\n\n    /// @notice Helper function to raise keeper fee\n    /// @param keeperFee Keeper fee to raise\n    /// @param data Data to raise keeper fee with\n    /// @return Amount of keeper fee raised\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory data) internal virtual override returns (UFixed18) {\n        (address account, IMarket market, UFixed6 fee) = abi.decode(data, (address, IMarket, UFixed6));\n        UFixed6 raisedKeeperFee = UFixed6Lib.from(keeperFee, true).min(fee);\n        _marketWithdraw(market, account, raisedKeeperFee);\n\n        return UFixed18Lib.from(raisedKeeperFee);\n    }\n\n    /// @notice Places order on behalf of msg.sender from the invoker\n    /// @param account Account to place order for\n    /// @param market Market to place order in\n    /// @param order Order state to place\n    function _placeOrder(\n        address account,\n        IMarket market,\n        TriggerOrder memory order\n    ) internal isMarketInstance(market) {\n        if (order.fee.isZero()) revert MultiInvokerInvalidOrderError();\n        if (order.comparison != -1 && order.comparison != 1) revert MultiInvokerInvalidOrderError();\n        if (\n            order.side > 3 ||                                       // Invalid side\n            (order.side == 3 && order.delta.gte(Fixed6Lib.ZERO))    // Disallow placing orders that increase collateral\n        ) revert MultiInvokerInvalidOrderError();\n\n        _orders[account][market][++latestNonce].store(order);\n        emit OrderPlaced(account, market, latestNonce, order);\n    }\n\n    /// @notice Cancels an open order for msg.sender\n    /// @param account Account to cancel order for\n    /// @param market Market order is open in\n    /// @param nonce UID of order\n    function _cancelOrder(address account, IMarket market, uint256 nonce) internal {\n        delete _orders[account][market][nonce];\n        emit OrderCancelled(account, market, nonce);\n    }\n\n    /// @notice Withdraws `withdrawal` from `account`'s `market` position\n    /// @param market Market to withdraw from\n    /// @param account Account to withdraw from\n    /// @param withdrawal Amount to withdraw\n    function _marketWithdraw(IMarket market, address account, UFixed6 withdrawal) private {\n        market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.from(-1, withdrawal), false);\n    }\n\n    /// @notice Settles `account`'s `market` position\n    /// @param market Market to settle\n    /// @param account Account to settle\n    function _marketSettle(IMarket market, address account) private {\n        _marketWithdraw(market, account, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Target market must be created by MarketFactory\n    modifier isMarketInstance(IMarket market) {\n        if (!marketFactory.instances(market))\n            revert MultiInvokerInvalidInstanceError();\n        _;\n    }\n\n    /// @notice Target vault must be created by VaultFactory\n    modifier isVaultInstance(IVault vault) {\n        if (!vaultFactory.instances(vault))\n            revert MultiInvokerInvalidInstanceError();\n        _;\n    }\n}\n"
    },
    "@equilibria/perennial-v2-extensions/contracts/types/InterfaceFee.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev Interface fee type\nstruct InterfaceFee {\n    /// @dev The amount of the fee\n    UFixed6 amount;\n\n    /// @dev The address to send the fee to\n    address receiver;\n\n    /// @dev Whether or not to unwrap the fee\n    bool unwrap;\n}\n"
    },
    "@equilibria/perennial-v2-extensions/contracts/types/TriggerOrder.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport \"@equilibria/perennial-v2/contracts/types/Position.sol\";\nimport \"./InterfaceFee.sol\";\n\nstruct TriggerOrder {\n    uint8 side;\n    int8 comparison;\n    UFixed6 fee;\n    Fixed6 price;\n    Fixed6 delta;\n    InterfaceFee interfaceFee1;\n    InterfaceFee interfaceFee2;\n}\nusing TriggerOrderLib for TriggerOrder global;\nstruct StoredTriggerOrder {\n    /* slot 0 */\n    uint8 side;         // 0 = maker, 1 = long, 2 = short\n    int8 comparison;    // -2 = lt, -1 = lte, 0 = eq, 1 = gte, 2 = gt\n    uint64 fee;         // <= 18.44tb\n    int64 price;        // <= 9.22t\n    int64 delta;        // <= 9.22t\n    bytes6 __unallocated0__;\n\n    /* slot 1 */\n    address interfaceFeeReceiver1;\n    uint48 interfaceFeeAmount1;      // <= 281m\n    bool interfaceFeeUnwrap1;\n    bytes5 __unallocated1__;\n\n    /* slot 2 */\n    address interfaceFeeReceiver2;\n    uint48 interfaceFeeAmount2;      // <= 281m\n    bool interfaceFeeUnwrap2;\n    bytes5 __unallocated2__;\n}\nstruct TriggerOrderStorage { StoredTriggerOrder value; }\nusing TriggerOrderStorageLib for TriggerOrderStorage global;\n\n/**\n * @title TriggerOrderLib\n * @notice Library for TriggerOrder logic and data.\n */\nlibrary TriggerOrderLib {\n    // @notice Returns whether the trigger order is fillable at the latest price\n    // @param self The trigger order\n    // @param latestVersion The latest oracle version\n    // @return Whether the trigger order is fillable\n    function fillable(TriggerOrder memory self, OracleVersion memory latestVersion) internal pure returns (bool) {\n        if (!latestVersion.valid) return false;\n        if (self.comparison == 1) return latestVersion.price.gte(self.price);\n        if (self.comparison == -1) return latestVersion.price.lte(self.price);\n        return false;\n    }\n\n    // @notice Executes the trigger order on the given position\n    // @param self The trigger order\n    // @param currentPosition The current position\n    // @return The collateral delta, if any\n    function execute(\n        TriggerOrder memory self,\n        Position memory currentPosition\n    ) internal pure returns (Fixed6 collateral) {\n        // update position\n        if (self.side == 0)\n            currentPosition.maker = self.delta.isZero() ?\n                UFixed6Lib.ZERO :\n                UFixed6Lib.from(Fixed6Lib.from(currentPosition.maker).add(self.delta));\n        if (self.side == 1)\n            currentPosition.long = self.delta.isZero() ?\n                UFixed6Lib.ZERO :\n                UFixed6Lib.from(Fixed6Lib.from(currentPosition.long).add(self.delta));\n        if (self.side == 2)\n            currentPosition.short = self.delta.isZero() ?\n                UFixed6Lib.ZERO :\n                UFixed6Lib.from(Fixed6Lib.from(currentPosition.short).add(self.delta));\n\n        // Handles collateral withdrawal magic value\n        if (self.side == 3) collateral = (self.delta.eq(Fixed6.wrap(type(int64).min)) ? Fixed6Lib.MIN : self.delta);\n    }\n}\n\nlibrary TriggerOrderStorageLib {\n    // sig: 0xf3469aa7\n    error TriggerOrderStorageInvalidError();\n\n    function read(TriggerOrderStorage storage self) internal view returns (TriggerOrder memory) {\n        StoredTriggerOrder memory storedValue = self.value;\n        return TriggerOrder(\n            uint8(storedValue.side),\n            int8(storedValue.comparison),\n            UFixed6.wrap(uint256(storedValue.fee)),\n            Fixed6.wrap(int256(storedValue.price)),\n            Fixed6.wrap(int256(storedValue.delta)),\n            InterfaceFee(\n                UFixed6.wrap(uint256(storedValue.interfaceFeeAmount1)),\n                storedValue.interfaceFeeReceiver1,\n                storedValue.interfaceFeeUnwrap1\n            ),\n            InterfaceFee(\n                UFixed6.wrap(uint256(storedValue.interfaceFeeAmount2)),\n                storedValue.interfaceFeeReceiver2,\n                storedValue.interfaceFeeUnwrap2\n            )\n        );\n    }\n\n    function store(TriggerOrderStorage storage self, TriggerOrder memory newValue) internal {\n        if (newValue.side > type(uint8).max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison > type(int8).max) revert TriggerOrderStorageInvalidError();\n        if (newValue.comparison < type(int8).min) revert TriggerOrderStorageInvalidError();\n        if (newValue.fee.gt(UFixed6.wrap(type(uint64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.gt(Fixed6.wrap(type(int64).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.delta.lt(Fixed6.wrap(type(int64).min))) revert TriggerOrderStorageInvalidError();\n        if (newValue.interfaceFee1.amount.gt(UFixed6.wrap(type(uint48).max))) revert TriggerOrderStorageInvalidError();\n        if (newValue.interfaceFee2.amount.gt(UFixed6.wrap(type(uint48).max))) revert TriggerOrderStorageInvalidError();\n\n        self.value = StoredTriggerOrder(\n            uint8(newValue.side),\n            int8(newValue.comparison),\n            uint64(UFixed6.unwrap(newValue.fee)),\n            int64(Fixed6.unwrap(newValue.price)),\n            int64(Fixed6.unwrap(newValue.delta)),\n            bytes6(0),\n            newValue.interfaceFee1.receiver,\n            uint48(UFixed6.unwrap(newValue.interfaceFee1.amount)),\n            newValue.interfaceFee1.unwrap,\n            bytes5(0),\n            newValue.interfaceFee2.receiver,\n            uint48(UFixed6.unwrap(newValue.interfaceFee2.amount)),\n            newValue.interfaceFee2.unwrap,\n            bytes5(0)\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IKeeperFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport \"@equilibria/root/attribute/interfaces/IKept.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\";\nimport \"./IKeeperOracle.sol\";\nimport \"./IOracleFactory.sol\";\nimport \"./IPayoffProvider.sol\";\n\ninterface IKeeperFactory is IOracleProviderFactory, IFactory, IKept {\n    struct Granularity {\n        uint64 latestGranularity;\n        uint64 currentGranularity;\n        uint128 effectiveAfter;\n    }\n\n    struct PayoffDefinition {\n        IPayoffProvider provider;\n        int16 decimals;\n    }\n\n    struct PriceRecord {\n        uint256 timestamp;\n        Fixed18 price;\n    }\n\n    event OracleAssociated(bytes32 indexed id, bytes32 indexed underlyingId);\n    event GranularityUpdated(uint256 newGranularity, uint256 effectiveAfter);\n    event CallerAuthorized(IFactory indexed caller);\n    event PayoffRegistered(IPayoffProvider indexed payoff);\n\n    // sig: 0xe65b0914\n    error KeeperFactoryNotInstanceError();\n    // sig: 0x19136990\n    error KeeperFactoryInvalidGranularityError();\n    // sig: 0x953ec95c\n    error KeeperFactoryAlreadyCreatedError();\n    // sig: 0x7e387175\n    error KeeperFactoryNotCreatedError();\n    // sig: 0x131b567b\n    error KeeperFactoryInvalidIdError();\n    // sig: 0xb043fd7b\n    error KeeperFactoryInvalidSettleError();\n    // sig: 0xb2e11555\n    error KeeperFactoryInvalidPayoffError();\n    // sig: 0x0afa0593\n    error KeeperFactoryVersionOutsideRangeError();\n\n    function validFrom() external view returns (uint256);\n    function validTo() external view returns (uint256);\n    function commitKeepConfig(uint256 numRequested) external view returns (KeepConfig memory);\n    function settleKeepConfig() external view returns (KeepConfig memory);\n\n    function initialize(IOracleFactory oracleFactory, AggregatorV3Interface chainlinkFeed_, Token18 dsu_) external;\n    function authorize(IFactory factory) external;\n    function register(IPayoffProvider payoff) external;\n    function toUnderlyingId(bytes32 id) external returns (bytes32);\n    function toUnderlyingPayoff(bytes32 id) external returns (PayoffDefinition memory payoff);\n    function fromUnderlying(bytes32 underlyingId, IPayoffProvider payoff) external returns (bytes32);\n    function create(bytes32 id, bytes32 underlyingId, PayoffDefinition memory payoff) external returns (IKeeperOracle oracle);\n    function current() external view returns (uint256);\n    function granularity() external view returns (Granularity memory);\n    function updateGranularity(uint256 newGranularity) external;\n    function commit(bytes32[] memory ids, uint256 version, bytes calldata data) external payable;\n    function settle(bytes32[] memory ids, IMarket[] memory markets, uint256[] memory versions, uint256[] memory maxCounts) external;\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IKeeperOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProvider.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport \"../Oracle.sol\";\n\ninterface IKeeperOracle is IOracleProvider, IInstance {\n    event CallbackRequested(SettlementCallback indexed callback);\n    event CallbackFulfilled(SettlementCallback indexed callback);\n\n    struct SettlementCallback {\n        /// @dev The market to settle\n        IMarket market;\n\n        /// @dev The account to settle\n        address account;\n\n        /// @dev The version to settle for\n        uint256 version;\n    }\n\n    struct Global {\n        /// @dev The latest committed oracle version\n        uint64 latestVersion;\n\n        /// @dev Index in `versions` of the most recent version requested\n        uint64 currentIndex;\n\n        /// @dev Index in `versions` of the latest version a keeper has committed\n        uint64 latestIndex;\n    }\n\n    // sig: 0xb8499c31\n    error KeeperOracleVersionOutsideRangeError();\n    // sig: 0xce9529c8\n    error KeeperOracleInvalidPriceError();\n    //sig: 0x4889ef6f\n    error KeeperOracleInvalidCallbackError();\n\n    function initialize() external;\n    function commit(OracleVersion memory version) external returns (bool);\n    function settle(IMarket market, uint256 version, uint256 maxCount) external;\n    function next() external view returns (uint256);\n    function globalCallbacks(uint256 version) external view returns (address[] memory);\n    function localCallbacks(uint256 version, IMarket market) external view returns (address[] memory);\n\n    function timeout() external view returns (uint256);\n    function versions(uint256 index) external view returns (uint256);\n    function global() external view returns (Global memory);\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProvider.sol\";\n\ninterface IOracle is IOracleProvider, IInstance {\n    // sig: 0x8852e53b\n    error OracleOutOfSyncError();\n    // sig: 0x0f7338e5\n    error OracleOutOfOrderCommitError();\n\n    event OracleUpdated(IOracleProvider newProvider);\n\n    /// @dev The state for a single epoch\n    struct Epoch {\n        /// @dev The oracle provider for this epoch\n        IOracleProvider provider;\n\n        /// @dev The last timestamp that this oracle provider is valid\n        uint96 timestamp;\n    }\n\n    /// @dev The global state for oracle\n    struct Global {\n        /// @dev The current epoch\n        uint128 current;\n\n        /// @dev The latest epoch\n        uint128 latest;\n    }\n\n    function initialize(IOracleProvider initialProvider) external;\n    function update(IOracleProvider newProvider) external;\n}"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IOracleFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport \"./IOracle.sol\";\n\ninterface IOracleFactory is IOracleProviderFactory, IFactory {\n    event MaxClaimUpdated(UFixed6 newMaxClaim);\n    event FactoryRegistered(IOracleProviderFactory factory);\n    event CallerAuthorized(IFactory caller);\n\n    // sig: 0xe7911099\n    error OracleFactoryInvalidIdError();\n    // sig: 0xe232e366\n    error OracleFactoryAlreadyCreatedError();\n    // sig: 0xbbfaa925\n    error OracleFactoryNotRegisteredError();\n    // sig: 0xfeb0e18c\n    error OracleFactoryNotCreatedError();\n    // sig: 0x4ddc5544\n    error OracleFactoryClaimTooLargeError();\n\n    function factories(IOracleProviderFactory factory) external view returns (bool);\n    function initialize(Token18 incentive) external;\n    function register(IOracleProviderFactory factory) external;\n    function create(bytes32 id, IOracleProviderFactory factory) external returns (IOracle newOracle);\n    function update(bytes32 id, IOracleProviderFactory factory) external;\n    function updateMaxClaim(UFixed6 newClaimAmount) external;\n    function maxClaim() external view returns (UFixed6);\n    function claim(UFixed6 amount) external;\n    function callers(IFactory caller) external view returns (bool);\n    function fund(IMarket market) external;\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IPayoffProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/Fixed18.sol\";\n\ninterface IPayoffProvider {\n    function payoff(Fixed18 price) external pure returns (Fixed18 payoff);\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/interfaces/IPythFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IKeeperFactory.sol\";\n\ninterface IPythFactory is IKeeperFactory {\n    // sig: 0x22445848\n    error PythFactoryInvalidIdError();\n}\n\n/// @dev PythStaticFee interface, this is not exposed in the AbstractPyth contract\ninterface IPythStaticFee {\n    function singleUpdateFeeInWei() external view returns (uint);\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@equilibria/root/attribute/Factory.sol\";\nimport \"@equilibria/root/attribute/Kept/Kept.sol\";\nimport \"../interfaces/IKeeperFactory.sol\";\nimport \"../interfaces/IOracleFactory.sol\";\n\n/// @title KeeperFactory\n/// @notice Factory contract for creating and managing keeper-based oracles\nabstract contract KeeperFactory is IKeeperFactory, Factory, Kept {\n    /// @dev The maximum value for granularity\n    uint256 public constant MAX_GRANULARITY = 1 hours;\n\n    /// @dev A Keeper update must come at least this long after a version to be valid\n    uint256 public immutable validFrom;\n\n    /// @dev A Keeper update must come at most this long after a version to be valid\n    uint256 public immutable validTo;\n\n    /// @dev The multiplier for the keeper fee on top of cost of commit\n    UFixed18 internal immutable _keepCommitMultiplierBase;\n\n    /// @dev The fixed gas buffer that is added to the keeper fee for commits\n    uint256 internal immutable _keepCommitBufferBase;\n\n    /// @dev The multiplier for the calldata portion of the keeper fee on top of cost of commit\n    UFixed18 internal immutable _keepCommitMultiplierCalldata;\n\n    /// @dev The fixed gas buffer that is added to the calldata portion of the keeper fee for commits\n    uint256 internal immutable _keepCommitBufferCalldata;\n\n    /// @dev The fixed gas buffer that is added for each incremental update\n    uint256 internal immutable _keepCommitIncrementalBufferCalldata;\n\n    /// @dev The multiplier for the keeper fee on top of cost of settle\n    UFixed18 internal immutable _keepSettleMultiplierBase;\n\n    /// @dev The fixed gas buffer that is added to the keeper fee for settles\n    uint256 internal immutable _keepSettleBufferBase;\n\n    /// @dev The multiplier for the calldata portion of the keeper fee on top of cost of settle\n    UFixed18 internal immutable _keepSettleMultiplierCalldata;\n\n    /// @dev The fixed gas buffer that is added to the calldata portion of the keeper fee for settles\n    uint256 internal immutable _keepSettleBufferCalldata;\n\n    /// @dev The root oracle factory\n    IOracleFactory public oracleFactory;\n\n    /// @dev Mapping of which factory's instances are authorized to request from this factory's instances\n    mapping(IFactory => bool) public callers;\n\n    /// @dev Registered payoff providers\n    mapping(IPayoffProvider => bool) public payoffs;\n\n    /// @dev Mapping of oracle id to oracle instance\n    mapping(bytes32 => IOracleProvider) public oracles;\n\n    /// @dev Mapping of oracle id to underlying id\n    mapping(bytes32 => bytes32) public toUnderlyingId;\n\n    /// @dev Mapping of oracle id to payoff provider\n    mapping(bytes32 => PayoffDefinition) public _toUnderlyingPayoff;\n\n    /// @dev Mapping of oracle id to underlying id\n    mapping(bytes32 => mapping(IPayoffProvider => bytes32)) public fromUnderlying;\n\n    /// @notice The granularity of the oracle\n    Granularity private _granularity;\n\n    /// @notice Initializes the immutable contract state\n    /// @param implementation_ IKeeperOracle implementation contract\n    /// @param validFrom_ The minimum time after a version that a keeper update can be valid\n    /// @param validTo_ The maximum time after a version that a keeper update can be valid\n    /// @param commitKeepConfig_ Parameter configuration for commit keeper incentivization\n    /// @param settleKeepConfig_ Parameter configuration for settle keeper incentivization\n    /// @param keepCommitIncrementalBufferCallata_ Calldata buffer amount for each incremental requested update\n    constructor(\n        address implementation_,\n        uint256 validFrom_,\n        uint256 validTo_,\n        KeepConfig memory commitKeepConfig_,\n        KeepConfig memory settleKeepConfig_,\n        uint256 keepCommitIncrementalBufferCallata_\n    ) Factory(implementation_) {\n        validFrom = validFrom_;\n        validTo = validTo_;\n        _keepCommitMultiplierBase = commitKeepConfig_.multiplierBase;\n        _keepCommitBufferBase = commitKeepConfig_.bufferBase;\n        _keepCommitMultiplierCalldata = commitKeepConfig_.multiplierCalldata;\n        _keepCommitBufferCalldata = commitKeepConfig_.bufferCalldata;\n        _keepCommitIncrementalBufferCalldata = keepCommitIncrementalBufferCallata_;\n        _keepSettleMultiplierBase = settleKeepConfig_.multiplierBase;\n        _keepSettleBufferBase = settleKeepConfig_.bufferBase;\n        _keepSettleMultiplierCalldata = settleKeepConfig_.multiplierCalldata;\n        _keepSettleBufferCalldata = settleKeepConfig_.bufferCalldata;\n    }\n\n    /// @notice Initializes the contract state\n    /// @param oracleFactory_ The root oracle factory\n    function initialize(\n        IOracleFactory oracleFactory_,\n        AggregatorV3Interface chainlinkFeed_,\n        Token18 dsu_\n    ) external initializer(1) {\n        __Factory__initialize();\n        __Kept__initialize(chainlinkFeed_, dsu_);\n\n        oracleFactory = oracleFactory_;\n        _granularity = Granularity(0, 1, 0);\n        payoffs[IPayoffProvider(address(0))] = true;\n    }\n\n    /// @notice Authorizes a factory's instances to request from this factory's instances\n    /// @param factory The factory to authorize\n    function authorize(IFactory factory) external onlyOwner {\n        callers[factory] = true;\n        emit CallerAuthorized(factory);\n    }\n\n    /// @notice Authorizes a factory's instances to request from this factory's instances\n    /// @param payoff The payoff provider to register\n    function register(IPayoffProvider payoff) external onlyOwner {\n        payoffs[payoff] = true;\n        emit PayoffRegistered(payoff);\n    }\n\n    /// @notice Creates a new oracle instance\n    /// @param id The id of the oracle to create\n    /// @param underlyingId The underlying id of the oracle to create\n    /// @param payoff The payoff provider for the oracle\n    /// @return newOracle The newly created oracle instance\n    function create(\n        bytes32 id,\n        bytes32 underlyingId,\n        PayoffDefinition memory payoff\n     ) public virtual onlyOwner returns (IKeeperOracle newOracle) {\n        if (oracles[id] != IOracleProvider(address(0))) revert KeeperFactoryAlreadyCreatedError();\n        if (!payoffs[payoff.provider]) revert KeeperFactoryInvalidPayoffError();\n        if (fromUnderlying[underlyingId][payoff.provider] != bytes32(0)) revert KeeperFactoryAlreadyCreatedError();\n\n        newOracle = IKeeperOracle(address(_create(abi.encodeCall(IKeeperOracle.initialize, ()))));\n        oracles[id] = newOracle;\n        toUnderlyingId[id] = underlyingId;\n        _toUnderlyingPayoff[id] = payoff;\n        fromUnderlying[underlyingId][payoff.provider] = id;\n\n        emit OracleCreated(newOracle, id);\n    }\n\n    /// @notice Returns the current timestamp\n    /// @dev Rounded up to the nearest granularity\n    /// @return The current timestamp\n    function current() public view returns (uint256) {\n        uint256 effectiveGranularity = block.timestamp <= uint256(_granularity.effectiveAfter) ?\n            uint256(_granularity.latestGranularity) :\n            uint256(_granularity.currentGranularity);\n\n        return Math.ceilDiv(block.timestamp, effectiveGranularity) * effectiveGranularity;\n    }\n\n    /// @notice Commits the price to specified version\n    /// @dev Accepts both requested and non-requested versions.\n    ///      Requested versions will pay out a keeper fee, non-requested versions will not.\n    ///      Accepts any publish time in the underlying price message, as long as it is within the validity window,\n    ///      which means its possible for publish times to be slightly out of order with respect to versions.\n    ///      Batched updates are supported by passing in a list of price feed ids along with a valid batch update data.\n    /// @param ids The list of price feed ids to commit\n    /// @param version The oracle version to commit\n    /// @param data The update data to commit\n    function commit(bytes32[] memory ids, uint256 version, bytes calldata data) external payable {\n        bool valid = data.length != 0;\n        PriceRecord[] memory prices = valid ? _parsePrices(ids, data) : new PriceRecord[](ids.length);\n        if (valid) _validatePrices(version, prices);\n        _transformPrices(ids, prices);\n\n        uint256 numRequested;\n        for (uint256 i; i < ids.length; i++)\n            if (IKeeperOracle(address(oracles[ids[i]])).commit(\n                OracleVersion(version, Fixed6Lib.from(prices[i].price), valid))\n            ) numRequested++;\n\n        if (numRequested != 0) _handleKeeperFee(\n            commitKeepConfig(numRequested),\n            0,\n            msg.data[0:0],\n            _applicableValue(numRequested, data),\n            \"\"\n        );\n    }\n\n    /// @notice Returns the keep config for commit\n    function commitKeepConfig(uint256 numRequested) public view returns (KeepConfig memory) {\n        return KeepConfig(\n            _keepCommitMultiplierBase,\n            _keepCommitBufferBase * numRequested,\n            _keepCommitMultiplierCalldata,\n            _keepCommitBufferCalldata + _keepCommitIncrementalBufferCalldata * numRequested\n        );\n    }\n\n    /// @notice Returns the keep config for settle\n    function settleKeepConfig() public view returns (KeepConfig memory) {\n        return KeepConfig(\n            _keepSettleMultiplierBase,\n            _keepSettleBufferBase,\n            _keepSettleMultiplierCalldata,\n            _keepSettleBufferCalldata\n        );\n    }\n\n    /// @notice Performs a list of local settlement callbacks\n    /// @dev Pays out a keeper incentive if all supplied local settlement callbacks succeed\n    ///      Each array must be the same length, each index is a separate corresponding callback entry\n    /// @param ids The list of price feed ids to settle\n    /// @param markets The list of markets to settle\n    /// @param versions The list of versions to settle\n    /// @param maxCounts The list of maximum number of settlement callbacks to perform before exiting\n    function settle(bytes32[] memory ids, IMarket[] memory markets, uint256[] memory versions, uint256[] memory maxCounts)\n        external\n        keep(settleKeepConfig(), abi.encode(ids, markets, versions, maxCounts), 0, \"\")\n    {\n        if (\n            ids.length == 0 ||\n            ids.length != markets.length ||\n            ids.length != versions.length ||\n            ids.length != maxCounts.length\n        ) revert KeeperFactoryInvalidSettleError();\n\n        for (uint256 i; i < ids.length; i++)\n            IKeeperOracle(address(oracles[ids[i]])).settle(markets[i], versions[i], maxCounts[i]);\n    }\n\n    /// @notice Pulls funds from the factory to award the keeper\n    /// @param keeperFee The keeper fee to pull\n    /// @return The keeper fee that was raised\n    function _raiseKeeperFee(UFixed18 keeperFee, bytes memory) internal virtual override returns (UFixed18) {\n        UFixed6 raisedKeeperFee = UFixed6Lib.from(keeperFee, true).min(oracleFactory.maxClaim());\n        oracleFactory.claim(raisedKeeperFee);\n        return UFixed18Lib.from(raisedKeeperFee);\n    }\n\n    /// @notice Returns the granularity\n    /// @return The granularity\n    function granularity() external view returns (Granularity memory) {\n        return _granularity;\n    }\n\n    /// @notice Updates the granularity\n    /// @param newGranularity The new granularity\n    function updateGranularity(uint256 newGranularity) external onlyOwner {\n        uint256 _current = current();\n        if (newGranularity == 0) revert KeeperFactoryInvalidGranularityError();\n        if (_current <= uint256(_granularity.effectiveAfter)) revert KeeperFactoryInvalidGranularityError();\n        if (newGranularity > MAX_GRANULARITY) revert KeeperFactoryInvalidGranularityError();\n\n        _granularity = Granularity(\n            _granularity.currentGranularity,\n            uint64(newGranularity),\n            uint128(_current)\n        );\n        emit GranularityUpdated(newGranularity, _current);\n    }\n\n    /// @notice Returns whether a caller is authorized to request from this factory's instances\n    /// @param caller The caller to check\n    /// @return Whether the caller is authorized\n    function authorized(address caller) external view returns (bool) {\n        IInstance callerInstance = IInstance(caller);\n        IFactory callerFactory = callerInstance.factory();\n        if (!callerFactory.instances(callerInstance)) return false;\n        return callers[callerFactory];\n    }\n\n    /// @notice Returns the payoff definition for the specified id\n    /// @param id The id to lookup\n    /// @return The payoff definition\n    function toUnderlyingPayoff(bytes32 id) external view returns (PayoffDefinition memory) {\n        return _toUnderlyingPayoff[id];\n    }\n\n    /// @notice Transforms the price records by the payoff and decimal offset\n    /// @param ids The list of price feed ids to transform\n    /// @param prices The list of price records to transform\n    function _transformPrices(bytes32[] memory ids, PriceRecord[] memory prices) private view {\n        for (uint256 i; i < prices.length; i++) {\n            PayoffDefinition memory payoff = _toUnderlyingPayoff[ids[i]];\n\n            // apply payoff if it exists\n            if (payoff.provider != IPayoffProvider(address(0)))\n                prices[i].price = payoff.provider.payoff(prices[i].price);\n\n            // apply decimal offset\n            Fixed18 base = Fixed18Lib.from(int256(10 ** SignedMath.abs(payoff.decimals)));\n            prices[i].price = payoff.decimals < 0 ? prices[i].price.div(base) : prices[i].price.mul(base);\n        }\n    }\n\n    /// @notice Validates that the parse price record has a valid timestamp\n    /// @param version The oracle version to validate against\n    /// @param prices The list of price records to validate\n    function _validatePrices(uint256 version, PriceRecord[] memory prices) private view {\n        for (uint256 i; i < prices.length; i++)\n            if (prices[i].timestamp < version + validFrom || prices[i].timestamp > version + validTo)\n                revert KeeperFactoryVersionOutsideRangeError();\n    }\n\n    /// @notice Returns the applicable value for the keeper fee\n    /// @param numRequested The number of requested price commits\n    /// @param data The price commit update data\n    /// @return The applicable value for the keeper fee\n    function _applicableValue(uint256 numRequested, bytes memory data) internal view virtual returns (uint256) {\n        return 0;\n    }\n\n    /// @notice Validates and parses the update data payload against the specified version\n    /// @param ids The list of price feed ids validate against\n    /// @param data The update data to validate\n    /// @return prices The parsed price list if valid\n    function _parsePrices(\n        bytes32[] memory ids,\n        bytes calldata data\n    ) internal virtual returns (PriceRecord[] memory prices);\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"../interfaces/IKeeperFactory.sol\";\nimport \"./types/Price.sol\";\n\n/// @title KeeperOracle\n/// @notice Generic implementation of the IOracle interface for keeper-based oracles.\n/// @dev One instance per price feed should be deployed. Multiple products may use the same\n///      KeeperOracle instance if their payoff functions are based on the same underlying oracle.\n///      This implementation only supports non-negative prices.\ncontract KeeperOracle is IKeeperOracle, Instance {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\n    uint256 public immutable timeout;\n\n    /// @dev List of all requested oracle versions\n    mapping(uint256 => uint256) public versions;\n\n    /// @dev The global state of the oracle\n    Global private _global;\n\n    /// @dev Mapping from oracle version to oracle version data\n    mapping(uint256 => PriceStorage) private _prices;\n\n    /// @dev Mapping from version to a set of registered markets for settlement callback\n    mapping(uint256 => EnumerableSet.AddressSet) private _globalCallbacks;\n\n    /// @dev Mapping from version and market to a set of registered accounts for settlement callback\n    mapping(uint256 => mapping(IMarket => EnumerableSet.AddressSet)) private _localCallbacks;\n\n    /// @notice Constructs the contract\n    /// @param timeout_ The timeout for a version to be committed\n    constructor(uint256 timeout_)  {\n        timeout = timeout_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Instance__initialize();\n    }\n\n    /// @notice Returns the global state of the oracle\n    /// @return The global state of the oracle\n    function global() external view returns (Global memory) { return _global; }\n\n    /// @notice Returns the global oracle callback set for a version\n    /// @param version The version to lookup\n    /// @return The global oracle callback set for the version\n    function globalCallbacks(uint256 version) external view returns (address[] memory) {\n        return _globalCallbacks[version].values();\n    }\n\n    /// @notice Returns the local oracle callback set for a version and market\n    /// @param version The version to lookup\n    /// @param market The market to lookup\n    /// @return The local oracle callback set for the version and market\n    function localCallbacks(uint256 version, IMarket market) external view returns (address[] memory) {\n        return _localCallbacks[version][market].values();\n    }\n\n    /// @notice Returns the next requested oracle version\n    /// @dev Returns 0 if no next version is requested\n    /// @return The next requested oracle version\n    function next() public view returns (uint256) {\n        return versions[_global.latestIndex + 1];\n    }\n\n    /// @notice Records a request for a new oracle version\n    /// @param market The market to callback to\n    /// @param account The account to callback to\n    function request(IMarket market, address account) external onlyAuthorized {\n        uint256 currentTimestamp = current();\n\n        _globalCallbacks[currentTimestamp].add(address(market));\n        _localCallbacks[currentTimestamp][market].add(account);\n        emit CallbackRequested(SettlementCallback(market, account, currentTimestamp));\n\n        if (versions[_global.currentIndex] == currentTimestamp) return;\n        versions[++_global.currentIndex] = currentTimestamp;\n        emit OracleProviderVersionRequested(currentTimestamp);\n    }\n\n    /// @notice Returns the latest synced oracle version and the current oracle version\n    /// @return The latest synced oracle version\n    /// @return The current oracle version collecting new orders\n    function status() external view returns (OracleVersion memory, uint256) {\n        return (latest(), current());\n    }\n\n    /// @notice Returns the latest synced oracle version\n    /// @return Latest oracle version\n    function latest() public view returns (OracleVersion memory) {\n        return at(_global.latestVersion);\n    }\n\n    /// @notice Returns the current oracle version accepting new orders\n    /// @return Current oracle version\n    function current() public view returns (uint256) {\n        return IKeeperFactory(address(factory())).current();\n    }\n\n    /// @notice Returns the oracle version at version `version`\n    /// @param timestamp The timestamp of which to lookup\n    /// @return oracleVersion Oracle version at version `version`\n    function at(uint256 timestamp) public view returns (OracleVersion memory) {\n        return _prices[timestamp].read().toOracleVersion(timestamp);\n    }\n\n    /// @notice Commits the price to specified version\n    /// @dev Verification of price happens in the oracle's factory\n    /// @param version The oracle version to commit\n    /// @return requested Whether the commit was requested\n    function commit(OracleVersion memory version) external onlyFactory returns (bool requested) {\n        if (version.timestamp == 0) revert KeeperOracleVersionOutsideRangeError();\n        requested = (version.timestamp == next()) ? _commitRequested(version) : _commitUnrequested(version);\n        _global.latestVersion = uint64(version.timestamp);\n\n        for (uint256 i; i < _globalCallbacks[version.timestamp].length(); i++)\n            _settle(IMarket(_globalCallbacks[version.timestamp].at(i)), address(0));\n\n        emit OracleProviderVersionFulfilled(version);\n    }\n\n    /// @notice Performs an asynchronous local settlement callback\n    /// @dev Distribution of keeper incentive is consolidated in the oracle's factory\n    /// @param market The market to settle\n    /// @param version The version to settle\n    /// @param maxCount The maximum number of settlement callbacks to perform before exiting\n    function settle(IMarket market, uint256 version, uint256 maxCount) external onlyFactory {\n        EnumerableSet.AddressSet storage callbacks = _localCallbacks[version][market];\n\n        if (_global.latestVersion < version) revert KeeperOracleVersionOutsideRangeError();\n        if (maxCount == 0) revert KeeperOracleInvalidCallbackError();\n        if (callbacks.length() == 0) revert KeeperOracleInvalidCallbackError();\n\n        for (uint256 i; i < maxCount && callbacks.length() > 0; i++) {\n            address account = callbacks.at(0);\n            _settle(market, account);\n            callbacks.remove(account);\n            emit CallbackFulfilled(SettlementCallback(market, account, version));\n        }\n    }\n\n    /// @notice Commits the price to a requested version\n    /// @dev This commit function will pay out a keeper fee for providing a valid price or carrying over latest price\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitRequested(OracleVersion memory version) private returns (bool) {\n        if (block.timestamp <= (next() + timeout)) {\n            if (!version.valid) revert KeeperOracleInvalidPriceError();\n            _prices[version.timestamp].store(Price(version.price, true));\n        } else {\n            Price memory latestPrice = _prices[_global.latestVersion].read();\n            _prices[version.timestamp].store(Price(latestPrice.price, false));\n        }\n        _global.latestIndex++;\n        return true;\n    }\n\n    /// @notice Commits the price to a non-requested version\n    /// @param version The oracle version to commit\n    /// @return Whether the commit was requested\n    function _commitUnrequested(OracleVersion memory version) private returns (bool) {\n        if (!version.valid) revert KeeperOracleInvalidPriceError();\n        if (version.timestamp <= _global.latestVersion || (next() != 0 && version.timestamp >= next()))\n            revert KeeperOracleVersionOutsideRangeError();\n\n        _prices[version.timestamp].store(Price(version.price, true));\n        return false;\n    }\n\n    /// @notice Performs a settlement callback for the account on the market\n    /// @param market The market to settle\n    /// @param account The account to settle\n    function _settle(IMarket market, address account) private {\n        market.settle(account);\n    }\n\n    /// @dev Only allow authorized callers\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\n        _;\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/keeper/types/Price.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"@equilibria/perennial-v2/contracts/types/OracleVersion.sol\";\n\nstruct Price {\n    Fixed6 price;\n    bool valid;\n}\nusing PriceLib for Price global;\nstruct StoredPrice {\n    int64 price;\n    bool valid;\n}\nstruct PriceStorage { StoredPrice value; }\nusing PriceStorageLib for PriceStorage global;\n\n/**\n * @title PriceLib\n * @notice Library for Price logic and data.\n */\nlibrary PriceLib {\n    // @notice Returns an oracle version based on the price snapshot and timestamp\n    // @param self The price snapshot object\n    // @param timestamp The timestamp of the price snapshot\n    // @return The corresponding oracle version\n    function toOracleVersion(Price memory self, uint256 timestamp) internal pure returns (OracleVersion memory) {\n        return OracleVersion(timestamp, self.price, self.valid);\n    }\n}\n\nlibrary PriceStorageLib {\n    // sig: 0x2dbc6ed2\n    error PriceStorageInvalidError();\n\n    function read(PriceStorage storage self) internal view returns (Price memory) {\n        StoredPrice memory storedValue = self.value;\n        return Price(Fixed6.wrap(int256(storedValue.price)), storedValue.valid);\n    }\n\n    function store(PriceStorage storage self, Price memory newValue) internal {\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert PriceStorageInvalidError();\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert PriceStorageInvalidError();\n\n        self.value = StoredPrice(int64(Fixed6.unwrap(newValue.price)), newValue.valid);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/Oracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport \"./interfaces/IOracle.sol\";\n\n/// @title Oracle\n/// @notice The top-level oracle contract that implements an oracle provider interface.\n/// @dev Manages swapping between different underlying oracle provider interfaces over time.\ncontract Oracle is IOracle, Instance {\n    /// @notice A historical mapping of underlying oracle providers\n    mapping(uint256 => Epoch) public oracles;\n\n    /// @notice The global state of the oracle\n    Global public global;\n\n    /// @notice Initializes the contract state\n    /// @param initialProvider The initial oracle provider\n    function initialize(IOracleProvider initialProvider) external initializer(1) {\n        __Instance__initialize();\n        _updateCurrent(initialProvider);\n        _updateLatest(initialProvider.latest());\n    }\n\n    /// @notice Updates the current oracle provider\n    /// @dev Both the current and new oracle provider must have the same current\n    /// @param newProvider The new oracle provider\n    function update(IOracleProvider newProvider) external onlyFactory {\n        _updateCurrent(newProvider);\n        _updateLatest(newProvider.latest());\n    }\n\n    /// @notice Requests a new version at the current timestamp\n    /// @param market Original market to optionally use for callbacks\n    /// @param account Original sender to optionally use for callbacks\n    function request(IMarket market, address account) external onlyAuthorized {\n        (OracleVersion memory latestVersion, uint256 currentTimestamp) = oracles[global.current].provider.status();\n\n        oracles[\n            (currentTimestamp > oracles[global.latest].timestamp) ? global.current : global.latest\n        ].provider.request(market, account);\n\n        oracles[global.current].timestamp = uint96(currentTimestamp);\n        _updateLatest(latestVersion);\n    }\n\n    /// @notice Returns the latest committed version as well as the current timestamp\n    /// @return latestVersion The latest committed version\n    /// @return currentTimestamp The current timestamp\n    function status() external view returns (OracleVersion memory latestVersion, uint256 currentTimestamp) {\n        (latestVersion, currentTimestamp) = oracles[global.current].provider.status();\n        latestVersion = _handleLatest(latestVersion);\n    }\n\n    /// @notice Returns the latest committed version\n    function latest() public view returns (OracleVersion memory) {\n        return _handleLatest(oracles[global.current].provider.latest());\n    }\n\n    /// @notice Returns the current value\n    function current() public view returns (uint256) {\n        return oracles[global.current].provider.current();\n    }\n\n    /// @notice Returns the oracle version at a given timestamp\n    /// @param timestamp The timestamp to query\n    /// @return atVersion The oracle version at the given timestamp\n    function at(uint256 timestamp) public view returns (OracleVersion memory atVersion) {\n        if (timestamp == 0) return atVersion;\n        IOracleProvider provider = oracles[global.current].provider;\n        for (uint256 i = global.current - 1; i > 0; i--) {\n            if (timestamp > uint256(oracles[i].timestamp)) break;\n            provider = oracles[i].provider;\n        }\n        return provider.at(timestamp);\n    }\n\n    /// @notice Handles update the oracle to the new provider\n    /// @param newProvider The new oracle provider\n    function _updateCurrent(IOracleProvider newProvider) private {\n        // oracle must not already be updating\n        if (global.current != global.latest) revert OracleOutOfSyncError();\n\n        // if the latest version of the underlying oracle is further ahead than its latest request update its timestamp\n        if (global.current != 0) {\n            OracleVersion memory latestVersion = oracles[global.current].provider.latest();\n            if (latestVersion.timestamp > oracles[global.current].timestamp)\n                oracles[global.current].timestamp = uint96(latestVersion.timestamp);\n        }\n\n        // add the new oracle registration\n        oracles[++global.current] = Epoch(newProvider, uint96(newProvider.current()));\n        emit OracleUpdated(newProvider);\n    }\n\n    /// @notice Handles updating the latest oracle to the current if it is ready\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    function _updateLatest(OracleVersion memory currentOracleLatestVersion) private {\n        if (_latestStale(currentOracleLatestVersion)) global.latest = global.current;\n    }\n\n    /// @notice Handles overriding the latest version\n    /// @dev Applicable if we haven't yet switched over to the current oracle from the latest oracle\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    /// @return latestVersion The latest version\n    function _handleLatest(\n        OracleVersion memory currentOracleLatestVersion\n    ) private view returns (OracleVersion memory latestVersion) {\n        if (global.current == global.latest) return currentOracleLatestVersion;\n\n        bool isLatestStale = _latestStale(currentOracleLatestVersion);\n        latestVersion = isLatestStale ? currentOracleLatestVersion : oracles[global.latest].provider.latest();\n\n        uint256 latestOracleTimestamp =\n            uint256(isLatestStale ? oracles[global.current].timestamp : oracles[global.latest].timestamp);\n        if (!isLatestStale && latestVersion.timestamp > latestOracleTimestamp)\n            return at(latestOracleTimestamp);\n    }\n\n    /// @notice Returns whether the latest oracle is ready to be updated\n    /// @param currentOracleLatestVersion The latest version from the current oracle\n    /// @return Whether the latest oracle is ready to be updated\n    function _latestStale(OracleVersion memory currentOracleLatestVersion) private view returns (bool) {\n        if (global.current == global.latest) return false;\n        if (global.latest == 0) return true;\n\n        if (uint256(oracles[global.latest].timestamp) > oracles[global.latest].provider.latest().timestamp) return false;\n        if (uint256(oracles[global.latest].timestamp) >= currentOracleLatestVersion.timestamp) return false;\n\n        return true;\n    }\n\n    /// @dev Only if the caller is authorized by the factory\n    modifier onlyAuthorized {\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender))\n            revert OracleProviderUnauthorizedError();\n        _;\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/OracleFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/attribute/Factory.sol\";\nimport \"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\";\nimport \"./interfaces/IOracleFactory.sol\";\n\n/// @title OracleFactory\n/// @notice Factory for creating and managing oracles\ncontract OracleFactory is IOracleFactory, Factory {\n    /// @notice The token that is paid out as a fee to oracle keepers\n    Token18 public incentive;\n\n    /// @notice The maximum amount of tokens that can be awarded in a single price update\n    UFixed6 public maxClaim;\n\n    /// @notice Mapping of which factory's instances are authorized to request from this contract\n    mapping(IFactory => bool) public callers;\n\n    /// @notice Mapping of oracle id to oracle instance\n    mapping(bytes32 => IOracleProvider) public oracles;\n\n    /// @notice Mapping of factory to whether it is registered\n    mapping(IOracleProviderFactory => bool) public factories;\n\n    /// @notice Constructs the contract\n    /// @param implementation_ The implementation contract for the oracle\n    constructor(address implementation_) Factory(implementation_) { }\n\n    /// @notice Initializes the contract state\n    /// @param incentive_ The token that is paid out as a fee to oracle keepers\n    function initialize(Token18 incentive_) external initializer(3) {\n        // Re-initialize if owner is unset\n        if (owner() == address(0))\n            __Factory__initialize();\n\n        incentive = incentive_;\n    }\n\n    /// @notice Registers a new oracle provider factory to be used in the underlying oracle instances\n    /// @param factory The factory to register\n    function register(IOracleProviderFactory factory) external onlyOwner {\n        factories[factory] = true;\n        emit FactoryRegistered(factory);\n    }\n\n    /// @notice Authorizes a factory's instances to request from this contract\n    /// @param caller The factory to authorize\n    function authorize(IFactory caller) external onlyOwner {\n        callers[caller] = true;\n        emit CallerAuthorized(caller);\n    }\n\n    /// @notice Creates a new oracle instance\n    /// @param id The id of the oracle to create\n    /// @param factory The initial underlying oracle factory for this oracle to use\n    /// @return newOracle The newly created oracle instance\n    function create(bytes32 id, IOracleProviderFactory factory) external onlyOwner returns (IOracle newOracle) {\n        if (!factories[factory]) revert OracleFactoryNotRegisteredError();\n        if (oracles[id] != IOracleProvider(address(0))) revert OracleFactoryAlreadyCreatedError();\n\n        IOracleProvider oracleProvider = factory.oracles(id);\n        if (oracleProvider == IOracleProvider(address(0))) revert OracleFactoryInvalidIdError();\n\n        newOracle = IOracle(address(_create(abi.encodeCall(IOracle.initialize, (oracleProvider)))));\n        oracles[id] = newOracle;\n\n        emit OracleCreated(newOracle, id);\n    }\n\n    /// @notice Updates the underlying oracle factory for an oracle instance\n    /// @param id The id of the oracle to update\n    /// @param factory The new underlying oracle factory for this oracle to use\n    function update(bytes32 id, IOracleProviderFactory factory) external onlyOwner {\n        if (!factories[factory]) revert OracleFactoryNotRegisteredError();\n        if (oracles[id] == IOracleProvider(address(0))) revert OracleFactoryNotCreatedError();\n\n        IOracleProvider oracleProvider = factory.oracles(id);\n        if (oracleProvider == IOracleProvider(address(0))) revert OracleFactoryInvalidIdError();\n\n        IOracle oracle = IOracle(address(oracles[id]));\n        oracle.update(oracleProvider);\n    }\n\n    /// @notice Updates the maximum amount of tokens that can be ewarded in a single price update\n    /// @param newMaxClaim The new maximum amount\n    function updateMaxClaim(UFixed6 newMaxClaim) external onlyOwner {\n        maxClaim = newMaxClaim;\n        emit MaxClaimUpdated(newMaxClaim);\n    }\n\n    /// @notice Claims an amount of incentive tokens, to be paid out as a fee to the keeper\n    /// @dev Can only be called by a registered underlying oracle provider factory\n    /// @param amount The amount of tokens to claim\n    function claim(UFixed6 amount) external {\n        if (amount.gt(maxClaim)) revert OracleFactoryClaimTooLargeError();\n        if (!factories[IOracleProviderFactory(msg.sender)]) revert OracleFactoryNotRegisteredError();\n        incentive.push(msg.sender, UFixed18Lib.from(amount));\n    }\n\n    /// @notice Checks whether a caller is authorized to request from this contract\n    /// @param caller The caller to check\n    /// @return Whether the caller is authorized\n    function authorized(address caller) external view returns (bool) {\n        IInstance callerInstance = IInstance(caller);\n        IFactory callerFactory = callerInstance.factory();\n        if (!callerFactory.instances(callerInstance)) return false;\n        return callers[callerFactory];\n    }\n\n    // @notice Claims the oracle's fee from the given market\n    /// @param market The market to claim from\n    function fund(IMarket market) external {\n        if (!instances(IInstance(address(market.oracle())))) revert FactoryNotInstanceError();\n        market.claimFee();\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/payoff/PowerHalf.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/IPayoffProvider.sol\";\n\ncontract PowerHalf is IPayoffProvider {\n    uint256 private constant BASE = 1e18;\n\n    function payoff(Fixed18 price) external pure override returns (Fixed18) {\n        return Fixed18Lib.from(UFixed18.wrap(Math.sqrt(UFixed18.unwrap(price.abs()) * BASE)));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/payoff/PowerTwo.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"../interfaces/IPayoffProvider.sol\";\n\ncontract PowerTwo is IPayoffProvider {\n    function payoff(Fixed18 price) external pure override returns (Fixed18) {\n        return price.mul(price);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol\";\nimport \"@equilibria/root/attribute/Kept/Kept_Arbitrum.sol\";\nimport \"./PythFactory.sol\";\nimport \"../keeper/KeeperFactory.sol\";\n\n/// @title PythFactory_Arbitrum\n/// @notice Arbitrum Kept Oracle implementation for Pyth price feeds.\n/// @dev Additionally incentivizes keepers with L1 rollup fees according to the Arbitrum spec\ncontract PythFactory_Arbitrum is PythFactory, Kept_Arbitrum {\n    constructor(\n        AbstractPyth pyth_,\n        address implementation_,\n        uint256 validFrom_,\n        uint256 validTo_,\n        KeepConfig memory commitKeepConfig_,\n        KeepConfig memory settleKeepConfig_,\n        uint256 keepCommitIncrementalBufferData_\n    ) PythFactory(pyth_, implementation_, validFrom_, validTo_, commitKeepConfig_, settleKeepConfig_, keepCommitIncrementalBufferData_) { }\n\n    /// @dev Use the Kept_Arbitrum implementation for calculating the dynamic fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view virtual override(Kept_Arbitrum, Kept) returns (UFixed18) {\n        return Kept_Arbitrum._calldataFee(applicableCalldata, multiplierCalldata, bufferCalldata);\n    }\n\n    /// @dev Use the PythFactory implementation for raising the keeper fee\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal override(KeeperFactory, Kept) returns (UFixed18) {\n        return KeeperFactory._raiseKeeperFee(amount, data);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory_Optimism.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol\";\nimport \"@equilibria/root/attribute/Kept/Kept_Optimism.sol\";\nimport \"./PythFactory.sol\";\nimport \"../keeper/KeeperFactory.sol\";\n\n/// @title PythFactory_Optimism\n/// @notice Optimism Kept Oracle implementation for Pyth price feeds.\n/// @dev Additionally incentivizes keepers with L1 rollup fees according to the Optimism spec\ncontract PythFactory_Optimism is PythFactory, Kept_Optimism {\n    constructor(\n        AbstractPyth pyth_,\n        address implementation_,\n        uint256 validFrom_,\n        uint256 validTo_,\n        KeepConfig memory commitKeepConfig_,\n        KeepConfig memory settleKeepConfig_,\n        uint256 keepCommitIncrementalBufferData_\n    ) PythFactory(pyth_, implementation_, validFrom_, validTo_, commitKeepConfig_, settleKeepConfig_, keepCommitIncrementalBufferData_) { }\n\n    /// @dev Use the Kept_Optimism implementation for calculating the dynamic fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view virtual override(Kept_Optimism, Kept) returns (UFixed18) {\n        return Kept_Optimism._calldataFee(applicableCalldata, multiplierCalldata, bufferCalldata);\n    }\n\n    /// @dev Use the PythFactory implementation for raising the keeper fee\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal override(KeeperFactory, Kept) returns (UFixed18) {\n        return KeeperFactory._raiseKeeperFee(amount, data);\n    }\n}\n"
    },
    "@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol\";\nimport \"../interfaces/IPythFactory.sol\";\nimport \"../keeper/KeeperFactory.sol\";\n\n/// @title PythFactory\n/// @notice Factory contract for creating and managing Pyth oracles\ncontract PythFactory is IPythFactory, KeeperFactory {\n    int32 private constant PARSE_DECIMALS = 18;\n\n    /// @dev Pyth contract\n    AbstractPyth public immutable pyth;\n\n    /// @notice Initializes the immutable contract state\n    /// @param pyth_ Pyth contract\n    /// @param implementation_ IPythOracle implementation contract\n    /// @param validFrom_ The minimum time after a version that a keeper update can be valid\n    /// @param validTo_ The maximum time after a version that a keeper update can be valid\n    /// @param commitKeepConfig_ Parameter configuration for commit keeper incentivization\n    /// @param settleKeepConfig_ Parameter configuration for settle keeper incentivization\n    constructor(\n        AbstractPyth pyth_,\n        address implementation_,\n        uint256 validFrom_,\n        uint256 validTo_,\n        KeepConfig memory commitKeepConfig_,\n        KeepConfig memory settleKeepConfig_,\n        uint256 keepCommitIncrementalBufferData_\n    ) KeeperFactory(implementation_, validFrom_, validTo_, commitKeepConfig_, settleKeepConfig_, keepCommitIncrementalBufferData_) {\n        pyth = pyth_;\n    }\n\n    /// @notice Creates a new oracle instance\n    /// @param id The id of the oracle to create\n    /// @param underlyingId The underlying id of the oracle to create\n    /// @param payoff The payoff provider contract\n    /// @return newOracle The newly created oracle instance\n    function create(\n        bytes32 id,\n        bytes32 underlyingId,\n        PayoffDefinition memory payoff\n    ) public override(IKeeperFactory, KeeperFactory) returns (IKeeperOracle newOracle) {\n        if (!pyth.priceFeedExists(underlyingId)) revert PythFactoryInvalidIdError();\n        return super.create(id, underlyingId, payoff);\n    }\n\n    /// @notice Validates and parses the update data payload against the specified version\n    /// @param ids The list of price feed ids validate against\n    /// @param data The update data to validate\n    /// @return prices The parsed price list if valid\n    function _parsePrices(\n        bytes32[] memory ids,\n        bytes calldata data\n    ) internal override returns (PriceRecord[] memory prices) {\n        prices = new PriceRecord[](ids.length);\n        bytes[] memory datas = new bytes[](1);\n        datas[0] = data;\n\n        PythStructs.PriceFeed[] memory parsedPrices = pyth.parsePriceFeedUpdates{value: msg.value}(\n            datas,\n            _toUnderlyingIds(ids),\n            type(uint64).min,\n            type(uint64).max\n        );\n\n        for (uint256 i; i < parsedPrices.length; i++) {\n            (Fixed18 significand, int256 exponent) =\n                (Fixed18.wrap(parsedPrices[i].price.price), parsedPrices[i].price.expo + PARSE_DECIMALS);\n            Fixed18 base = Fixed18Lib.from(int256(10 ** SignedMath.abs(exponent)));\n            prices[i] = PriceRecord(\n                parsedPrices[i].price.publishTime,\n                exponent < 0 ? significand.div(base) : significand.mul(base)\n            );\n        }\n    }\n\n    /// @notice Converts a list of oracle ids to a list of underlying ids\n    /// @dev Reverts if any of the ids are not associated\n    /// @param ids The list of oracle ids to convert\n    /// @return underlyingIds The list of underlying ids\n    function _toUnderlyingIds(bytes32[] memory ids) private view returns (bytes32[] memory underlyingIds) {\n        underlyingIds = new bytes32[](ids.length);\n        for (uint256 i; i < ids.length; i++) {\n            underlyingIds[i] = toUnderlyingId[ids[i]];\n            if (underlyingIds[i] == bytes32(0)) revert KeeperFactoryNotCreatedError();\n        }\n    }\n\n    /// @notice Returns the applicable value for the keeper fee\n    /// @param numRequested The number of requested price commits\n    /// @return The applicable value for the keeper fee\n    function _applicableValue(uint256 numRequested, bytes memory) internal view override returns (uint256) {\n        return IPythStaticFee(address(pyth)).singleUpdateFeeInWei() * numRequested;\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/interfaces/IVault.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IMarket, Checkpoint as PerennialCheckpoint } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { IInstance } from \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { Account } from \"../types/Account.sol\";\nimport { Checkpoint } from \"../types/Checkpoint.sol\";\nimport { VaultParameter } from \"../types/VaultParameter.sol\";\nimport { Registration } from \"../types/Registration.sol\";\n\ninterface IVault is IInstance {\n    struct Context {\n        // parameters\n        UFixed6 settlementFee;\n\n        // markets\n        uint256 currentId;\n        uint256 currentTimestamp;\n        uint256 latestTimestamp;\n        Registration[] registrations;\n        Fixed6[] collaterals;\n        Fixed6 totalCollateral;\n\n        // state\n        VaultParameter parameter;\n        Checkpoint currentCheckpoint;\n        Checkpoint latestCheckpoint;\n        Account global;\n        Account local;\n    }\n\n    struct Target {\n        Fixed6 collateral;\n        UFixed6 position;\n    }\n\n    event MarketRegistered(uint256 indexed marketId, IMarket market);\n    event MarketUpdated(uint256 indexed marketId, UFixed6 newWeight, UFixed6 newLeverage);\n    event ParameterUpdated(VaultParameter newParameter);\n    event Updated(address indexed sender, address indexed account, uint256 version, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets);\n\n    // sig: 0xa9785d3d\n    error VaultDepositLimitExceededError();\n    // sig: 0xc85650f7\n    error VaultRedemptionLimitExceededError();\n    // sig: 0xe4b29524\n    error VaultExistingOrderError();\n    // sig: 0x499943cd\n    error VaultMarketExistsError();\n    // sig: 0x04467fe8\n    error VaultMarketDoesNotExistError();\n    // sig: 0x7c04a019\n    error VaultNotMarketError();\n    // sig: 0xaddc4c0d\n    error VaultIncorrectAssetError();\n    // sig: 0x7eb267c7\n    error VaultNotOperatorError();\n    // sig: 0xa65ac9fb\n    error VaultNotSingleSidedError();\n    // sig: 0xa65ac9fb\n    error VaultInsufficientMinimumError();\n    // sig: 0xdbdb7620\n    error VaultAggregateWeightError();\n    // sig: 0x50ad85d6\n    error VaultCurrentOutOfSyncError();\n\n    // sig: 0xb8a09499\n    error AccountStorageInvalidError();\n    // sig: 0xba85116a\n    error CheckpointStorageInvalidError();\n    // sig: 0xf003e2c3\n    error MappingStorageInvalidError();\n    // sig: 0x92f03c86\n    error RegistrationStorageInvalidError();\n    // sig: 0x0f9f8b19\n    error VaultParameterStorageInvalidError();\n    // sig: 0x97635122\n    error StrategyLibInsufficientCollateralError();\n    // sig: 0xfd9cbca5\n    error StrategyLibInsufficientAssetsError();\n\n    function initialize(Token18 asset, IMarket initialMaker, UFixed6 cap, string calldata name_) external;\n    function name() external view returns (string memory);\n    function settle(address account) external;\n    function rebalance(address account) external;\n    function update(address account, UFixed6 depositAssets, UFixed6 redeemShares, UFixed6 claimAssets) external;\n    function asset() external view returns (Token18);\n    function totalAssets() external view returns (Fixed6);\n    function totalShares() external view returns (UFixed6);\n    function convertToShares(UFixed6 assets) external view returns (UFixed6);\n    function convertToAssets(UFixed6 shares) external view returns (UFixed6);\n    function totalMarkets() external view returns (uint256);\n    function parameter() external view returns (VaultParameter memory);\n    function registrations(uint256 marketId) external view returns (Registration memory);\n    function accounts(address account) external view returns (Account memory);\n    function checkpoints(uint256 id) external view returns (Checkpoint memory);\n    function register(IMarket market) external;\n    function updateLeverage(uint256 marketId, UFixed6 newLeverage) external;\n    function updateWeights(UFixed6[] calldata newWeights) external;\n    function updateParameter(VaultParameter memory newParameter) external;\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/interfaces/IVaultFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IFactory } from \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport { IMarket } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { IMarketFactory } from \"@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { IVault } from \"./IVault.sol\";\n\ninterface IVaultFactory is IFactory {\n    event OperatorUpdated(address indexed account, address indexed operator, bool newEnabled);\n    event VaultCreated(IVault indexed vault, Token18 indexed asset, IMarket initialMarket);\n\n    function initialAmount() external view returns (UFixed6);\n    function marketFactory() external view returns (IMarketFactory);\n    function initialize() external;\n    function operators(address account, address operator) external view returns (bool);\n    function updateOperator(address operator, bool newEnabled) external;\n    function create(Token18 asset, IMarket initialMarket, string calldata name) external returns (IVault);\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/lib/StrategyLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport {\n    MarketParameter,\n    RiskParameter,\n    Local,\n    Global,\n    Position,\n    PositionLib,\n    Order,\n    OracleVersion\n} from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Registration } from \"../types/Registration.sol\";\n\n/// @dev The context of an underlying market\nstruct MarketStrategyContext {\n    /// @dev Registration of the market\n    Registration registration;\n\n    /// @dev The market parameter set\n    MarketParameter marketParameter;\n\n    /// @dev The risk parameter set\n    RiskParameter riskParameter;\n\n    /// @dev The local state of the vault\n    Local local;\n\n    /// @dev The vault's current account position\n    Position currentAccountPosition;\n\n    /// @dev The vault's latest account position\n    Position latestAccountPosition;\n\n    /// @dev The current global position\n    Position currentPosition;\n\n    /// @dev The latest valid price\n    Fixed6 latestPrice;\n\n    /// @dev The margin requirement of the vault\n    UFixed6 margin;\n\n    /// @dev The current closable amount of the vault\n    UFixed6 closable;\n\n    // @dev minimum position size before crossing the net position\n    UFixed6 minPosition;\n\n    // @dev maximum position size before crossing the maker limit\n    UFixed6 maxPosition;\n}\n\nstruct Strategy {\n    UFixed6 totalMargin;\n\n    Fixed6 totalCollateral;\n\n    UFixed6 minAssets;\n\n    MarketStrategyContext[] marketContexts;\n}\nusing StrategyLib for Strategy global;\n\n/// @title Strategy\n/// @notice Logic for vault capital allocation\n/// @dev - Deploys collateral first to satisfy the margin of each market, then deploys the rest by weight.\n///      - Positions are then targeted based on the amount of collateral that ends up deployed to each market.\nlibrary StrategyLib {\n    error StrategyLibInsufficientCollateralError();\n    error StrategyLibInsufficientAssetsError();\n\n    /// @dev The maximum multiplier that is allowed for leverage\n    UFixed6 public constant LEVERAGE_BUFFER = UFixed6.wrap(1.2e6);\n\n    /// @dev The target allocation for a market\n    struct MarketTarget {\n        /// @dev The amount of change in collateral\n        Fixed6 collateral;\n\n        /// @dev The new position\n        UFixed6 position;\n    }\n\n    /// @notice Loads the strategy context of each of the underlying markets\n    /// @param registrations The registrations of the underlying markets\n    /// @return strategy The strategy contexts of the vault\n    function load(Registration[] memory registrations) internal view returns (Strategy memory strategy) {\n        strategy.marketContexts = new MarketStrategyContext[](registrations.length);\n        for (uint256 marketId; marketId < registrations.length; marketId++) {\n            strategy.marketContexts[marketId] = _loadContext(registrations[marketId]);\n            strategy.totalMargin = strategy.totalMargin.add(strategy.marketContexts[marketId].margin);\n            strategy.totalCollateral = strategy.totalCollateral.add(strategy.marketContexts[marketId].local.collateral);\n            strategy.minAssets = strategy.minAssets.max(\n                (registrations[marketId].leverage.isZero() || registrations[marketId].weight.isZero()) ?\n                    UFixed6Lib.ZERO : // skip if no leverage or weight\n                    strategy.marketContexts[marketId].minPosition\n                        .muldiv(strategy.marketContexts[marketId].latestPrice.abs(), registrations[marketId].leverage)\n                        .div(registrations[marketId].weight)\n            );\n        }\n    }\n\n    /// @notice Compute the target allocation for each market\n    /// @param strategy The strategy of the vault\n    /// @param deposit The amount of assets that are being deposited into the vault\n    /// @param withdrawal The amount of assets to make available for withdrawal\n    /// @param ineligible The amount of assets that are inapplicable for allocation\n    function allocate(\n        Strategy memory strategy,\n        UFixed6 deposit,\n        UFixed6 withdrawal,\n        UFixed6 ineligible\n    ) internal pure returns (MarketTarget[] memory targets) {\n        UFixed6 collateral = UFixed6Lib.unsafeFrom(strategy.totalCollateral).add(deposit).unsafeSub(withdrawal);\n        UFixed6 assets = collateral.unsafeSub(ineligible);\n\n        if (collateral.lt(strategy.totalMargin)) revert StrategyLibInsufficientCollateralError();\n        if (assets.lt(strategy.minAssets)) revert StrategyLibInsufficientAssetsError();\n\n        targets = new MarketTarget[](strategy.marketContexts.length);\n        UFixed6 totalMarketCollateral;\n        for (uint256 marketId; marketId < strategy.marketContexts.length; marketId++) {\n            UFixed6 marketCollateral;\n            (targets[marketId], marketCollateral) = _allocateMarket(\n                strategy.marketContexts[marketId],\n                strategy.totalMargin,\n                collateral,\n                assets\n            );\n            totalMarketCollateral = totalMarketCollateral.add(marketCollateral);\n        }\n\n        if (strategy.marketContexts.length != 0)\n            targets[0].collateral = targets[0].collateral.add(Fixed6Lib.from(collateral.sub(totalMarketCollateral)));\n    }\n\n    /// @notice Compute the target allocation for a market\n    /// @param marketContext The context of the market\n    /// @param totalMargin The total margin requirement of the vault\n    /// @param collateral The total amount of collateral of the vault\n    /// @param assets The total amount of collateral available for allocation\n    function _allocateMarket(\n        MarketStrategyContext memory marketContext,\n        UFixed6 totalMargin,\n        UFixed6 collateral,\n        UFixed6 assets\n    ) private pure returns (MarketTarget memory target, UFixed6 marketCollateral) {\n        marketCollateral = marketContext.margin\n            .add(collateral.sub(totalMargin).mul(marketContext.registration.weight));\n\n        UFixed6 marketAssets = assets\n            .mul(marketContext.registration.weight)\n            .min(marketCollateral.mul(LEVERAGE_BUFFER));\n\n        target.collateral = Fixed6Lib.from(marketCollateral).sub(marketContext.local.collateral);\n\n        UFixed6 minAssets = marketContext.riskParameter.minMargin\n            .unsafeDiv(marketContext.registration.leverage.mul(marketContext.riskParameter.maintenance));\n\n        if (marketContext.marketParameter.closed || marketAssets.lt(minAssets)) marketAssets = UFixed6Lib.ZERO;\n\n        target.position = marketAssets\n            .muldiv(marketContext.registration.leverage, marketContext.latestPrice.abs())\n            .max(marketContext.minPosition)\n            .min(marketContext.maxPosition);\n    }\n\n    /// @notice Load the context of a market\n    /// @param registration The registration of the market\n    /// @return marketContext The context of the market\n    function _loadContext(\n        Registration memory registration\n    ) private view returns (MarketStrategyContext memory marketContext) {\n        marketContext.registration = registration;\n        marketContext.marketParameter = registration.market.parameter();\n        marketContext.riskParameter = registration.market.riskParameter();\n        marketContext.local = registration.market.locals(address(this));\n        OracleVersion memory latestVersion = registration.market.oracle().latest();\n\n        marketContext.latestAccountPosition = registration.market.positions(address(this));\n        marketContext.currentAccountPosition = marketContext.latestAccountPosition.clone();\n\n        Order memory pendingLocal = registration.market.pendings(address(this));\n        marketContext.currentAccountPosition.update(pendingLocal);\n\n        marketContext.margin = PositionLib.margin(\n            marketContext.latestAccountPosition.magnitude().add(pendingLocal.pos()),\n            latestVersion,\n            marketContext.riskParameter\n        );\n        marketContext.latestPrice = latestVersion.price;\n\n        marketContext.closable = marketContext.latestAccountPosition.magnitude().sub(pendingLocal.neg());\n\n        // current position\n        Order memory pendingGlobal = registration.market.pending();\n        marketContext.currentPosition = registration.market.position();\n        marketContext.currentPosition.update(pendingGlobal);\n        marketContext.minPosition = marketContext.currentAccountPosition.maker\n            .unsafeSub(marketContext.currentPosition.maker\n                .unsafeSub(marketContext.currentPosition.skew().abs()).min(marketContext.closable));\n        marketContext.maxPosition = marketContext.currentAccountPosition.maker\n            .add(marketContext.riskParameter.makerLimit.unsafeSub(marketContext.currentPosition.maker));\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/types/Account.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"./Checkpoint.sol\";\n\n/// @dev Account type\nstruct Account {\n    /// @dev The current position id\n    uint256 current;\n\n    /// @dev The latest position id\n    uint256 latest;\n\n    /// @dev The total shares\n    UFixed6 shares;\n\n    /// @dev The total assets\n    UFixed6 assets;\n\n    /// @dev The amount of pending deposits\n    UFixed6 deposit;\n\n    /// @dev The amount of pending redemptions\n    UFixed6 redemption;\n}\nusing AccountLib for Account global;\nstruct StoredAccount {\n    /* slot 0 */\n    uint32 current;         // <= 4.29b\n    uint32 latest;          // <= 4.29b\n    bytes24 __unallocated0__;\n\n    /* slot 1 */\n    uint64 shares;          // <= 18.44t\n    uint64 assets;          // <= 18.44t\n    uint64 deposit;         // <= 18.44t\n    uint64 redemption;      // <= 18.44t\n}\nstruct AccountStorage { StoredAccount value; }\nusing AccountStorageLib for AccountStorage global;\n\n\n/// @title Account\n/// @notice Holds the state for the account type\nlibrary AccountLib {\n    /// @notice Processes the position in a global context\n    /// @param self The account to update\n    /// @param latestId The latest position id\n    /// @param checkpoint The checkpoint to process\n    /// @param deposit The amount of pending deposits\n    /// @param redemption The amount of pending redemptions\n    function processGlobal(\n        Account memory self,\n        uint256 latestId,\n        Checkpoint memory checkpoint,\n        UFixed6 deposit,\n        UFixed6 redemption\n    ) internal pure {\n        self.latest = latestId;\n        (self.assets, self.shares) = (\n            self.assets.add(checkpoint.toAssetsGlobal(redemption)),\n            self.shares.add(checkpoint.toSharesGlobal(deposit))\n        );\n        (self.deposit, self.redemption) = (self.deposit.sub(deposit), self.redemption.sub(redemption));\n    }\n\n    /// @notice Processes the position in a local context\n    /// @param self The account to update\n    /// @param latestId The latest position id\n    /// @param checkpoint The checkpoint to process\n    /// @param deposit The amount of pending deposits to clear\n    /// @param redemption The amount of pending redemptions to clear\n    function processLocal(\n        Account memory self,\n        uint256 latestId,\n        Checkpoint memory checkpoint,\n        UFixed6 deposit,\n        UFixed6 redemption\n    ) internal pure {\n        self.latest = latestId;\n        (self.assets, self.shares) = (\n            self.assets.add(checkpoint.toAssetsLocal(redemption)),\n            self.shares.add(checkpoint.toSharesLocal(deposit))\n        );\n        (self.deposit, self.redemption) = (self.deposit.sub(deposit), self.redemption.sub(redemption));\n    }\n\n    /// @notice Updates the account with a new order\n    /// @param self The account to update\n    /// @param currentId The current position id\n    /// @param assets The amount of assets to deduct\n    /// @param shares The amount of shares to deduct\n    /// @param deposit The amount of pending deposits\n    /// @param redemption The amount of pending redemptions\n    function update(\n        Account memory self,\n        uint256 currentId,\n        UFixed6 assets,\n        UFixed6 shares,\n        UFixed6 deposit,\n        UFixed6 redemption\n    ) internal pure {\n        self.current = currentId;\n        (self.assets, self.shares) = (self.assets.sub(assets), self.shares.sub(shares));\n        (self.deposit, self.redemption) = (self.deposit.add(deposit), self.redemption.add(redemption));\n    }\n}\n\nlibrary AccountStorageLib {\n    // sig: 0xb8a09499\n    error AccountStorageInvalidError();\n\n    function read(AccountStorage storage self) internal view returns (Account memory) {\n        StoredAccount memory storedValue = self.value;\n        return Account(\n            uint256(storedValue.current),\n            uint256(storedValue.latest),\n            UFixed6.wrap(uint256(storedValue.shares)),\n            UFixed6.wrap(uint256(storedValue.assets)),\n            UFixed6.wrap(uint256(storedValue.deposit)),\n            UFixed6.wrap(uint256(storedValue.redemption))\n        );\n    }\n\n    function store(AccountStorage storage self, Account memory newValue) internal {\n        if (newValue.current > uint256(type(uint32).max)) revert AccountStorageInvalidError();\n        if (newValue.latest > uint256(type(uint32).max)) revert AccountStorageInvalidError();\n        if (newValue.shares.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n        if (newValue.assets.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n        if (newValue.deposit.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n        if (newValue.redemption.gt(UFixed6.wrap(type(uint64).max))) revert AccountStorageInvalidError();\n\n        self.value = StoredAccount(\n            uint32(newValue.current),\n            uint32(newValue.latest),\n            bytes24(0),\n\n            uint64(UFixed6.unwrap(newValue.shares)),\n            uint64(UFixed6.unwrap(newValue.assets)),\n            uint64(UFixed6.unwrap(newValue.deposit)),\n            uint64(UFixed6.unwrap(newValue.redemption))\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/types/Checkpoint.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Checkpoint as PerennialCheckpoint } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport { Account } from \"./Account.sol\";\n\n/// @dev Checkpoint type\nstruct Checkpoint {\n    /// @dev The total amount of pending deposits\n    UFixed6 deposit;\n\n    /// @dev The total amount of pending redemptions\n    UFixed6 redemption;\n\n    /// @dev The total shares at the checkpoint\n    UFixed6 shares;\n\n    /// @dev The total assets at the checkpoint\n    Fixed6 assets;\n\n    /// @dev The total fee at the checkpoint\n    Fixed6 tradeFee;\n\n    /// @dev The total settlement fee at the checkpoint\n    UFixed6 settlementFee;\n\n    /// @dev The number of deposits and redemptions during the checkpoint\n    uint256 deposits;\n\n    /// @dev The number of deposits and redemptions during the checkpoint\n    uint256 redemptions;\n\n    // @dev The timestamp of of the checkpoint\n    uint256 timestamp;\n}\nusing CheckpointLib for Checkpoint global;\nstruct StoredCheckpoint {\n    /* slot 0 */\n    uint64 deposit;         // <= 18.44t\n    uint64 redemption;      // <= 18.44t\n    uint64 shares;          // <= 18.44t\n    int64 assets;           // <= 9.22t\n\n    /* slot 1 */\n    int64 tradeFee;         // <= 9.22t\n    uint64 settlementFee;   // <= 18.44t\n    uint32 deposits;        // <= 4.29b\n    uint32 timestamp;       // <= 4.29b\n    uint32 redemptions;\n    bytes4 __unallocated0__;\n}\nstruct CheckpointStorage { StoredCheckpoint value; }\nusing CheckpointStorageLib for CheckpointStorage global;\n\n/// @title Checkpoint\n/// @notice Holds the state for the checkpoint type\nlibrary CheckpointLib {\n    /// @notice Initializes the checkpoint\n    /// @dev Saves the current shares, and the assets + liabilities in the vault itself (not in the markets)\n    /// @param self The checkpoint to initialize\n    /// @param timestamp The timestamp of the checkpoint\n    /// @param global The global account\n    function next(Checkpoint memory self, uint256 timestamp, Account memory global) internal pure {\n        (self.timestamp, self.shares, self.assets) =\n            (timestamp, global.shares, Fixed6Lib.from(-1, global.deposit.add(global.assets)));\n        (self.deposit, self.redemption, self.tradeFee, self.settlementFee, self.deposits, self.redemptions) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, Fixed6Lib.ZERO, UFixed6Lib.ZERO, 0, 0);\n    }\n\n    /// @notice Updates the checkpoint with a new deposit or redemption\n    /// @param self The checkpoint to update\n    /// @param deposit The amount of new deposits\n    /// @param redemption The amount of new redemptions\n    function update(Checkpoint memory self, UFixed6 deposit, UFixed6 redemption) internal pure {\n        (self.deposit, self.redemption) =\n            (self.deposit.add(deposit), self.redemption.add(redemption));\n        if (!deposit.isZero()) self.deposits++;\n        if (!redemption.isZero()) self.redemptions++;\n    }\n\n    /// @notice Completes the checkpoint\n    /// @dev Increments the assets by the snapshotted amount of collateral in the underlying markets\n    /// @param self The checkpoint to complete\n    /// @param marketCheckpoint The checkpoint to complete with\n    function complete(Checkpoint memory self, PerennialCheckpoint memory marketCheckpoint) internal pure {\n        self.assets = self.assets.add(marketCheckpoint.collateral);\n        self.tradeFee = marketCheckpoint.tradeFee;\n        self.settlementFee = marketCheckpoint.settlementFee;\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the global context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesGlobal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        UFixed6 settlementFee = _settlementFeeForOrders(self, self.deposits);\n        return self.assets.lte(Fixed6Lib.ZERO) ?\n            assets.unsafeSub(settlementFee) :\n            _toShares(self, assets).unsafeSub(_toSharesExact(self, settlementFee));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsGlobal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        UFixed6 settlementFee = _settlementFeeForOrders(self, self.redemptions);\n        return (self.shares.isZero() ? shares : _toAssets(self, shares)).unsafeSub(settlementFee);\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint in the local context\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function toSharesLocal(Checkpoint memory self, UFixed6 assets) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        if (self.shares.isZero()) return assets;\n\n        // if vault is insolvent, default to par value\n        UFixed6 settlementFee = _settlementFeeForOrders(self, 1);\n        return self.assets.lte(Fixed6Lib.ZERO) ?\n            assets.unsafeSub(settlementFee) :\n            _toShares(self, assets).unsafeSub(_toSharesExact(self, settlementFee));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the local context\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssetsLocal(Checkpoint memory self, UFixed6 shares) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        UFixed6 settlementFee = _settlementFeeForOrders(self, 1);\n        return (self.shares.isZero() ? shares : _toAssets(self, shares)).unsafeSub(settlementFee);\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint in the global context\n    /// @dev Dev used in limit calculations when a non-historical settlement fee must be used\n    /// @param shares Number of shares to convert to shares\n    /// @param settlementFee Custom settlement fee\n    /// @return Amount of assets for the given shares at checkpoint\n    function toAssets(Checkpoint memory self, UFixed6 shares, UFixed6 settlementFee) internal pure returns (UFixed6) {\n        // vault is fresh, use par value\n        return (self.shares.isZero() ? shares : _toAssets(self, shares)).unsafeSub(settlementFee);\n    }\n\n    /// @notice Converts a given amount of assets to shares at checkpoint\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets at checkpoint\n    function _toShares(Checkpoint memory self, UFixed6 assets) private pure returns (UFixed6) {\n        return _withSpread(self, _toSharesExact(self, assets));\n    }\n\n    /// @notice Converts a given amount of shares to assets with checkpoint\n    /// @param shares Number of shares to convert to shares\n    /// @return Amount of assets for the given shares at checkpoint\n    function _toAssets(Checkpoint memory self, UFixed6 shares) private pure returns (UFixed6) {\n        return _withSpread(self, _toAssetsExact(self, shares));\n    }\n\n    /// @notice Applies a spread to a given amount from the relative fee amount of the checkpoint\n    /// @param self The checkpoint to apply the spread to\n    /// @param amount The amount to apply the spread to\n    function _withSpread(Checkpoint memory self, UFixed6 amount) private pure returns (UFixed6) {\n        UFixed6 totalAmount = self.deposit.add(_toAssetsExact(self, self.redemption));\n        UFixed6 totalAmountIncludingFee = UFixed6Lib.unsafeFrom(Fixed6Lib.from(totalAmount).sub(self.tradeFee));\n\n        return totalAmount.isZero() ?\n            amount :\n            amount.muldiv(totalAmountIncludingFee, totalAmount);\n    }\n\n    function _settlementFeeForOrders(Checkpoint memory self, uint256 orders) private pure returns (UFixed6) {\n        UFixed6 totalOrders = UFixed6Lib.from(self.deposits + self.redemptions);\n        return totalOrders.isZero() ?\n            UFixed6Lib.ZERO :\n            self.settlementFee.muldivOut(UFixed6Lib.from(orders), totalOrders);\n    }\n\n    function _toAssetsExact(Checkpoint memory self, UFixed6 shares) private pure returns (UFixed6) {\n        return shares.muldiv(UFixed6Lib.unsafeFrom(self.assets), self.shares);\n    }\n\n    function _toSharesExact(Checkpoint memory self, UFixed6 assets) private pure returns (UFixed6) {\n        return assets.muldiv(self.shares, UFixed6Lib.unsafeFrom(self.assets));\n    }\n\n    /// @notice Returns if the checkpoint is healthy\n    /// @dev A checkpoint is unhealthy when it has shares but no assets, since this cannot be recovered from\n    /// @param self The checkpoint to check\n    /// @return Whether the checkpoint is healthy\n    function unhealthy(Checkpoint memory self) internal pure returns (bool) {\n        return !self.shares.isZero() && self.assets.lte(Fixed6Lib.ZERO);\n    }\n}\n\nlibrary CheckpointStorageLib {\n    // sig: 0xba85116a\n    error CheckpointStorageInvalidError();\n\n    function read(CheckpointStorage storage self) internal view returns (Checkpoint memory) {\n        StoredCheckpoint memory storedValue = self.value;\n        return Checkpoint(\n            UFixed6.wrap(uint256(storedValue.deposit)),\n            UFixed6.wrap(uint256(storedValue.redemption)),\n            UFixed6.wrap(uint256(storedValue.shares)),\n            Fixed6.wrap(int256(storedValue.assets)),\n            Fixed6.wrap(int256(storedValue.tradeFee)),\n            UFixed6.wrap(uint256(storedValue.settlementFee)),\n            uint256(storedValue.deposits),\n            uint256(storedValue.redemptions),\n            uint256(storedValue.timestamp)\n        );\n    }\n\n    function store(CheckpointStorage storage self, Checkpoint memory newValue) internal {\n        if (newValue.deposit.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.redemption.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.shares.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.assets.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.assets.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.settlementFee.gt(UFixed6.wrap(type(uint64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.deposits > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n        if (newValue.redemptions > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n        if (newValue.timestamp > uint256(type(uint32).max)) revert CheckpointStorageInvalidError();\n\n        self.value = StoredCheckpoint(\n            uint64(UFixed6.unwrap(newValue.deposit)),\n            uint64(UFixed6.unwrap(newValue.redemption)),\n            uint64(UFixed6.unwrap(newValue.shares)),\n            int64(Fixed6.unwrap(newValue.assets)),\n\n            int64(Fixed6.unwrap(newValue.tradeFee)),\n            uint64(UFixed6.unwrap(newValue.settlementFee)),\n            uint32(newValue.deposits),\n            uint32(newValue.timestamp),\n            uint32(newValue.redemptions),\n            bytes4(0)\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/types/Registration.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IMarket } from \"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\";\nimport \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev Registration type\nstruct Registration {\n    /// @dev The underlying market\n    IMarket market;\n\n    /// @dev The weight of the market\n    UFixed6 weight;\n\n    /// @dev The leverage of the market\n    UFixed6 leverage;\n}\nstruct StoredRegistration {\n    /* slot 0 */\n    address market;\n    uint32 weight;          // <= 4.29b\n    uint32 leverage;        // <= 4290x\n    bytes4 __unallocated0__;\n}\nstruct RegistrationStorage { StoredRegistration value; }\nusing RegistrationStorageLib for RegistrationStorage global;\n\nlibrary RegistrationStorageLib {\n    // sig: 0x92f03c86\n    error RegistrationStorageInvalidError();\n\n    function read(RegistrationStorage storage self) internal view returns (Registration memory) {\n        StoredRegistration memory storedValue = self.value;\n        return Registration(\n            IMarket(storedValue.market),\n            UFixed6.wrap(uint256(storedValue.weight)),\n            UFixed6.wrap(uint256(storedValue.leverage))\n        );\n    }\n\n    function store(RegistrationStorage storage self, Registration memory newValue) internal {\n        if (newValue.weight.gt(UFixed6.wrap(type(uint32).max))) revert RegistrationStorageInvalidError();\n        if (newValue.leverage.gt(UFixed6.wrap(type(uint32).max))) revert RegistrationStorageInvalidError();\n\n        self.value = StoredRegistration(\n            address(newValue.market),\n            uint32(UFixed6.unwrap(newValue.weight)),\n            uint32(UFixed6.unwrap(newValue.leverage)),\n            bytes4(0)\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/types/VaultParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev VaultParameter type\nstruct VaultParameter {\n    /// @dev The collateral cap of the vault\n    UFixed6 cap;\n}\nstruct StoredVaultParameter {\n    /* slot 0 */\n    uint64 cap;\n    bytes24 __unallocated0__;\n}\nstruct VaultParameterStorage { StoredVaultParameter value; } // SECURITY: must remain at (1) slots\nusing VaultParameterStorageLib for VaultParameterStorage global;\n\nlibrary VaultParameterStorageLib {\n    // sig: 0x0f9f8b19\n    error VaultParameterStorageInvalidError();\n\n    function read(VaultParameterStorage storage self) internal view returns (VaultParameter memory) {\n        StoredVaultParameter memory storedValue = self.value;\n\n        return VaultParameter(\n            UFixed6.wrap(uint256(storedValue.cap))\n        );\n    }\n\n    function store(VaultParameterStorage storage self, VaultParameter memory newValue) internal {\n        if (newValue.cap.gt(UFixed6.wrap(type(uint64).max))) revert VaultParameterStorageInvalidError();\n\n        self.value = StoredVaultParameter(\n            uint64(UFixed6.unwrap(newValue.cap)),\n            bytes24(0)\n        );\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/Vault.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/IVaultFactory.sol\";\nimport \"./types/Account.sol\";\nimport \"./types/Checkpoint.sol\";\nimport \"./types/Registration.sol\";\nimport \"./types/VaultParameter.sol\";\nimport \"./interfaces/IVault.sol\";\nimport \"./lib/StrategyLib.sol\";\n\n/// @title Vault\n/// @notice Deploys underlying capital by weight in maker positions across registered markets\n/// @dev Vault deploys and rebalances collateral between the registered markets, while attempting to\n///      maintain `targetLeverage` with its open maker positions at any given time. Deposits are only gated in so much\n///      as to cap the maximum amount of assets in the vault.\n///\n///      All registered markets are expected to be on the same \"clock\", i.e. their oracle.current() is always equal.\n///\n///      The vault has a \"delayed settlement\" mechanism. After depositing to or redeeming from the vault, a user must\n///      wait until the next settlement of all underlying markets in order for vault settlement to be available.\ncontract Vault is IVault, Instance {\n    /// @dev The vault's name\n    string private _name;\n\n    /// @dev The underlying asset\n    Token18 public asset;\n\n    /// @dev The vault parameter set\n    VaultParameterStorage private _parameter;\n\n    /// @dev The total number of registered markets\n    uint256 public totalMarkets;\n\n    /// @dev Per-market registration state variables\n    mapping(uint256 => RegistrationStorage) private _registrations;\n\n    /// @dev Per-account accounting state variables\n    mapping(address => AccountStorage) private _accounts;\n\n    /// @dev Per-id accounting state variables\n    mapping(uint256 => CheckpointStorage) private _checkpoints;\n\n    /// @dev DEPRECATED SLOT -- previously the mappings\n    bytes32 private __unused0__;\n\n    /// @notice Initializes the vault\n    /// @param asset_ The underlying asset\n    /// @param initialMarket The initial market to register\n    /// @param name_ The vault's name\n    function initialize(\n        Token18 asset_,\n        IMarket initialMarket,\n        UFixed6 cap,\n        string calldata name_\n    ) external initializer(1) {\n        __Instance__initialize();\n\n        asset = asset_;\n        _name = name_;\n        _register(initialMarket);\n        _updateParameter(VaultParameter(cap));\n    }\n\n    /// @notice Returns the vault parameter set\n    /// @return The vault parameter set\n    function parameter() external view returns (VaultParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the registration for a given market\n    /// @param marketId The market id\n    /// @return The registration for the given market\n    function registrations(uint256 marketId) external view returns (Registration memory) {\n        return _registrations[marketId].read();\n    }\n\n    /// @notice Returns the account state for a account\n    /// @param account The account to query\n    /// @return The account state for the given account\n    function accounts(address account) external view returns (Account memory) {\n        return _accounts[account].read();\n    }\n\n    /// @notice Returns the checkpoint for a given id\n    /// @param id The id to query\n    /// @return The checkpoint for the given id\n    function checkpoints(uint256 id) external view returns (Checkpoint memory) {\n        return _checkpoints[id].read();\n    }\n\n    /// @notice Returns the name of the vault\n    /// @return The name of the vault\n    function name() external view returns (string memory) {\n        return string(abi.encodePacked(\"Perennial V2 Vault: \", _name));\n    }\n\n    /// @notice Returns the total number of underlying assets at the last checkpoint\n    /// @return The total number of underlying assets at the last checkpoint\n    function totalAssets() public view returns (Fixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.assets\n            .add(Fixed6Lib.from(checkpoint.deposit))\n            .sub(Fixed6Lib.from(checkpoint.toAssetsGlobal(checkpoint.redemption)));\n    }\n\n    /// @notice Returns the total number of shares at the last checkpoint\n    /// @return The total number of shares at the last checkpoint\n    function totalShares() public view returns (UFixed6) {\n        Checkpoint memory checkpoint = _checkpoints[_accounts[address(0)].read().latest].read();\n        return checkpoint.shares\n            .add(checkpoint.toSharesGlobal(checkpoint.deposit))\n            .sub(checkpoint.redemption);\n    }\n\n    /// @notice Converts a given amount of assets to shares\n    /// @param assets Number of assets to convert to shares\n    /// @return Amount of shares for the given assets\n    function convertToShares(UFixed6 assets) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.unsafeFrom(totalAssets()), totalShares());\n        return _totalShares.isZero() ? assets : assets.muldiv(_totalShares, _totalAssets);\n    }\n\n    /// @notice Converts a given amount of shares to assets\n    /// @param shares Number of shares to convert to assets\n    /// @return Amount of assets for the given shares\n    function convertToAssets(UFixed6 shares) external view returns (UFixed6) {\n        (UFixed6 _totalAssets, UFixed6 _totalShares) =\n            (UFixed6Lib.unsafeFrom(totalAssets()), totalShares());\n        return _totalShares.isZero() ? shares : shares.muldiv(_totalAssets, _totalShares);\n    }\n\n    /// @notice Registers a new market\n    /// @param market The market to register\n    function register(IMarket market) external onlyOwner {\n        rebalance(address(0));\n\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            if (_registrations[marketId].read().market == market) revert VaultMarketExistsError();\n        }\n\n        _register(market);\n    }\n\n    /// @notice Handles the registration for a new market\n    /// @param market The market to register\n    function _register(IMarket market) private {\n        if (!IVaultFactory(address(factory())).marketFactory().instances(market)) revert VaultNotMarketError();\n        if (!market.token().eq(asset)) revert VaultIncorrectAssetError();\n\n        asset.approve(address(market));\n\n        uint256 newMarketId = _registerMarket(market);\n        _updateMarket(newMarketId, newMarketId == 0 ? UFixed6Lib.ONE : UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Processes the state changes for a market registration\n    /// @param market The market to register\n    /// @return newMarketId The new market id\n    function _registerMarket(IMarket market) private returns (uint256 newMarketId) {\n        newMarketId = totalMarkets++;\n        _registrations[newMarketId].store(Registration(market, UFixed6Lib.ZERO, UFixed6Lib.ZERO));\n        emit MarketRegistered(newMarketId, market);\n    }\n\n    /// @notice Processes the state changes for a market update\n    /// @param marketId The market id\n    /// @param newWeight The new weight for the market\n    /// @param newLeverage The new leverage for the market\n    function _updateMarket(uint256 marketId, UFixed6 newWeight, UFixed6 newLeverage) private {\n        Registration memory registration = _registrations[marketId].read();\n        registration.weight = newWeight.eq(UFixed6Lib.MAX) ? registration.weight : newWeight;\n        registration.leverage = newLeverage.eq(UFixed6Lib.MAX) ? registration.leverage : newLeverage;\n        _registrations[marketId].store(registration);\n        emit MarketUpdated(marketId, registration.weight, registration.leverage);\n    }\n\n    /// @notice Settles, then updates the registration parameters for a given market\n    /// @param marketId The market id\n    /// @param newLeverage The new leverage\n    function updateLeverage(uint256 marketId, UFixed6 newLeverage) external onlyOwner {\n        rebalance(address(0));\n\n        if (marketId >= totalMarkets) revert VaultMarketDoesNotExistError();\n\n        _updateMarket(marketId, UFixed6Lib.MAX, newLeverage);\n    }\n\n    /// @notice Updates the set of market weights for the vault\n    /// @param newWeights The new set of market weights\n    function updateWeights(UFixed6[] calldata newWeights) external onlyOwner {\n        rebalance(address(0));\n\n        if (newWeights.length != totalMarkets) revert VaultMarketDoesNotExistError();\n\n        UFixed6 totalWeight;\n        for(uint256 i; i < totalMarkets; i++) {\n            _updateMarket(i, newWeights[i], UFixed6Lib.MAX);\n            totalWeight = totalWeight.add(newWeights[i]);\n        }\n\n        if (!totalWeight.eq(UFixed6Lib.ONE)) revert VaultAggregateWeightError();\n    }\n\n    /// @notice Settles, then updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function updateParameter(VaultParameter memory newParameter) external onlyOwner {\n        rebalance(address(0));\n        _updateParameter(newParameter);\n    }\n\n    /// @notice Updates the vault parameter set\n    /// @param newParameter The new vault parameter set\n    function _updateParameter(VaultParameter memory newParameter) private {\n        _parameter.store(newParameter);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Syncs `account`'s state up to current\n    /// @param account The account that should be synced\n    function settle(address account) public whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _saveContext(context, account);\n    }\n\n    /// @notice Syncs `account`'s state up to current\n    /// @dev Rebalances only the collateral of the vault\n    /// @param account The account that should be synced\n    function rebalance(address account) public whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _manage(context, UFixed6Lib.ZERO, UFixed6Lib.ZERO, false);\n        _saveContext(context, account);\n    }\n\n    /// @notice Updates `account`, depositing `depositAssets` assets, redeeming `redeemShares` shares, and claiming `claimAssets` assets\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function update(\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) external whenNotPaused {\n        _settleUnderlying();\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _checkpoint(context);\n        _update(context, account, depositAssets, redeemShares, claimAssets);\n        _saveContext(context, account);\n    }\n\n    /// @notice Loads or initializes the current checkpoint\n    /// @param context The context to use\n    function _checkpoint(Context memory context) private view {\n        context.currentId = context.global.current;\n        context.currentCheckpoint = _checkpoints[context.currentId].read();\n\n        if (context.currentTimestamp > context.currentCheckpoint.timestamp) {\n            context.currentId++;\n            context.currentCheckpoint.next(context.currentTimestamp, context.global);\n        }\n    }\n\n    /// @notice Handles updating the account's position\n    /// @param context The context to use\n    /// @param account The account to operate on\n    /// @param depositAssets The amount of assets to deposit\n    /// @param redeemShares The amount of shares to redeem\n    /// @param claimAssets The amount of assets to claim\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 depositAssets,\n        UFixed6 redeemShares,\n        UFixed6 claimAssets\n    ) private {\n        // magic values\n        if (claimAssets.eq(UFixed6Lib.MAX)) claimAssets = context.local.assets;\n        if (redeemShares.eq(UFixed6Lib.MAX)) redeemShares = context.local.shares;\n\n        // invariant\n        if (msg.sender != account && !IVaultFactory(address(factory())).operators(account, msg.sender))\n            revert VaultNotOperatorError();\n        if (!depositAssets.add(redeemShares).add(claimAssets).eq(depositAssets.max(redeemShares).max(claimAssets)))\n            revert VaultNotSingleSidedError();\n        if (depositAssets.gt(_maxDeposit(context)))\n            revert VaultDepositLimitExceededError();\n        if (!depositAssets.isZero() && depositAssets.lt(context.settlementFee))\n            revert VaultInsufficientMinimumError();\n        if (!redeemShares.isZero() && context.latestCheckpoint.toAssets(redeemShares, context.settlementFee).isZero())\n            revert VaultInsufficientMinimumError();\n        if (context.local.current != context.local.latest) revert VaultExistingOrderError();\n\n        // asses socialization\n        UFixed6 claimAmount = _socialize(context, claimAssets);\n\n        // update positions\n        context.global.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.local.update(context.currentId, claimAssets, redeemShares, depositAssets, redeemShares);\n        context.currentCheckpoint.update(depositAssets, redeemShares);\n\n        // manage assets\n        asset.pull(msg.sender, UFixed18Lib.from(depositAssets));\n        _manage(context, depositAssets, claimAmount, !depositAssets.isZero() || !redeemShares.isZero());\n        asset.push(msg.sender, UFixed18Lib.from(claimAmount));\n\n        emit Updated(msg.sender, account, context.currentId, depositAssets, redeemShares, claimAssets);\n    }\n\n    /// @notice Returns the claim amount after socialization\n    /// @param context The context to use\n    /// @param claimAssets The amount of assets to claim\n    function _socialize(Context memory context, UFixed6 claimAssets) private pure returns (UFixed6) {\n        return context.global.assets.isZero() ?\n            UFixed6Lib.ZERO :\n            claimAssets.muldiv(\n                UFixed6Lib.unsafeFrom(context.totalCollateral).min(context.global.assets),\n                context.global.assets\n            );\n    }\n\n    /// @notice Handles settling the vault's underlying markets\n    function _settleUnderlying() private {\n        for (uint256 marketId; marketId < totalMarkets; marketId++)\n            _registrations[marketId].read().market.settle(address(this));\n    }\n\n    /// @notice Handles settling the vault state\n    /// @dev Run before every stateful operation to settle up the latest global state of the vault\n    /// @param context The context to use\n    function _settle(Context memory context, address account) private {\n        Checkpoint memory nextCheckpoint;\n\n        // settle global positions\n        while (\n            context.global.current > context.global.latest &&\n            context.latestTimestamp >= (nextCheckpoint = _checkpoints[context.global.latest + 1].read()).timestamp\n        ) {\n            nextCheckpoint.complete(_checkpointAtId(context, nextCheckpoint.timestamp));\n            context.global.processGlobal(\n                context.global.latest + 1,\n                nextCheckpoint,\n                nextCheckpoint.deposit,\n                nextCheckpoint.redemption\n            );\n            _checkpoints[context.global.latest].store(nextCheckpoint);\n            context.latestCheckpoint = nextCheckpoint;\n        }\n\n        if (account == address(0)) return;\n\n        // settle local position\n        if (\n            context.local.current > context.local.latest &&\n            context.latestTimestamp >= (nextCheckpoint = _checkpoints[context.local.current].read()).timestamp\n        )\n            context.local.processLocal(\n                context.local.current,\n                nextCheckpoint,\n                context.local.deposit,\n                context.local.redemption\n            );\n    }\n\n    /// @notice Manages the internal collateral and position strategy of the vault\n    /// @param deposit The amount of assets that are being deposited into the vault\n    /// @param withdrawal The amount of assets that need to be withdrawn from the markets into the vault\n    /// @param rebalance Whether to rebalance the vault's position\n    function _manage(Context memory context, UFixed6 deposit, UFixed6 withdrawal, bool rebalance) private {\n        if (context.totalCollateral.lt(Fixed6Lib.ZERO)) return;\n\n        StrategyLib.MarketTarget[] memory targets = StrategyLib\n            .load(context.registrations)\n            .allocate(\n                deposit,\n                withdrawal,\n                _ineligible(context, withdrawal)\n            );\n\n        for (uint256 marketId; marketId < context.registrations.length; marketId++)\n            if (targets[marketId].collateral.lt(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId], rebalance);\n        for (uint256 marketId; marketId < context.registrations.length; marketId++)\n            if (targets[marketId].collateral.gte(Fixed6Lib.ZERO))\n                _retarget(context.registrations[marketId], targets[marketId], rebalance);\n    }\n\n    /// @notice Returns the amount of collateral is ineligible for allocation\n    /// @param context The context to use\n    /// @param withdrawal The amount of assets that need to be withdrawn from the markets into the vault\n    /// @return The amount of assets that are ineligible from being allocated\n    function _ineligible(Context memory context, UFixed6 withdrawal) private pure returns (UFixed6) {\n        // assets eligible for redemption\n        UFixed6 redemptionEligible = UFixed6Lib.unsafeFrom(context.totalCollateral)\n            // assets pending claim (use latest global assets before withdrawal for redeemability)\n            .unsafeSub(context.global.assets.add(withdrawal))\n            // assets pending deposit\n            .unsafeSub(context.global.deposit);\n\n        return redemptionEligible\n            // approximate assets up for redemption\n            .mul(context.global.redemption.unsafeDiv(context.global.shares.add(context.global.redemption)))\n            // assets pending claim (use new global assets after withdrawal for eligability)\n            .add(context.global.assets);\n            // assets pending deposit are eligible for allocation\n    }\n\n    /// @notice Adjusts the position on `market` to `targetPosition`\n    /// @param registration The registration of the market to use\n    /// @param target The new state to target\n    /// @param rebalance Whether to rebalance the vault's position\n    function _retarget(\n        Registration memory registration,\n        StrategyLib.MarketTarget memory target,\n        bool rebalance\n    ) private {\n        registration.market.update(\n            address(this),\n            rebalance ? target.position : UFixed6Lib.MAX,\n            UFixed6Lib.ZERO,\n            UFixed6Lib.ZERO,\n            target.collateral,\n            false\n        );\n    }\n\n    /// @notice Loads the context for the given `account`\n    /// @param account Account to load the context for\n    /// @return context The context\n    function _loadContext(address account) private view returns (Context memory context) {\n        context.parameter = _parameter.read();\n\n        context.latestTimestamp = type(uint256).max;\n        context.currentTimestamp = type(uint256).max;\n        context.registrations = new Registration[](totalMarkets);\n        context.collaterals = new Fixed6[](totalMarkets);\n\n        for (uint256 marketId; marketId < totalMarkets; marketId++) {\n            // parameter\n            Registration memory registration = _registrations[marketId].read();\n            MarketParameter memory marketParameter = registration.market.parameter();\n            context.registrations[marketId] = registration;\n            context.settlementFee = context.settlementFee.add(marketParameter.settlementFee);\n\n            // version\n            (OracleVersion memory oracleVersion, uint256 currentTimestamp) = registration.market.oracle().status();\n            context.latestTimestamp = Math.min(context.latestTimestamp, oracleVersion.timestamp);\n            if (context.currentTimestamp == type(uint256).max) context.currentTimestamp = currentTimestamp;\n            else if (currentTimestamp != context.currentTimestamp) revert VaultCurrentOutOfSyncError();\n\n            // local\n            Local memory local = registration.market.locals(address(this));\n            context.collaterals[marketId] = local.collateral;\n            context.totalCollateral = context.totalCollateral.add(local.collateral);\n        }\n\n        if (account != address(0)) context.local = _accounts[account].read();\n        context.global = _accounts[address(0)].read();\n        context.latestCheckpoint = _checkpoints[context.global.latest].read();\n    }\n\n    /// @notice Saves the context into storage\n    /// @param context Context to use\n    /// @param account Account to save the context for\n    function _saveContext(Context memory context, address account) private {\n        if (account != address(0)) _accounts[account].store(context.local);\n        _accounts[address(0)].store(context.global);\n        _checkpoints[context.currentId].store(context.currentCheckpoint);\n    }\n\n    /// @notice The maximum available deposit amount\n    /// @param context Context to use in calculation\n    /// @return Maximum available deposit amount\n    function _maxDeposit(Context memory context) private view returns (UFixed6) {\n        return context.latestCheckpoint.unhealthy() ?\n            UFixed6Lib.ZERO :\n            context.parameter.cap.unsafeSub(UFixed6Lib.unsafeFrom(totalAssets()).add(context.global.deposit));\n    }\n\n    /// @notice Returns the aggregate perennial checkpoint for the vault at position\n    /// @param context Context to use\n    /// @param timestamp The timestamp to use\n    /// @return checkpoint The checkpoint at the given position\n    function _checkpointAtId(\n        Context memory context,\n        uint256 timestamp\n    ) public view returns (PerennialCheckpoint memory checkpoint) {\n        for (uint256 marketId; marketId < context.registrations.length; marketId++) {\n            PerennialCheckpoint memory marketCheckpoint = context.registrations[marketId].market\n                .checkpoints(address(this), timestamp);\n\n            (checkpoint.collateral, checkpoint.tradeFee, checkpoint.settlementFee) = (\n                checkpoint.collateral.add(marketCheckpoint.collateral),\n                checkpoint.tradeFee.add(marketCheckpoint.tradeFee),\n                checkpoint.settlementFee.add(marketCheckpoint.settlementFee)\n            );\n        }\n    }\n}\n"
    },
    "@equilibria/perennial-v2-vault/contracts/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Ownable.sol\";\nimport \"@equilibria/root/attribute/Factory.sol\";\nimport \"@equilibria/root/attribute/Pausable.sol\";\nimport \"./interfaces/IVaultFactory.sol\";\n\n/// @title VaultFactory\n/// @notice Manages creating new markets and global protocol parameters.\ncontract VaultFactory is IVaultFactory, Factory {\n    UFixed6 public immutable initialAmount;\n\n    /// @dev The market factory\n    IMarketFactory public immutable marketFactory;\n\n    /// @dev Mapping of allowed operators for each account\n    mapping(address => mapping(address => bool)) public operators;\n\n    /// @notice Constructs the contract\n    /// @param marketFactory_ The market factory\n    /// @param implementation_ The initial vault implementation contract\n    /// @param initialAmount_ The initial amount of the underlying asset to deposit and lock\n    constructor(\n        IMarketFactory marketFactory_,\n        address implementation_,\n        UFixed6 initialAmount_\n    ) Factory(implementation_) {\n        marketFactory = marketFactory_;\n        initialAmount = initialAmount_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Factory__initialize();\n    }\n\n    /// @notice Creates a new vault\n    /// @param asset The underlying asset of the vault\n    /// @param initialMarket The initial market of the vault\n    /// @param name The name of the vault\n    /// @return newVault The new vault\n    function create(\n        Token18 asset,\n        IMarket initialMarket,\n        string calldata name\n    ) external onlyOwner returns (IVault newVault) {\n        UFixed6 initialAmountWithFee = initialAmount.add(initialMarket.parameter().settlementFee);\n\n        // create vault\n        newVault = IVault(address(\n            _create(abi.encodeCall(IVault.initialize, (asset, initialMarket, initialAmountWithFee, name)))));\n\n        // deposit and lock initial amount of the underlying asset to prevent inflation attacks\n        asset.pull(msg.sender, UFixed18Lib.from(initialAmountWithFee));\n        asset.approve(address(newVault), UFixed18Lib.from(initialAmountWithFee));\n        newVault.update(address(this), initialAmountWithFee, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n\n        emit VaultCreated(newVault, asset, initialMarket);\n    }\n\n    /// @notice Updates the status of an operator for the caller\n    /// @param operator The operator to update\n    /// @param newEnabled The new status of the operator\n    function updateOperator(address operator, bool newEnabled) external {\n        operators[msg.sender][operator] = newEnabled;\n        emit OperatorUpdated(msg.sender, operator, newEnabled);\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/interfaces/IMarket.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"./IOracleProvider.sol\";\nimport \"../types/OracleVersion.sol\";\nimport \"../types/MarketParameter.sol\";\nimport \"../types/RiskParameter.sol\";\nimport \"../types/Version.sol\";\nimport \"../types/Local.sol\";\nimport \"../types/Global.sol\";\nimport \"../types/Position.sol\";\nimport \"../types/Checkpoint.sol\";\nimport \"../libs/VersionLib.sol\";\n\ninterface IMarket is IInstance {\n    struct MarketDefinition {\n        Token18 token;\n        IOracleProvider oracle;\n    }\n\n    struct Context {\n        ProtocolParameter protocolParameter;\n        MarketParameter marketParameter;\n        RiskParameter riskParameter;\n        OracleVersion latestOracleVersion;\n        uint256 currentTimestamp;\n        Global global;\n        Local local;\n        PositionContext latestPosition;\n        OrderContext pending;\n    }\n\n    struct SettlementContext {\n        Version latestVersion;\n        Checkpoint latestCheckpoint;\n        OracleVersion orderOracleVersion;\n    }\n\n    struct UpdateContext {\n        bool operator;\n        address liquidator;\n        address referrer;\n        UFixed6 referralFee;\n        OrderContext order;\n        PositionContext currentPosition;\n    }\n\n    struct PositionContext {\n        Position global;\n        Position local;\n    }\n\n    struct OrderContext {\n        Order global;\n        Order local;\n    }\n\n    event Updated(address indexed sender, address indexed account, uint256 version, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect, address referrer);\n    event OrderCreated(address indexed account, Order order);\n    event PositionProcessed(uint256 orderId, Order order, VersionAccumulationResult accumulationResult);\n    event AccountPositionProcessed(address indexed account, uint256 orderId, Order order, CheckpointAccumulationResult accumulationResult);\n    event BeneficiaryUpdated(address newBeneficiary);\n    event CoordinatorUpdated(address newCoordinator);\n    event FeeClaimed(address indexed account, UFixed6 amount);\n    event ExposureClaimed(address indexed account, Fixed6 amount);\n    event ParameterUpdated(MarketParameter newParameter);\n    event RiskParameterUpdated(RiskParameter newRiskParameter);\n    event OracleUpdated(IOracleProvider newOracle);\n\n    // sig: 0x0fe90964\n    error MarketInsufficientLiquidityError();\n    // sig: 0x00e2b6a8\n    error MarketInsufficientMarginError();\n    // sig: 0x442145e5\n    error MarketInsufficientCollateralError();\n    // sig: 0xba555da7\n    error MarketProtectedError();\n    // sig: 0x6ed43d8e\n    error MarketMakerOverLimitError();\n    // sig: 0x29ab4c44\n    error MarketClosedError();\n    // sig: 0x07732aee\n    error MarketCollateralBelowLimitError();\n    // sig: 0x5bdace60\n    error MarketOperatorNotAllowedError();\n    // sig: 0x8a68c1dc\n    error MarketNotSingleSidedError();\n    // sig: 0x736f9fda\n    error MarketOverCloseError();\n    // sig: 0x935bdc21\n    error MarketExceedsPendingIdLimitError();\n    // sig: 0x9bca0625\n    error MarketNotCoordinatorError();\n    // sig: 0xb602d086\n    error MarketNotBeneficiaryError();\n    // sig: 0x534f7fe6\n    error MarketInvalidProtectionError();\n    // sig: 0xab1e3a00\n    error MarketStalePriceError();\n    // sig: 0x15f9ae70\n    error MarketEfficiencyUnderLimitError();\n    // sig: 0x7302d51a\n    error MarketInvalidMarketParameterError(uint256 code);\n    // sig: 0xc5f0e98a\n    error MarketInvalidRiskParameterError(uint256 code);\n    // sig: 0x9dbdc5fd\n    error MarketInvalidReferrerError();\n    // sig: 0x5c5cb438\n    error MarketSettleOnlyError();\n\n    // sig: 0x2142bc27\n    error GlobalStorageInvalidError();\n    // sig: 0xc83d08ec\n    error LocalStorageInvalidError();\n    // sig: 0x7c53e926\n    error MarketParameterStorageInvalidError();\n    // sig: 0x98eb4898\n    error PositionStorageLocalInvalidError();\n    // sig: 0x7ecd083f\n    error RiskParameterStorageInvalidError();\n    // sig: 0xd2777e72\n    error VersionStorageInvalidError();\n\n    function initialize(MarketDefinition calldata definition_) external;\n    function token() external view returns (Token18);\n    function oracle() external view returns (IOracleProvider);\n    function payoff() external view returns (address);\n    function positions(address account) external view returns (Position memory);\n    function pendingOrders(address account, uint256 id) external view returns (Order memory);\n    function pendings(address account) external view returns (Order memory);\n    function locals(address account) external view returns (Local memory);\n    function versions(uint256 timestamp) external view returns (Version memory);\n    function position() external view returns (Position memory);\n    function pendingOrder(uint256 id) external view returns (Order memory);\n    function pending() external view returns (Order memory);\n    function global() external view returns (Global memory);\n    function checkpoints(address account, uint256 id) external view returns (Checkpoint memory);\n    function liquidators(address account, uint256 id) external view returns (address);\n    function referrers(address account, uint256 id) external view returns (address);\n    function settle(address account) external;\n    function update(address account, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect) external;\n    function update(address account, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect, address referrer) external;\n    function parameter() external view returns (MarketParameter memory);\n    function riskParameter() external view returns (RiskParameter memory);\n    function updateOracle(IOracleProvider newOracle) external;\n    function updateParameter(address newBeneficiary, address newCoordinator, MarketParameter memory newParameter) external;\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external;\n    function claimFee() external;\n}\n"
    },
    "@equilibria/perennial-v2/contracts/interfaces/IMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport \"../types/ProtocolParameter.sol\";\nimport \"./IMarket.sol\";\n\ninterface IMarketFactory is IFactory {\n    event ParameterUpdated(ProtocolParameter newParameter);\n    event OperatorUpdated(address indexed account, address indexed operator, bool newEnabled);\n    event ReferralFeeUpdated(address indexed referrer, UFixed6 newFee);\n    event MarketCreated(IMarket indexed market, IMarket.MarketDefinition definition);\n\n    // sig: 0x0a37dc74\n    error FactoryInvalidPayoffError();\n    // sig: 0x5116bce5\n    error FactoryInvalidOracleError();\n    // sig: 0x213e2260\n    error FactoryAlreadyRegisteredError();\n\n    // sig: 0x4dc1bc59\n    error ProtocolParameterStorageInvalidError();\n\n    function oracleFactory() external view returns (IFactory);\n    function parameter() external view returns (ProtocolParameter memory);\n    function operators(address account, address operator) external view returns (bool);\n    function referralFee(address referrer) external view returns (UFixed6);\n    function markets(IOracleProvider oracle) external view returns (IMarket);\n    function initialize() external;\n    function updateParameter(ProtocolParameter memory newParameter) external;\n    function updateOperator(address operator, bool newEnabled) external;\n    function updateReferralFee(address referrer, UFixed6 newReferralFee) external;\n    function create(IMarket.MarketDefinition calldata definition) external returns (IMarket);\n}\n"
    },
    "@equilibria/perennial-v2/contracts/interfaces/IOracleProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../types/OracleVersion.sol\";\nimport \"./IMarket.sol\";\n\n/// @dev OracleVersion Invariants\n///       - Version are requested at a timestamp, the current timestamp is determined by the oracle\n///         - The current timestamp may not be equal to block.timestamp, for example when batching timestamps\n///       - Versions are allowed to \"fail\" and will be marked as .valid = false\n///         - Invalid versions will always include the latest valid price as its price field\n///       - Versions must be committed in order, i.e. all requested versions prior to latestVersion must be available\n///       - Non-requested versions may be committed, but will not receive a settlement fee\n///         - This is useful for immediately liquidating an account with a valid off-chain price in between orders\n///         - Satisfying the above constraints, only versions more recent than the latest version may be committed\n///       - Current must always be greater than Latest, never equal\ninterface IOracleProvider {\n    // sig: 0x652fafab\n    error OracleProviderUnauthorizedError();\n\n    event OracleProviderVersionRequested(uint256 indexed version);\n    event OracleProviderVersionFulfilled(OracleVersion version);\n\n    function request(IMarket market, address account) external;\n    function status() external view returns (OracleVersion memory, uint256);\n    function latest() external view returns (OracleVersion memory);\n    function current() external view returns (uint256);\n    function at(uint256 timestamp) external view returns (OracleVersion memory);\n}"
    },
    "@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../types/OracleVersion.sol\";\nimport \"./IOracleProvider.sol\";\n\ninterface IOracleProviderFactory {\n    event OracleCreated(IOracleProvider indexed oracle, bytes32 indexed id);\n\n    function oracles(bytes32 id) external view returns (IOracleProvider);\n    function authorized(address caller) external view returns (bool);\n}"
    },
    "@equilibria/perennial-v2/contracts/libs/CheckpointLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"../types/OracleVersion.sol\";\nimport \"../types/RiskParameter.sol\";\nimport \"../types/Global.sol\";\nimport \"../types/Local.sol\";\nimport \"../types/Order.sol\";\nimport \"../types/Version.sol\";\nimport \"../types/Checkpoint.sol\";\n\nstruct CheckpointAccumulationResult {\n    /// @dev Total Collateral change due to pnl, funding, and interest from the previous position to the next position\n    Fixed6 collateral;\n\n    /// @dev Linear fee accumulated from the previous position to the next position\n    Fixed6 linearFee;\n\n    /// @dev Proportional fee accumulated from the previous position to the next position\n    Fixed6 proportionalFee;\n\n    /// @dev Adiabatic fee accumulated from the previous position to the next position\n    Fixed6 adiabaticFee;\n\n    /// @dev Settlement fee charged for this checkpoint\n    UFixed6 settlementFee;\n\n    /// @dev Liquidation fee accumulated for this checkpoint (only if the order is protected)\n    UFixed6 liquidationFee;\n\n    /// @dev Subtractive fee accumulated from the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 subtractiveFee;\n}\n\n/// @title CheckpointLib\n/// @notice Manages the logic for the local order accumulation\nlibrary CheckpointLib {\n    /// @notice Accumulate pnl and fees from the latest position to next position\n    /// @param self The Local object to update\n    /// @param order The next order\n    /// @param fromPosition The previous latest position\n    /// @param fromVersion The previous latest version\n    /// @param toVersion The next latest version\n    /// @return next The next checkpoint\n    /// @return result The accumulated pnl and fees\n    function accumulate(\n        Checkpoint memory self,\n        Order memory order,\n        Position memory fromPosition,\n        Version memory fromVersion,\n        Version memory toVersion\n    ) external pure returns (Checkpoint memory next, CheckpointAccumulationResult memory result) {\n        // accumulate\n        result.collateral = _accumulateCollateral(fromPosition, fromVersion, toVersion);\n        (result.linearFee, result.subtractiveFee) = _accumulateLinearFee(order, toVersion);\n        result.proportionalFee = _accumulateProportionalFee(order, toVersion);\n        result.adiabaticFee = _accumulateAdiabaticFee(order, toVersion);\n        result.settlementFee = _accumulateSettlementFee(order, toVersion);\n        result.liquidationFee = _accumulateLiquidationFee(order, toVersion);\n\n        // update checkpoint\n        next.collateral = self.collateral\n            .sub(self.tradeFee)                       // trade fee processed post settlement\n            .sub(Fixed6Lib.from(self.settlementFee))  // settlement / liquidation fee processed post settlement\n            .add(self.transfer)                       // deposit / withdrawal processed post settlement\n            .add(result.collateral);                  // incorporate collateral change at this settlement\n        next.transfer = order.collateral;\n        next.tradeFee = result.linearFee.add(result.proportionalFee).add(result.adiabaticFee);\n        next.settlementFee = result.settlementFee.add(result.liquidationFee);\n    }\n\n    /// @notice Accumulate pnl, funding, and interest from the latest position to next position\n    /// @param fromPosition The previous latest position\n    /// @param fromVersion The previous latest version\n    /// @param toVersion The next version\n    function _accumulateCollateral(\n        Position memory fromPosition,\n        Version memory fromVersion,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        return toVersion.makerValue.accumulated(fromVersion.makerValue, fromPosition.maker)\n            .add(toVersion.longValue.accumulated(fromVersion.longValue, fromPosition.long))\n            .add(toVersion.shortValue.accumulated(fromVersion.shortValue, fromPosition.short));\n    }\n\n    /// @notice Accumulate trade fees for the next position\n    /// @param order The next order\n    /// @param toVersion The next version\n    function _accumulateLinearFee(\n        Order memory order,\n        Version memory toVersion\n    ) private pure returns (Fixed6 linearFee, UFixed6 subtractiveFee) {\n        Fixed6 makerLinearFee = Fixed6Lib.ZERO\n            .sub(toVersion.makerLinearFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()));\n        Fixed6 takerLinearFee = Fixed6Lib.ZERO\n            .sub(toVersion.takerLinearFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.takerTotal()));\n\n        UFixed6 makerSubtractiveFee = order.makerTotal().isZero() ?\n            UFixed6Lib.ZERO :\n            UFixed6Lib.from(makerLinearFee).muldiv(order.makerReferral, order.makerTotal());\n        UFixed6 takerSubtractiveFee = order.takerTotal().isZero() ?\n            UFixed6Lib.ZERO :\n            UFixed6Lib.from(takerLinearFee).muldiv(order.takerReferral, order.takerTotal());\n\n        linearFee = makerLinearFee.add(takerLinearFee);\n        subtractiveFee = makerSubtractiveFee.add(takerSubtractiveFee);\n    }\n\n    /// @notice Accumulate trade fees for the next position\n    /// @param order The next order\n    /// @param toVersion The next version\n    function _accumulateProportionalFee(\n        Order memory order,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        return Fixed6Lib.ZERO\n            .sub(toVersion.makerProportionalFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()))\n            .sub(toVersion.takerProportionalFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.takerTotal()));\n    }\n\n    /// @notice Accumulate adiabatic fees for the next position\n    /// @param order The next order\n    /// @param toVersion The next version\n    function _accumulateAdiabaticFee(\n        Order memory order,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        return Fixed6Lib.ZERO\n            .sub(toVersion.makerPosFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerPos))\n            .sub(toVersion.makerNegFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerNeg))\n            .sub(toVersion.takerPosFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.takerPos()))\n            .sub(toVersion.takerNegFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.takerNeg()));\n    }\n\n\n    /// @notice Accumulate settlement fees for the next position\n    /// @param order The next order\n    /// @param toVersion The next version\n    function _accumulateSettlementFee(\n        Order memory order,\n        Version memory toVersion\n    ) private pure returns (UFixed6) {\n        return toVersion.settlementFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.from(order.orders)).abs();\n    }\n\n    /// @notice Accumulate liquidation fees for the next position\n    /// @param order The next order\n    /// @param toVersion The next version\n    function _accumulateLiquidationFee(\n        Order memory order,\n        Version memory toVersion\n    ) private pure returns (UFixed6 liquidationFee) {\n        if (order.protected())\n            return toVersion.liquidationFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.ONE).abs();\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/libs/InvariantLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"../interfaces/IMarket.sol\";\nimport \"../types/OracleVersion.sol\";\nimport \"../types/RiskParameter.sol\";\nimport \"../types/Global.sol\";\nimport \"../types/Local.sol\";\nimport \"../types/Order.sol\";\nimport \"../types/Version.sol\";\nimport \"../types/Checkpoint.sol\";\n\n/// @title InvariantLib\n/// @notice Manages the logic for the system invariant\nlibrary InvariantLib {\n    /// @notice Verifies the invariant of the market\n    /// @param context The context to use\n    /// @param account The account to verify the invariant for\n    /// @param newOrder The order to verify the invariant for\n    /// @param collateral The collateral change to verify the invariant for\n    function validate(\n        IMarket.Context memory context,\n        IMarket.UpdateContext memory updateContext,\n        address sender,\n        address account,\n        Order memory newOrder,\n        Fixed6 collateral\n    ) external pure {\n        if (context.pending.local.neg().gt(context.latestPosition.local.magnitude())) revert IMarket.MarketOverCloseError();\n\n        if (newOrder.protected() && (\n            !context.pending.local.neg().eq(context.latestPosition.local.magnitude()) ||\n            context.latestPosition.local.maintained(\n                context.latestOracleVersion,\n                context.riskParameter,\n                context.local.collateral.sub(collateral)\n            ) ||\n            collateral.lt(Fixed6Lib.ZERO) ||\n            newOrder.magnitude().gte(Fixed6Lib.ZERO)\n        )) revert IMarket.MarketInvalidProtectionError();\n\n        if (\n            !(updateContext.currentPosition.local.magnitude().isZero() && context.latestPosition.local.magnitude().isZero()) &&     // sender has no position\n            !(newOrder.isEmpty() && collateral.gte(Fixed6Lib.ZERO)) &&                                                              // sender is depositing zero or more into account, without position change\n            (context.currentTimestamp - context.latestOracleVersion.timestamp >= context.riskParameter.staleAfter)                  // price is not stale\n        ) revert IMarket.MarketStalePriceError();\n\n        if (context.marketParameter.closed && newOrder.increasesPosition())\n            revert IMarket.MarketClosedError();\n\n        if (\n            updateContext.currentPosition.global.maker.gt(context.riskParameter.makerLimit) &&\n            newOrder.increasesMaker()\n        ) revert IMarket.MarketMakerOverLimitError();\n\n        if (\n            !updateContext.currentPosition.local.singleSided() || (\n                context.latestPosition.local.direction() != updateContext.currentPosition.local.direction() &&\n                    !context.latestPosition.local.empty() &&\n                    !updateContext.currentPosition.local.empty()\n            )\n        ) revert IMarket.MarketNotSingleSidedError();\n\n        if (newOrder.protected()) return; // The following invariants do not apply to protected position updates (liquidations)\n\n        if (\n            sender != account &&                                    // sender is operating on own account\n            !updateContext.operator &&                                  // sender is operator approved for account\n            !(newOrder.isEmpty() && collateral.gte(Fixed6Lib.ZERO))     // sender is depositing zero or more into account, without position change\n        ) revert IMarket.MarketOperatorNotAllowedError();\n\n        if (\n            context.global.currentId > context.global.latestId + context.marketParameter.maxPendingGlobal ||\n            context.local.currentId > context.local.latestId + context.marketParameter.maxPendingLocal\n        ) revert IMarket.MarketExceedsPendingIdLimitError();\n\n        if (\n            !PositionLib.margined(\n                context.latestPosition.local.magnitude().add(context.pending.local.pos()),\n                context.latestOracleVersion,\n                context.riskParameter,\n                context.local.collateral\n            )\n        ) revert IMarket.MarketInsufficientMarginError();\n\n        if (context.pending.local.protected() && !newOrder.protected() && !newOrder.isEmpty())\n            revert IMarket.MarketProtectedError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            newOrder.decreasesEfficiency(updateContext.currentPosition.global) &&\n            updateContext.currentPosition.global.efficiency().lt(context.riskParameter.efficiencyLimit)\n        ) revert IMarket.MarketEfficiencyUnderLimitError();\n\n        if (\n            newOrder.liquidityCheckApplicable(context.marketParameter) &&\n            updateContext.currentPosition.global.socialized() &&\n            newOrder.decreasesLiquidity(updateContext.currentPosition.global)\n        ) revert IMarket.MarketInsufficientLiquidityError();\n\n        if (collateral.lt(Fixed6Lib.ZERO) && context.local.collateral.lt(Fixed6Lib.ZERO))\n            revert IMarket.MarketInsufficientCollateralError();\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/libs/VersionLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"@equilibria/root/accumulator/types/UAccumulator6.sol\";\nimport \"../types/ProtocolParameter.sol\";\nimport \"../types/MarketParameter.sol\";\nimport \"../types/RiskParameter.sol\";\nimport \"../types/Global.sol\";\nimport \"../types/Position.sol\";\nimport \"../types/Version.sol\";\n\n/// @dev Individual accumulation values\nstruct VersionAccumulationResult {\n    /// @dev Sum of the linear and proportional fees\n    UFixed6 positionFee;\n\n    /// @dev Position fee received by makers\n    UFixed6 positionFeeMaker;\n\n    /// @dev Position fee received by the protocol\n    UFixed6 positionFeeProtocol;\n\n    /// @dev Total subtractive position fees credited to referrers\n    UFixed6 positionFeeSubtractive;\n\n    /// @dev Profit/loss accrued from the oustanding adiabatic fee credit or liability\n    Fixed6 positionFeeExposure;\n\n    /// @dev Portion of exposure fees charged to makers\n    Fixed6 positionFeeExposureMaker;\n\n    /// @dev Portion of exposure fees charged to the protocol\n    Fixed6 positionFeeExposureProtocol;\n\n    /// @dev Sum of the adiabatic fees charged or credited\n    Fixed6 positionFeeImpact;\n\n    /// @dev Funding accrued by makers\n    Fixed6 fundingMaker;\n\n    /// @dev Funding accrued by longs\n    Fixed6 fundingLong;\n\n    /// @dev Funding accrued by shorts\n    Fixed6 fundingShort;\n\n    /// @dev Funding received by the protocol\n    UFixed6 fundingFee;\n\n    /// @dev Interest accrued by makers\n    Fixed6 interestMaker;\n\n    /// @dev Interest accrued by longs\n    Fixed6 interestLong;\n\n    /// @dev Interest accrued by shorts\n    Fixed6 interestShort;\n\n    /// @dev Interest received by the protocol\n    UFixed6 interestFee;\n\n    /// @dev Price-based profit/loss accrued by makers\n    Fixed6 pnlMaker;\n\n    /// @dev Price-based profit/loss accrued by longs\n    Fixed6 pnlLong;\n\n    /// @dev Price-based profit/loss accrued by shorts\n    Fixed6 pnlShort;\n\n    /// @dev Total settlement fee charged\n    UFixed6 settlementFee;\n\n    /// @dev Snapshot of the riskParameter.liquidationFee at the version (0 if not valid)\n    UFixed6 liquidationFee;\n}\n\n/// @title VersionLib\n/// @notice Manages the logic for the global order accumulation\nlibrary VersionLib {\n    struct AccumulationContext {\n        Global global;\n        Position fromPosition;\n        Order order;\n        OracleVersion fromOracleVersion;\n        OracleVersion toOracleVersion;\n        MarketParameter marketParameter;\n        RiskParameter riskParameter;\n    }\n\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\n    /// @param self The Version object to update\n    /// @param global The global state\n    /// @param fromPosition The previous latest position\n    /// @param order The new order\n    /// @param fromOracleVersion The previous latest oracle version\n    /// @param toOracleVersion The next latest oracle version\n    /// @param marketParameter The market parameter\n    /// @param riskParameter The risk parameter\n    /// @return next The accumulated version\n    /// @return nextGlobal The next global state\n    /// @return result The accumulation result\n    function accumulate(\n        Version memory self,\n        Global memory global,\n        Position memory fromPosition,\n        Order memory order,\n        OracleVersion memory fromOracleVersion,\n        OracleVersion memory toOracleVersion,\n        MarketParameter memory marketParameter,\n        RiskParameter memory riskParameter\n    ) external pure returns (Version memory next, Global memory nextGlobal, VersionAccumulationResult memory result) {\n        AccumulationContext memory context = AccumulationContext(\n            global,\n            fromPosition,\n            order,\n            fromOracleVersion,\n            toOracleVersion,\n            marketParameter,\n            riskParameter\n        );\n\n        // setup next accumulators\n        _next(self, next);\n\n        // record oracle version\n        next.valid = toOracleVersion.valid;\n        global.latestPrice = toOracleVersion.price;\n\n        // accumulate settlement fee\n        result.settlementFee = _accumulateSettlementFee(next, context);\n\n        // accumulate liquidation fee\n        result.liquidationFee = _accumulateLiquidationFee(next, context);\n\n        // accumulate linear fee\n        _accumulateLinearFee(next, context, result);\n\n        // accumulate proportional fee\n        _accumulateProportionalFee(next, context, result);\n\n        // accumulate adiabatic fee\n        _accumulateAdiabaticFee(next, context, result);\n\n        // if closed, don't accrue anything else\n        if (marketParameter.closed) return (next, global, result);\n\n        // accumulate funding\n        (result.fundingMaker, result.fundingLong, result.fundingShort, result.fundingFee) =\n            _accumulateFunding(next, context);\n\n        // accumulate interest\n        (result.interestMaker, result.interestLong, result.interestShort, result.interestFee) =\n            _accumulateInterest(next, context);\n\n        // accumulate P&L\n        (result.pnlMaker, result.pnlLong, result.pnlShort) = _accumulatePNL(next, context);\n\n        return (next, global, result);\n    }\n\n    /// @notice Copies over the version-over-version accumulators to prepare the next version\n    /// @param self The Version object to update\n    function _next(Version memory self, Version memory next) internal pure {\n        next.makerValue._value = self.makerValue._value;\n        next.longValue._value = self.longValue._value;\n        next.shortValue._value = self.shortValue._value;\n    }\n\n    /// @notice Globally accumulates settlement fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateSettlementFee(\n        Version memory next,\n        AccumulationContext memory context\n    ) private pure returns (UFixed6 settlementFee) {\n        settlementFee = context.order.orders == 0 ? UFixed6Lib.ZERO : context.marketParameter.settlementFee;\n        next.settlementFee.decrement(Fixed6Lib.from(settlementFee), UFixed6Lib.from(context.order.orders));\n    }\n\n    /// @notice Globally accumulates hypothetical liquidation fee since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateLiquidationFee(\n        Version memory next,\n        AccumulationContext memory context\n    ) private pure returns (UFixed6 liquidationFee) {\n        liquidationFee = context.toOracleVersion.valid ? context.riskParameter.liquidationFee : UFixed6Lib.ZERO;\n        next.liquidationFee.decrement(Fixed6Lib.from(liquidationFee), UFixed6Lib.ONE);\n    }\n\n    /// @notice Globally accumulates linear fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateLinearFee(\n        Version memory next,\n        AccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        (UFixed6 makerLinearFee, UFixed6 makerSubtractiveFee) = _accumulateSubtractiveFee(\n            context.riskParameter.makerFee.linear(\n                Fixed6Lib.from(context.order.makerTotal()),\n                context.toOracleVersion.price.abs()\n            ),\n            context.order.makerTotal(),\n            context.order.makerReferral,\n            next.makerLinearFee\n        );\n\n        (UFixed6 takerLinearFee, UFixed6 takerSubtractiveFee) = _accumulateSubtractiveFee(\n            context.riskParameter.takerFee.linear(\n                Fixed6Lib.from(context.order.takerTotal()),\n                context.toOracleVersion.price.abs()\n            ),\n            context.order.takerTotal(),\n            context.order.takerReferral,\n            next.takerLinearFee\n        );\n\n        UFixed6 linearFee = makerLinearFee.add(takerLinearFee);\n\n        UFixed6 protocolFee = context.fromPosition.maker.isZero() ?\n            linearFee :\n            context.marketParameter.positionFee.mul(linearFee);\n        UFixed6 positionFeeMaker = linearFee.sub(protocolFee);\n        next.makerValue.increment(Fixed6Lib.from(positionFeeMaker), context.fromPosition.maker);\n\n        result.positionFee = result.positionFee.add(linearFee);\n        result.positionFeeMaker = result.positionFeeMaker.add(positionFeeMaker);\n        result.positionFeeProtocol = result.positionFeeProtocol.add(protocolFee);\n        result.positionFeeSubtractive = result.positionFeeSubtractive.add(makerSubtractiveFee).add(takerSubtractiveFee);\n    }\n\n    /// @notice Globally accumulates subtractive fees since last oracle update\n    /// @param linearFee The linear fee to accumulate\n    /// @param total The total order size for the fee\n    /// @param referral The referral size for the fee\n    /// @param linearFeeAccumulator The accumulator for the linear fee\n    /// @return newLinearFee The new linear fee after subtractive fees\n    /// @return subtractiveFee The total subtractive fee\n    function _accumulateSubtractiveFee(\n        UFixed6 linearFee,\n        UFixed6 total,\n        UFixed6 referral,\n        Accumulator6 memory linearFeeAccumulator\n    ) private pure returns (UFixed6 newLinearFee, UFixed6 subtractiveFee) {\n        linearFeeAccumulator.decrement(Fixed6Lib.from(linearFee), total);\n        subtractiveFee = total.isZero() ? UFixed6Lib.ZERO : linearFee.muldiv(referral, total);\n        newLinearFee = linearFee.sub(subtractiveFee);\n    }\n\n    /// @notice Globally accumulates proportional fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateProportionalFee(\n        Version memory next,\n        AccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        UFixed6 makerProportionalFee = context.riskParameter.makerFee.proportional(\n            Fixed6Lib.from(context.order.makerTotal()),\n            context.toOracleVersion.price.abs()\n        );\n        next.makerProportionalFee.decrement(Fixed6Lib.from(makerProportionalFee), context.order.makerTotal());\n\n        UFixed6 takerProportionalFee = context.riskParameter.takerFee.proportional(\n            Fixed6Lib.from(context.order.takerTotal()),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerProportionalFee.decrement(Fixed6Lib.from(takerProportionalFee), context.order.takerTotal());\n\n        UFixed6 proportionalFee = makerProportionalFee.add(takerProportionalFee);\n        UFixed6 protocolFee = context.fromPosition.maker.isZero() ?\n            proportionalFee :\n            context.marketParameter.positionFee.mul(proportionalFee);\n        UFixed6 positionFeeMaker = proportionalFee.sub(protocolFee);\n        next.makerValue.increment(Fixed6Lib.from(positionFeeMaker), context.fromPosition.maker);\n\n        result.positionFee = result.positionFee.add(proportionalFee);\n        result.positionFeeMaker = result.positionFeeMaker.add(positionFeeMaker);\n        result.positionFeeProtocol = result.positionFeeProtocol.add(protocolFee);\n    }\n\n    /// @notice Globally accumulates adiabatic fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateAdiabaticFee(\n        Version memory next,\n        AccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        Fixed6 exposure = context.riskParameter.takerFee.exposure(context.fromPosition.skew())\n            .add(context.riskParameter.makerFee.exposure(context.fromPosition.maker));\n\n        _accumulatePositionFeeComponentExposure(next, context, result, exposure);\n\n        Fixed6 adiabaticFee;\n\n        // position fee from positive skew taker orders\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\n            context.fromPosition.skew(),\n            Fixed6Lib.from(context.order.takerPos()),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerPosFee.decrement(adiabaticFee, context.order.takerPos());\n        result.positionFeeImpact = result.positionFeeImpact.add(adiabaticFee);\n\n        // position fee from negative skew taker orders\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\n            context.fromPosition.skew().add(Fixed6Lib.from(context.order.takerPos())),\n            Fixed6Lib.from(-1, context.order.takerNeg()),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerNegFee.decrement(adiabaticFee, context.order.takerNeg());\n        result.positionFeeImpact = result.positionFeeImpact.add(adiabaticFee);\n\n        // position fee from negative skew maker orders\n        adiabaticFee = context.riskParameter.makerFee.adiabatic(\n            context.fromPosition.maker,\n            Fixed6Lib.from(-1, context.order.makerNeg),\n            context.toOracleVersion.price.abs()\n        );\n        next.makerNegFee.decrement(adiabaticFee, context.order.makerNeg);\n        result.positionFeeImpact = result.positionFeeImpact.add(adiabaticFee);\n\n        // position fee from positive skew maker orders\n        adiabaticFee = context.riskParameter.makerFee.adiabatic(\n            context.fromPosition.maker.sub(context.order.makerNeg),\n            Fixed6Lib.from(context.order.makerPos),\n            context.toOracleVersion.price.abs()\n        );\n        next.makerPosFee.decrement(adiabaticFee, context.order.makerPos);\n        result.positionFeeImpact = result.positionFeeImpact.add(adiabaticFee);\n    }\n\n    /// @notice Globally accumulates single component of the position fees exposure since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @param result The accumulation result\n    /// @param latestExposure The latest exposure\n    function _accumulatePositionFeeComponentExposure(\n        Version memory next,\n        AccumulationContext memory context,\n        VersionAccumulationResult memory result,\n        Fixed6 latestExposure\n    ) private pure {\n        Fixed6 impactExposure = context.toOracleVersion.price.sub(context.fromOracleVersion.price).mul(latestExposure);\n        Fixed6 impactExposureMaker = impactExposure.mul(Fixed6Lib.NEG_ONE);\n        Fixed6 impactExposureProtocol = context.fromPosition.maker.isZero() ? impactExposureMaker : Fixed6Lib.ZERO;\n        impactExposureMaker = impactExposureMaker.sub(impactExposureProtocol);\n        next.makerValue.increment(impactExposureMaker, context.fromPosition.maker);\n\n        result.positionFeeExposure = impactExposure;\n        result.positionFeeExposureProtocol = impactExposureProtocol;\n        result.positionFeeExposureMaker = impactExposureMaker;\n    }\n\n    /// @notice Globally accumulates all long-short funding since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return fundingMaker The total funding accrued by makers\n    /// @return fundingLong The total funding accrued by longs\n    /// @return fundingShort The total funding accrued by shorts\n    /// @return fundingFee The total fee accrued from funding accumulation\n    function _accumulateFunding(Version memory next, AccumulationContext memory context) private pure returns (\n        Fixed6 fundingMaker,\n        Fixed6 fundingLong,\n        Fixed6 fundingShort,\n        UFixed6 fundingFee\n    ) {\n        Fixed6 toSkew = context.toOracleVersion.valid ?\n            context.fromPosition.skew().add(context.order.long()).sub(context.order.short()) :\n            context.fromPosition.skew();\n\n        // Compute long-short funding rate\n        Fixed6 funding = context.global.pAccumulator.accumulate(\n            context.riskParameter.pController,\n            toSkew.unsafeDiv(Fixed6Lib.from(context.riskParameter.takerFee.scale)).min(Fixed6Lib.ONE).max(Fixed6Lib.NEG_ONE),\n            context.fromOracleVersion.timestamp,\n            context.toOracleVersion.timestamp,\n            context.fromPosition.takerSocialized().mul(context.fromOracleVersion.price.abs())\n        );\n\n        // Handle maker receive-only status\n        if (context.riskParameter.makerReceiveOnly && funding.sign() != context.fromPosition.skew().sign())\n            funding = funding.mul(Fixed6Lib.NEG_ONE);\n\n        // Initialize long and short funding\n        (fundingLong, fundingShort) = (Fixed6Lib.NEG_ONE.mul(funding), funding);\n\n        // Compute fee spread\n        fundingFee = funding.abs().mul(context.marketParameter.fundingFee);\n        Fixed6 fundingSpread = Fixed6Lib.from(fundingFee).div(Fixed6Lib.from(2));\n\n        // Adjust funding with spread\n        (fundingLong, fundingShort) = (\n            fundingLong.sub(Fixed6Lib.from(fundingFee)).add(fundingSpread),\n            fundingShort.sub(fundingSpread)\n        );\n\n        // Redirect net portion of minor's side to maker\n        if (context.fromPosition.long.gt(context.fromPosition.short)) {\n            fundingMaker = fundingShort.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\n            fundingShort = fundingShort.sub(fundingMaker);\n        }\n        if (context.fromPosition.short.gt(context.fromPosition.long)) {\n            fundingMaker = fundingLong.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\n            fundingLong = fundingLong.sub(fundingMaker);\n        }\n\n        next.makerValue.increment(fundingMaker, context.fromPosition.maker);\n        next.longValue.increment(fundingLong, context.fromPosition.long);\n        next.shortValue.increment(fundingShort, context.fromPosition.short);\n    }\n\n    /// @notice Globally accumulates all maker interest since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return interestMaker The total interest accrued by makers\n    /// @return interestLong The total interest accrued by longs\n    /// @return interestShort The total interest accrued by shorts\n    /// @return interestFee The total fee accrued from interest accumulation\n    function _accumulateInterest(\n        Version memory next,\n        AccumulationContext memory context\n    ) private pure returns (Fixed6 interestMaker, Fixed6 interestLong, Fixed6 interestShort, UFixed6 interestFee) {\n        UFixed6 notional = context.fromPosition.long.add(context.fromPosition.short).min(context.fromPosition.maker).mul(context.fromOracleVersion.price.abs());\n\n        // Compute maker interest\n        UFixed6 interest = context.riskParameter.utilizationCurve.accumulate(\n            context.fromPosition.utilization(context.riskParameter),\n            context.fromOracleVersion.timestamp,\n            context.toOracleVersion.timestamp,\n            notional\n        );\n\n        // Compute fee\n        interestFee = interest.mul(context.marketParameter.interestFee);\n\n        // Adjust long and short funding with spread\n        interestLong = Fixed6Lib.from(\n            context.fromPosition.major().isZero() ?\n            interest :\n            interest.muldiv(context.fromPosition.long, context.fromPosition.long.add(context.fromPosition.short))\n        );\n        interestShort = Fixed6Lib.from(interest).sub(interestLong);\n        interestMaker = Fixed6Lib.from(interest.sub(interestFee));\n\n        interestLong = interestLong.mul(Fixed6Lib.NEG_ONE);\n        interestShort = interestShort.mul(Fixed6Lib.NEG_ONE);\n        next.makerValue.increment(interestMaker, context.fromPosition.maker);\n        next.longValue.increment(interestLong, context.fromPosition.long);\n        next.shortValue.increment(interestShort, context.fromPosition.short);\n    }\n\n    /// @notice Globally accumulates position profit & loss since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return pnlMaker The total pnl accrued by makers\n    /// @return pnlLong The total pnl accrued by longs\n    /// @return pnlShort The total pnl accrued by shorts\n    function _accumulatePNL(\n        Version memory next,\n        AccumulationContext memory context\n    ) private pure returns (Fixed6 pnlMaker, Fixed6 pnlLong, Fixed6 pnlShort) {\n        pnlLong = context.toOracleVersion.price.sub(context.fromOracleVersion.price)\n            .mul(Fixed6Lib.from(context.fromPosition.longSocialized()));\n        pnlShort = context.fromOracleVersion.price.sub(context.toOracleVersion.price)\n            .mul(Fixed6Lib.from(context.fromPosition.shortSocialized()));\n        pnlMaker = pnlLong.add(pnlShort).mul(Fixed6Lib.NEG_ONE);\n\n        next.longValue.increment(pnlLong, context.fromPosition.long);\n        next.shortValue.increment(pnlShort, context.fromPosition.short);\n        next.makerValue.increment(pnlMaker, context.fromPosition.maker);\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/Market.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Instance.sol\";\nimport \"@equilibria/root/attribute/ReentrancyGuard.sol\";\nimport \"./interfaces/IMarket.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\nimport \"./libs/InvariantLib.sol\";\n\n/// @title Market\n/// @notice Manages logic and state for a single market.\n/// @dev Cloned by the Factory contract to launch new markets.\ncontract Market is IMarket, Instance, ReentrancyGuard {\n    Fixed6 private constant MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL = Fixed6.wrap(type(int256).min);\n    UFixed6 private constant MAGIC_VALUE_UNCHANGED_POSITION = UFixed6.wrap(type(uint256).max);\n    UFixed6 private constant MAGIC_VALUE_FULLY_CLOSED_POSITION = UFixed6.wrap(type(uint256).max - 1);\n\n    /// @dev The underlying token that the market settles in\n    Token18 public token;\n\n    /// @dev DEPRECATED SLOT -- previously the reward token\n    bytes32 private __unused0__;\n\n    /// @dev The oracle that provides the market price\n    IOracleProvider public oracle;\n\n    /// @dev DEPRECATED SLOT -- previously the payoff provider\n    bytes32 private __unused1__;\n\n    /// @dev Beneficiary of the market, receives donations\n    address private beneficiary;\n\n    /// @dev Risk coordinator of the market\n    address private coordinator;\n\n    /// @dev Risk parameters of the market\n    RiskParameterStorage private _riskParameter;\n\n    /// @dev Parameters of the market\n    MarketParameterStorage private _parameter;\n\n    /// @dev Current global state of the market\n    GlobalStorage private _global;\n\n    /// @dev Current global position of the market\n    PositionStorageGlobal private _position;\n\n    /// @dev DEPRECATED SLOT -- previously the global pending positions\n    bytes32 private __unused2__;\n\n    /// @dev Current local state of each account\n    mapping(address => LocalStorage) private _locals;\n\n    /// @dev Current local position of each account\n    mapping(address => PositionStorageLocal) private _positions;\n\n    /// @dev DEPRECATED SLOT -- previously the local pending positions\n    bytes32 private __unused3__;\n\n    /// @dev The historical version accumulator data for each accessed version\n    mapping(uint256 => VersionStorage) private _versions;\n\n    /// @dev The global pending order for each id\n    mapping(uint256 => OrderStorageGlobal) private _pendingOrder;\n\n    /// @dev The local pending order for each id for each account\n    mapping(address => mapping(uint256 => OrderStorageLocal)) private _pendingOrders;\n\n    /// @dev The global aggregate pending order\n    OrderStorageGlobal private _pending;\n\n    /// @dev The local aggregate pending order for each account\n    mapping(address => OrderStorageLocal) private _pendings;\n\n    /// @dev The local checkpoint for each id for each account\n    mapping(address => mapping(uint256 => CheckpointStorage)) private _checkpoints;\n\n    /// @dev The liquidator for each id for each account\n    mapping(address => mapping(uint256 => address)) public liquidators;\n\n    /// @dev The referrer for each id for each account\n    mapping(address => mapping(uint256 => address)) public referrers;\n\n    /// @notice Initializes the contract state\n    /// @param definition_ The market definition\n    function initialize(IMarket.MarketDefinition calldata definition_) external initializer(1) {\n        __Instance__initialize();\n        __ReentrancyGuard__initialize();\n\n        token = definition_.token;\n        oracle = definition_.oracle;\n    }\n\n    /// @notice Settles the account's position and collateral\n    /// @param account The account to operate on\n    function settle(address account) external nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n\n        _storeContext(context, account);\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect\n    ) external {\n        update(account, newMaker, newLong, newShort, collateral, protect, address(0));\n    }\n\n    /// @notice Updates the account's position and collateral\n    /// @param account The account to operate on\n    /// @param newMaker The new maker position for the account\n    /// @param newMaker The new long position for the account\n    /// @param newMaker The new short position for the account\n    /// @param collateral The collateral amount to add or remove from the account\n    /// @param protect Whether to put the account into a protected status for liquidations\n    /// @param referrer The referrer of the order\n    function update(\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect,\n        address referrer\n    ) public nonReentrant whenNotPaused {\n        Context memory context = _loadContext(account);\n\n        _settle(context, account);\n        _update(context, account, newMaker, newLong, newShort, collateral, protect, referrer);\n\n        _storeContext(context, account);\n    }\n\n    /// @notice Updates the oracle of the market\n    /// @dev For the v2.1.1 -> v2.2 migration process, not to be used otherwise\n    /// @param newOracle The new oracle address\n    function updateOracle(IOracleProvider newOracle) external onlyOwner {\n        oracle = newOracle;\n        emit OracleUpdated(newOracle);\n    }\n\n    /// @notice Updates the beneficiary, coordinator, and parameter set of the market\n    /// @param newBeneficiary The new beneficiary address\n    /// @param newCoordinator The new coordinator address\n    /// @param newParameter The new parameter set\n    function updateParameter(\n        address newBeneficiary,\n        address newCoordinator,\n        MarketParameter memory newParameter\n    ) external onlyOwner {\n        beneficiary = newBeneficiary;\n        emit BeneficiaryUpdated(newBeneficiary);\n\n        coordinator = newCoordinator;\n        emit CoordinatorUpdated(newCoordinator);\n\n        _parameter.validateAndStore(newParameter, IMarketFactory(address(factory())).parameter());\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the risk parameter set of the market\n    /// @param newRiskParameter The new risk parameter set\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external onlyCoordinator {\n\n        // credit impact update fee to the protocol account\n        Global memory newGlobal = _global.read();\n        Position memory latestPosition = _position.read();\n        RiskParameter memory latestRiskParameter = _riskParameter.read();\n        OracleVersion memory latestVersion = oracle.at(latestPosition.timestamp);\n\n        Fixed6 updateFee = latestRiskParameter.makerFee\n            .update(newRiskParameter.makerFee, latestPosition.maker, latestVersion.price.abs())\n            .add(latestRiskParameter.takerFee\n                .update(newRiskParameter.takerFee, latestPosition.skew(), latestVersion.price.abs()));\n\n        newGlobal.exposure = newGlobal.exposure.sub(updateFee);\n        _global.store(newGlobal);\n\n        // update\n        _riskParameter.validateAndStore(newRiskParameter, IMarketFactory(address(factory())).parameter());\n        emit RiskParameterUpdated(newRiskParameter);\n    }\n\n    /// @notice Claims any available fee that the sender has accrued\n    /// @dev Applicable fees include: protocol, oracle, risk, donation, and claimable\n    function claimFee() external {\n        Global memory newGlobal = _global.read();\n        Local memory newLocal = _locals[msg.sender].read();\n\n        if (_claimFee(factory().owner(), newGlobal.protocolFee)) newGlobal.protocolFee = UFixed6Lib.ZERO;\n        if (_claimFee(address(IMarketFactory(address(factory())).oracleFactory()), newGlobal.oracleFee))\n            newGlobal.oracleFee = UFixed6Lib.ZERO;\n        if (_claimFee(coordinator, newGlobal.riskFee)) newGlobal.riskFee = UFixed6Lib.ZERO;\n        if (_claimFee(beneficiary, newGlobal.donation)) newGlobal.donation = UFixed6Lib.ZERO;\n        if (_claimFee(msg.sender, newLocal.claimable)) newLocal.claimable = UFixed6Lib.ZERO;\n\n        _global.store(newGlobal);\n        _locals[msg.sender].store(newLocal);\n    }\n\n    /// @notice Settles any exposure that has accrued to the market\n    /// @dev Resets exposure to zero, caller pays or receives to net out the exposure\n    function claimExposure() external onlyOwner {\n        Global memory newGlobal = _global.read();\n\n        if (newGlobal.exposure.sign() == 1) token.push(msg.sender, UFixed18Lib.from(newGlobal.exposure.abs()));\n        if (newGlobal.exposure.sign() == -1) token.pull(msg.sender, UFixed18Lib.from(newGlobal.exposure.abs()));\n\n        emit ExposureClaimed(msg.sender, newGlobal.exposure);\n\n        newGlobal.exposure = Fixed6Lib.ZERO;\n        _global.store(newGlobal);\n    }\n\n    /// @notice Helper function to handle a singular fee claim.\n    /// @param receiver The address to receive the fee\n    /// @param fee The amount of the fee to claim\n    function _claimFee(address receiver, UFixed6 fee) private returns (bool) {\n        if (msg.sender != receiver || fee.isZero()) return false;\n\n        token.push(receiver, UFixed18Lib.from(fee));\n        emit FeeClaimed(receiver, fee);\n        return true;\n    }\n\n    /// @notice Returns the payoff provider\n    /// @dev For backwards compatibility\n    function payoff() external pure returns (address) {\n        return address(0);\n    }\n\n    /// @notice Returns the current parameter set\n    function parameter() external view returns (MarketParameter memory) {\n        return _parameter.read();\n    }\n\n    /// @notice Returns the current risk parameter set\n    function riskParameter() external view returns (RiskParameter memory) {\n        return _riskParameter.read();\n    }\n\n    /// @notice Returns the current global position\n    function position() external view returns (Position memory) {\n        return _position.read();\n    }\n\n    /// @notice Returns the current local position for the account\n    /// @param account The account to query\n    function positions(address account) external view returns (Position memory) {\n        return _positions[account].read();\n    }\n\n    /// @notice Returns the current global state\n    function global() external view returns (Global memory) {\n        return _global.read();\n    }\n\n    /// @notice Returns the historical version snapshot at the given timestamp\n    /// @param timestamp The timestamp to query\n    function versions(uint256 timestamp) external view returns (Version memory) {\n        return _versions[timestamp].read();\n    }\n\n    /// @notice Returns the local state for the given account\n    /// @param account The account to query\n    function locals(address account) external view returns (Local memory) {\n        return _locals[account].read();\n    }\n\n    /// @notice Returns the global pending order for the given id\n    /// @param id The id to query\n    function pendingOrder(uint256 id) external view returns (Order memory) {\n        return _pendingOrder[id].read();\n    }\n\n    /// @notice Returns the local pending order for the given account and id\n    /// @param account The account to query\n    /// @param id The id to query\n    function pendingOrders(address account, uint256 id) external view returns (Order memory) {\n        return _pendingOrders[account][id].read();\n    }\n\n    /// @notice Returns the aggregate global pending order\n    function pending() external view returns (Order memory) {\n        return _pending.read();\n    }\n\n    /// @notice Returns the aggregate local pending order for the given account\n    /// @param account The account to query\n    function pendings(address account) external view returns (Order memory) {\n        return _pendings[account].read();\n    }\n\n    /// @notice Returns the local checkpoint for the given account and version\n    /// @param account The account to query\n    /// @param version The version to query\n    function checkpoints(address account, uint256 version) external view returns (Checkpoint memory) {\n        return _checkpoints[account][version].read();\n    }\n\n    /// @notice Loads the transaction context\n    /// @param account The account to load for\n    /// @return context The transaction context\n    function _loadContext(address account) private view returns (Context memory context) {\n        // parameters\n        context.marketParameter = _parameter.read();\n        context.riskParameter = _riskParameter.read();\n        context.protocolParameter = IMarketFactory(address(factory())).parameter();\n\n        // oracle\n        (context.latestOracleVersion, context.currentTimestamp) = oracle.status();\n\n        // state\n        context.global = _global.read();\n        context.local = _locals[account].read();\n\n        // latest positions\n        context.latestPosition.global = _position.read();\n        context.latestPosition.local = _positions[account].read();\n\n        // aggregate pending orders\n        context.pending.global = _pending.read();\n        context.pending.local = _pendings[account].read();\n    }\n\n    /// @notice Stores the context for the transaction\n    /// @param context The context to store\n    /// @param account The account to store for\n    function _storeContext(Context memory context, address account) private {\n        // state\n        _global.store(context.global);\n        _locals[account].store(context.local);\n\n        // latest positions\n        _position.store(context.latestPosition.global);\n        _positions[account].store(context.latestPosition.local);\n\n        // aggregate pending orders\n        _pending.store(context.pending.global);\n        _pendings[account].store(context.pending.local);\n    }\n\n    /// @notice Loads the context for the update process\n    /// @param context The context to load to\n    /// @param account The account to load for\n    /// @param referrer The referrer to load for\n    /// @return updateContext The update context\n    function _loadUpdateContext(\n        Context memory context,\n        address account,\n        address referrer\n    ) private view returns (UpdateContext memory updateContext) {\n        // load current position\n        updateContext.currentPosition.global = context.latestPosition.global.clone();\n        updateContext.currentPosition.global.update(context.pending.global);\n        updateContext.currentPosition.local = context.latestPosition.local.clone();\n        updateContext.currentPosition.local.update(context.pending.local);\n\n        // load current order\n        updateContext.order.global = _pendingOrder[context.global.currentId].read();\n        updateContext.order.local = _pendingOrders[account][context.local.currentId].read();\n\n        // load external actors\n        updateContext.operator = IMarketFactory(address(factory())).operators(account, msg.sender);\n        updateContext.liquidator = liquidators[account][context.local.currentId];\n        updateContext.referrer = referrers[account][context.local.currentId];\n        updateContext.referralFee = IMarketFactory(address(factory())).referralFee(referrer);\n    }\n\n    /// @notice Stores the context for the update process\n    /// @param context The transaction context\n    /// @param updateContext The update context to store\n    /// @param account The account to store for\n    function _storeUpdateContext(Context memory context, UpdateContext memory updateContext, address account) private {\n        // current orders\n        _pendingOrder[context.global.currentId].store(updateContext.order.global);\n        _pendingOrders[account][context.local.currentId].store(updateContext.order.local);\n\n        // external actors\n        liquidators[account][context.local.currentId] = updateContext.liquidator;\n        referrers[account][context.local.currentId] = updateContext.referrer;\n    }\n\n    /// @notice Updates the current position\n    /// @param context The context to use\n    /// @param account The account to update\n    /// @param newMaker The new maker position size\n    /// @param newLong The new long position size\n    /// @param newShort The new short position size\n    /// @param collateral The change in collateral\n    /// @param protect Whether to protect the position for liquidation\n    function _update(\n        Context memory context,\n        address account,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        Fixed6 collateral,\n        bool protect,\n        address referrer\n    ) private notSettleOnly(context) {\n        // load\n        UpdateContext memory updateContext = _loadUpdateContext(context, account, referrer);\n\n        // magic values\n        collateral = _processCollateralMagicValue(context, collateral);\n        newMaker = _processPositionMagicValue(context, updateContext.currentPosition.local.maker, newMaker);\n        newLong = _processPositionMagicValue(context, updateContext.currentPosition.local.long, newLong);\n        newShort = _processPositionMagicValue(context, updateContext.currentPosition.local.short, newShort);\n\n        // referral fee\n        UFixed6 referralFee = _processReferralFee(context, updateContext, referrer);\n\n        // advance to next id if applicable, resetting referrer and liquidator\n        if (context.currentTimestamp > updateContext.order.local.timestamp) {\n            updateContext.order.local.next(context.currentTimestamp);\n            updateContext.referrer = address(0);\n            updateContext.liquidator = address(0);\n            context.local.currentId++;\n        }\n        if (context.currentTimestamp > updateContext.order.global.timestamp) {\n            updateContext.order.global.next(context.currentTimestamp);\n            context.global.currentId++;\n        }\n\n        // update current position\n        Order memory newOrder = OrderLib.from(\n            context.currentTimestamp,\n            updateContext.currentPosition.local,\n            collateral,\n            newMaker,\n            newLong,\n            newShort,\n            protect,\n            referralFee\n        );\n        updateContext.currentPosition.global.update(newOrder);\n        updateContext.currentPosition.local.update(newOrder);\n\n        // apply new order\n        updateContext.order.local.add(newOrder);\n        updateContext.order.global.add(newOrder);\n        context.pending.global.add(newOrder);\n        context.pending.local.add(newOrder);\n\n        // update collateral\n        context.local.update(collateral);\n\n        // protect account\n        if (newOrder.protected()) updateContext.liquidator = msg.sender;\n\n        // apply referrer\n        _processReferrer(updateContext, newOrder, referrer);\n\n        // request version\n        if (!newOrder.isEmpty()) oracle.request(IMarket(this), account);\n\n        // after\n        InvariantLib.validate(context, updateContext, msg.sender, account, newOrder, collateral);\n\n        // store\n        _storeUpdateContext(context, updateContext, account);\n\n        // fund\n        if (collateral.sign() == 1) token.pull(msg.sender, UFixed18Lib.from(collateral.abs()));\n        if (collateral.sign() == -1) token.push(msg.sender, UFixed18Lib.from(collateral.abs()));\n\n        // events\n        emit Updated(msg.sender, account, context.currentTimestamp, newMaker, newLong, newShort, collateral, protect, referrer);\n        emit OrderCreated(account, newOrder);\n    }\n\n    /// @notice Processes the referral fee for the given order\n    /// @param context The context to use\n    /// @param updateContext The update context to use\n    /// @param referrer The referrer of the order\n    /// @return The referral fee to apply\n    function _processReferralFee(\n        Context memory context,\n        UpdateContext memory updateContext,\n        address referrer\n    ) private pure returns (UFixed6) {\n        if (referrer == address(0)) return UFixed6Lib.ZERO;\n        if (!updateContext.referralFee.isZero()) return updateContext.referralFee;\n        return context.protocolParameter.referralFee;\n    }\n\n    /// @notice Processes the referrer for the given order\n    /// @param updateContext The update context to use\n    /// @param newOrder The order to process\n    /// @param referrer The referrer of the order\n    function _processReferrer(\n        UpdateContext memory updateContext,\n        Order memory newOrder,\n        address referrer\n    ) private pure {\n        if (newOrder.makerReferral.isZero() && newOrder.takerReferral.isZero()) return;\n        if (updateContext.referrer == address(0)) updateContext.referrer = referrer;\n        if (updateContext.referrer == referrer) return;\n\n        revert MarketInvalidReferrerError();\n    }\n\n    /// @notice Loads the settlement context\n    /// @param context The transaction context\n    /// @param account The account to load for\n    /// @return settlementContext The settlement context\n    function _loadSettlementContext(\n        Context memory context,\n        address account\n    ) private view returns (SettlementContext memory settlementContext) {\n        // processing accumulators\n        settlementContext.latestVersion = _versions[context.latestPosition.global.timestamp].read();\n        settlementContext.latestCheckpoint = _checkpoints[account][context.latestPosition.local.timestamp].read();\n        settlementContext.orderOracleVersion = oracle.at(context.latestPosition.global.timestamp);\n\n        // v2.2 migration (if latest checkpoint is empty, initialize with latest local collateral)\n        if (\n            settlementContext.latestCheckpoint.tradeFee.isZero() &&\n            settlementContext.latestCheckpoint.settlementFee.isZero() &&\n            settlementContext.latestCheckpoint.transfer.isZero() &&\n            settlementContext.latestCheckpoint.collateral.isZero() &&\n            context.pending.local.collateral.isZero()\n        ) settlementContext.latestCheckpoint.collateral = context.local.collateral;\n    }\n\n    /// @notice Settles the account position up to the latest version\n    /// @param context The context to use\n    /// @param account The account to settle\n    function _settle(Context memory context, address account) private {\n        SettlementContext memory settlementContext = _loadSettlementContext(context, account);\n\n        Order memory nextOrder;\n\n        // settle - process orders whose requested prices are now available from oracle\n        while (\n            context.global.currentId != context.global.latestId &&\n            (nextOrder = _pendingOrder[context.global.latestId + 1].read()).ready(context.latestOracleVersion)\n        ) _processOrderGlobal(context, settlementContext, context.global.latestId + 1, nextOrder);\n\n        while (\n            context.local.currentId != context.local.latestId &&\n            (nextOrder = _pendingOrders[account][context.local.latestId + 1].read()).ready(context.latestOracleVersion)\n        ) _processOrderLocal(context, settlementContext, account, context.local.latestId + 1, nextOrder);\n\n        // sync - advance position timestamps with the latest oracle version\n        if (context.latestOracleVersion.timestamp > context.latestPosition.global.timestamp) {\n            nextOrder = _pendingOrder[context.global.latestId].read();\n            nextOrder.next(context.latestOracleVersion.timestamp);\n            _processOrderGlobal(context, settlementContext, context.global.latestId, nextOrder);\n        }\n\n        if (context.latestOracleVersion.timestamp > context.latestPosition.local.timestamp) {\n            nextOrder = _pendingOrders[account][context.local.latestId].read();\n            nextOrder.next(context.latestOracleVersion.timestamp);\n            _processOrderLocal(context, settlementContext, account, context.local.latestId, nextOrder);\n        }\n    }\n\n    /// @notice Modifies the collateral input per magic values\n    /// @param context The context to use\n    /// @param collateral The collateral to process\n    /// @return The resulting collateral value\n    function _processCollateralMagicValue(Context memory context, Fixed6 collateral) private pure returns (Fixed6) {\n        return collateral.eq(MAGIC_VALUE_WITHDRAW_ALL_COLLATERAL) ?\n            context.local.collateral.mul(Fixed6Lib.NEG_ONE) :\n            collateral;\n    }\n\n    /// @notice Modifies the position input per magic values\n    /// @param context The context to use\n    /// @param currentPosition The current position prior to update\n    /// @param newPosition The position to process\n    /// @return The resulting position value\n    function _processPositionMagicValue(\n        Context memory context,\n        UFixed6 currentPosition,\n        UFixed6 newPosition\n    ) private pure returns (UFixed6) {\n        if (newPosition.eq(MAGIC_VALUE_UNCHANGED_POSITION))\n            return currentPosition;\n        if (newPosition.eq(MAGIC_VALUE_FULLY_CLOSED_POSITION)) {\n            if (currentPosition.isZero()) return currentPosition;\n            return currentPosition.sub(context.latestPosition.local.magnitude().sub(context.pending.local.neg()));\n        }\n        return newPosition;\n    }\n\n    /// @notice Processes the given global pending position into the latest position\n    /// @param context The context to use\n    /// @param newOrderId The id of the pending position to process\n    /// @param newOrder The pending position to process\n    function _processOrderGlobal(\n        Context memory context,\n        SettlementContext memory settlementContext,\n        uint256 newOrderId,\n        Order memory newOrder\n    ) private {\n        OracleVersion memory oracleVersion = oracle.at(newOrder.timestamp);\n        if (oracleVersion.price.isZero()) oracleVersion.price = context.global.latestPrice;\n\n        context.pending.global.sub(newOrder);\n        if (!oracleVersion.valid) newOrder.invalidate();\n\n        VersionAccumulationResult memory accumulationResult;\n        (settlementContext.latestVersion, context.global, accumulationResult) = VersionLib.accumulate(\n            settlementContext.latestVersion,\n            context.global,\n            context.latestPosition.global,\n            newOrder,\n            settlementContext.orderOracleVersion,\n            oracleVersion,\n            context.marketParameter,\n            context.riskParameter\n        );\n\n        context.global.update(newOrderId, accumulationResult, context.marketParameter, context.protocolParameter);\n        context.latestPosition.global.update(newOrder);\n\n        settlementContext.orderOracleVersion = oracleVersion;\n        _versions[newOrder.timestamp].store(settlementContext.latestVersion);\n\n        emit PositionProcessed(newOrderId, newOrder, accumulationResult);\n    }\n\n    /// @notice Processes the given local pending position into the latest position\n    /// @param context The context to use\n    /// @param account The account to process for\n    /// @param newOrderId The id of the pending position to process\n    /// @param newOrder The pending order to process\n    function _processOrderLocal(\n        Context memory context,\n        SettlementContext memory settlementContext,\n        address account,\n        uint256 newOrderId,\n        Order memory newOrder\n    ) private {\n        Version memory versionFrom = _versions[context.latestPosition.local.timestamp].read();\n        Version memory versionTo = _versions[newOrder.timestamp].read();\n\n        context.pending.local.sub(newOrder);\n        if (!versionTo.valid) newOrder.invalidate();\n\n        CheckpointAccumulationResult memory accumulationResult;\n        (settlementContext.latestCheckpoint, accumulationResult) = CheckpointLib.accumulate(\n            settlementContext.latestCheckpoint,\n            newOrder,\n            context.latestPosition.local,\n            versionFrom,\n            versionTo\n        );\n\n        context.local.update(newOrderId, accumulationResult);\n        context.latestPosition.local.update(newOrder);\n\n        _checkpoints[account][newOrder.timestamp].store(settlementContext.latestCheckpoint);\n\n        _credit(context, account, liquidators[account][newOrderId], accumulationResult.liquidationFee);\n        _credit(context, account, referrers[account][newOrderId], accumulationResult.subtractiveFee);\n\n        emit AccountPositionProcessed(account, newOrderId, newOrder, accumulationResult);\n    }\n\n    /// @notice Credits an account's claimable\n    /// @dev The amount must have already come from a corresponding debit in the settlement flow.\n    ///      If the receiver is the context's account, the amount is instead credited in-memory.\n    /// @param context The context to use\n    /// @param contextAccount The account of the current context\n    /// @param receiver The account to credit\n    /// @param amount The amount to credit\n    function _credit(Context memory context, address contextAccount, address receiver, UFixed6 amount) private {\n        if (amount.isZero()) return;\n\n        if (receiver == contextAccount) context.local.credit(amount);\n        else {\n            Local memory receiverLocal = _locals[receiver].read();\n            receiverLocal.credit(amount);\n            _locals[receiver].store(receiverLocal);\n        }\n    }\n\n    /// @notice Only the coordinator or the owner can call\n    modifier onlyCoordinator {\n        if (msg.sender != coordinator && msg.sender != factory().owner()) revert MarketNotCoordinatorError();\n        _;\n    }\n\n    /// @notice Only when the market is not in settle-only mode\n    modifier notSettleOnly(Context memory context) {\n        if (context.marketParameter.settle) revert MarketSettleOnlyError();\n        _;\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/MarketFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport \"@equilibria/root/attribute/Factory.sol\";\nimport \"./interfaces/IOracleProvider.sol\";\nimport \"./interfaces/IMarketFactory.sol\";\n\n/// @title MarketFactory\n/// @notice Manages creating new markets and global protocol parameters.\ncontract MarketFactory is IMarketFactory, Factory {\n    /// @dev The oracle factory\n    IFactory public immutable oracleFactory;\n\n    /// @dev The global protocol parameters\n    ProtocolParameterStorage private _parameter;\n\n    /// @dev Mapping of allowed operators for each account\n    mapping(address => mapping(address => bool)) public operators;\n\n    /// @dev Registry of created markets by oracle and payoff\n    ///      Note: address(0) is used in place of the deprecated payoff provider field\n    mapping(IOracleProvider => mapping(address => IMarket)) private _markets;\n\n    /// @dev The referreral fee level for each referrer\n    mapping(address => UFixed6) public referralFee;\n\n    /// @notice Constructs the contract\n    /// @param oracleFactory_ The oracle factory\n    /// @param implementation_ The initial market implementation contract\n    constructor(IFactory oracleFactory_, address implementation_) Factory(implementation_) {\n        oracleFactory = oracleFactory_;\n    }\n\n    /// @notice Initializes the contract state\n    function initialize() external initializer(1) {\n        __Factory__initialize();\n    }\n\n    /// @notice Returns the global protocol parameters\n    function parameter() public view returns (ProtocolParameter memory) {\n        return _parameter.read();\n    }\n\n    function markets(IOracleProvider oracle) external view returns (IMarket) {\n        return _markets[oracle][address(0)];\n    }\n\n    /// @notice Updates the global protocol parameters\n    /// @param newParameter The new protocol parameters\n    function updateParameter(ProtocolParameter memory newParameter) public onlyOwner {\n        _parameter.validateAndStore(newParameter);\n        emit ParameterUpdated(newParameter);\n    }\n\n    /// @notice Updates the status of an operator for the caller\n    /// @param operator The operator to update\n    /// @param newEnabled The new status of the operator\n    function updateOperator(address operator, bool newEnabled) external {\n        operators[msg.sender][operator] = newEnabled;\n        emit OperatorUpdated(msg.sender, operator, newEnabled);\n    }\n\n    /// @notice Updates the referral fee for a referrer\n    /// @param referrer The referrer to update\n    /// @param newReferralFee The new referral fee\n    function updateReferralFee(address referrer, UFixed6 newReferralFee) external onlyOwner {\n        referralFee[referrer] = newReferralFee;\n        emit ReferralFeeUpdated(referrer, newReferralFee);\n    }\n\n    /// @notice Creates a new market market with the given definition\n    /// @param definition The market definition\n    /// @return newMarket New market contract address\n    function create(IMarket.MarketDefinition calldata definition) external onlyOwner returns (IMarket newMarket) {\n        // verify oracle\n        if (!oracleFactory.instances(IInstance(address(definition.oracle)))) revert FactoryInvalidOracleError();\n\n        // verify invariants\n        if (_markets[definition.oracle][address(0)] != IMarket(address(0)))\n            revert FactoryAlreadyRegisteredError();\n\n        // create and register market\n        newMarket = IMarket(address(_create(abi.encodeCall(IMarket.initialize, (definition)))));\n        _markets[definition.oracle][address(0)] = newMarket;\n\n        emit MarketCreated(newMarket, definition);\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/types/Checkpoint.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"./OracleVersion.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./Global.sol\";\nimport \"./Local.sol\";\nimport \"./Order.sol\";\nimport \"./Version.sol\";\n\n/// @dev Checkpoint type\nstruct Checkpoint {\n    /// @dev The trade fee that the order incurred at the checkpoint settlement\n    Fixed6 tradeFee;\n\n    // @dev The settlement and liquidation fee that the order incurred at the checkpoint settlement\n    UFixed6 settlementFee;\n\n    /// @dev The amount deposited or withdrawn at the checkpoint settlement\n    Fixed6 transfer;\n\n    /// @dev The collateral at the time of the checkpoint settlement\n    Fixed6 collateral;\n}\nstruct CheckpointStorage { uint256 slot0; }\nusing CheckpointStorageLib for CheckpointStorage global;\n\n/// @dev Manually encodes and decodes the Checkpoint struct into storage.\n///\n///     struct StoredCheckpoint {\n///         /* slot 0 */\n///         int48 tradeFee;\n///         uint48 settlementFee;\n///         int64 transfer;\n///         int64 collateral;\n///     }\n///\nlibrary CheckpointStorageLib {\n    // sig: 0xba85116a\n    error CheckpointStorageInvalidError();\n\n    function read(CheckpointStorage storage self) internal view returns (Checkpoint memory) {\n        uint256 slot0 = self.slot0;\n        return Checkpoint(\n            Fixed6.wrap(int256(slot0 << (256 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(slot0 << (256 - 48 - 48)) >> (256 - 48)),\n            Fixed6.wrap(int256(slot0 << (256 - 48 - 48 - 64)) >> (256 - 64)),\n            Fixed6.wrap(int256(slot0 << (256 - 48 - 48 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(CheckpointStorage storage self, Checkpoint memory newValue) external {\n        if (newValue.tradeFee.gt(Fixed6.wrap(type(int48).max))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.lt(Fixed6.wrap(type(int48).min))) revert CheckpointStorageInvalidError();\n        if (newValue.settlementFee.gt(UFixed6.wrap(type(uint48).max))) revert CheckpointStorageInvalidError();\n        if (newValue.transfer.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.transfer.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(Fixed6.unwrap(newValue.tradeFee)        << (256 - 48)) >> (256 - 48) |\n            uint256(UFixed6.unwrap(newValue.settlementFee)  << (256 - 48)) >> (256 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.transfer)        << (256 - 64)) >> (256 - 48 - 48 - 64) |\n            uint256(Fixed6.unwrap(newValue.collateral)      << (256 - 64)) >> (256 - 48 - 48 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/types/Global.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/pid/types/PAccumulator6.sol\";\nimport \"./ProtocolParameter.sol\";\nimport \"./MarketParameter.sol\";\nimport \"../libs/VersionLib.sol\";\n\n/// @dev Global type\nstruct Global {\n    /// @dev The current position ID\n    uint256 currentId;\n\n    /// @dev The latest position id\n    uint256 latestId;\n\n    /// @dev The accrued protocol fee\n    UFixed6 protocolFee;\n\n    /// @dev The accrued oracle fee\n    UFixed6 oracleFee;\n\n    /// @dev The accrued risk fee\n    UFixed6 riskFee;\n\n    /// @dev The accrued donation\n    UFixed6 donation;\n\n    /// @dev The latest seen price\n    Fixed6 latestPrice;\n\n    /// @dev The accumulated market exposure\n    Fixed6 exposure;\n\n    /// @dev The current PAccumulator state\n    PAccumulator6 pAccumulator;\n}\nusing GlobalLib for Global global;\nstruct GlobalStorage { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing GlobalStorageLib for GlobalStorage global;\n\n/// @title Global\n/// @notice Holds the global market state\nlibrary GlobalLib {\n    /// @notice Increments the fees by `amount` using current parameters\n    /// @param self The Global object to update\n    /// @param newLatestId The new latest position id\n    /// @param accumulation The accumulation result\n    /// @param marketParameter The current market parameters\n    /// @param protocolParameter The current protocol parameters\n    function update(\n        Global memory self,\n        uint256 newLatestId,\n        VersionAccumulationResult memory accumulation,\n        MarketParameter memory marketParameter,\n        ProtocolParameter memory protocolParameter\n    ) internal pure {\n        UFixed6 marketFee = accumulation.positionFeeProtocol\n            .add(accumulation.fundingFee)\n            .add(accumulation.interestFee);\n\n        UFixed6 protocolFeeAmount = marketFee.mul(protocolParameter.protocolFee);\n        UFixed6 marketFeeAmount = marketFee.sub(protocolFeeAmount);\n\n        UFixed6 oracleFeeAmount = marketFeeAmount.mul(marketParameter.oracleFee);\n        UFixed6 riskFeeAmount = marketFeeAmount.mul(marketParameter.riskFee);\n        UFixed6 donationAmount = marketFeeAmount.sub(oracleFeeAmount).sub(riskFeeAmount);\n\n        self.latestId = newLatestId;\n        self.protocolFee = self.protocolFee.add(protocolFeeAmount);\n        self.oracleFee = self.oracleFee.add(accumulation.settlementFee).add(oracleFeeAmount);\n        self.riskFee = self.riskFee.add(riskFeeAmount);\n        self.donation = self.donation.add(donationAmount);\n        self.exposure = self.exposure.add(accumulation.positionFeeExposureProtocol);\n    }\n}\n\n/// @dev Manually encodes and decodes the Global struct into storage.\n///\n///     struct StoredGlobal {\n///         /* slot 0 */\n///         uint32 currentId;           // <= 4.29b\n///         uint32 latestId;            // <= 4.29b\n///         uint48 protocolFee;         // <= 281m\n///         uint48 oracleFee;           // <= 281m\n///         uint48 riskFee;             // <= 281m\n///         uint48 donation;            // <= 281m\n///\n///         /* slot 1 */\n///         int32 pAccumulator.value;   // <= 214000%\n///         int24 pAccumulator.skew;    // <= 838%\n///         int64 latestPrice;          // <= 9.22t\n///         int64 exposure;             // <= 9.22t\n///     }\n///\nlibrary GlobalStorageLib {\n    // sig: 0x2142bc27\n    error GlobalStorageInvalidError();\n\n    function read(GlobalStorage storage self) internal view returns (Global memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n        return Global(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48 - 48 - 48)) >> (256 - 48)),\n            Fixed6.wrap(int256(slot1 << (256 - 32 - 24 - 64)) >> (256 - 64)),\n            Fixed6.wrap(int256(slot1 << (256 - 32 - 24 - 64 - 64)) >> (256 - 64)),\n            PAccumulator6(\n                Fixed6.wrap(int256(slot1 << (256 - 32)) >> (256 - 32)),\n                Fixed6.wrap(int256(slot1 << (256 - 32 - 24)) >> (256 - 24))\n            )\n        );\n    }\n\n    function store(GlobalStorage storage self, Global memory newValue) external {\n        if (newValue.currentId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\n        if (newValue.latestId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\n        if (newValue.protocolFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\n        if (newValue.oracleFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\n        if (newValue.riskFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\n        if (newValue.donation.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\n        if (newValue.latestPrice.gt(Fixed6.wrap(type(int64).max))) revert GlobalStorageInvalidError();\n        if (newValue.latestPrice.lt(Fixed6.wrap(type(int64).min))) revert GlobalStorageInvalidError();\n        if (newValue.exposure.gt(Fixed6.wrap(type(int64).max))) revert GlobalStorageInvalidError();\n        if (newValue.exposure.lt(Fixed6.wrap(type(int64).min))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._value.gt(Fixed6.wrap(type(int32).max))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._value.lt(Fixed6.wrap(type(int32).min))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._skew.gt(Fixed6.wrap(type(int24).max))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._skew.lt(Fixed6.wrap(type(int24).min))) revert GlobalStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(UFixed6.unwrap(newValue.protocolFee) << (256 - 48)) >> (256 - 32 - 32 - 48) |\n            uint256(UFixed6.unwrap(newValue.oracleFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48) |\n            uint256(UFixed6.unwrap(newValue.riskFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48 - 48) |\n            uint256(UFixed6.unwrap(newValue.donation) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48 - 48 - 48);\n\n        uint256 encoded1 =\n            uint256(Fixed6.unwrap(newValue.pAccumulator._value) << (256 - 32)) >> (256 - 32) |\n            uint256(Fixed6.unwrap(newValue.pAccumulator._skew) << (256 - 24)) >> (256 - 32 - 24) |\n            uint256(Fixed6.unwrap(newValue.latestPrice) << (256 - 64)) >> (256 - 32 - 24 - 64) |\n            uint256(Fixed6.unwrap(newValue.exposure) << (256 - 64)) >> (256 - 32 - 24 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}\n"
    },
    "@equilibria/perennial-v2/contracts/types/Local.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/Fixed6.sol\";\nimport \"@equilibria/root/accumulator/types/UAccumulator6.sol\";\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"./Version.sol\";\nimport \"./Position.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./OracleVersion.sol\";\nimport \"./Order.sol\";\nimport \"./Checkpoint.sol\";\nimport \"../libs/CheckpointLib.sol\";\n\n/// @dev Local type\nstruct Local {\n    /// @dev The current position id\n    uint256 currentId;\n\n    /// @dev The latest position id\n    uint256 latestId;\n\n    /// @dev The collateral balance\n    Fixed6 collateral;\n\n    /// @dev The claimable balance\n    UFixed6 claimable;\n}\nusing LocalLib for Local global;\nstruct LocalStorage { uint256 slot0; uint256 slot1; }\nusing LocalStorageLib for LocalStorage global;\n\n/// @title Local\n/// @notice Holds the local account state\nlibrary LocalLib {\n    /// @notice Updates the collateral with the new deposit or withdrwal\n    /// @param self The Local object to update\n    /// @param transfer The amount to update the collateral by\n    function update(Local memory self, Fixed6 transfer) internal pure {\n        self.collateral = self.collateral.add(transfer);\n    }\n\n    /// @notice Updates the collateral with the new collateral change\n    /// @param self The Local object to update\n    /// @param accumulation The accumulation result\n    function update(Local memory self, uint256 newId, CheckpointAccumulationResult memory accumulation) internal pure {\n        Fixed6 tradeFee = accumulation.linearFee\n            .add(accumulation.proportionalFee)\n            .add(accumulation.adiabaticFee);\n        self.collateral = self.collateral\n            .add(accumulation.collateral)\n            .sub(tradeFee)\n            .sub(Fixed6Lib.from(accumulation.settlementFee))\n            .sub(Fixed6Lib.from(accumulation.liquidationFee));\n        self.latestId = newId;\n    }\n\n    /// @notice Updates the claimable with the new amount\n    /// @param self The Local object to update\n    /// @param amount The amount to update the claimable by\n    function credit(Local memory self, UFixed6 amount) internal pure {\n        self.claimable = self.claimable.add(amount);\n    }\n}\n\n/// @dev Manually encodes and decodes the Local struct into storage.\n///\n///     struct StoredLocal {\n///         /* slot 0 */\n///         uint32 currentId;       // <= 4.29b\n///         uint32 latestId;        // <= 4.29b\n///         int64 collateral;       // <= 9.22t\n///         uint64 claimable;       // <= 18.44t\n///         bytes4 __DEPRECATED;    // UNSAFE UNTIL RESET\n///\n///         /* slot 1 */\n///         bytes28 __DEPRECATED;   // UNSAFE UNTIL RESET\n///     }\n///\nlibrary LocalStorageLib {\n    // sig: 0xc83d08ec\n    error LocalStorageInvalidError();\n\n    function read(LocalStorage storage self) internal view returns (Local memory) {\n        uint256 slot0 = self.slot0;\n        return Local(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(LocalStorage storage self, Local memory newValue) internal {\n        if (newValue.currentId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\n        if (newValue.latestId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert LocalStorageInvalidError();\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert LocalStorageInvalidError();\n        if (newValue.claimable.gt(UFixed6.wrap(type(uint64).max))) revert LocalStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.claimable) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64);\n        uint256 encoded1; // reset deprecated storage on settlement\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/MarketParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/token/types/Token18.sol\";\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"./ProtocolParameter.sol\";\n\n/// @dev MarketParameter type\nstruct MarketParameter {\n    /// @dev The fee that is taken out of funding\n    UFixed6 fundingFee;\n\n    /// @dev The fee that is taken out of interest\n    UFixed6 interestFee;\n\n    /// @dev The fee that is taken out of maker and taker fees\n    UFixed6 positionFee;\n\n    /// @dev The share of the collected fees that is paid to the oracle\n    UFixed6 oracleFee;\n\n    /// @dev The share of the collected fees that is paid to the risk coordinator\n    UFixed6 riskFee;\n\n    /// @dev The maximum amount of orders that can be pending at one time globally\n    uint256 maxPendingGlobal;\n\n    /// @dev The maximum amount of orders that can be pending at one time per account\n    uint256 maxPendingLocal;\n\n    /// @dev The fixed fee that is charge whenever an oracle request occurs\n    UFixed6 settlementFee;\n\n    /// @dev Whether longs and shorts can always close even when they'd put the market into socialization\n    bool takerCloseAlways;\n\n    /// @dev Whether makers can always close even when they'd put the market into socialization\n    bool makerCloseAlways;\n\n    /// @dev Whether the market is in close-only mode\n    bool closed;\n\n     /// @dev Whether the market is in settle-only mode\n    bool settle;\n}\nstruct MarketParameterStorage { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (1) slots\nusing MarketParameterStorageLib for MarketParameterStorage global;\n\n/// @dev Manually encodes and decodes the MarketParameter struct into storage.\n///\n///    struct StoredMarketParameter {\n///        /* slot 0 */\n///        uint24 fundingFee;          // <= 1677%\n///        uint24 interestFee;         // <= 1677%\n///        uint24 positionFee;         // <= 1677%\n///        uint24 oracleFee;           // <= 1677%\n///        uint24 riskFee;             // <= 1677%\n///        uint16 maxPendingGlobal;    // <= 65k\n///        uint16 maxPendingLocal;     // <= 65k\n///        uint48 settlementFee;       // <= 281m\n///        uint8 flags;\n///    }\n///\nlibrary MarketParameterStorageLib {\n    // sig: 0x7c53e926\n    error MarketParameterStorageInvalidError();\n\n    function read(MarketParameterStorage storage self) internal view returns (MarketParameter memory) {\n        uint256 slot0 = self.slot0;\n\n        uint256 flags = uint256(slot0) >> (256 - 8);\n        (bool takerCloseAlways, bool makerCloseAlways, bool closed, bool settle) =\n            (flags & 0x01 == 0x01, flags & 0x02 == 0x02, flags & 0x04 == 0x04, flags & 0x08 == 0x08);\n\n        return MarketParameter(\n            UFixed6.wrap(uint256(slot0 << (256 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n            uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16)) >> (256 - 16),\n            uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16)) >> (256 - 16),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 48)) >> (256 - 48)),\n            takerCloseAlways,\n            makerCloseAlways,\n            closed,\n            settle\n        );\n    }\n\n    function validate(MarketParameter memory self, ProtocolParameter memory protocolParameter) private pure {\n        if (self.settlementFee.gt(protocolParameter.maxFeeAbsolute)) revert MarketParameterStorageInvalidError();\n\n        if (self.fundingFee.max(self.interestFee).max(self.positionFee).gt(protocolParameter.maxCut))\n            revert MarketParameterStorageInvalidError();\n\n        if (self.oracleFee.add(self.riskFee).gt(UFixed6Lib.ONE)) revert MarketParameterStorageInvalidError();\n    }\n\n    function validateAndStore(\n        MarketParameterStorage storage self,\n        MarketParameter memory newValue,\n        ProtocolParameter memory protocolParameter\n    ) external {\n        validate(newValue, protocolParameter);\n\n        if (newValue.maxPendingGlobal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\n        if (newValue.maxPendingLocal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\n\n        _store(self, newValue);\n    }\n\n    function _store(MarketParameterStorage storage self, MarketParameter memory newValue) private {\n        uint256 flags = (newValue.takerCloseAlways ? 0x01 : 0x00) |\n            (newValue.makerCloseAlways ? 0x02 : 0x00) |\n            (newValue.closed ? 0x04 : 0x00) |\n            (newValue.settle ? 0x08 : 0x00);\n\n        uint256 encoded0 =\n            uint256(UFixed6.unwrap(newValue.fundingFee) << (256 - 24)) >> (256 - 24) |\n            uint256(UFixed6.unwrap(newValue.interestFee) << (256 - 24)) >> (256 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.positionFee) << (256 - 24)) >> (256 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.oracleFee) << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.riskFee) << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24) |\n            uint256(newValue.maxPendingGlobal << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16) |\n            uint256(newValue.maxPendingLocal << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16) |\n            uint256(UFixed6.unwrap(newValue.settlementFee) << (256 - 48)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 48) |\n            uint256(flags << (256 - 8)) >> (256 - 24 - 24 - 24 - 24 - 24 - 32 - 32 - 32 - 32 - 8);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/OracleVersion.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/Fixed6.sol\";\n\n/// @dev A singular oracle version with its corresponding data\nstruct OracleVersion {\n    /// @dev the timestamp of the oracle update\n    uint256 timestamp;\n\n    /// @dev The oracle price of the corresponding version\n    Fixed6 price;\n\n    /// @dev Whether the version is valid\n    bool valid;\n}\n"
    },
    "@equilibria/perennial-v2/contracts/types/Order.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./OracleVersion.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./Global.sol\";\nimport \"./Local.sol\";\nimport \"./Position.sol\";\nimport \"./MarketParameter.sol\";\n\n/// @dev Order type\nstruct Order {\n    /// @dev The timestamp of the order\n    uint256 timestamp;\n\n    /// @dev The quantity of orders that are included in this order\n    uint256 orders;\n\n    /// @dev The change in the collateral\n    Fixed6 collateral;\n\n    /// @dev The positive skew maker order size\n    UFixed6 makerPos;\n\n    /// @dev The negative skew maker order size\n    UFixed6 makerNeg;\n\n    /// @dev The positive skew long order size\n    UFixed6 longPos;\n\n    /// @dev The negative skew long order size\n    UFixed6 longNeg;\n\n    /// @dev The positive skew short order size\n    UFixed6 shortPos;\n\n    /// @dev The negative skew short order size\n    UFixed6 shortNeg;\n\n    /// @dev The protection status semaphore\n    uint256 protection;\n\n    /// @dev The referral fee\n    UFixed6 makerReferral;\n\n    /// @dev The referral fee\n    UFixed6 takerReferral;\n}\nusing OrderLib for Order global;\nstruct OrderStorageGlobal { uint256 slot0; uint256 slot1; uint256 slot2; } // SECURITY: must remain at (3) slots\nusing OrderStorageGlobalLib for OrderStorageGlobal global;\nstruct OrderStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing OrderStorageLocalLib for OrderStorageLocal global;\n\n/// @title Order\n/// @notice Holds the state for an account's update order\nlibrary OrderLib {\n    /// @notice Returns whether the order is ready to be settled\n    /// @param self The order object to check\n    /// @param latestVersion The latest oracle version\n    /// @return Whether the order is ready to be settled\n    function ready(Order memory self, OracleVersion memory latestVersion) internal pure returns (bool) {\n        return latestVersion.timestamp >= self.timestamp;\n    }\n\n    /// @notice Prepares the next order from the current order\n    /// @param self The order object to update\n    /// @param timestamp The current timestamp\n    function next(Order memory self, uint256 timestamp) internal pure  {\n        invalidate(self);\n        (self.timestamp, self.orders, self.collateral, self.protection) = (timestamp, 0, Fixed6Lib.ZERO, 0);\n    }\n\n    /// @notice Invalidates the order\n    /// @param self The order object to update\n    function invalidate(Order memory self) internal pure {\n        (self.makerReferral, self.takerReferral) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Creates a new order from the current position and an update request\n    /// @param timestamp The current timestamp\n    /// @param position The current position\n    /// @param collateral The change in the collateral\n    /// @param newMaker The new maker\n    /// @param newLong The new long\n    /// @param newShort The new short\n    /// @param protect Whether to protect the order\n    /// @param referralFee The referral fee\n    /// @return newOrder The resulting order\n    function from(\n        uint256 timestamp,\n        Position memory position,\n        Fixed6 collateral,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        bool protect,\n        UFixed6 referralFee\n    ) internal pure returns (Order memory newOrder) {\n        (Fixed6 makerAmount, Fixed6 longAmount, Fixed6 shortAmount) = (\n            Fixed6Lib.from(newMaker).sub(Fixed6Lib.from(position.maker)),\n            Fixed6Lib.from(newLong).sub(Fixed6Lib.from(position.long)),\n            Fixed6Lib.from(newShort).sub(Fixed6Lib.from(position.short))\n        );\n\n        UFixed6 referral = makerAmount.abs().add(longAmount.abs()).add(shortAmount.abs()).mul(referralFee);\n\n        newOrder = Order(\n            timestamp,\n            0,\n            collateral,\n            makerAmount.max(Fixed6Lib.ZERO).abs(),\n            makerAmount.min(Fixed6Lib.ZERO).abs(),\n            longAmount.max(Fixed6Lib.ZERO).abs(),\n            longAmount.min(Fixed6Lib.ZERO).abs(),\n            shortAmount.max(Fixed6Lib.ZERO).abs(),\n            shortAmount.min(Fixed6Lib.ZERO).abs(),\n            protect ? 1 : 0,\n            makerAmount.isZero() ? UFixed6Lib.ZERO : referral,\n            makerAmount.isZero() ? referral : UFixed6Lib.ZERO\n        );\n        if (!isEmpty(newOrder)) newOrder.orders = 1;\n    }\n\n    /// @notice Returns whether the order increases any of the account's positions\n    /// @return Whether the order increases any of the account's positions\n    function increasesPosition(Order memory self) internal pure returns (bool) {\n        return increasesMaker(self) || increasesTaker(self);\n    }\n\n    /// @notice Returns whether the order increases the account's long or short positions\n    /// @return Whether the order increases the account's long or short positions\n    function increasesTaker(Order memory self) internal pure returns (bool) {\n        return !self.longPos.isZero() || !self.shortPos.isZero();\n    }\n\n    /// @notice Returns whether the order increases the account's maker position\n    /// @return Whether the order increases the account's maker positions\n    function increasesMaker(Order memory self) internal pure returns (bool) {\n        return !self.makerPos.isZero();\n    }\n\n    /// @notice Returns whether the order decreases the liquidity of the market\n    /// @return Whether the order decreases the liquidity of the market\n    function decreasesLiquidity(Order memory self, Position memory currentPosition) internal pure returns (bool) {\n        Fixed6 currentSkew = currentPosition.skew();\n        Fixed6 latestSkew = currentSkew.sub(long(self)).add(short(self));\n        return !self.makerNeg.isZero() || currentSkew.abs().gt(latestSkew.abs());\n    }\n\n    /// @notice Returns whether the order decreases the efficieny of the market\n    /// @dev Decreased efficiency ratio intuitively means that the market is \"more efficient\" on an OI to LP basis.\n    /// @return Whether the order decreases the liquidity of the market\n    function decreasesEfficiency(Order memory self, Position memory currentPosition) internal pure returns (bool) {\n        UFixed6 currentMajor = currentPosition.major();\n        UFixed6 latestMajor = UFixed6Lib.from(Fixed6Lib.from(currentPosition.long).sub(long(self)))\n            .max(UFixed6Lib.from(Fixed6Lib.from(currentPosition.short).sub(short(self))));\n        return !self.makerNeg.isZero() || currentMajor.gt(latestMajor);\n    }\n\n    /// @notice Returns whether the order is applicable for liquidity checks\n    /// @param self The Order object to check\n    /// @param marketParameter The market parameter\n    /// @return Whether the order is applicable for liquidity checks\n    function liquidityCheckApplicable(\n        Order memory self,\n        MarketParameter memory marketParameter\n    ) internal pure returns (bool) {\n        return !marketParameter.closed &&\n            ((maker(self).isZero()) || !marketParameter.makerCloseAlways || increasesMaker(self)) &&\n            ((long(self).isZero() && short(self).isZero()) || !marketParameter.takerCloseAlways || increasesTaker(self));\n    }\n\n    /// @notice Returns whether the order is protected\n    /// @param self The order object to check\n    /// @return Whether the order is protected\n    function protected(Order memory self) internal pure returns (bool) {\n        return self.protection != 0;\n    }\n\n    /// @notice Returns whether the order is empty\n    /// @param self The order object to check\n    /// @return Whether the order is empty\n    function isEmpty(Order memory self) internal pure returns (bool) {\n        return pos(self).isZero() && neg(self).isZero();\n    }\n\n     /// @notice Returns the direction of the order\n    /// @dev 0 = maker, 1 = long, 2 = short\n    /// @param self The position object to check\n    /// @return The direction of the position\n    function direction(Order memory self) internal pure returns (uint256) {\n        if (!self.longPos.isZero() || !self.longNeg.isZero()) return 1;\n        if (!self.shortPos.isZero() || !self.shortNeg.isZero()) return 2;\n\n        return 0;\n    }\n\n    /// @notice Returns the magnitude of the order\n    /// @param self The order object to check\n    /// @return The magnitude of the order\n    function magnitude(Order memory self) internal pure returns (Fixed6) {\n        return maker(self).add(long(self)).add(short(self));\n    }\n\n    /// @notice Returns the maker delta of the order\n    /// @param self The order object to check\n    /// @return The maker delta of the order\n    function maker(Order memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.makerPos).sub(Fixed6Lib.from(self.makerNeg));\n    }\n\n    /// @notice Returns the long delta of the order\n    /// @param self The order object to check\n    /// @return The long delta of the order\n    function long(Order memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.longPos).sub(Fixed6Lib.from(self.longNeg));\n    }\n\n    /// @notice Returns the short delta of the order\n    /// @param self The order object to check\n    /// @return The short delta of the order\n    function short(Order memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.shortPos).sub(Fixed6Lib.from(self.shortNeg));\n    }\n\n    /// @notice Returns the positive taker delta of the order\n    /// @param self The order object to check\n    /// @return The positive taker delta of the order\n    function takerPos(Order memory self) internal pure returns (UFixed6) {\n        return self.longPos.add(self.shortNeg);\n    }\n\n    /// @notice Returns the negative taker delta of the order\n    /// @param self The order object to check\n    /// @return The negative taker delta of the order\n    function takerNeg(Order memory self) internal pure returns (UFixed6) {\n        return self.shortPos.add(self.longNeg);\n    }\n\n    /// @notice Returns the total maker delta of the order\n    /// @param self The order object to check\n    /// @return The total maker delta of the order\n    function makerTotal(Order memory self) internal pure returns (UFixed6) {\n        return self.makerPos.add(self.makerNeg);\n    }\n\n    /// @notice Returns the total taker delta of the order\n    /// @param self The order object to check\n    /// @return The total taker delta of the order\n    function takerTotal(Order memory self) internal pure returns (UFixed6) {\n        return self.takerPos().add(self.takerNeg());\n    }\n\n    /// @notice Returns the positive delta of the order\n    /// @param self The order object to check\n    /// @return The positive delta of the order\n    function pos(Order memory self) internal pure returns (UFixed6) {\n        return self.makerPos.add(self.longPos).add(self.shortPos);\n    }\n\n    /// @notice Returns the positive delta of the order\n    /// @param self The order object to check\n    /// @return The positive delta of the order\n    function neg(Order memory self) internal pure returns (UFixed6) {\n        return self.makerNeg.add(self.longNeg).add(self.shortNeg);\n    }\n\n    /// @notice Updates the current global order with a new local order\n    /// @param self The order object to update\n    /// @param order The new order\n    function add(Order memory self, Order memory order) internal pure {\n        (self.orders, self.collateral, self.protection, self.makerReferral, self.takerReferral) = (\n            self.orders + order.orders,\n            self.collateral.add(order.collateral),\n            self.protection + order.protection,\n            self.makerReferral.add(order.makerReferral),\n            self.takerReferral.add(order.takerReferral)\n        );\n\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) = (\n            self.makerPos.add(order.makerPos),\n            self.makerNeg.add(order.makerNeg),\n            self.longPos.add(order.longPos),\n            self.longNeg.add(order.longNeg),\n            self.shortPos.add(order.shortPos),\n            self.shortNeg.add(order.shortNeg)\n        );\n    }\n\n    /// @notice Subtracts the latest local order from current global order\n    /// @param self The order object to update\n    /// @param order The latest order\n    function sub(Order memory self, Order memory order) internal pure {\n        (self.orders, self.collateral, self.protection, self.makerReferral, self.takerReferral) = (\n            self.orders - order.orders,\n            self.collateral.sub(order.collateral),\n            self.protection - order.protection,\n            self.makerReferral.sub(order.makerReferral),\n            self.takerReferral.sub(order.takerReferral)\n        );\n\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) = (\n            self.makerPos.sub(order.makerPos),\n            self.makerNeg.sub(order.makerNeg),\n            self.longPos.sub(order.longPos),\n            self.longNeg.sub(order.longNeg),\n            self.shortPos.sub(order.shortPos),\n            self.shortNeg.sub(order.shortNeg)\n        );\n    }\n}\n\n/// @dev Manually encodes and decodes the global Order struct into storage.\n///\n///     struct StoredOrderGlobal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint32 orders;\n///         int64 collateral;\n///         uint64 makerPos;\n///         uint64 makerNeg;\n///\n///         /* slot 1 */\n///         uint64 longPos;\n///         uint64 longNeg;\n///         uint64 shortPos;\n///         uint64 shortNeg;\n///\n///         /* slot 2 */\n///         uint64 takerReferral;\n///         uint64 makerReferral;\n///     }\n///\nlibrary OrderStorageGlobalLib {\n    function read(OrderStorageGlobal storage self) internal view returns (Order memory) {\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\n\n        return Order(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64 - 64)) >> (256 - 64)),\n            0,\n            UFixed6.wrap(uint256(slot2 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot2 << (256 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(OrderStorageGlobal storage self, Order memory newValue) internal {\n        OrderStorageLib.validate(newValue);\n\n        if (newValue.makerPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.makerNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.longPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.longNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.shortPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.shortNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.makerPos) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.makerNeg) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64 - 64);\n        uint256 encoded1 =\n            uint256(UFixed6.unwrap(newValue.longPos) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.longNeg) << (256 - 64)) >> (256 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.shortPos) << (256 - 64)) >> (256 - 64 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.shortNeg) << (256 - 64)) >> (256 - 64 - 64 - 64 - 64);\n        uint256 encoded2 =\n            uint256(UFixed6.unwrap(newValue.makerReferral) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerReferral) << (256 - 64)) >> (256 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n            sstore(add(self.slot, 2), encoded2)\n        }\n    }\n}\n\n/// @dev Manually encodes and decodes the local Order struct into storage.\n///\n///     struct StoredOrderLocal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint32 orders;\n///         int64 collateral;\n///         uint2 direction;\n///         uint62 magnitudePos;\n///         uint62 magnitudeNeg;\n///         uint1 protection;\n///\n///         /* slot 1 */\n///         uint64 takerReferral;\n///         uint64 makerReferral;\n///     }\n///\nlibrary OrderStorageLocalLib {\n    function read(OrderStorageLocal storage self) internal view returns (Order memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n\n        uint256 direction = uint256(slot0 << (256 - 32 - 32 - 64 - 2)) >> (256 - 2);\n        UFixed6 magnitudePos = UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62)) >> (256 - 62));\n        UFixed6 magnitudeNeg = UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62 - 62)) >> (256 - 62));\n\n        return Order(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\n            direction == 0 ? magnitudePos : UFixed6Lib.ZERO,\n            direction == 0 ? magnitudeNeg : UFixed6Lib.ZERO,\n            direction == 1 ? magnitudePos : UFixed6Lib.ZERO,\n            direction == 1 ? magnitudeNeg : UFixed6Lib.ZERO,\n            direction == 2 ? magnitudePos : UFixed6Lib.ZERO,\n            direction == 2 ? magnitudeNeg : UFixed6Lib.ZERO,\n            uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62 - 62 - 1)) >> (256 - 1),\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(OrderStorageLocal storage self, Order memory newValue) internal {\n        OrderStorageLib.validate(newValue);\n\n        (UFixed6 magnitudePos, UFixed6 magnitudeNeg) = (newValue.pos(), newValue.neg());\n\n        if (magnitudePos.gt(UFixed6.wrap(2 ** 62 - 1))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (magnitudeNeg.gt(UFixed6.wrap(2 ** 62 - 1))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.protection > 1) revert OrderStorageLib.OrderStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\n            uint256(newValue.direction() << (256 - 2)) >> (256 - 32 - 32 - 64 - 2) |\n            uint256(UFixed6.unwrap(magnitudePos) << (256 - 62)) >> (256 - 32 - 32 - 64 - 2 - 62) |\n            uint256(UFixed6.unwrap(magnitudeNeg) << (256 - 62)) >> (256 - 32 - 32 - 64 - 2 - 62 - 62) |\n            uint256(newValue.protection << (256 - 1)) >> (256 - 32 - 32 - 64 - 2 - 62 - 62 - 1);\n        uint256 encoded1 =\n            uint256(UFixed6.unwrap(newValue.makerReferral) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerReferral) << (256 - 64)) >> (256 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}\n\nlibrary OrderStorageLib {\n    // sig: 0x67e45965\n    error OrderStorageInvalidError();\n\n    function validate(Order memory newValue) internal pure {\n        if (newValue.timestamp > type(uint32).max) revert OrderStorageInvalidError();\n        if (newValue.orders > type(uint32).max) revert OrderStorageInvalidError();\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert OrderStorageInvalidError();\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert OrderStorageInvalidError();\n        if (newValue.makerReferral.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageInvalidError();\n        if (newValue.takerReferral.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageInvalidError();\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/Position.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./OracleVersion.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./Global.sol\";\nimport \"./Local.sol\";\nimport \"./Order.sol\";\n\n/// @dev Order type\nstruct Position {\n    /// @dev The timestamp of the position\n    uint256 timestamp;\n\n    /// @dev The maker position size\n    UFixed6 maker;\n\n    /// @dev The long position size\n    UFixed6 long;\n\n    /// @dev The short position size\n    UFixed6 short;\n}\nusing PositionLib for Position global;\nstruct PositionStorageGlobal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing PositionStorageGlobalLib for PositionStorageGlobal global;\nstruct PositionStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing PositionStorageLocalLib for PositionStorageLocal global;\n\n/// @title Position\n/// @notice Holds the state for a position\nlibrary PositionLib {\n    /// @notice Returns a cloned copy of the position\n    /// @param self The position object to clone\n    /// @return A cloned copy of the position\n    function clone(Position memory self) internal pure returns (Position memory) {\n        return Position(self.timestamp, self.maker, self.long, self.short);\n    }\n\n    /// @notice Updates the position with a new order\n    /// @param self The position object to update\n    /// @param order The new order\n    function update(Position memory self, Order memory order) internal pure {\n        self.timestamp = order.timestamp;\n\n        (self.maker, self.long, self.short) = (\n            UFixed6Lib.from(Fixed6Lib.from(self.maker).add(order.maker())),\n            UFixed6Lib.from(Fixed6Lib.from(self.long).add(order.long())),\n            UFixed6Lib.from(Fixed6Lib.from(self.short).add(order.short()))\n        );\n    }\n\n    /// @notice Returns the direction of the position\n    /// @dev 0 = maker, 1 = long, 2 = short\n    /// @param self The position object to check\n    /// @return The direction of the position\n    function direction(Position memory self) internal pure returns (uint256) {\n        return self.long.isZero() ? (self.short.isZero() ? 0 : 2) : 1;\n    }\n\n    /// @notice Returns the maximum position size\n    /// @param self The position object to check\n    /// @return The maximum position size\n    function magnitude(Position memory self) internal pure returns (UFixed6) {\n        return self.long.max(self.short).max(self.maker);\n    }\n\n    /// @notice Returns the maximum taker position size\n    /// @param self The position object to check\n    /// @return The maximum taker position size\n    function major(Position memory self) internal pure returns (UFixed6) {\n        return self.long.max(self.short);\n    }\n\n    /// @notice Returns the minimum maker position size\n    /// @param self The position object to check\n    /// @return The minimum maker position size\n    function minor(Position memory self) internal pure returns (UFixed6) {\n        return self.long.min(self.short);\n    }\n\n    /// @notice Returns the skew of the position\n    /// @param self The position object to check\n    /// @return The skew of the position\n    function skew(Position memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.long).sub(Fixed6Lib.from(self.short));\n    }\n\n    /// @notice Returns the utilization of the position\n    /// @dev utilization = major / (maker + minor)\n    /// @param self The position object to check\n    /// @param riskParameter The current risk parameter\n    /// @return The utilization of the position\n    function utilization(Position memory self, RiskParameter memory riskParameter) internal pure returns (UFixed6) {\n        // long-short net utilization of the maker position\n        UFixed6 netUtilization = major(self).unsafeDiv(self.maker.add(minor(self)));\n\n        // efficiency limit utilization of the maker position\n        UFixed6 efficiencyUtilization = major(self).mul(riskParameter.efficiencyLimit).unsafeDiv(self.maker);\n\n        // maximum of the two utilizations, capped at 100%\n        return netUtilization.max(efficiencyUtilization).min(UFixed6Lib.ONE);\n    }\n\n    /// @notice Returns the portion of the position that is covered by the maker\n    /// @param self The position object to check\n    /// @return The portion of the position that is covered by the maker\n    function socializedMakerPortion(Position memory self) internal pure returns (UFixed6) {\n        return takerSocialized(self).isZero() ?\n            UFixed6Lib.ZERO :\n            takerSocialized(self).sub(minor(self)).div(takerSocialized(self));\n    }\n\n    /// @notice Returns the long position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The long position with socialization taken into account\n    function longSocialized(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.add(self.short).min(self.long);\n    }\n\n    /// @notice Returns the short position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The short position with socialization taken into account\n    function shortSocialized(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.add(self.long).min(self.short);\n    }\n\n    /// @notice Returns the major position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The major position with socialization taken into account\n    function takerSocialized(Position memory self) internal pure returns (UFixed6) {\n        return major(self).min(minor(self).add(self.maker));\n    }\n\n    /// @notice Returns the efficiency of the position\n    /// @dev efficiency = maker / major\n    /// @param self The position object to check\n    /// @return The efficiency of the position\n    function efficiency(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.unsafeDiv(major(self)).min(UFixed6Lib.ONE);\n    }\n\n    /// @notice Returns the whether the position is socialized\n    /// @param self The position object to check\n    /// @return Whether the position is socialized\n    function socialized(Position memory self) internal pure returns (bool) {\n        return self.maker.add(self.short).lt(self.long) || self.maker.add(self.long).lt(self.short);\n    }\n\n    /// @notice Returns the whether the position is single-sided\n    /// @param self The position object to check\n    /// @return Whether the position is single-sided\n    function singleSided(Position memory self) internal pure returns (bool) {\n        return magnitude(self).eq(self.long.add(self.short).add(self.maker));\n    }\n\n    /// @notice Returns the whether the position is empty\n    /// @param self The position object to check\n    /// @return Whether the position is empty\n    function empty(Position memory self) internal pure returns (bool) {\n        return magnitude(self).isZero();\n    }\n\n    /// @notice Returns the maintenance requirement of the position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The maintenance requirement of the position\n    function maintenance(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.maintenance, riskParameter.minMaintenance);\n    }\n\n    /// @notice Returns the margin requirement of the position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The margin requirement of the position\n    function margin(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.margin, riskParameter.minMargin);\n    }\n\n    /// @notice Returns the maintenance requirement of the position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The maintenance requirement of the position\n    function maintenance(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        return maintenance(magnitude(self), latestVersion, riskParameter);\n    }\n\n    /// @notice Returns the margin requirement of the position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The margin requirement of the position\n    function margin(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        return margin(magnitude(self), latestVersion, riskParameter);\n    }\n\n    /// @notice Returns the collateral requirement of the position magnitude\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param requirementRatio The ratio requirement to the notional\n    /// @param requirementFixed The fixed requirement\n    /// @return The collateral requirement of the position magnitude\n    function _collateralRequirement(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        UFixed6 requirementRatio,\n        UFixed6 requirementFixed\n    ) private pure returns (UFixed6) {\n        if (positionMagnitude.isZero()) return UFixed6Lib.ZERO;\n        return positionMagnitude.mul(latestVersion.price.abs()).mul(requirementRatio).max(requirementFixed);\n    }\n\n    /// @notice Returns the whether the position is maintained\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is maintained\n    function maintained(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return UFixed6Lib.unsafeFrom(collateral).gte(maintenance(positionMagnitude, latestVersion, riskParameter));\n    }\n\n    /// @notice Returns the whether the position is margined\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is margined\n    function margined(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return UFixed6Lib.unsafeFrom(collateral).gte(margin(positionMagnitude, latestVersion, riskParameter));\n    }\n\n    /// @notice Returns the whether the position is maintained\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is maintained\n    function maintained(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return maintained(magnitude(self), latestVersion, riskParameter, collateral);\n    }\n\n    /// @notice Returns the whether the position is margined\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is margined\n    function margined(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return margined(magnitude(self), latestVersion, riskParameter, collateral);\n    }\n}\n\n/// @dev Manually encodes and decodes the global Position struct into storage.\n///\n///     struct StoredPositionGlobal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint96 __unallocated__;\n///         uint64 long;\n///         uint64 short;\n///\n///         /* slot 1 */\n///         uint64 maker;\n///         uint192 __unallocated__;\n///     }\n///\nlibrary PositionStorageGlobalLib {\n    function read(PositionStorageGlobal storage self) internal view returns (Position memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n        return Position(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 48 - 48 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 48 - 48 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(PositionStorageGlobal storage self, Position memory newValue) external {\n        PositionStorageLib.validate(newValue);\n\n        if (newValue.maker.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\n        if (newValue.long.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\n        if (newValue.short.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(UFixed6.unwrap(newValue.long) << (256 - 64)) >> (256 - 32 - 48 - 48 - 64) |\n            uint256(UFixed6.unwrap(newValue.short) << (256 - 64)) >> (256 - 32 - 48 - 48 - 64 - 64);\n        uint256 encoded1 =\n            uint256(UFixed6.unwrap(newValue.maker) << (256 - 64)) >> (256 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}\n\n/// @dev Manually encodes and decodes the local Position struct into storage.\n///\n///     struct StoredPositionLocal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint224 __unallocated__;\n///\n///         /* slot 1 */\n///         uint2 direction;\n///         uint62 magnitude;\n///         uint192 __unallocated__;\n///     }\n///\nlibrary PositionStorageLocalLib {\n    function read(PositionStorageLocal storage self) internal view returns (Position memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n\n        uint256 direction = uint256(slot1 << (256 - 2)) >> (256 - 2);\n        UFixed6 magnitude = UFixed6.wrap(uint256(slot1 << (256 - 2 - 62)) >> (256 - 62));\n\n        return Position(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            direction == 0 ? magnitude : UFixed6Lib.ZERO,\n            direction == 1 ? magnitude : UFixed6Lib.ZERO,\n            direction == 2 ? magnitude : UFixed6Lib.ZERO\n        );\n    }\n\n    function store(PositionStorageLocal storage self, Position memory newValue) external {\n        PositionStorageLib.validate(newValue);\n\n        UFixed6 magnitude = newValue.magnitude();\n\n        if (magnitude.gt(UFixed6.wrap(2 ** 62 - 1))) revert PositionStorageLib.PositionStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32);\n        uint256 encoded1 =\n            uint256(newValue.direction() << (256 - 2)) >> (256 - 2) |\n            uint256(UFixed6.unwrap(magnitude) << (256 - 62)) >> (256 - 2 - 62);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}\n\nlibrary PositionStorageLib {\n    // sig: 0x52a8a97f\n    error PositionStorageInvalidError();\n\n    function validate(Position memory newValue) internal pure {\n        if (newValue.timestamp > type(uint32).max) revert PositionStorageInvalidError();\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/ProtocolParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev ProtocolParameter type\nstruct ProtocolParameter {\n    /// @dev The share of the market fees that are retained by the protocol before being distributed\n    UFixed6 protocolFee;\n\n    /// @dev The maximum for market fee parameters\n    UFixed6 maxFee;\n\n    /// @dev The maximum for market absolute fee parameters\n    UFixed6 maxFeeAbsolute;\n\n    /// @dev The maximum for market cut parameters\n    UFixed6 maxCut;\n\n    /// @dev The maximum for market rate parameters\n    UFixed6 maxRate;\n\n    /// @dev The minimum for market maintenance parameters\n    UFixed6 minMaintenance;\n\n    /// @dev The minimum for market efficiency parameters\n    UFixed6 minEfficiency;\n\n    /// @dev The default referrer fee\n    UFixed6 referralFee;\n}\nstruct StoredProtocolParameter {\n    /* slot 0 */\n    uint24 protocolFee;        // <= 1677%\n    uint24 maxFee;             // <= 1677%\n    uint48 maxFeeAbsolute;     // <= 281m\n    uint24 maxCut;             // <= 1677%\n    uint32 maxRate;            // <= 214748% (capped at 31 bits to accommodate int32 rates)\n    uint24 minMaintenance;     // <= 1677%\n    uint24 minEfficiency;      // <= 1677%\n    uint24 referralFee;        // <= 1677%\n}\nstruct ProtocolParameterStorage { StoredProtocolParameter value; } // SECURITY: must remain at (1) slots\nusing ProtocolParameterStorageLib for ProtocolParameterStorage global;\n\nlibrary ProtocolParameterStorageLib {\n    // sig: 0x4dc1bc59\n    error ProtocolParameterStorageInvalidError();\n\n    function read(ProtocolParameterStorage storage self) internal view returns (ProtocolParameter memory) {\n        StoredProtocolParameter memory value = self.value;\n        return ProtocolParameter(\n            UFixed6.wrap(uint256(value.protocolFee)),\n            UFixed6.wrap(uint256(value.maxFee)),\n            UFixed6.wrap(uint256(value.maxFeeAbsolute)),\n            UFixed6.wrap(uint256(value.maxCut)),\n            UFixed6.wrap(uint256(value.maxRate)),\n            UFixed6.wrap(uint256(value.minMaintenance)),\n            UFixed6.wrap(uint256(value.minEfficiency)),\n            UFixed6.wrap(uint256(value.referralFee))\n        );\n    }\n\n    function validate(ProtocolParameter memory self) internal pure {\n        if (self.protocolFee.gt(self.maxCut)) revert ProtocolParameterStorageInvalidError();\n        if (self.maxCut.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\n    }\n\n    function validateAndStore(ProtocolParameterStorage storage self, ProtocolParameter memory newValue) internal {\n        validate(newValue);\n\n        if (newValue.maxFee.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.maxFeeAbsolute.gt(UFixed6.wrap(type(uint48).max))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.maxRate.gt(UFixed6.wrap(type(uint32).max / 2))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.minMaintenance.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.minEfficiency.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.referralFee.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\n\n        self.value = StoredProtocolParameter(\n            uint24(UFixed6.unwrap(newValue.protocolFee)),\n            uint24(UFixed6.unwrap(newValue.maxFee)),\n            uint48(UFixed6.unwrap(newValue.maxFeeAbsolute)),\n            uint24(UFixed6.unwrap(newValue.maxCut)),\n            uint32(UFixed6.unwrap(newValue.maxRate)),\n            uint24(UFixed6.unwrap(newValue.minMaintenance)),\n            uint24(UFixed6.unwrap(newValue.minEfficiency)),\n            uint24(UFixed6.unwrap(newValue.referralFee))\n        );\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/RiskParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed6.sol\";\nimport \"@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol\";\nimport \"@equilibria/root/pid/types/PController6.sol\";\nimport \"@equilibria/root/adiabatic/types/LinearAdiabatic6.sol\";\nimport \"@equilibria/root/adiabatic/types/InverseAdiabatic6.sol\";\nimport \"../interfaces/IOracleProvider.sol\";\nimport \"./ProtocolParameter.sol\";\n\n/// @dev RiskParameter type\nstruct RiskParameter {\n    /// @dev The minimum amount of collateral required to open a new position as a percentage of notional\n    UFixed6 margin;\n\n    /// @dev The minimum amount of collateral that must be maintained as a percentage of notional\n    UFixed6 maintenance;\n\n    /// @dev The taker impact fee\n    LinearAdiabatic6 takerFee;\n\n    /// @dev The maker fee configuration\n    InverseAdiabatic6 makerFee;\n\n    /// @dev The maximum amount of maker positions that opened\n    UFixed6 makerLimit;\n\n    /// @dev The minimum limit of the efficiency metric\n    UFixed6 efficiencyLimit;\n\n    /// @dev The percentage fee on the notional that is charged when a position is liquidated\n    UFixed6 liquidationFee;\n\n    /// @dev The utilization curve that is used to compute maker interest\n    UJumpRateUtilizationCurve6 utilizationCurve;\n\n    /// @dev The p controller that is used to compute long-short funding\n    PController6 pController;\n\n    /// @dev The minimum fixed amount that is required to open a position\n    UFixed6 minMargin;\n\n    /// @dev The minimum fixed amount that is required for maintenance\n    UFixed6 minMaintenance;\n\n    /// @dev The maximum amount of time since the latest oracle version that update may still be called\n    uint256 staleAfter;\n\n    /// @dev Whether or not the maker should always receive positive funding\n    bool makerReceiveOnly;\n}\nstruct RiskParameterStorage { uint256 slot0; uint256 slot1; uint256 slot2; } // SECURITY: must remain at (3) slots\nusing RiskParameterStorageLib for RiskParameterStorage global;\n\n//    struct StoredRiskParameter {\n//        /* slot 0 */ (30)\n//        uint24 margin;                              // <= 1677%\n//        uint24 maintenance;                         // <= 1677%\n//        uint24 takerFee;                            // <= 1677%\n//        uint24 takerFeeMagnitude;                   // <= 1677%\n//        uint24 takerImpactFee;                      // <= 1677%\n//        uint24 makerFee;                            // <= 1677%\n//        uint24 makerFeeMagnitude;                   // <= 1677%\n//        uint48 makerLimit;                          // <= 281t (no decimals)\n//        uint24 efficiencyLimit;                     // <= 1677%\n//\n//        /* slot 1 */ (31)\n//        uint24 makerImpactFee;                      // <= 1677%\n//        uint48 makerSkewScale;                      // <= 281t (no decimals)\n//        uint48 takerSkewScale;                      // <= 281t (no decimals)\n//        uint24 utilizationCurveMinRate;             // <= 1677%\n//        uint24 utilizationCurveMaxRate;             // <= 1677%\n//        uint24 utilizationCurveTargetRate;          // <= 1677%\n//        uint24 utilizationCurveTargetUtilization;   // <= 1677%\n//        int32 pControllerMin;                       // <= 214748%\n//\n//        /* slot 2 */ (32)\n//        uint48 pControllerK;                        // <= 281m\n//        int32 pControllerMax;                       // <= 214748%\n//        uint48 minMargin;                           // <= 281m\n//        uint48 minMaintenance;                      // <= 281m\n//        uint48 liquidationFee;                      // <= 281m\n//        uint24 staleAfter;                          // <= 16m s\n//        bool makerReceiveOnly;\n//    }\nlibrary RiskParameterStorageLib {\n    // sig: 0x7ecd083f\n    error RiskParameterStorageInvalidError();\n\n    function read(RiskParameterStorage storage self) internal view returns (RiskParameter memory) {\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\n        return RiskParameter(\n            UFixed6.wrap(uint256(       slot0 << (256 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24)) >> (256 - 24)),\n            LinearAdiabatic6(\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6Lib.from(uint256(slot1 << (256 - 24 - 48 - 48)) >> (256 - 48))\n            ),\n            InverseAdiabatic6(\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot1 << (256 - 24)) >> (256 - 24)),\n                UFixed6Lib.from(uint256(slot1 << (256 - 24 - 48)) >> (256 - 48))\n            ),\n            UFixed6Lib.from(uint256(    slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48 - 24)) >> (256 - 24)),\n\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48)) >> (256 - 48)),\n            UJumpRateUtilizationCurve6(\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24)) >> (256 - 24))\n            ),\n\n            PController6(\n                UFixed6.wrap(uint256(   slot2 << (256 - 48)) >> (256 - 48)),\n                Fixed6.wrap(int256(     slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24 - 32)) >> (256 - 32)),\n                Fixed6.wrap(int256(     slot2 << (256 - 48 - 32)) >> (256 - 32))\n            ),\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48)) >> (256 - 48)),\n                         uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48 - 24)) >> (256 - 24),\n            0 !=        (uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48 - 24 - 8)) >> (256 - 8))\n        );\n    }\n\n    function validate(RiskParameter memory self, ProtocolParameter memory protocolParameter) private pure {\n        if (\n            self.takerFee.linearFee.max(self.takerFee.proportionalFee).max(self.takerFee.adiabaticFee)\n                .max(self.makerFee.linearFee).max(self.makerFee.proportionalFee).max(self.makerFee.adiabaticFee)\n                .gt(protocolParameter.maxFee)\n        ) revert RiskParameterStorageInvalidError();\n\n        if (self.liquidationFee.gt(protocolParameter.maxFeeAbsolute)) revert RiskParameterStorageInvalidError();\n\n        if (\n            self.utilizationCurve.minRate.max(self.utilizationCurve.maxRate).max(self.utilizationCurve.targetRate)\n                .max(self.pController.max.abs()).max(self.pController.min.abs())\n                .gt(protocolParameter.maxRate)\n        ) revert RiskParameterStorageInvalidError();\n\n        if (self.maintenance.lt(protocolParameter.minMaintenance)) revert RiskParameterStorageInvalidError();\n\n        if (self.margin.lt(self.maintenance)) revert RiskParameterStorageInvalidError();\n\n        if (self.efficiencyLimit.lt(protocolParameter.minEfficiency)) revert RiskParameterStorageInvalidError();\n\n        if (self.utilizationCurve.targetUtilization.gt(UFixed6Lib.ONE)) revert RiskParameterStorageInvalidError();\n\n        if (self.minMaintenance.lt(self.liquidationFee)) revert RiskParameterStorageInvalidError();\n\n        if (self.minMargin.lt(self.minMaintenance)) revert RiskParameterStorageInvalidError();\n\n        // Disable non-zero maker adiabatic fee\n        if (!self.makerFee.adiabaticFee.isZero()) revert RiskParameterStorageInvalidError();\n    }\n\n    function validateAndStore(\n        RiskParameterStorage storage self,\n        RiskParameter memory newValue,\n        ProtocolParameter memory protocolParameter\n    ) external {\n        validate(newValue, protocolParameter);\n\n        if (newValue.margin.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.minMargin.gt(UFixed6.wrap(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.efficiencyLimit.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.makerLimit.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.pController.k.gt(UFixed6.wrap(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.takerFee.scale.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.makerFee.scale.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.staleAfter > uint256(type(uint24).max)) revert RiskParameterStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(UFixed6.unwrap(newValue.margin)                    << (256 - 24)) >> (256 - 24) |\n            uint256(UFixed6.unwrap(newValue.maintenance)               << (256 - 24)) >> (256 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.takerFee.linearFee)        << (256 - 24)) >> (256 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.takerFee.proportionalFee)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.takerFee.adiabaticFee)     << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.makerFee.linearFee)        << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.makerFee.proportionalFee)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24) |\n            uint256(newValue.makerLimit.truncate()                     << (256 - 48)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48) |\n            uint256(UFixed6.unwrap(newValue.efficiencyLimit)           << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48 - 24);\n\n        uint256 encoded1 =\n            uint256(UFixed6.unwrap(newValue.makerFee.adiabaticFee)              << (256 - 24)) >> (256 - 24) |\n            uint256(newValue.makerFee.scale.truncate()                          << (256 - 48)) >> (256 - 24 - 48) |\n            uint256(newValue.takerFee.scale.truncate()                          << (256 - 48)) >> (256 - 24 - 48 - 48) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.minRate)           << (256 - 24)) >> (256 - 24 - 48 - 48 - 24) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.maxRate)           << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetRate)        << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetUtilization) << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24) |\n            uint256(Fixed6.unwrap(newValue.pController.min)                     << (256 - 32)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24 - 32);\n\n        uint256 encoded2 =\n            uint256(UFixed6.unwrap(newValue.pController.k)                  << (256 - 48)) >> (256 - 48) |\n            uint256(Fixed6.unwrap(newValue.pController.max)                 << (256 - 32)) >> (256 - 48 - 32) |\n            uint256(UFixed6.unwrap(newValue.minMargin)                      << (256 - 48)) >> (256 - 48 - 32 - 48) |\n            uint256(UFixed6.unwrap(newValue.minMaintenance)                 << (256 - 48)) >> (256 - 48 - 32 - 48 - 48) |\n            uint256(UFixed6.unwrap(newValue.liquidationFee)                 << (256 - 48)) >> (256 - 48 - 32 - 48 - 48 - 48) |\n            uint256(newValue.staleAfter                                     << (256 - 24)) >> (256 - 48 - 32 - 48 - 48 - 48 - 24) |\n            uint256((newValue.makerReceiveOnly ? uint256(1) : uint256(0))   << (256 - 8))  >> (256 - 48 - 32 - 48 - 48 - 48 - 24 - 8);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n            sstore(add(self.slot, 2), encoded2)\n        }\n    }\n}"
    },
    "@equilibria/perennial-v2/contracts/types/Version.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport \"./ProtocolParameter.sol\";\nimport \"./MarketParameter.sol\";\nimport \"./RiskParameter.sol\";\nimport \"./Global.sol\";\nimport \"./Position.sol\";\nimport \"./Order.sol\";\n\n/// @dev Version type\nstruct Version {\n    /// @dev whether this version had a valid oracle price\n    bool valid;\n\n    /// @dev The maker accumulator value\n    Accumulator6 makerValue;\n\n    /// @dev The long accumulator value\n    Accumulator6 longValue;\n\n    /// @dev The short accumulator value\n    Accumulator6 shortValue;\n\n    /// @dev The accumulated linear fee for maker orders\n    Accumulator6 makerLinearFee;\n\n    /// @dev The accumulated proportional fee for maker orders\n    Accumulator6 makerProportionalFee;\n\n    /// @dev The accumulated linear fee for taker orders\n    Accumulator6 takerLinearFee;\n\n    /// @dev The accumulated proportional fee for taker orders\n    Accumulator6 takerProportionalFee;\n\n    /// @dev The accumulated fee for positive skew maker orders\n    Accumulator6 makerPosFee;\n\n    /// @dev The accumulated fee for negative skew maker orders\n    Accumulator6 makerNegFee;\n\n    /// @dev The accumulated fee for positive skew taker orders\n    Accumulator6 takerPosFee;\n\n    /// @dev The accumulated fee for negative skew taker orders\n    Accumulator6 takerNegFee;\n\n    /// @dev The accumulated settlement fee for each individual order\n    Accumulator6 settlementFee;\n\n    /// @dev The accumulated liquidation fee for each individual order\n    Accumulator6 liquidationFee;\n}\nstruct VersionStorage { uint256 slot0; uint256 slot1; uint256 slot2; }\nusing VersionStorageLib for VersionStorage global;\n\n/// @dev Manually encodes and decodes the Version struct into storage.\n///\n///     struct StoredVersion {\n///         /* slot 0 */\n///         bool valid;\n///         int64 makerValue;\n///         int64 longValue;\n///         int64 shortValue;\n///         uint48 liquidationFee;\n///\n///         /* slot 1 */\n///         int48 makerPosFee;\n///         int48 makerNegFee;\n///         int48 takerPosFee;\n///         int48 takerNegFee;\n///         uint48 settlementFee;\n///\n///         /* slot 2 */\n///         int48 makerLinearFee;\n///         int48 makerProportionalFee;\n///         int48 takerLinearFee;\n///         int48 takerProportionalFee;\n///     }\n///\nlibrary VersionStorageLib {\n    // sig: 0xd2777e72\n    error VersionStorageInvalidError();\n\n    function read(VersionStorage storage self) internal view returns (Version memory) {\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\n        return Version(\n            (uint256(slot0 << (256 - 8)) >> (256 - 8)) != 0,\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64)) >> (256 - 64))),\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64)) >> (256 - 64))),\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64)) >> (256 - 64))),\n\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48 - 48 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48 - 48 - 48 - 48)) >> (256 - 48))),\n\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 48 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 48 - 48 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 48 - 48 - 48 - 48)) >> (256 - 48))),\n\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 48 - 48 - 48 - 48 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64 - 48)) >> (256 - 48)))\n        );\n    }\n\n    function store(VersionStorage storage self, Version memory newValue) external {\n        if (newValue.makerValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.makerValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.longValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.longValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.shortValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.shortValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.makerLinearFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.makerLinearFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.makerProportionalFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.makerProportionalFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.takerLinearFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.takerLinearFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.takerProportionalFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.takerProportionalFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.makerPosFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.makerPosFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.makerNegFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.makerNegFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.takerPosFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.takerPosFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.takerNegFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.takerNegFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.settlementFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.settlementFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.liquidationFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.liquidationFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256((newValue.valid ? uint256(1) : uint256(0)) << (256 - 8)) >> (256 - 8) |\n            uint256(Fixed6.unwrap(newValue.makerValue._value) << (256 - 64)) >> (256 - 8 - 64) |\n            uint256(Fixed6.unwrap(newValue.longValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64) |\n            uint256(Fixed6.unwrap(newValue.shortValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64 - 64) |\n            uint256(Fixed6.unwrap(newValue.liquidationFee._value) << (256 - 48)) >> (256 - 8 - 64 - 64 - 64 - 48);\n        uint256 encoded1 =\n            uint256(Fixed6.unwrap(newValue.makerPosFee._value) << (256 - 48)) >> (256 - 48) |\n            uint256(Fixed6.unwrap(newValue.makerNegFee._value) << (256 - 48)) >> (256 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.takerPosFee._value) << (256 - 48)) >> (256 - 48 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.takerNegFee._value) << (256 - 48)) >> (256 - 48 - 48 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.settlementFee._value) << (256 - 48)) >> (256 - 48 - 48 - 48 - 48 - 48);\n        uint256 encoded2 =\n            uint256(Fixed6.unwrap(newValue.makerLinearFee._value) << (256 - 48)) >> (256 - 48) |\n            uint256(Fixed6.unwrap(newValue.makerProportionalFee._value) << (256 - 48)) >> (256 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.takerLinearFee._value) << (256 - 48)) >> (256 - 48 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.takerProportionalFee._value) << (256 - 48)) >> (256 - 48 - 48 - 48 - 48);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n            sstore(add(self.slot, 2), encoded2)\n        }\n    }\n}\n"
    },
    "@equilibria/root/accumulator/types/Accumulator6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"../../number/types/UFixed6.sol\";\n\n/// @dev Accumulator6 type\nstruct Accumulator6 {\n    Fixed6 _value;\n}\n\nusing Accumulator6Lib for Accumulator6 global;\nstruct StoredAccumulator6 {\n    int256 _value;\n}\nstruct Accumulator6Storage { StoredAccumulator6 value; }\nusing Accumulator6StorageLib for Accumulator6Storage global;\n\n\n/**\n * @title Accumulator6Lib\n * @notice Library that surfaces math operations for the signed Accumulator type.\n * @dev This accumulator tracks cumulative changes to a value over time. Using the `accumulated` function, one\n * can determine how much a value has changed between two points in time. The `increment` and `decrement` functions\n * can be used to update the accumulator.\n */\nlibrary Accumulator6Lib {\n    /**\n     * Returns how much has been accumulated between two accumulators\n     * @param self The current point of the accumulation to compare with `from`\n     * @param from The starting point of the accumulation\n     * @param total Demoninator of the ratio (see `increment` and `decrement` functions)\n     */\n    function accumulated(Accumulator6 memory self, Accumulator6 memory from, UFixed6 total) internal pure returns (Fixed6) {\n        return _mul(self._value.sub(from._value), total);\n    }\n\n    /**\n     * @notice Increments an accumulator by a given ratio\n     * @dev Always rounds down in order to prevent overstating the accumulated value\n     * @param self The accumulator to increment\n     * @param amount Numerator of the ratio\n     * @param total Denominator of the ratio\n     */\n    function increment(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\n        if (amount.isZero()) return;\n        self._value = self._value.add(_div(amount, total));\n    }\n\n    /**\n     * @notice Decrements an accumulator by a given ratio\n     * @dev Always rounds down in order to prevent overstating the accumulated value\n     * @param self The accumulator to decrement\n     * @param amount Numerator of the ratio\n     * @param total Denominator of the ratio\n     */\n    function decrement(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\n        if (amount.isZero()) return;\n        self._value = self._value.add(_div(amount.mul(Fixed6Lib.NEG_ONE), total));\n    }\n\n    function _div(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\n        return amount.sign() == -1 ? amount.divOut(Fixed6Lib.from(total)) : amount.div(Fixed6Lib.from(total));\n    }\n\n    function _mul(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\n        return amount.sign() == -1 ? amount.mulOut(Fixed6Lib.from(total)) : amount.mul(Fixed6Lib.from(total));\n    }\n}\n\nlibrary Accumulator6StorageLib {\n    function read(Accumulator6Storage storage self) internal view returns (Accumulator6 memory) {\n        StoredAccumulator6 memory storedValue = self.value;\n        return Accumulator6(Fixed6.wrap(int256(storedValue._value)));\n    }\n\n    function store(Accumulator6Storage storage self, Accumulator6 memory newValue) internal {\n        self.value = StoredAccumulator6(Fixed6.unwrap(newValue._value));\n    }\n}\n"
    },
    "@equilibria/root/accumulator/types/UAccumulator6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/UFixed6.sol\";\n\n/// @dev UAccumulator6 type\nstruct UAccumulator6 {\n    UFixed6 _value;\n}\n\nusing UAccumulator6Lib for UAccumulator6 global;\nstruct StoredUAccumulator6 {\n    uint256 _value;\n}\nstruct UAccumulator6Storage { StoredUAccumulator6 value; }\nusing UAccumulator6StorageLib for UAccumulator6Storage global;\n\n\n/**\n * @title UAccumulator6Lib\n * @notice Library that surfaces math operations for the unsigned Accumulator type.\n * @dev This accumulator tracks cumulative changes to a monotonically increasing value over time. Using the `accumulated` function, one\n * can determine how much a value has changed between two points in time. The `increment` function can be used to update the accumulator.\n */\nlibrary UAccumulator6Lib {\n    /**\n     * Returns how much has been accumulated between two accumulators\n     * @param self The current point of the accumulation to compare with `from`\n     * @param from The starting point of the accumulation\n     * @param total Demoninator of the ratio (see `increment` function)\n     */\n    function accumulated(UAccumulator6 memory self, UAccumulator6 memory from, UFixed6 total) internal pure returns (UFixed6) {\n        return self._value.sub(from._value).mul(total);\n    }\n\n    /**\n     * @notice Increments an accumulator by a given ratio\n     * @dev Always rounds down in order to prevent overstating the accumulated value\n     * @param self The accumulator to increment\n     * @param amount Numerator of the ratio\n     * @param total Denominator of the ratio\n     */\n    function increment(UAccumulator6 memory self, UFixed6 amount, UFixed6 total) internal pure {\n        if (amount.isZero()) return;\n        self._value = self._value.add(amount.div(total));\n    }\n}\n\nlibrary UAccumulator6StorageLib {\n    function read(UAccumulator6Storage storage self) internal view returns (UAccumulator6 memory) {\n        StoredUAccumulator6 memory storedValue = self.value;\n        return UAccumulator6(UFixed6.wrap(uint256(storedValue._value)));\n    }\n\n    function store(UAccumulator6Storage storage self, UAccumulator6 memory newValue) internal {\n        self.value = StoredUAccumulator6(UFixed6.unwrap(newValue._value));\n    }\n}\n"
    },
    "@equilibria/root/adiabatic/AdiabaticMath6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../number/types/UFixed6.sol\";\nimport \"../number/types/Fixed6.sol\";\n\n/**\n * @title AdiabaticMath6\n * @notice Library for managing math operations for adiabatic fees.\n */\nlibrary AdiabaticMath6 {\n    error Adiabatic6ZeroScaleError();\n\n    /// @notice Computes the base fees for an order\n    /// @param fee The linear fee percentage\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The linear fee in underlying terms\n    function linearFee(UFixed6 fee, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return change.abs().mul(price).mul(fee);\n    }\n\n    /// @notice Computes the base fees for an order\n    /// @param scale The scale of the skew\n    /// @param fee The proportional fee percentage\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The proportional fee in underlying terms\n    function proportionalFee(UFixed6 scale, UFixed6 fee, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return change.abs().mul(price).muldiv(change.abs(), scale).mul(fee);\n    }\n\n    /// @notice Computes the adiabatic fee from a latest skew and change in skew over a linear function\n    /// @param scale The scale of the skew\n    /// @param adiabaticFee The adiabatic fee percentage\n    /// @param latest The latest skew in asset terms\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The adiabatic fee in underlying terms\n    function linearCompute(\n        UFixed6 scale,\n        UFixed6 adiabaticFee,\n        Fixed6 latest,\n        Fixed6 change,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        if (latest.isZero() && change.isZero()) return Fixed6Lib.ZERO;\n        if (scale.isZero()) revert Adiabatic6ZeroScaleError();\n\n        // normalize for skew scale\n        (Fixed6 latestScaled, Fixed6 changeScaled) =\n            (latest.div(Fixed6Lib.from(scale)), change.div(Fixed6Lib.from(scale)));\n\n        // adiabatic fee = notional * fee percentage * mean of skew range\n        return change.mul(Fixed6Lib.from(price)).mul(Fixed6Lib.from(adiabaticFee))\n            .mul(_linearMean(latestScaled, latestScaled.add(changeScaled)));\n    }\n\n    /// @notice Finds the mean value of the function f(x) = x over `from` to `to`\n    /// @param from The lower bound\n    /// @param to The upper bound\n    /// @return The mean value\n    function _linearMean(Fixed6 from, Fixed6 to) private pure returns (Fixed6) {\n        return from.add(to).div(Fixed6Lib.from(2));\n    }\n}\n"
    },
    "@equilibria/root/adiabatic/types/InverseAdiabatic6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"../../number/types/UFixed6.sol\";\nimport \"../AdiabaticMath6.sol\";\n\n/// @dev InverseAdiabatic6 type\nstruct InverseAdiabatic6 {\n    UFixed6 linearFee;\n    UFixed6 proportionalFee;\n    UFixed6 adiabaticFee;\n    UFixed6 scale;\n}\nusing InverseAdiabatic6Lib for InverseAdiabatic6 global;\n\n/**\n * @title InverseAdiabatic6Lib\n * @notice Library that that manages the inverse adiabatic fee algorithm\n * @dev This algorithm specifies an adiatatic fee over the function:\n *\n *      f(skew) = adiabaticFee * max(scale - skew, 0), skew >= 0\n *\n *      This is used to reward or penalize actions that move skew up or down this curve accordingly with net-zero\n *      value to the system with respect to the underlying asset.\n */\nlibrary InverseAdiabatic6Lib {\n    /// @notice Computes the adiabatic fee from a latest skew and change in skew\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The adiabatic fee in underlying terms\n    function compute(\n        InverseAdiabatic6 memory self,\n        UFixed6 latest,\n        Fixed6 change,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        UFixed6 current = UFixed6Lib.from(Fixed6Lib.from(latest).add(change));\n        Fixed6 latestSkew = Fixed6Lib.from(self.scale.unsafeSub(latest));\n        Fixed6 currentSkew = Fixed6Lib.from(self.scale.unsafeSub(current));\n\n        return AdiabaticMath6.linearCompute(\n            self.scale,\n            self.adiabaticFee,\n            latestSkew,\n            currentSkew.sub(latestSkew),\n            price\n        );\n    }\n\n    /// @notice Computes the latest exposure\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @return The latest total exposure in asset terms\n    function exposure(InverseAdiabatic6 memory self, UFixed6 latest) internal pure returns (Fixed6) {\n        return compute(self, UFixed6Lib.ZERO, Fixed6Lib.from(latest), UFixed6Lib.ONE);\n    }\n\n    /// @notice Computes the linear fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The linear fee in underlying terms\n    function linear(InverseAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.linearFee(self.linearFee, change, price);\n    }\n\n    /// @notice Computes the proportional fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The proportional fee in underlying terms\n    function proportional(InverseAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.proportionalFee(self.scale, self.proportionalFee, change, price);\n    }\n\n    /// @notice Computes the adiabatic fee\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The adiabatic fee in underlying terms\n    function adiabatic(\n        InverseAdiabatic6 memory self,\n        UFixed6 latest,\n        Fixed6 change,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        return compute(self, latest, change, price);\n    }\n\n    /// @dev Updates the scale and compute the resultant change fee\n    /// @param self The adiabatic configuration\n    /// @param newConfig The new fee config\n    /// @param latest The latest skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The update fee in underlying terms\n    function update(\n        InverseAdiabatic6 memory self,\n        InverseAdiabatic6 memory newConfig,\n        UFixed6 latest,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        Fixed6 prior = compute(self, UFixed6Lib.ZERO, Fixed6Lib.from(latest), price);\n        (self.linearFee, self.proportionalFee, self.adiabaticFee, self.scale) =\n            (newConfig.linearFee, newConfig.proportionalFee, newConfig.adiabaticFee, newConfig.scale);\n        return compute(self, UFixed6Lib.ZERO, Fixed6Lib.from(latest), price).sub(prior);\n    }\n}\n"
    },
    "@equilibria/root/adiabatic/types/LinearAdiabatic6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"../../number/types/UFixed6.sol\";\nimport \"../AdiabaticMath6.sol\";\n\n/// @dev LinearAdiabatic6 type\nstruct LinearAdiabatic6 {\n    UFixed6 linearFee;\n    UFixed6 proportionalFee;\n    UFixed6 adiabaticFee;\n    UFixed6 scale;\n}\nusing LinearAdiabatic6Lib for LinearAdiabatic6 global;\n\n/**\n * @title LinearAdiabatic6Lib\n * @notice Library that that manages the linear adiabatic fee algorithm\n * @dev This algorithm specifies an adiatatic fee over the function:\n *\n *      f(skew) = adiabaticFee * skew\n *\n *      This is used to reward or penalize actions that move skew up or down this curve accordingly with net-zero\n *      value to the system with respect to the underlying asset.\n */\nlibrary LinearAdiabatic6Lib {\n    /// @notice Computes the adiabatic fee from a latest skew and change in skew\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The adiabatic fee in underlying terms\n    function compute(\n        LinearAdiabatic6 memory self,\n        Fixed6 latest,\n        Fixed6 change,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        return AdiabaticMath6.linearCompute(\n            self.scale,\n            self.adiabaticFee,\n            latest,\n            change,\n            price\n        );\n    }\n\n    /// @notice Computes the latest exposure along with all fees\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @return The latest total exposure in asset terms\n    function exposure(LinearAdiabatic6 memory self, Fixed6 latest) internal pure returns (Fixed6) {\n        return compute(self, Fixed6Lib.ZERO, latest, UFixed6Lib.ONE);\n    }\n\n    /// @notice Computes the linear fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The linear fee in underlying terms\n    function linear(LinearAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.linearFee(self.linearFee, change, price);\n    }\n\n    /// @notice Computes the proportional fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The proportional fee in underlying terms\n    function proportional(LinearAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.proportionalFee(self.scale, self.proportionalFee, change, price);\n    }\n\n    /// @notice Computes the adiabatic fee\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The adiabatic fee in underlying terms\n    function adiabatic(\n        LinearAdiabatic6 memory self,\n        Fixed6 latest,\n        Fixed6 change,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        return compute(self, latest, change, price);\n    }\n\n    /// @dev Updates the scale and compute the resultant change fee\n    /// @param self The adiabatic configuration\n    /// @param newConfig The new fee config\n    /// @param latest The latest skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The update fee in underlying terms\n    function update(\n        LinearAdiabatic6 memory self,\n        LinearAdiabatic6 memory newConfig,\n        Fixed6 latest,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        Fixed6 prior = compute(self, Fixed6Lib.ZERO, latest, price);\n        (self.linearFee, self.proportionalFee, self.adiabaticFee, self.scale) =\n            (newConfig.linearFee, newConfig.proportionalFee, newConfig.adiabaticFee, newConfig.scale);\n        return compute(self, Fixed6Lib.ZERO, latest, price).sub(prior);\n    }\n}\n"
    },
    "@equilibria/root/attribute/Factory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"./interfaces/IInstance.sol\";\nimport \"./Pausable.sol\";\n\n/// @title Factory\n/// @notice An abstract factory that manages creates and manages instances\n/// @dev Ownable and Pausable, and satisfies the IBeacon interface by default.\nabstract contract Factory is IFactory, Ownable, Pausable {\n    /// @notice The instances mapping storage slot\n    bytes32 private constant INSTANCE_MAP_SLOT = keccak256(\"equilibria.root.Factory.instances\");\n\n    /// @notice The instance implementation address\n    address public immutable implementation;\n\n    /// @notice Constructs the contract\n    /// @param implementation_ The instance implementation address\n    constructor(address implementation_) { implementation = implementation_; }\n\n    /// @notice Initializes the contract state\n    function __Factory__initialize() internal onlyInitializer {\n        __Ownable__initialize();\n    }\n\n    /// @notice Returns whether the instance is valid\n    /// @param instance The instance to check\n    /// @return Whether the instance is valid\n    function instances(IInstance instance) public view returns (bool) {\n        return _instances()[instance];\n    }\n\n    /// @notice Creates a new instance\n    /// @dev Deploys a BeaconProxy with the this contract as the beacon\n    /// @param data The initialization data\n    /// @return newInstance The new instance\n    function _create(bytes memory data) internal returns (IInstance newInstance) {\n        newInstance = IInstance(address(new BeaconProxy(address(this), data)));\n        _register(newInstance);\n    }\n\n    /// @notice Registers a new instance\n    /// @dev Called by _create automatically, or can be called manually in an extending implementation\n    /// @param newInstance The new instance\n    function _register(IInstance newInstance) internal {\n        _instances()[newInstance] = true;\n        emit InstanceRegistered(newInstance);\n    }\n\n    /// @notice Returns the storage mapping for instances\n    /// @return r The storage mapping for instances\n    function _instances() private pure returns (mapping(IInstance => bool) storage r) {\n        bytes32 slot = INSTANCE_MAP_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly { r.slot := slot }\n    }\n\n    /// @notice Only allow the function by a valid instance\n    modifier onlyInstance {\n        if (!instances(IInstance(msg.sender))) revert FactoryNotInstanceError();\n        _;\n    }\n}\n"
    },
    "@equilibria/root/attribute/Initializable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/IInitializable.sol\";\nimport \"../storage/Storage.sol\";\n\n/**\n * @title Initializable\n * @notice Library to manage the initialization lifecycle of upgradeable contracts\n * @dev `Initializable.sol` allows the creation of pseudo-constructors for upgradeable contracts. One\n *      `initializer` should be declared per top-level contract. Child contracts can use the `onlyInitializer`\n *      modifier to tag their internal initialization functions to ensure that they can only be called\n *      from a top-level `initializer` or a constructor.\n */\nabstract contract Initializable is IInitializable {\n    /// @dev The initialized flag\n    Uint256Storage private constant _version = Uint256Storage.wrap(keccak256(\"equilibria.root.Initializable.version\"));\n\n    /// @dev The initializing flag\n    BoolStorage private constant _initializing = BoolStorage.wrap(keccak256(\"equilibria.root.Initializable.initializing\"));\n\n    /// @dev Can only be called once per version, `version` is 1-indexed\n    modifier initializer(uint256 version) {\n        if (version == 0) revert InitializableZeroVersionError();\n        if (_version.read() >= version) revert InitializableAlreadyInitializedError(version);\n\n        _version.store(version);\n        _initializing.store(true);\n\n        _;\n\n        _initializing.store(false);\n        emit Initialized(version);\n    }\n\n    /// @dev Can only be called from an initializer or constructor\n    modifier onlyInitializer() {\n        if (!_constructing() && !_initializing.read()) revert InitializableNotInitializingError();\n        _;\n    }\n\n    /**\n     * @notice Returns whether the contract is currently being constructed\n     * @dev {Address.isContract} returns false for contracts currently in the process of being constructed\n     * @return Whether the contract is currently being constructed\n     */\n    function _constructing() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "@equilibria/root/attribute/Instance.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../storage/Storage.sol\";\nimport \"./interfaces/IInstance.sol\";\nimport \"./Initializable.sol\";\n\n/// @title Instance\n/// @notice An abstract contract that is created and managed by a factory\nabstract contract Instance is IInstance, Initializable {\n    /// @dev The factory address storage slot\n    AddressStorage private constant _factory = AddressStorage.wrap(keccak256(\"equilibria.root.Instance.factory\"));\n\n    /// @notice Returns the factory that created this instance\n    /// @return The factory that created this instance\n    function factory() public view returns (IFactory) { return IFactory(_factory.read()); }\n\n    /// @notice Initializes the contract setting `msg.sender` as the factory\n    function __Instance__initialize() internal onlyInitializer {\n        _factory.store(msg.sender);\n    }\n\n    /// @notice Only allow the owner defined by the factory to call the function\n    modifier onlyOwner {\n        if (msg.sender != factory().owner()) revert InstanceNotOwnerError(msg.sender);\n        _;\n    }\n\n    /// @notice Only allow the factory to call the function\n    modifier onlyFactory {\n        if (msg.sender != address(factory())) revert InstanceNotFactoryError(msg.sender);\n        _;\n    }\n\n    /// @notice Only allow the function to be called when the factory is not paused\n    modifier whenNotPaused {\n        if (factory().paused()) revert InstancePausedError();\n        _;\n    }\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"./IPausable.sol\";\nimport \"./IInstance.sol\";\n\ninterface IFactory is IBeacon, IOwnable, IPausable {\n    event InstanceRegistered(IInstance indexed instance);\n\n    error FactoryNotInstanceError();\n\n    function instances(IInstance instance) external view returns (bool);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IInitializable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\ninterface IInitializable {\n    error InitializableZeroVersionError();\n    error InitializableAlreadyInitializedError(uint256 version);\n    error InitializableNotInitializingError();\n\n    event Initialized(uint256 version);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IInstance.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IFactory.sol\";\nimport \"./IInitializable.sol\";\n\ninterface IInstance is IInitializable {\n    error InstanceNotOwnerError(address sender);\n    error InstanceNotFactoryError(address sender);\n    error InstancePausedError();\n\n    function factory() external view returns (IFactory);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IKept.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../interfaces/IInitializable.sol\";\nimport \"../../number/types/UFixed18.sol\";\nimport \"../../token/types/Token18.sol\";\n\ninterface IKept is IInitializable {\n    struct KeepConfig {\n        UFixed18 multiplierBase;\n        uint256 bufferBase;\n        UFixed18 multiplierCalldata;\n        uint256 bufferCalldata;\n    }\n\n    event KeeperCall(address indexed sender, uint256 applicableGas, uint256 applicableValue, UFixed18 baseFee, UFixed18 calldataFee, UFixed18 keeperFee);\n\n    function ethTokenOracleFeed() external view returns (AggregatorV3Interface);\n    function keeperToken() external view returns (Token18);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IInitializable.sol\";\n\ninterface IOwnable is IInitializable {\n    event OwnerUpdated(address indexed newOwner);\n    event PendingOwnerUpdated(address indexed newPendingOwner);\n\n    error OwnableNotOwnerError(address sender);\n    error OwnableNotPendingOwnerError(address sender);\n\n    function owner() external view returns (address);\n    function pendingOwner() external view returns (address);\n    function updatePendingOwner(address newPendingOwner) external;\n    function acceptOwner() external;\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IInitializable.sol\";\nimport \"./IOwnable.sol\";\n\ninterface IPausable is IInitializable, IOwnable {\n    event PauserUpdated(address indexed newPauser);\n    event Paused();\n    event Unpaused();\n\n    error PausablePausedError();\n    error PausableNotPauserError(address sender);\n\n    function pauser() external view returns (address);\n    function paused() external view returns (bool);\n    function updatePauser(address newPauser) external;\n    function pause() external;\n    function unpause() external;\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IInitializable.sol\";\n\ninterface IReentrancyGuard is IInitializable {\n    error ReentrancyGuardReentrantCallError();\n}\n"
    },
    "@equilibria/root/attribute/Kept/Kept_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Kept.sol\";\n\n// https://github.com/OffchainLabs/nitro/blob/v2.0.14/contracts/src/precompiles/ArbGasInfo.sol#L93\ninterface ArbGasInfo {\n    /// @notice Get ArbOS's estimate of the L1 basefee in wei\n    function getL1BaseFeeEstimate() external view returns (uint256);\n}\n\n/// @dev Arbitrum Kept implementation\nabstract contract Kept_Arbitrum is Kept {\n    ArbGasInfo constant ARB_GAS = ArbGasInfo(0x000000000000000000000000000000000000006C);\n    uint256 public constant ARB_GAS_MULTIPLIER = 16;\n    uint256 public constant ARB_FIXED_OVERHEAD = 140;\n\n    // https://docs.arbitrum.io/devs-how-tos/how-to-estimate-gas#breaking-down-the-formula\n    // Tx Fee = block.baseFee * l2GasUsed + ArbGasInfo.getL1BaseFeeEstimate() * 16 * (calldataLength + fixedOverhead)\n    // Dynamic buffer = (ArbGasInfo.getL1BaseFeeEstimate() * 16 * (calldataLength + fixedOverhead))\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view virtual override returns (UFixed18) {\n        return _fee(\n            ARB_GAS_MULTIPLIER * (applicableCalldata.length + ARB_FIXED_OVERHEAD),\n            multiplierCalldata,\n            bufferCalldata,\n            ARB_GAS.getL1BaseFeeEstimate()\n        );\n    }\n}\n"
    },
    "@equilibria/root/attribute/Kept/Kept_Optimism.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Kept.sol\";\n\ninterface OptGasInfo {\n    function getL1GasUsed(bytes memory) external view returns (uint256);\n    function l1BaseFee() external view returns (uint256);\n    function baseFeeScalar() external view returns (uint256);\n    function blobBaseFee() external view returns (uint256);\n    function blobBaseFeeScalar() external view returns (uint256);\n    function decimals() external view returns (uint256);\n}\n\n/// @dev Optimism Kept implementation\nabstract contract Kept_Optimism is Kept {\n    // https://community.optimism.io/docs/developers/build/transaction-fees/#the-l1-data-fee\n    OptGasInfo constant OPT_GAS = OptGasInfo(0x420000000000000000000000000000000000000F);\n    uint256 public constant OPT_BASE_FEE_MULTIPLIER = 16;\n\n    // https://docs.optimism.io/stack/transactions/fees#ecotone\n    // Adds a buffer to the L1 gas used to account for the overhead of the transaction\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view virtual override returns (UFixed18) {\n        return _fee(\n            OPT_GAS.getL1GasUsed(applicableCalldata),\n            multiplierCalldata,\n            bufferCalldata,\n            // https://github.com/ethereum-optimism/optimism/blob/develop/packages/contracts-bedrock/src/L2/GasPriceOracle.sol#L138\n            (\n                OPT_BASE_FEE_MULTIPLIER * OPT_GAS.baseFeeScalar() * OPT_GAS.l1BaseFee() +\n                OPT_GAS.blobBaseFeeScalar() * OPT_GAS.blobBaseFee()\n            ) / (OPT_BASE_FEE_MULTIPLIER * 10 ** OPT_GAS.decimals())\n        );\n    }\n}\n"
    },
    "@equilibria/root/attribute/Kept/Kept.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../Initializable.sol\";\nimport \"../interfaces/IKept.sol\";\nimport \"../../storage/Storage.sol\";\n\n/// @title Kept\n/// @notice Library to manage keeper incentivization.\n/// @dev Surfaces a keep() modifier that handles measuring job gas costs and paying out rewards the keeper.\nabstract contract Kept is IKept, Initializable {\n    /// @dev The legacy Chainlink feed that is used to convert price ETH relative to the keeper token\n    AddressStorage private constant _ethTokenOracleFeed = AddressStorage.wrap(keccak256(\"equilibria.root.Kept.ethTokenOracleFeed\"));\n    function ethTokenOracleFeed() public view returns (AggregatorV3Interface) { return AggregatorV3Interface(_ethTokenOracleFeed.read()); }\n\n    /// @dev The token that the keeper is paid in\n    Token18Storage private constant _keeperToken = Token18Storage.wrap(keccak256(\"equilibria.root.Kept.keeperToken\"));\n    function keeperToken() public view returns (Token18) { return _keeperToken.read(); }\n\n    /// @notice Initializes the contract\n    /// @param ethTokenOracleFeed_ The legacy Chainlink feed that is used to convert price ETH relative to the keeper token\n    /// @param keeperToken_ The token that the keeper is paid in\n    function __Kept__initialize(\n        AggregatorV3Interface ethTokenOracleFeed_,\n        Token18 keeperToken_\n    ) internal onlyInitializer {\n        _ethTokenOracleFeed.store(address(ethTokenOracleFeed_));\n        _keeperToken.store(keeperToken_);\n    }\n\n    /// @notice Called by the keep modifier to raise the optionally raise the keeper fee\n    /// @param amount The amount of keeper fee to raise\n    /// @param data Arbitrary data passed in from the keep modifier\n    /// @return The amount of keeper fee that was actually raised\n    function _raiseKeeperFee(UFixed18 amount, bytes memory data) internal virtual returns (UFixed18) { return amount; }\n\n    /// @notice Computes the calldata portion of the keeper fee\n    /// @dev Used for L2 implementation with significant calldata costs\n    /// @param applicableCalldata The applicable calldata\n    /// @param multiplierCalldata The multiplier to apply to the calldata cost\n    /// @param bufferCalldata The buffer to apply to the calldata cost\n    /// @return The calldata portion of the keeper fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view virtual returns (UFixed18) { return UFixed18Lib.ZERO; }\n\n    /// @notice Computes the base gas portion of the keeper fee\n    /// @param applicableGas The applicable gas cost\n    /// @param multiplierBase The multiplier to apply to the gas cost\n    /// @param bufferBase The buffer to apply to the gas cost\n    /// @return The gas cost portion of the keeper fee\n    function _baseFee(\n        uint256 applicableGas,\n        UFixed18 multiplierBase,\n        uint256 bufferBase\n    ) internal view returns (UFixed18) {\n        return _fee(applicableGas, multiplierBase, bufferBase, block.basefee);\n    }\n\n    /// @notice Computes a generic keeper fee based on parameters\n    /// @dev Helper function to consolidate keeper fee computation logic\n    /// @param gas The gas cost\n    /// @param multiplier The multiplier to apply to the gas cost\n    /// @param buffer The buffer to apply to the gas cost\n    /// @return The resulting keeper fee\n    function _fee(uint256 gas, UFixed18 multiplier, uint256 buffer, uint256 baseFee) internal pure returns (UFixed18) {\n        return UFixed18Lib.from(gas).mul(multiplier).add(UFixed18Lib.from(buffer)).mul(UFixed18.wrap(baseFee));\n    }\n\n    /// @notice Placed on a function to incentivize keepers to call it\n    /// @param config The multiplier and buffer configuration to apply\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\n    /// @param applicableCalldata The applicable calldata\n    /// @param applicableValue The applicable value\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\n    modifier keep(\n        KeepConfig memory config,\n        bytes memory applicableCalldata,\n        uint256 applicableValue,\n        bytes memory data\n    ) {\n        uint256 startGas = gasleft();\n\n        _;\n\n        uint256 applicableGas = startGas - gasleft();\n\n        _handleKeeperFee(config, applicableGas, applicableCalldata, applicableValue, data);\n    }\n\n    /// @notice Called by the keep modifier to handle keeper fee computation and payment\n    /// @param config The multiplier and buffer configuration to apply\n    /// @param applicableGas The applicable gas cost\n    /// @param applicableCalldata The applicable calldata\n    /// @param applicableValue The applicable value\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\n    function _handleKeeperFee(\n        KeepConfig memory config,\n        uint256 applicableGas,\n        bytes memory applicableCalldata,\n        uint256 applicableValue,\n        bytes memory data\n    ) internal {\n        (UFixed18 baseFee, UFixed18 calldataFee) = (\n            _baseFee(applicableGas, config.multiplierBase, config.bufferBase),\n            _calldataFee(applicableCalldata, config.multiplierCalldata, config.bufferCalldata)\n        );\n\n        UFixed18 keeperFee = UFixed18.wrap(applicableValue).add(baseFee).add(calldataFee).mul(_etherPrice());\n        keeperFee = _raiseKeeperFee(keeperFee, data);\n        keeperToken().push(msg.sender, keeperFee);\n\n        emit KeeperCall(msg.sender, applicableGas, applicableValue, baseFee, calldataFee, keeperFee);\n    }\n\n    /// @notice Returns the price of ETH in terms of the keeper token\n    /// @return The price of ETH in terms of the keeper token\n    function _etherPrice() private view returns (UFixed18) {\n        (, int256 answer, , ,) = ethTokenOracleFeed().latestRoundData();\n        return UFixed18Lib.from(Fixed18Lib.ratio(answer, 1e8)); // chainlink eth-usd feed uses 8 decimals\n    }\n}\n"
    },
    "@equilibria/root/attribute/Ownable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Initializable.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"../storage/Storage.sol\";\n\n/**\n * @title Ownable\n * @notice Library to manage the ownership lifecycle of upgradeable contracts.\n * @dev This contract has been extended from the Open Zeppelin library to include an\n *      unstructured storage pattern so that it can be safely mixed in with upgradeable\n *      contracts without affecting their storage patterns through inheritance.\n */\nabstract contract Ownable is IOwnable, Initializable {\n    /// @dev The owner address\n    AddressStorage private constant _owner = AddressStorage.wrap(keccak256(\"equilibria.root.Ownable.owner\"));\n    function owner() public view returns (address) { return _owner.read(); }\n\n    /// @dev The pending owner address\n    AddressStorage private constant _pendingOwner = AddressStorage.wrap(keccak256(\"equilibria.root.Ownable.pendingOwner\"));\n    function pendingOwner() public view returns (address) { return _pendingOwner.read(); }\n\n    /**\n     * @notice Initializes the contract setting `msg.sender` as the initial owner\n     */\n    function __Ownable__initialize() internal onlyInitializer {\n        _updateOwner(_sender());\n    }\n\n    /**\n     * @notice Updates the new pending owner\n     * @dev Can only be called by the current owner\n     *      New owner does not take affect until that address calls `acceptOwner()`\n     * @param newPendingOwner New pending owner address\n     */\n    function updatePendingOwner(address newPendingOwner) public onlyOwner {\n        _pendingOwner.store(newPendingOwner);\n        emit PendingOwnerUpdated(newPendingOwner);\n    }\n\n    /**\n     * @notice Accepts and transfers the ownership of the contract to the pending owner\n     * @dev Can only be called by the pending owner to ensure correctness. Calls to the `_beforeAcceptOwner` hook\n     *      to perform logic before updating ownership.\n     */\n    function acceptOwner() public {\n        _beforeAcceptOwner();\n\n        if (_sender() != pendingOwner()) revert OwnableNotPendingOwnerError(_sender());\n\n        _updateOwner(pendingOwner());\n        updatePendingOwner(address(0));\n    }\n\n\n    /// @dev Hook for inheriting contracts to perform logic before accepting ownership\n    function _beforeAcceptOwner() internal virtual {}\n\n    /**\n     * @notice Updates the owner address\n     * @param newOwner New owner address\n     */\n    function _updateOwner(address newOwner) private {\n        _owner.store(newOwner);\n        emit OwnerUpdated(newOwner);\n    }\n\n    function _sender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    /// @dev Throws if called by any account other than the owner\n    modifier onlyOwner {\n        if (owner() != _sender()) revert OwnableNotOwnerError(_sender());\n        _;\n    }\n}\n"
    },
    "@equilibria/root/attribute/Pausable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Initializable.sol\";\nimport \"./Ownable.sol\";\nimport \"./interfaces/IPausable.sol\";\nimport \"../storage/Storage.sol\";\n\n/**\n * @title Pausable\n * @notice Library to allow for the emergency pausing and unpausing of contract functions\n *         by an authorized account.\n * @dev This contract has been extended from the Open Zeppelin library to include an\n *      unstructured storage pattern so that it can be safely mixed in with upgradeable\n *      contracts without affecting their storage patterns through inheritance.\n */\nabstract contract Pausable is IPausable, Ownable {\n    /// @dev The pauser address\n    AddressStorage private constant _pauser = AddressStorage.wrap(keccak256(\"equilibria.root.Pausable.pauser\"));\n    function pauser() public view returns (address) { return _pauser.read(); }\n\n    /// @dev Whether the contract is paused\n    BoolStorage private constant _paused = BoolStorage.wrap(keccak256(\"equilibria.root.Pausable.paused\"));\n    function paused() public view returns (bool) { return _paused.read(); }\n\n    /**\n     * @notice Initializes the contract setting `msg.sender` as the initial pauser\n     */\n    function __Pausable__initialize() internal onlyInitializer {\n        __Ownable__initialize();\n        updatePauser(_sender());\n    }\n\n    /**\n     * @notice Updates the new pauser\n     * @dev Can only be called by the current owner\n     * @param newPauser New pauser address\n     */\n    function updatePauser(address newPauser) public onlyOwner {\n        _pauser.store(newPauser);\n        emit PauserUpdated(newPauser);\n    }\n\n    /**\n     * @notice Pauses the contract\n     * @dev Can only be called by the pauser\n     */\n    function pause() external onlyPauser {\n        _paused.store(true);\n        emit Paused();\n    }\n\n    /**\n     * @notice Unpauses the contract\n     * @dev Can only be called by the pauser\n     */\n    function unpause() external onlyPauser {\n        _paused.store(false);\n        emit Unpaused();\n    }\n\n    /// @dev Throws if called by any account other than the pauser\n    modifier onlyPauser {\n        if (_sender() != pauser() && _sender() != owner()) revert PausableNotPauserError(_sender());\n        _;\n    }\n\n    /// @dev Throws if called when the contract is paused\n    modifier whenNotPaused {\n        if (paused()) revert PausablePausedError();\n        _;\n    }\n}\n"
    },
    "@equilibria/root/attribute/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Initializable.sol\";\nimport \"./interfaces/IReentrancyGuard.sol\";\nimport \"../storage/Storage.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n *\n * NOTE: This contract has been extended from the Open Zeppelin library to include an\n *       unstructured storage pattern, so that it can be safely mixed in with upgradeable\n *       contracts without affecting their storage patterns through inheritance.\n */\nabstract contract ReentrancyGuard is IReentrancyGuard, Initializable {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    /**\n     * @dev unstructured storage slot for the reentrancy status\n     */\n    Uint256Storage private constant _status = Uint256Storage.wrap(keccak256(\"equilibria.root.ReentrancyGuard.status\"));\n\n    /**\n     * @dev Initializes the contract setting the status to _NOT_ENTERED.\n     */\n    function __ReentrancyGuard__initialize() internal onlyInitializer {\n        _status.store(_NOT_ENTERED);\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        if (_status.read() == _ENTERED) revert ReentrancyGuardReentrantCallError();\n\n        // Any calls to nonReentrant after this point will fail\n        _status.store(_ENTERED);\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status.store(_NOT_ENTERED);\n    }\n}\n"
    },
    "@equilibria/root/number/NumberMath.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\n/**\n * @title NumberMath\n * @notice Library for additional math functions that are not included in the OpenZeppelin libraries.\n */\nlibrary NumberMath {\n    error DivisionByZero();\n\n    /**\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Dividend\n     * @param b Divisor\n     * @return Resulting quotient\n     */\n    function divOut(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) revert DivisionByZero();\n        return Math.ceilDiv(a, b);\n    }\n\n    /**\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Dividend\n     * @param b Divisor\n     * @return Resulting quotient\n     */\n    function divOut(int256 a, int256 b) internal pure returns (int256) {\n        return sign(a) * sign(b) * int256(divOut(SignedMath.abs(a), SignedMath.abs(b)));\n    }\n\n    /**\n     * @notice Returns the sign of an int256\n     * @dev Returns: -1 for negative\n     *                0 for zero\n     *                1 for positive\n     * @param a int256 to find the sign of\n     * @return Sign of the int256\n     */\n    function sign(int256 a) internal pure returns (int256) {\n        if (a > 0) return 1;\n        if (a < 0) return -1;\n        return 0;\n    }\n}\n"
    },
    "@equilibria/root/number/types/Fixed18.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed6.sol\";\nimport \"./UFixed18.sol\";\n\n/// @dev Fixed18 type\ntype Fixed18 is int256;\nusing Fixed18Lib for Fixed18 global;\ntype Fixed18Storage is bytes32;\nusing Fixed18StorageLib for Fixed18Storage global;\n\n/**\n * @title Fixed18Lib\n * @notice Library for the signed fixed-decimal type.\n */\nlibrary Fixed18Lib {\n    error Fixed18OverflowError(uint256 value);\n\n    int256 private constant BASE = 1e18;\n    Fixed18 public constant ZERO = Fixed18.wrap(0);\n    Fixed18 public constant ONE = Fixed18.wrap(BASE);\n    Fixed18 public constant NEG_ONE = Fixed18.wrap(-1 * BASE);\n    Fixed18 public constant MAX = Fixed18.wrap(type(int256).max);\n    Fixed18 public constant MIN = Fixed18.wrap(type(int256).min);\n\n    /**\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\n     * @param a Unsigned fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(UFixed18 a) internal pure returns (Fixed18) {\n        uint256 value = UFixed18.unwrap(a);\n        if (value > uint256(type(int256).max)) revert Fixed18OverflowError(value);\n        return Fixed18.wrap(int256(value));\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\n     * @param s Sign\n     * @param m Unsigned fixed-decimal magnitude\n     * @return New signed fixed-decimal\n     */\n    function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {\n        if (s > 0) return from(m);\n        if (s < 0) {\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\n            // which is the only value that would overflow when negated. Therefore,\n            // we can safely negate from(m) without checking for overflow.\n            unchecked { return Fixed18.wrap(-1 * Fixed18.unwrap(from(m))); }\n        }\n        return ZERO;\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a signed integer\n     * @param a Signed number\n     * @return New signed fixed-decimal\n     */\n    function from(int256 a) internal pure returns (Fixed18) {\n        return Fixed18.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\n     * @param a Base-6 signed fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(Fixed6 a) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed6.unwrap(a) * 1e12);\n    }\n\n    /**\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\n     * @param a Signed fixed-decimal\n     * @return Whether the signed fixed-decimal is zero.\n     */\n    function isZero(Fixed18 a) internal pure returns (bool) {\n        return Fixed18.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting summed signed fixed-decimal\n     */\n    function add(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) + Fixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts signed fixed-decimal `b` from `a`\n     * @param a Signed fixed-decimal to subtract from\n     * @param b Signed fixed-decimal to subtract\n     * @return Resulting subtracted signed fixed-decimal\n     */\n    function sub(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) - Fixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mul(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mulOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function div(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) * BASE / Fixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function divOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\n        return muldiv(a, Fixed18.wrap(b), Fixed18.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\n        return muldivOut(a, Fixed18.wrap(b), Fixed18.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / Fixed18.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), Fixed18.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the signed fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(Fixed18 a, Fixed18 b) internal pure returns (uint256) {\n        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\n     * @param a First signed number\n     * @param b Second signed number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(int256 a, int256 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(SignedMath.min(Fixed18.unwrap(a), Fixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(SignedMath.max(Fixed18.unwrap(a), Fixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\n     * @param a Signed fixed-decimal\n     * @return Truncated signed number\n     */\n    function truncate(Fixed18 a) internal pure returns (int256) {\n        return Fixed18.unwrap(a) / BASE;\n    }\n\n    /**\n     * @notice Returns the sign of the signed fixed-decimal\n     * @dev Returns: -1 for negative\n     *                0 for zero\n     *                1 for positive\n     * @param a Signed fixed-decimal\n     * @return Sign of the signed fixed-decimal\n     */\n    function sign(Fixed18 a) internal pure returns (int256) {\n        if (Fixed18.unwrap(a) > 0) return 1;\n        if (Fixed18.unwrap(a) < 0) return -1;\n        return 0;\n    }\n\n    /**\n     * @notice Returns the absolute value of the signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return Absolute value of the signed fixed-decimal\n     */\n    function abs(Fixed18 a) internal pure returns (UFixed18) {\n        return UFixed18.wrap(SignedMath.abs(Fixed18.unwrap(a)));\n    }\n}\n\nlibrary Fixed18StorageLib {\n    function read(Fixed18Storage self) internal view returns (Fixed18 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Fixed18Storage self, Fixed18 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/number/types/Fixed6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed18.sol\";\nimport \"./UFixed6.sol\";\n\n/// @dev Fixed6 type\ntype Fixed6 is int256;\nusing Fixed6Lib for Fixed6 global;\ntype Fixed6Storage is bytes32;\nusing Fixed6StorageLib for Fixed6Storage global;\n\n/**\n * @title Fixed6Lib\n * @notice Library for the signed fixed-decimal type.\n */\nlibrary Fixed6Lib {\n    error Fixed6OverflowError(uint256 value);\n\n    int256 private constant BASE = 1e6;\n    Fixed6 public constant ZERO = Fixed6.wrap(0);\n    Fixed6 public constant ONE = Fixed6.wrap(BASE);\n    Fixed6 public constant NEG_ONE = Fixed6.wrap(-1 * BASE);\n    Fixed6 public constant MAX = Fixed6.wrap(type(int256).max);\n    Fixed6 public constant MIN = Fixed6.wrap(type(int256).min);\n\n    /**\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\n     * @param a Unsigned fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(UFixed6 a) internal pure returns (Fixed6) {\n        uint256 value = UFixed6.unwrap(a);\n        if (value > uint256(type(int256).max)) revert Fixed6OverflowError(value);\n        return Fixed6.wrap(int256(value));\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\n     * @param s Sign\n     * @param m Unsigned fixed-decimal magnitude\n     * @return New signed fixed-decimal\n     */\n    function from(int256 s, UFixed6 m) internal pure returns (Fixed6) {\n        if (s > 0) return from(m);\n        if (s < 0) {\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\n            // which is the only value that would overflow when negated. Therefore,\n            // we can safely negate from(m) without checking for overflow.\n            unchecked { return Fixed6.wrap(-1 * Fixed6.unwrap(from(m))); }\n        }\n        return ZERO;\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a signed integer\n     * @param a Signed number\n     * @return New signed fixed-decimal\n     */\n    function from(int256 a) internal pure returns (Fixed6) {\n        return Fixed6.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\n     * @param a Base-18 signed fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(Fixed18 a) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed18.unwrap(a) / 1e12);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\n     * @param a Base-18 signed fixed-decimal\n     * @param roundOut Whether to round the result away from zero if there is a remainder\n     * @return New signed fixed-decimal\n     */\n    function from(Fixed18 a, bool roundOut) internal pure returns (Fixed6) {\n        return roundOut ? Fixed6.wrap(NumberMath.divOut(Fixed18.unwrap(a), 1e12)): from(a);\n    }\n\n    /**\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\n     * @param a Signed fixed-decimal\n     * @return Whether the signed fixed-decimal is zero.\n     */\n    function isZero(Fixed6 a) internal pure returns (bool) {\n        return Fixed6.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting summed signed fixed-decimal\n     */\n    function add(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) + Fixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts signed fixed-decimal `b` from `a`\n     * @param a Signed fixed-decimal to subtract from\n     * @param b Signed fixed-decimal to subtract\n     * @return Resulting subtracted signed fixed-decimal\n     */\n    function sub(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) - Fixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mul(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mulOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function div(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) * BASE / Fixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function divOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\n        return muldiv(a, Fixed6.wrap(b), Fixed6.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\n        return muldivOut(a, Fixed6.wrap(b), Fixed6.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / Fixed6.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), Fixed6.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the signed fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(Fixed6 a, Fixed6 b) internal pure returns (uint256) {\n        (int256 au, int256 bu) = (Fixed6.unwrap(a), Fixed6.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\n     * @param a First signed number\n     * @param b Second signed number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(int256 a, int256 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(SignedMath.min(Fixed6.unwrap(a), Fixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(SignedMath.max(Fixed6.unwrap(a), Fixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\n     * @param a Signed fixed-decimal\n     * @return Truncated signed number\n     */\n    function truncate(Fixed6 a) internal pure returns (int256) {\n        return Fixed6.unwrap(a) / BASE;\n    }\n\n    /**\n     * @notice Returns the sign of the signed fixed-decimal\n     * @dev Returns: -1 for negative\n     *                0 for zero\n     *                1 for positive\n     * @param a Signed fixed-decimal\n     * @return Sign of the signed fixed-decimal\n     */\n    function sign(Fixed6 a) internal pure returns (int256) {\n        if (Fixed6.unwrap(a) > 0) return 1;\n        if (Fixed6.unwrap(a) < 0) return -1;\n        return 0;\n    }\n\n    /**\n     * @notice Returns the absolute value of the signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return Absolute value of the signed fixed-decimal\n     */\n    function abs(Fixed6 a) internal pure returns (UFixed6) {\n        return UFixed6.wrap(SignedMath.abs(Fixed6.unwrap(a)));\n    }\n}\n\nlibrary Fixed6StorageLib {\n    function read(Fixed6Storage self) internal view returns (Fixed6 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Fixed6Storage self, Fixed6 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/number/types/UFixed18.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed18.sol\";\nimport \"./UFixed6.sol\";\n\n/// @dev UFixed18 type\ntype UFixed18 is uint256;\nusing UFixed18Lib for UFixed18 global;\ntype UFixed18Storage is bytes32;\nusing UFixed18StorageLib for UFixed18Storage global;\n\n/**\n * @title UFixed18Lib\n * @notice Library for the unsigned fixed-decimal type.\n */\nlibrary UFixed18Lib {\n    error UFixed18UnderflowError(int256 value);\n\n    uint256 private constant BASE = 1e18;\n    UFixed18 public constant ZERO = UFixed18.wrap(0);\n    UFixed18 public constant ONE = UFixed18.wrap(BASE);\n    UFixed18 public constant MAX = UFixed18.wrap(type(uint256).max);\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function from(Fixed18 a) internal pure returns (UFixed18) {\n        int256 value = Fixed18.unwrap(a);\n        if (value < 0) revert UFixed18UnderflowError(value);\n        return UFixed18.wrap(uint256(value));\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function unsafeFrom(Fixed18 a) internal pure returns (UFixed18) {\n        return a.lt(Fixed18Lib.ZERO) ? ZERO : from(a);\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\n     * @param a Unsigned number\n     * @return New unsigned fixed-decimal\n     */\n    function from(uint256 a) internal pure returns (UFixed18) {\n        return UFixed18.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\n     * @param a Base-6 signed fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(UFixed6 a) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed6.unwrap(a) * 1e12);\n    }\n\n    /**\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\n     * @param a Unsigned fixed-decimal\n     * @return Whether the unsigned fixed-decimal is zero.\n     */\n    function isZero(UFixed18 a) internal pure returns (bool) {\n        return UFixed18.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting summed unsigned fixed-decimal\n     */\n    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function unsafeSub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return gt(b, a) ? ZERO : sub(a, b);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mul(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mulOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function div(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) * BASE / UFixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function divOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * BASE, UFixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\n        return muldiv(a, UFixed18.wrap(b), UFixed18.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\n        return muldivOut(a, UFixed18.wrap(b), UFixed18.wrap(c));\n    }\n\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / UFixed18.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), UFixed18.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(UFixed18 a, UFixed18 b) internal pure returns (uint256) {\n        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\n     * @param a First unsigned number\n     * @param b Second unsigned number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(Math.min(UFixed18.unwrap(a), UFixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(Math.max(UFixed18.unwrap(a), UFixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\n     * @param a Unsigned fixed-decimal\n     * @return Truncated unsigned number\n     */\n    function truncate(UFixed18 a) internal pure returns (uint256) {\n        return UFixed18.unwrap(a) / BASE;\n    }\n}\n\nlibrary UFixed18StorageLib {\n    function read(UFixed18Storage self) internal view returns (UFixed18 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(UFixed18Storage self, UFixed18 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/number/types/UFixed6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed6.sol\";\nimport \"./UFixed18.sol\";\n\n/// @dev UFixed6 type\ntype UFixed6 is uint256;\nusing UFixed6Lib for UFixed6 global;\ntype UFixed6Storage is bytes32;\nusing UFixed6StorageLib for UFixed6Storage global;\n\n/**\n * @title UFixed6Lib\n * @notice Library for the unsigned fixed-decimal type.\n */\nlibrary UFixed6Lib {\n    error UFixed6UnderflowError(int256 value);\n\n    uint256 private constant BASE = 1e6;\n    UFixed6 public constant ZERO = UFixed6.wrap(0);\n    UFixed6 public constant ONE = UFixed6.wrap(BASE);\n    UFixed6 public constant MAX = UFixed6.wrap(type(uint256).max);\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function from(Fixed6 a) internal pure returns (UFixed6) {\n        int256 value = Fixed6.unwrap(a);\n        if (value < 0) revert UFixed6UnderflowError(value);\n        return UFixed6.wrap(uint256(value));\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function unsafeFrom(Fixed6 a) internal pure returns (UFixed6) {\n        return a.lt(Fixed6Lib.ZERO) ? ZERO : from(a);\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\n     * @param a Unsigned number\n     * @return New unsigned fixed-decimal\n     */\n    function from(uint256 a) internal pure returns (UFixed6) {\n        return UFixed6.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\n     * @param a Base-18 unsigned fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function from(UFixed18 a) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed18.unwrap(a) / 1e12);\n    }\n\n    /**\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\n     * @param a Base-18 unsigned fixed-decimal\n     * @param roundOut Whether to round the result away from zero if there is a remainder\n     * @return New unsigned fixed-decimal\n     */\n    function from(UFixed18 a, bool roundOut) internal pure returns (UFixed6) {\n        return roundOut ? UFixed6.wrap(NumberMath.divOut(UFixed18.unwrap(a), 1e12)): from(a);\n    }\n\n    /**\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\n     * @param a Unsigned fixed-decimal\n     * @return Whether the unsigned fixed-decimal is zero.\n     */\n    function isZero(UFixed6 a) internal pure returns (bool) {\n        return UFixed6.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting summed unsigned fixed-decimal\n     */\n    function add(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) + UFixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function sub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) - UFixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function unsafeSub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return gt(b, a) ? ZERO : sub(a, b);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mul(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mulOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function div(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) * BASE / UFixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function divOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * BASE, UFixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\n        return muldiv(a, UFixed6.wrap(b), UFixed6.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\n        return muldivOut(a, UFixed6.wrap(b), UFixed6.wrap(c));\n    }\n\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / UFixed6.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), UFixed6.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(UFixed6 a, UFixed6 b) internal pure returns (uint256) {\n        (uint256 au, uint256 bu) = (UFixed6.unwrap(a), UFixed6.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\n     * @param a First unsigned number\n     * @param b Second unsigned number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(Math.min(UFixed6.unwrap(a), UFixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(Math.max(UFixed6.unwrap(a), UFixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\n     * @param a Unsigned fixed-decimal\n     * @return Truncated unsigned number\n     */\n    function truncate(UFixed6 a) internal pure returns (uint256) {\n        return UFixed6.unwrap(a) / BASE;\n    }\n}\n\nlibrary UFixed6StorageLib {\n    function read(UFixed6Storage self) internal view returns (UFixed6 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(UFixed6Storage self, UFixed6 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/pid/types/PAccumulator6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"./PController6.sol\";\n\n/// @dev PAccumulator6 type\nstruct PAccumulator6 {\n    Fixed6 _value;\n    Fixed6 _skew;\n}\nusing PAccumulator6Lib for PAccumulator6 global;\n\n/// @title PAccumulator6Lib\n/// @notice Accumulator for a the fixed 6-decimal PID controller. This holds the \"last seen state\" of the PID controller\n///         and works in conjunction with the PController6 to compute the current rate.\n/// @dev This implementation is specifically a P controller, with I_k and D_k both set to 0. In between updates, it\n///      continues to accumulate at a linear rate based on the previous skew, but the rate is capped at the max value.\n///      Once the rate hits the max value, it will continue to accumulate at the max value until the next update.\nlibrary PAccumulator6Lib {\n    /// @notice Accumulates the rate against notional given the prior and current state\n    /// @param self The controller accumulator\n    /// @param controller The controller configuration\n    /// @param skew The current skew\n    /// @param fromTimestamp The timestamp of the prior accumulation\n    /// @param toTimestamp The current timestamp\n    /// @param notional The notional to accumulate against\n    /// @return accumulated The total accumulated amount\n    function accumulate(\n        PAccumulator6 memory self,\n        PController6 memory controller,\n        Fixed6 skew,\n        uint256 fromTimestamp,\n        uint256 toTimestamp,\n        UFixed6 notional\n    ) internal pure returns (Fixed6 accumulated) {\n        // compute new value and intercept\n        (Fixed6 newValue, UFixed6 interceptTimestamp) =\n            controller.compute(self._value, self._skew, fromTimestamp, toTimestamp);\n\n        // accumulate rate within max\n        accumulated = _accumulate(\n            self._value.add(newValue),\n            UFixed6Lib.from(fromTimestamp),\n            interceptTimestamp,\n            notional\n        ).div(Fixed6Lib.from(2)); // rate = self._value + newValue / 2 -> divide here for added precision\n\n        // accumulate rate outside of max\n        accumulated = _accumulate(\n            newValue,\n            interceptTimestamp,\n            UFixed6Lib.from(toTimestamp),\n            notional\n        ).add(accumulated);\n\n        // update values\n        self._value = newValue;\n        self._skew = skew;\n    }\n\n    /// @notice Helper function to accumulate a singular rate against notional\n    /// @param rate The rate to accumulate\n    /// @param fromTimestamp The timestamp to accumulate from\n    /// @param toTimestamp The timestamp to accumulate to\n    /// @param notional The notional to accumulate against\n    /// @return The accumulated amount\n    function _accumulate(\n        Fixed6 rate,\n        UFixed6 fromTimestamp,\n        UFixed6 toTimestamp,\n        UFixed6 notional\n    ) private pure returns (Fixed6) {\n        return rate\n            .mul(Fixed6Lib.from(toTimestamp.sub(fromTimestamp)))\n            .mul(Fixed6Lib.from(notional))\n            .div(Fixed6Lib.from(365 days));\n    }\n}\n"
    },
    "@equilibria/root/pid/types/PController6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\n\n/// @dev PController6 type\nstruct PController6 {\n    UFixed6 k;\n    Fixed6 min;\n    Fixed6 max;\n}\nusing PController6Lib for PController6 global;\n\n/// @title PController6Lib\n/// @notice Configuration for a the fixed 6-decimal PID controller.\n/// @dev Each second, the PID controller's value is incremented by `skew / k`, with `max` as the maximum value.\nlibrary PController6Lib {\n    /// @notice compute the new value and intercept timestamp based on the prior controller state\n    /// @dev `interceptTimestamp` will never exceed `toTimestamp`\n    /// @param self the controller configuration\n    /// @param value the prior value\n    /// @param skew The prior skew\n    /// @param fromTimestamp The prior timestamp\n    /// @param toTimestamp The current timestamp\n    /// @return newValue the new value\n    /// @return interceptTimestamp the timestamp at which the value will be at the max\n    function compute(\n        PController6 memory self,\n        Fixed6 value,\n        Fixed6 skew,\n        uint256 fromTimestamp,\n        uint256 toTimestamp\n    ) internal pure returns (Fixed6 newValue, UFixed6 interceptTimestamp) {\n        // compute the new value without considering the max\n        Fixed6 newValueUncapped = value.add(\n            Fixed6Lib.from(int256(toTimestamp - fromTimestamp))\n                .mul(skew)\n                .div(Fixed6Lib.from(self.k))\n        );\n\n        // cap the new value between min and max\n        newValue = newValueUncapped.min(self.max).max(self.min);\n\n        // compute distance and range to the resultant value\n        (UFixed6 distance, Fixed6 range) = (UFixed6Lib.from(toTimestamp - fromTimestamp), newValueUncapped.sub(value));\n\n        // compute the amount of buffer until the value is outside the max\n        UFixed6 buffer = value.gt(self.max) || value.lt(self.min) ?\n            UFixed6Lib.ZERO :\n            (range.sign() > 0 ? self.max : self.min).sub(value).abs();\n\n        // compute the timestamp at which the value will be at the max\n        interceptTimestamp = range.isZero() ?\n            UFixed6Lib.from(toTimestamp) :\n            UFixed6Lib.from(fromTimestamp).add(distance.muldiv(buffer, range.abs())).min(UFixed6Lib.from(toTimestamp));\n    }\n}\n"
    },
    "@equilibria/root/storage/Storage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../number/types/UFixed18.sol\";\n\n/// @dev Stored boolean slot\ntype BoolStorage is bytes32;\nusing BoolStorageLib for BoolStorage global;\n\n/// @dev Stored uint256 slot\ntype Uint256Storage is bytes32;\nusing Uint256StorageLib for Uint256Storage global;\n\n/// @dev Stored int256 slot\ntype Int256Storage is bytes32;\nusing Int256StorageLib for Int256Storage global;\n\n/// @dev Stored address slot\ntype AddressStorage is bytes32;\nusing AddressStorageLib for AddressStorage global;\n\n/// @dev Stored bytes32 slot\ntype Bytes32Storage is bytes32;\nusing Bytes32StorageLib for Bytes32Storage global;\n\n/**\n * @title BoolStorageLib\n * @notice Library to manage storage and retrieval of a boolean at a fixed storage slot\n */\nlibrary BoolStorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored bool value\n     */\n    function read(BoolStorage self) internal view returns (bool value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value boolean value to store\n     */\n    function store(BoolStorage self, bool value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title Uint256StorageLib\n * @notice Library to manage storage and retrieval of an uint256 at a fixed storage slot\n */\nlibrary Uint256StorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored uint256 value\n     */\n    function read(Uint256Storage self) internal view returns (uint256 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value uint256 value to store\n     */\n    function store(Uint256Storage self, uint256 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title Int256StorageLib\n * @notice Library to manage storage and retrieval of an int256 at a fixed storage slot\n */\nlibrary Int256StorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored int256 value\n     */\n    function read(Int256Storage self) internal view returns (int256 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value int256 value to store\n     */\n    function store(Int256Storage self, int256 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title AddressStorageLib\n * @notice Library to manage storage and retrieval of an address at a fixed storage slot\n */\nlibrary AddressStorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored address value\n     */\n    function read(AddressStorage self) internal view returns (address value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value address value to store\n     */\n    function store(AddressStorage self, address value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title Bytes32StorageLib\n * @notice Library to manage storage and retrieval of a bytes32 at a fixed storage slot\n */\nlibrary Bytes32StorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored bytes32 value\n     */\n    function read(Bytes32Storage self) internal view returns (bytes32 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value bytes32 value to store\n     */\n    function store(Bytes32Storage self, bytes32 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/token/types/Token18.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../number/types/UFixed18.sol\";\n\n/// @dev Token18\ntype Token18 is address;\nusing Token18Lib for Token18 global;\ntype Token18Storage is bytes32;\nusing Token18StorageLib for Token18Storage global;\n\n/**\n * @title Token18Lib\n * @notice Library to manage 18-decimal ERC20s that is compliant with the fixed-decimal types.\n * @dev Maintains significant gas savings over other Token implementations since no conversion take place\n */\nlibrary Token18Lib {\n    using SafeERC20 for IERC20;\n\n    Token18 public constant ZERO = Token18.wrap(address(0));\n\n    /**\n     * @notice Returns whether a token is the zero address\n     * @param self Token to check for\n     * @return Whether the token is the zero address\n     */\n    function isZero(Token18 self) internal pure returns (bool) {\n        return Token18.unwrap(self) == Token18.unwrap(ZERO);\n    }\n\n    /**\n     * @notice Returns whether the two tokens are equal\n     * @param a First token to compare\n     * @param b Second token to compare\n     * @return Whether the two tokens are equal\n     */\n    function eq(Token18 a, Token18 b) internal pure returns (bool) {\n        return Token18.unwrap(a) ==  Token18.unwrap(b);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend infinite tokens from the caller\n     * @dev Uses `approve` rather than `safeApprove` since the race condition\n     *      in safeApprove does not apply when going to an infinite approval\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     */\n    function approve(Token18 self, address grantee) internal {\n        IERC20(Token18.unwrap(self)).approve(grantee, type(uint256).max);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend `amount` tokens from the caller\n     * @dev There are important race conditions to be aware of when using this function\n            with values other than 0. This will revert if moving from non-zero to non-zero amounts\n            See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a55b7d13722e7ce850b626da2313f3e66ca1d101/contracts/token/ERC20/IERC20.sol#L57\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     * @param amount Amount of tokens to approve to spend\n     */\n    function approve(Token18 self, address grantee, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeApprove(grantee, UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers all held tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to receive the tokens\n     */\n    function push(Token18 self, address recipient) internal {\n        push(self, recipient, balanceOf(self, address(this)));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function push(Token18 self, address recipient, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeTransfer(recipient, UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to the caller\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param amount Amount of tokens to transfer\n     */\n    function pull(Token18 self, address benefactor, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, address(this), UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function pullTo(Token18 self, address benefactor, address recipient, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, recipient, UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Returns the name of the token\n     * @param self Token to check for\n     * @return Token name\n     */\n    function name(Token18 self) internal view returns (string memory) {\n        return IERC20Metadata(Token18.unwrap(self)).name();\n    }\n\n    /**\n     * @notice Returns the symbol of the token\n     * @param self Token to check for\n     * @return Token symbol\n     */\n    function symbol(Token18 self) internal view returns (string memory) {\n        return IERC20Metadata(Token18.unwrap(self)).symbol();\n    }\n\n    /**\n     * @notice Returns the `self` token balance of the caller\n     * @param self Token to check for\n     * @return Token balance of the caller\n     */\n    function balanceOf(Token18 self) internal view returns (UFixed18) {\n        return balanceOf(self, address(this));\n    }\n\n    /**\n     * @notice Returns the `self` token balance of `account`\n     * @param self Token to check for\n     * @param account Account to check\n     * @return Token balance of the account\n     */\n    function balanceOf(Token18 self, address account) internal view returns (UFixed18) {\n        return UFixed18.wrap(IERC20(Token18.unwrap(self)).balanceOf(account));\n    }\n}\n\nlibrary Token18StorageLib {\n    function read(Token18Storage self) internal view returns (Token18 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Token18Storage self, Token18 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/token/types/Token6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../number/types/UFixed6.sol\";\n\n/// @dev Token6\ntype Token6 is address;\nusing Token6Lib for Token6 global;\ntype Token6Storage is bytes32;\nusing Token6StorageLib for Token6Storage global;\n\n/**\n * @title Token6Lib\n * @notice Library to manage 6-decimal ERC20s that is compliant with the fixed-decimal types.\n */\nlibrary Token6Lib {\n    using SafeERC20 for IERC20;\n\n    Token6 public constant ZERO = Token6.wrap(address(0));\n\n    /**\n     * @notice Returns whether a token is the zero address\n     * @param self Token to check for\n     * @return Whether the token is the zero address\n     */\n    function isZero(Token6 self) internal pure returns (bool) {\n        return Token6.unwrap(self) == Token6.unwrap(ZERO);\n    }\n\n    /**\n     * @notice Returns whether the two tokens are equal\n     * @param a First token to compare\n     * @param b Second token to compare\n     * @return Whether the two tokens are equal\n     */\n    function eq(Token6 a, Token6 b) internal pure returns (bool) {\n        return Token6.unwrap(a) ==  Token6.unwrap(b);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend infinite tokens from the caller\n     * @dev Uses `approve` rather than `safeApprove` since the race condition\n     *      in safeApprove does not apply when going to an infinite approval\n     * @param self Token to grant approval\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     */\n    function approve(Token6 self, address grantee) internal {\n        IERC20(Token6.unwrap(self)).approve(grantee, type(uint256).max);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend `amount` tokens from the caller\n     * @dev There are important race conditions to be aware of when using this function\n            with values other than 0. This will revert if moving from non-zero to non-zero amounts\n            See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a55b7d13722e7ce850b626da2313f3e66ca1d101/contracts/token/ERC20/IERC20.sol#L57\n     * @param self Token to grant approval\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     * @param amount Amount of tokens to approve to spend\n     */\n    function approve(Token6 self, address grantee, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeApprove(grantee, UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers all held tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to receive the tokens\n     */\n    function push(Token6 self, address recipient) internal {\n        push(self, recipient, balanceOf(self, address(this)));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function push(Token6 self, address recipient, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeTransfer(recipient, UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to the caller\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param amount Amount of tokens to transfer\n     */\n    function pull(Token6 self, address benefactor, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeTransferFrom(benefactor, address(this), UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function pullTo(Token6 self, address benefactor, address recipient, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeTransferFrom(benefactor, recipient, UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Returns the name of the token\n     * @param self Token to check for\n     * @return Token name\n     */\n    function name(Token6 self) internal view returns (string memory) {\n        return IERC20Metadata(Token6.unwrap(self)).name();\n    }\n\n    /**\n     * @notice Returns the symbol of the token\n     * @param self Token to check for\n     * @return Token symbol\n     */\n    function symbol(Token6 self) internal view returns (string memory) {\n        return IERC20Metadata(Token6.unwrap(self)).symbol();\n    }\n\n    /**\n     * @notice Returns the `self` token balance of the caller\n     * @param self Token to check for\n     * @return Token balance of the caller\n     */\n    function balanceOf(Token6 self) internal view returns (UFixed6) {\n        return balanceOf(self, address(this));\n    }\n\n    /**\n     * @notice Returns the `self` token balance of `account`\n     * @param self Token to check for\n     * @param account Account to check\n     * @return Token balance of the account\n     */\n    function balanceOf(Token6 self, address account) internal view returns (UFixed6) {\n        return UFixed6.wrap(IERC20(Token6.unwrap(self)).balanceOf(account));\n    }\n}\n\nlibrary Token6StorageLib {\n    function read(Token6Storage self) internal view returns (Token6 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Token6Storage self, Token6 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/utilization/CurveMath6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../number/types/UFixed6.sol\";\nimport \"../number/types/Fixed6.sol\";\n\n/**\n * @title CurveMath6\n * @notice Library for managing math operations for utilization curves.\n */\nlibrary CurveMath6 {\n    error CurveMath6OutOfBoundsError();\n\n    /**\n     * @notice Computes a linear interpolation between two points\n     * @param startX First point's x-coordinate\n     * @param startY First point's y-coordinate\n     * @param endX Second point's x-coordinate\n     * @param endY Second point's y-coordinate\n     * @param targetX x-coordinate to interpolate\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\n     */\n    function linearInterpolation(\n        UFixed6 startX,\n        Fixed6 startY,\n        UFixed6 endX,\n        Fixed6 endY,\n        UFixed6 targetX\n    ) internal pure returns (Fixed6) {\n        if (targetX.lt(startX) || targetX.gt(endX)) revert CurveMath6OutOfBoundsError();\n\n        UFixed6 xRange = endX.sub(startX);\n        Fixed6 yRange = endY.sub(startY);\n        UFixed6 xRatio = targetX.sub(startX).div(xRange);\n        return yRange.mul(Fixed6Lib.from(xRatio)).add(startY);\n    }\n\n    /**\n     * @notice Computes a linear interpolation between two points\n     * @param startX First point's x-coordinate\n     * @param startY First point's y-coordinate\n     * @param endX Second point's x-coordinate\n     * @param endY Second point's y-coordinate\n     * @param targetX x-coordinate to interpolate\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\n     */\n    function linearInterpolation(\n        UFixed6 startX,\n        UFixed6 startY,\n        UFixed6 endX,\n        UFixed6 endY,\n        UFixed6 targetX\n    ) internal pure returns (UFixed6) {\n        return UFixed6Lib.from(linearInterpolation(startX, Fixed6Lib.from(startY), endX, Fixed6Lib.from(endY), targetX));\n    }\n}\n"
    },
    "@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../CurveMath6.sol\";\nimport \"../../number/types/UFixed6.sol\";\n\n/// @dev UJumpRateUtilizationCurve6 type\nstruct UJumpRateUtilizationCurve6 {\n    UFixed6 minRate;\n    UFixed6 maxRate;\n    UFixed6 targetRate;\n    UFixed6 targetUtilization;\n}\nusing UJumpRateUtilizationCurve6Lib for UJumpRateUtilizationCurve6 global;\n\n/**\n * @title UJumpRateUtilizationCurve6Lib\n * @notice Library for the unsigned base-6 Jump Rate utilization curve type\n */\nlibrary UJumpRateUtilizationCurve6Lib {\n    /**\n     * @notice Computes the corresponding rate for a utilization ratio\n     * @param utilization The utilization ratio\n     * @return The corresponding rate\n     */\n    function compute(UJumpRateUtilizationCurve6 memory self, UFixed6 utilization) internal pure returns (UFixed6) {\n        if (utilization.lt(self.targetUtilization)) {\n            return CurveMath6.linearInterpolation(\n                UFixed6Lib.ZERO,\n                self.minRate,\n                self.targetUtilization,\n                self.targetRate,\n                utilization\n            );\n        }\n        if (utilization.lt(UFixed6Lib.ONE)) {\n            return CurveMath6.linearInterpolation(\n                self.targetUtilization,\n                self.targetRate,\n                UFixed6Lib.ONE,\n                self.maxRate,\n                utilization\n            );\n        }\n        return self.maxRate;\n    }\n\n    function accumulate(\n        UJumpRateUtilizationCurve6 memory self,\n        UFixed6 utilization,\n        uint256 fromTimestamp,\n        uint256 toTimestamp,\n        UFixed6 notional\n    ) internal pure returns (UFixed6) {\n        return compute(self, utilization)\n            .mul(UFixed6Lib.from(toTimestamp - fromTimestamp))\n            .mul(notional)\n            .div(UFixed6Lib.from(365 days));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControl.sol\";\nimport \"../utils/Context.sol\";\nimport \"../utils/Strings.sol\";\nimport \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        Strings.toHexString(account),\n                        \" is missing role \",\n                        Strings.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControl.sol\";\nimport \"../token/ERC721/IERC721Receiver.sol\";\nimport \"../token/ERC1155/IERC1155Receiver.sol\";\nimport \"../utils/Address.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockController is AccessControl, IERC721Receiver, IERC1155Receiver {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with the following parameters:\n     *\n     * - `minDelay`: initial minimum delay for operations\n     * - `proposers`: accounts to be granted proposer and canceller roles\n     * - `executors`: accounts to be granted executor role\n     * - `admin`: optional account to be granted admin role; disable with zero address\n     *\n     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment\n     * without being subject to delay, but this role should be subsequently renounced in favor of\n     * administration through timelocked proposals. Previous versions of this contract would assign\n     * this admin to the deployer automatically and should be renounced as well.\n     */\n    constructor(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors,\n        address admin\n    ) {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // optional admin\n        if (admin != address(0)) {\n            _setupRole(TIMELOCK_ADMIN_ROLE, admin);\n        }\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n            _setupRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, AccessControl) returns (bool) {\n        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool registered) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) internal virtual {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/transparent/ProxyAdmin.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./TransparentUpgradeableProxy.sol\";\nimport \"../../access/Ownable.sol\";\n\n/**\n * @dev This is an auxiliary contract meant to be assigned as the admin of a {TransparentUpgradeableProxy}. For an\n * explanation of why you would want to use this see the documentation for {TransparentUpgradeableProxy}.\n */\ncontract ProxyAdmin is Ownable {\n    /**\n     * @dev Returns the current implementation of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"implementation()\")) == 0x5c60da1b\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Returns the current admin of `proxy`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {\n        // We need to manually run the static call since the getter cannot be flagged as view\n        // bytes4(keccak256(\"admin()\")) == 0xf851a440\n        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");\n        require(success);\n        return abi.decode(returndata, (address));\n    }\n\n    /**\n     * @dev Changes the admin of `proxy` to `newAdmin`.\n     *\n     * Requirements:\n     *\n     * - This contract must be the current admin of `proxy`.\n     */\n    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {\n        proxy.changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {\n        proxy.upgradeTo(implementation);\n    }\n\n    /**\n     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See\n     * {TransparentUpgradeableProxy-upgradeToAndCall}.\n     *\n     * Requirements:\n     *\n     * - This contract must be the admin of `proxy`.\n     */\n    function upgradeAndCall(\n        TransparentUpgradeableProxy proxy,\n        address implementation,\n        bytes memory data\n    ) public payable virtual onlyOwner {\n        proxy.upgradeToAndCall{value: msg.value}(implementation, data);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/AbstractPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPyth.sol\";\nimport \"./PythErrors.sol\";\n\nabstract contract AbstractPyth is IPyth {\n    /// @notice Returns the price feed with given id.\n    /// @dev Reverts if the price does not exist.\n    /// @param id The Pyth Price Feed ID of which to fetch the PriceFeed.\n    function queryPriceFeed(\n        bytes32 id\n    ) public view virtual returns (PythStructs.PriceFeed memory priceFeed);\n\n    /// @notice Returns true if a price feed with the given id exists.\n    /// @param id The Pyth Price Feed ID of which to check its existence.\n    function priceFeedExists(\n        bytes32 id\n    ) public view virtual returns (bool exists);\n\n    function getValidTimePeriod()\n        public\n        view\n        virtual\n        override\n        returns (uint validTimePeriod);\n\n    function getPrice(\n        bytes32 id\n    ) external view virtual override returns (PythStructs.Price memory price) {\n        return getPriceNoOlderThan(id, getValidTimePeriod());\n    }\n\n    function getEmaPrice(\n        bytes32 id\n    ) external view virtual override returns (PythStructs.Price memory price) {\n        return getEmaPriceNoOlderThan(id, getValidTimePeriod());\n    }\n\n    function getPriceUnsafe(\n        bytes32 id\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        PythStructs.PriceFeed memory priceFeed = queryPriceFeed(id);\n        return priceFeed.price;\n    }\n\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        price = getPriceUnsafe(id);\n\n        if (diff(block.timestamp, price.publishTime) > age)\n            revert PythErrors.StalePrice();\n\n        return price;\n    }\n\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        PythStructs.PriceFeed memory priceFeed = queryPriceFeed(id);\n        return priceFeed.emaPrice;\n    }\n\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) public view virtual override returns (PythStructs.Price memory price) {\n        price = getEmaPriceUnsafe(id);\n\n        if (diff(block.timestamp, price.publishTime) > age)\n            revert PythErrors.StalePrice();\n\n        return price;\n    }\n\n    function diff(uint x, uint y) internal pure returns (uint) {\n        if (x > y) {\n            return x - y;\n        } else {\n            return y - x;\n        }\n    }\n\n    // Access modifier is overridden to public to be able to call it locally.\n    function updatePriceFeeds(\n        bytes[] calldata updateData\n    ) public payable virtual override;\n\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable virtual override {\n        if (priceIds.length != publishTimes.length)\n            revert PythErrors.InvalidArgument();\n\n        for (uint i = 0; i < priceIds.length; i++) {\n            if (\n                !priceFeedExists(priceIds[i]) ||\n                queryPriceFeed(priceIds[i]).price.publishTime < publishTimes[i]\n            ) {\n                updatePriceFeeds(updateData);\n                return;\n            }\n        }\n\n        revert PythErrors.NoFreshUpdate();\n    }\n\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    )\n        external\n        payable\n        virtual\n        override\n        returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPyth.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\nimport \"./PythStructs.sol\";\nimport \"./IPythEvents.sol\";\n\n/// @title Consume prices from the Pyth Network (https://pyth.network/).\n/// @dev Please refer to the guidance at https://docs.pyth.network/consumers/best-practices for how to consume prices safely.\n/// @author Pyth Data Association\ninterface IPyth is IPythEvents {\n    /// @notice Returns the period (in seconds) that a price feed is considered valid since its publish time\n    function getValidTimePeriod() external view returns (uint validTimePeriod);\n\n    /// @notice Returns the price and confidence interval.\n    /// @dev Reverts if the price has not been updated within the last `getValidTimePeriod()` seconds.\n    /// @param id The Pyth Price Feed ID of which to fetch the price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price and confidence interval.\n    /// @dev Reverts if the EMA price is not available.\n    /// @param id The Pyth Price Feed ID of which to fetch the EMA price and confidence interval.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPrice(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price of a price feed without any sanity checks.\n    /// @dev This function returns the most recent price update in this contract without any recency checks.\n    /// This function is unsafe as the returned price update may be arbitrarily far in the past.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getPrice` or `getPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the price that is no older than `age` seconds of the current time.\n    /// @dev This function is a sanity-checked version of `getPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price of a price feed without any sanity checks.\n    /// @dev This function returns the same price as `getEmaPrice` in the case where the price is available.\n    /// However, if the price is not recent this function returns the latest available price.\n    ///\n    /// The returned price can be from arbitrarily far in the past; this function makes no guarantees that\n    /// the returned price is recent or useful for any particular application.\n    ///\n    /// Users of this function should check the `publishTime` in the price to ensure that the returned price is\n    /// sufficiently recent for their application. If you are considering using this function, it may be\n    /// safer / easier to use either `getEmaPrice` or `getEmaPriceNoOlderThan`.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceUnsafe(\n        bytes32 id\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Returns the exponentially-weighted moving average price that is no older than `age` seconds\n    /// of the current time.\n    /// @dev This function is a sanity-checked version of `getEmaPriceUnsafe` which is useful in\n    /// applications that require a sufficiently-recent price. Reverts if the price wasn't updated sufficiently\n    /// recently.\n    /// @return price - please read the documentation of PythStructs.Price to understand how to use this safely.\n    function getEmaPriceNoOlderThan(\n        bytes32 id,\n        uint age\n    ) external view returns (PythStructs.Price memory price);\n\n    /// @notice Update price feeds with given update messages.\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    /// Prices will be updated if they are more recent than the current stored prices.\n    /// The call will succeed even if the update is not the most recent.\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    function updatePriceFeeds(bytes[] calldata updateData) external payable;\n\n    /// @notice Wrapper around updatePriceFeeds that rejects fast if a price update is not necessary. A price update is\n    /// necessary if the current on-chain publishTime is older than the given publishTime. It relies solely on the\n    /// given `publishTimes` for the price feeds and does not read the actual price update publish time within `updateData`.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    /// `priceIds` and `publishTimes` are two arrays with the same size that correspond to senders known publishTime\n    /// of each priceId when calling this method. If all of price feeds within `priceIds` have updated and have\n    /// a newer or equal publish time than the given publish time, it will reject the transaction to save gas.\n    /// Otherwise, it calls updatePriceFeeds method to update the prices.\n    ///\n    /// @dev Reverts if update is not needed or the transferred fee is not sufficient or the updateData is invalid.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param publishTimes Array of publishTimes. `publishTimes[i]` corresponds to known `publishTime` of `priceIds[i]`\n    function updatePriceFeedsIfNecessary(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64[] calldata publishTimes\n    ) external payable;\n\n    /// @notice Returns the required fee to update an array of price updates.\n    /// @param updateData Array of price update data.\n    /// @return feeAmount The required fee in Wei.\n    function getUpdateFee(\n        bytes[] calldata updateData\n    ) external view returns (uint feeAmount);\n\n    /// @notice Parse `updateData` and return price feeds of the given `priceIds` if they are all published\n    /// within `minPublishTime` and `maxPublishTime`.\n    ///\n    /// You can use this method if you want to use a Pyth price at a fixed time and not the most recent price;\n    /// otherwise, please consider using `updatePriceFeeds`. This method does not store the price updates on-chain.\n    ///\n    /// This method requires the caller to pay a fee in wei; the required fee can be computed by calling\n    /// `getUpdateFee` with the length of the `updateData` array.\n    ///\n    ///\n    /// @dev Reverts if the transferred fee is not sufficient or the updateData is invalid or there is\n    /// no update for any of the given `priceIds` within the given time range.\n    /// @param updateData Array of price update data.\n    /// @param priceIds Array of price ids.\n    /// @param minPublishTime minimum acceptable publishTime for the given `priceIds`.\n    /// @param maxPublishTime maximum acceptable publishTime for the given `priceIds`.\n    /// @return priceFeeds Array of the price feeds corresponding to the given `priceIds` (with the same order).\n    function parsePriceFeedUpdates(\n        bytes[] calldata updateData,\n        bytes32[] calldata priceIds,\n        uint64 minPublishTime,\n        uint64 maxPublishTime\n    ) external payable returns (PythStructs.PriceFeed[] memory priceFeeds);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/IPythEvents.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\n/// @title IPythEvents contains the events that Pyth contract emits.\n/// @dev This interface can be used for listening to the updates for off-chain and testing purposes.\ninterface IPythEvents {\n    /// @dev Emitted when the price feed with `id` has received a fresh update.\n    /// @param id The Pyth Price Feed ID.\n    /// @param publishTime Publish time of the given price update.\n    /// @param price Price of the given price update.\n    /// @param conf Confidence interval of the given price update.\n    event PriceFeedUpdate(\n        bytes32 indexed id,\n        uint64 publishTime,\n        int64 price,\n        uint64 conf\n    );\n\n    /// @dev Emitted when a batch price update is processed successfully.\n    /// @param chainId ID of the source chain that the batch price update comes from.\n    /// @param sequenceNumber Sequence number of the batch price update.\n    event BatchPriceFeedUpdate(uint16 chainId, uint64 sequenceNumber);\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythErrors.sol": {
      "content": "// SPDX-License-Identifier: Apache 2\n\npragma solidity ^0.8.0;\n\nlibrary PythErrors {\n    // Function arguments are invalid (e.g., the arguments lengths mismatch)\n    error InvalidArgument();\n    // Update data is coming from an invalid data source.\n    error InvalidUpdateDataSource();\n    // Update data is invalid (e.g., deserialization error)\n    error InvalidUpdateData();\n    // Insufficient fee is paid to the method.\n    error InsufficientFee();\n    // There is no fresh update, whereas expected fresh updates.\n    error NoFreshUpdate();\n    // There is no price feed found within the given range or it does not exists.\n    error PriceFeedNotFoundWithinRange();\n    // Price feed not found or it is not pushed on-chain yet.\n    error PriceFeedNotFound();\n    // Requested price is stale.\n    error StalePrice();\n    // Given message is not a valid Wormhole VAA.\n    error InvalidWormholeVaa();\n    // Governance message is invalid (e.g., deserialization error).\n    error InvalidGovernanceMessage();\n    // Governance message is not for this contract.\n    error InvalidGovernanceTarget();\n    // Governance message is coming from an invalid data source.\n    error InvalidGovernanceDataSource();\n    // Governance message is old.\n    error OldGovernanceMessage();\n}\n"
    },
    "@pythnetwork/pyth-sdk-solidity/PythStructs.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.0;\n\ncontract PythStructs {\n    // A price with a degree of uncertainty, represented as a price +- a confidence interval.\n    //\n    // The confidence interval roughly corresponds to the standard error of a normal distribution.\n    // Both the price and confidence are stored in a fixed-point numeric representation,\n    // `x * (10^expo)`, where `expo` is the exponent.\n    //\n    // Please refer to the documentation at https://docs.pyth.network/consumers/best-practices for how\n    // to how this price safely.\n    struct Price {\n        // Price\n        int64 price;\n        // Confidence interval around the price\n        uint64 conf;\n        // Price exponent\n        int32 expo;\n        // Unix timestamp describing when the price was published\n        uint publishTime;\n    }\n\n    // PriceFeed represents a current aggregate price from pyth publisher feeds.\n    struct PriceFeed {\n        // The price ID.\n        bytes32 id;\n        // Latest available price\n        Price price;\n        // Latest available exponentially-weighted moving average price\n        Price emaPrice;\n    }\n}\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-extensions/contracts/Coordinator.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-extensions/contracts/Coordinator.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Arbitrum.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Optimism.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-extensions/contracts/MultiInvoker_Optimism.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-extensions/contracts/MultiInvoker.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-extensions/contracts/MultiInvoker.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/keeper/KeeperFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/keeper/KeeperFactory.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/Oracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/Oracle.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/OracleFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/OracleFactory.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/payoff/PowerHalf.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/payoff/PowerHalf.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/payoff/PowerTwo.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/payoff/PowerTwo.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory_Arbitrum.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory_Optimism.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory_Optimism.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-oracle/contracts/pyth/PythFactory.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-vault/contracts/Vault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-vault/contracts/Vault.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2-vault/contracts/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2-vault/contracts/VaultFactory.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2/contracts/Market.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2/contracts/Market.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@equilibria/perennial-v2/contracts/MarketFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@equilibria/perennial-v2/contracts/MarketFactory.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/governance/TimelockController.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/governance/TimelockController.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/interfaces/IERC20.sol';\n"
    },
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol';\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "viaIR": true,
    "metadata": {
      "useLiteralContent": true
    }
  }
}
