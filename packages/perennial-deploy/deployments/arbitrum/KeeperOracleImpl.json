{
  "address": "0x2a9CD101B90CaE856F8484062516035f4ecBa3de",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "timeout_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        }
      ],
      "name": "InitializableAlreadyInitializedError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InitializableNotInitializingError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InitializableZeroVersionError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "InstanceNotFactoryError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "sender",
          "type": "address"
        }
      ],
      "name": "InstanceNotOwnerError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InstancePausedError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "KeeperOracleInvalidCallbackError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "KeeperOracleInvalidPriceError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "KeeperOracleVersionOutsideRangeError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OracleProviderUnauthorizedError",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "contract IMarket",
              "name": "market",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "version",
              "type": "uint256"
            }
          ],
          "indexed": true,
          "internalType": "struct IKeeperOracle.SettlementCallback",
          "name": "callback",
          "type": "tuple"
        }
      ],
      "name": "CallbackFulfilled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "contract IMarket",
              "name": "market",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "account",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "version",
              "type": "uint256"
            }
          ],
          "indexed": true,
          "internalType": "struct IKeeperOracle.SettlementCallback",
          "name": "callback",
          "type": "tuple"
        }
      ],
      "name": "CallbackRequested",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "Fixed6",
              "name": "price",
              "type": "int256"
            },
            {
              "internalType": "bool",
              "name": "valid",
              "type": "bool"
            }
          ],
          "indexed": false,
          "internalType": "struct OracleVersion",
          "name": "version",
          "type": "tuple"
        }
      ],
      "name": "OracleProviderVersionFulfilled",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        }
      ],
      "name": "OracleProviderVersionRequested",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        }
      ],
      "name": "at",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "Fixed6",
              "name": "price",
              "type": "int256"
            },
            {
              "internalType": "bool",
              "name": "valid",
              "type": "bool"
            }
          ],
          "internalType": "struct OracleVersion",
          "name": "oracleVersion",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "Fixed6",
              "name": "price",
              "type": "int256"
            },
            {
              "internalType": "bool",
              "name": "valid",
              "type": "bool"
            }
          ],
          "internalType": "struct OracleVersion",
          "name": "version",
          "type": "tuple"
        }
      ],
      "name": "commit",
      "outputs": [
        {
          "internalType": "bool",
          "name": "requested",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "current",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "factory",
      "outputs": [
        {
          "internalType": "contract IFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "global",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint64",
              "name": "latestVersion",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "currentIndex",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "latestIndex",
              "type": "uint64"
            }
          ],
          "internalType": "struct IKeeperOracle.Global",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        }
      ],
      "name": "globalCallbacks",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "latest",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "Fixed6",
              "name": "price",
              "type": "int256"
            },
            {
              "internalType": "bool",
              "name": "valid",
              "type": "bool"
            }
          ],
          "internalType": "struct OracleVersion",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        },
        {
          "internalType": "contract IMarket",
          "name": "market",
          "type": "address"
        }
      ],
      "name": "localCallbacks",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "next",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IMarket",
          "name": "market",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "request",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IMarket",
          "name": "market",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "version",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "maxCount",
          "type": "uint256"
        }
      ],
      "name": "settle",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "status",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "Fixed6",
              "name": "price",
              "type": "int256"
            },
            {
              "internalType": "bool",
              "name": "valid",
              "type": "bool"
            }
          ],
          "internalType": "struct OracleVersion",
          "name": "",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "timeout",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "versions",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x2ac5f7491046b932661afd37518bb2354ca1d7b92ba15e3b9bd285984b0c525f",
  "receipt": {
    "to": null,
    "from": "0x66a7fDB96C583c59597de16d8b2B989231415339",
    "contractAddress": "0x2a9CD101B90CaE856F8484062516035f4ecBa3de",
    "transactionIndex": 3,
    "gasUsed": "14755729",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xc18576cea464bf99cac94c9ccedd6d388d394e3953ce576cfc16ee06eb32b001",
    "transactionHash": "0x2ac5f7491046b932661afd37518bb2354ca1d7b92ba15e3b9bd285984b0c525f",
    "logs": [],
    "blockNumber": 170734096,
    "cumulativeGasUsed": "19754295",
    "status": 1,
    "byzantium": true
  },
  "args": [60],
  "numDeployments": 1,
  "solcInputHash": "c00e0b6ab696ec04bf536435476c1cf2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.19+commit.7dd6d404\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timeout_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"InitializableAlreadyInitializedError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitializableNotInitializingError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InitializableZeroVersionError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"InstanceNotFactoryError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"InstanceNotOwnerError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InstancePausedError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KeeperOracleInvalidCallbackError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KeeperOracleInvalidPriceError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"KeeperOracleVersionOutsideRangeError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OracleProviderUnauthorizedError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"indexed\":true,\"internalType\":\"struct IKeeperOracle.SettlementCallback\",\"name\":\"callback\",\"type\":\"tuple\"}],\"name\":\"CallbackFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"indexed\":true,\"internalType\":\"struct IKeeperOracle.SettlementCallback\",\"name\":\"callback\",\"type\":\"tuple\"}],\"name\":\"CallbackRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"Fixed6\",\"name\":\"price\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"indexed\":false,\"internalType\":\"struct OracleVersion\",\"name\":\"version\",\"type\":\"tuple\"}],\"name\":\"OracleProviderVersionFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"OracleProviderVersionRequested\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"at\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"Fixed6\",\"name\":\"price\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"internalType\":\"struct OracleVersion\",\"name\":\"oracleVersion\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"Fixed6\",\"name\":\"price\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"internalType\":\"struct OracleVersion\",\"name\":\"version\",\"type\":\"tuple\"}],\"name\":\"commit\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"requested\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"current\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"factory\",\"outputs\":[{\"internalType\":\"contract IFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"global\",\"outputs\":[{\"components\":[{\"internalType\":\"uint64\",\"name\":\"latestVersion\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"currentIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"latestIndex\",\"type\":\"uint64\"}],\"internalType\":\"struct IKeeperOracle.Global\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"}],\"name\":\"globalCallbacks\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"latest\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"Fixed6\",\"name\":\"price\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"internalType\":\"struct OracleVersion\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"}],\"name\":\"localCallbacks\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"next\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"request\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IMarket\",\"name\":\"market\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"version\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxCount\",\"type\":\"uint256\"}],\"name\":\"settle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"Fixed6\",\"name\":\"price\",\"type\":\"int256\"},{\"internalType\":\"bool\",\"name\":\"valid\",\"type\":\"bool\"}],\"internalType\":\"struct OracleVersion\",\"name\":\"\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"timeout\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"versions\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"One instance per price feed should be deployed. Multiple products may use the same      KeeperOracle instance if their payoff functions are based on the same underlying oracle.      This implementation only supports non-negative prices.\",\"kind\":\"dev\",\"methods\":{\"at(uint256)\":{\"params\":{\"timestamp\":\"The timestamp of which to lookup\"},\"returns\":{\"oracleVersion\":\"Oracle version at version `version`\"}},\"commit((uint256,int256,bool))\":{\"details\":\"Verification of price happens in the oracle's factory\",\"params\":{\"version\":\"The oracle version to commit\"},\"returns\":{\"requested\":\"Whether the commit was requested\"}},\"constructor\":{\"params\":{\"timeout_\":\"The timeout for a version to be committed\"}},\"current()\":{\"returns\":{\"_0\":\"Current oracle version\"}},\"factory()\":{\"returns\":{\"_0\":\"The factory that created this instance\"}},\"global()\":{\"returns\":{\"_0\":\"The global state of the oracle\"}},\"globalCallbacks(uint256)\":{\"params\":{\"version\":\"The version to lookup\"},\"returns\":{\"_0\":\"The global oracle callback set for the version\"}},\"latest()\":{\"returns\":{\"_0\":\"Latest oracle version\"}},\"localCallbacks(uint256,address)\":{\"params\":{\"market\":\"The market to lookup\",\"version\":\"The version to lookup\"},\"returns\":{\"_0\":\"The local oracle callback set for the version and market\"}},\"next()\":{\"details\":\"Returns 0 if no next version is requested\",\"returns\":{\"_0\":\"The next requested oracle version\"}},\"request(address,address)\":{\"params\":{\"account\":\"The account to callback to\",\"market\":\"The market to callback to\"}},\"settle(address,uint256,uint256)\":{\"details\":\"Distribution of keeper incentive is consolidated in the oracle's factory\",\"params\":{\"market\":\"The market to settle\",\"maxCount\":\"The maximum number of settlement callbacks to perform before exiting\",\"version\":\"The version to settle\"}},\"status()\":{\"returns\":{\"_0\":\"The latest synced oracle version\",\"_1\":\"The current oracle version collecting new orders\"}}},\"stateVariables\":{\"_global\":{\"details\":\"The global state of the oracle\"},\"_globalCallbacks\":{\"details\":\"Mapping from version to a set of registered markets for settlement callback\"},\"_localCallbacks\":{\"details\":\"Mapping from version and market to a set of registered accounts for settlement callback\"},\"_prices\":{\"details\":\"Mapping from oracle version to oracle version data\"},\"timeout\":{\"details\":\"After this amount of time has passed for a version without being committed, the version can be invalidated.\"},\"versions\":{\"details\":\"List of all requested oracle versions\"}},\"title\":\"KeeperOracle\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"at(uint256)\":{\"notice\":\"Returns the oracle version at version `version`\"},\"commit((uint256,int256,bool))\":{\"notice\":\"Commits the price to specified version\"},\"constructor\":{\"notice\":\"Constructs the contract\"},\"current()\":{\"notice\":\"Returns the current oracle version accepting new orders\"},\"factory()\":{\"notice\":\"Returns the factory that created this instance\"},\"global()\":{\"notice\":\"Returns the global state of the oracle\"},\"globalCallbacks(uint256)\":{\"notice\":\"Returns the global oracle callback set for a version\"},\"initialize()\":{\"notice\":\"Initializes the contract state\"},\"latest()\":{\"notice\":\"Returns the latest synced oracle version\"},\"localCallbacks(uint256,address)\":{\"notice\":\"Returns the local oracle callback set for a version and market\"},\"next()\":{\"notice\":\"Returns the next requested oracle version\"},\"request(address,address)\":{\"notice\":\"Records a request for a new oracle version\"},\"settle(address,uint256,uint256)\":{\"notice\":\"Performs an asynchronous local settlement callback\"},\"status()\":{\"notice\":\"Returns the latest synced oracle version and the current oracle version\"}},\"notice\":\"Generic implementation of the IOracle interface for keeper-based oracles.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol\":\"KeeperOracle\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  // getRoundData and latestRoundData should both raise \\\"No data present\\\"\\n  // if they do not have data to report, instead of returning unset values\\n  // which could be misinterpreted as actual reported values.\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0xf2b6c9adb3552254df1445b73563cf014434ff5e78663e9b961b6c059506ceb5\",\"license\":\"MIT\"},\"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\":{\"content\":\"//SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/UFixed18.sol\\\";\\n\\ninterface IEmptySetReserve {\\n    event Redeem(address indexed account, uint256 costAmount, uint256 redeemAmount);\\n    event Mint(address indexed account, uint256 mintAmount, uint256 costAmount);\\n    event Repay(address indexed account, uint256 repayAmount);\\n\\n    function debt(address borrower) external view returns (UFixed18);\\n    function repay(address borrower, UFixed18 amount) external;\\n    function mint(UFixed18 amount) external;\\n    function redeem(UFixed18 amount) external;\\n}\\n\",\"keccak256\":\"0xdb96e26082a471c7803e892ecd8d2877f23cd9e31f13a3e407dd5f8909078864\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-oracle/contracts/Oracle.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.19;\\n\\nimport \\\"@equilibria/root/attribute/Instance.sol\\\";\\nimport \\\"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\\\";\\nimport \\\"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\\\";\\nimport \\\"./interfaces/IOracle.sol\\\";\\n\\n/// @title Oracle\\n/// @notice The top-level oracle contract that implements an oracle provider interface.\\n/// @dev Manages swapping between different underlying oracle provider interfaces over time.\\ncontract Oracle is IOracle, Instance {\\n    /// @notice A historical mapping of underlying oracle providers\\n    mapping(uint256 => Epoch) public oracles;\\n\\n    /// @notice The global state of the oracle\\n    Global public global;\\n\\n    /// @notice Initializes the contract state\\n    /// @param initialProvider The initial oracle provider\\n    function initialize(IOracleProvider initialProvider) external initializer(1) {\\n        __Instance__initialize();\\n        _updateCurrent(initialProvider);\\n        _updateLatest(initialProvider.latest());\\n    }\\n\\n    /// @notice Updates the current oracle provider\\n    /// @dev Both the current and new oracle provider must have the same current\\n    /// @param newProvider The new oracle provider\\n    function update(IOracleProvider newProvider) external onlyFactory {\\n        _updateCurrent(newProvider);\\n        _updateLatest(newProvider.latest());\\n    }\\n\\n    /// @notice Requests a new version at the current timestamp\\n    /// @param market Original market to optionally use for callbacks\\n    /// @param account Original sender to optionally use for callbacks\\n    function request(IMarket market, address account) external onlyAuthorized {\\n        (OracleVersion memory latestVersion, uint256 currentTimestamp) = oracles[global.current].provider.status();\\n\\n        oracles[\\n            (currentTimestamp > oracles[global.latest].timestamp) ? global.current : global.latest\\n        ].provider.request(market, account);\\n\\n        oracles[global.current].timestamp = uint96(currentTimestamp);\\n        _updateLatest(latestVersion);\\n    }\\n\\n    /// @notice Returns the latest committed version as well as the current timestamp\\n    /// @return latestVersion The latest committed version\\n    /// @return currentTimestamp The current timestamp\\n    function status() external view returns (OracleVersion memory latestVersion, uint256 currentTimestamp) {\\n        (latestVersion, currentTimestamp) = oracles[global.current].provider.status();\\n        latestVersion = _handleLatest(latestVersion);\\n    }\\n\\n    /// @notice Returns the latest committed version\\n    function latest() public view returns (OracleVersion memory) {\\n        return _handleLatest(oracles[global.current].provider.latest());\\n    }\\n\\n    /// @notice Returns the current value\\n    function current() public view returns (uint256) {\\n        return oracles[global.current].provider.current();\\n    }\\n\\n    /// @notice Returns the oracle version at a given timestamp\\n    /// @param timestamp The timestamp to query\\n    /// @return atVersion The oracle version at the given timestamp\\n    function at(uint256 timestamp) public view returns (OracleVersion memory atVersion) {\\n        if (timestamp == 0) return atVersion;\\n        IOracleProvider provider = oracles[global.current].provider;\\n        for (uint256 i = global.current - 1; i > 0; i--) {\\n            if (timestamp > uint256(oracles[i].timestamp)) break;\\n            provider = oracles[i].provider;\\n        }\\n        return provider.at(timestamp);\\n    }\\n\\n    /// @notice Handles update the oracle to the new provider\\n    /// @param newProvider The new oracle provider\\n    function _updateCurrent(IOracleProvider newProvider) private {\\n        // oracle must not already be updating\\n        if (global.current != global.latest) revert OracleOutOfSyncError();\\n\\n        // if the latest version of the underlying oracle is further ahead than its latest request update its timestamp\\n        if (global.current != 0) {\\n            OracleVersion memory latestVersion = oracles[global.current].provider.latest();\\n            if (latestVersion.timestamp > oracles[global.current].timestamp)\\n                oracles[global.current].timestamp = uint96(latestVersion.timestamp);\\n        }\\n\\n        // add the new oracle registration\\n        oracles[++global.current] = Epoch(newProvider, uint96(newProvider.current()));\\n        emit OracleUpdated(newProvider);\\n    }\\n\\n    /// @notice Handles updating the latest oracle to the current if it is ready\\n    /// @param currentOracleLatestVersion The latest version from the current oracle\\n    function _updateLatest(OracleVersion memory currentOracleLatestVersion) private {\\n        if (_latestStale(currentOracleLatestVersion)) global.latest = global.current;\\n    }\\n\\n    /// @notice Handles overriding the latest version\\n    /// @dev Applicable if we haven't yet switched over to the current oracle from the latest oracle\\n    /// @param currentOracleLatestVersion The latest version from the current oracle\\n    /// @return latestVersion The latest version\\n    function _handleLatest(\\n        OracleVersion memory currentOracleLatestVersion\\n    ) private view returns (OracleVersion memory latestVersion) {\\n        if (global.current == global.latest) return currentOracleLatestVersion;\\n\\n        bool isLatestStale = _latestStale(currentOracleLatestVersion);\\n        latestVersion = isLatestStale ? currentOracleLatestVersion : oracles[global.latest].provider.latest();\\n\\n        uint256 latestOracleTimestamp =\\n            uint256(isLatestStale ? oracles[global.current].timestamp : oracles[global.latest].timestamp);\\n        if (!isLatestStale && latestVersion.timestamp > latestOracleTimestamp)\\n            return at(latestOracleTimestamp);\\n    }\\n\\n    /// @notice Returns whether the latest oracle is ready to be updated\\n    /// @param currentOracleLatestVersion The latest version from the current oracle\\n    /// @return Whether the latest oracle is ready to be updated\\n    function _latestStale(OracleVersion memory currentOracleLatestVersion) private view returns (bool) {\\n        if (global.current == global.latest) return false;\\n        if (global.latest == 0) return true;\\n\\n        if (uint256(oracles[global.latest].timestamp) > oracles[global.latest].provider.latest().timestamp) return false;\\n        if (uint256(oracles[global.latest].timestamp) >= currentOracleLatestVersion.timestamp) return false;\\n\\n        return true;\\n    }\\n\\n    /// @dev Only if the caller is authorized by the factory\\n    modifier onlyAuthorized {\\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender))\\n            revert OracleProviderUnauthorizedError();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x0b790fd73c8a04db4355e4994cd06328f40a9b6e5db2cd97f68a6bc874dd36a9\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-oracle/contracts/interfaces/IKeeperFactory.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/token/types/Token18.sol\\\";\\nimport \\\"@equilibria/root/attribute/interfaces/IFactory.sol\\\";\\nimport \\\"@equilibria/root/attribute/interfaces/IKept.sol\\\";\\nimport \\\"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\\\";\\nimport \\\"./IKeeperOracle.sol\\\";\\nimport \\\"./IOracleFactory.sol\\\";\\n\\ninterface IKeeperFactory is IOracleProviderFactory, IFactory, IKept {\\n    struct Granularity {\\n        uint64 latestGranularity;\\n        uint64 currentGranularity;\\n        uint128 effectiveAfter;\\n    }\\n\\n    event OracleAssociated(bytes32 indexed id, bytes32 indexed underlyingId);\\n    event GranularityUpdated(uint256 newGranularity, uint256 effectiveAfter);\\n    event CallerAuthorized(IFactory indexed caller);\\n\\n    // sig: 0xe65b0914\\n    error KeeperFactoryNotInstanceError();\\n    // sig: 0x19136990\\n    error KeeperFactoryInvalidGranularityError();\\n    // sig: 0x953ec95c\\n    error KeeperFactoryAlreadyCreatedError();\\n    // sig: 0x131b567b\\n    error KeeperFactoryInvalidIdError();\\n    // sig: 0x267646d7\\n    error KeeperFactoryNotAssociatedError();\\n    // sig: 0xf0253cdc\\n    error KeeperFactoryAlreadyAssociatedError();\\n    // sig: 0xb043fd7b\\n    error KeeperFactoryInvalidSettleError();\\n\\n    function validFrom() external view returns (uint256);\\n    function validTo() external view returns (uint256);\\n    function commitKeepConfig(uint256 numRequested) external view returns (KeepConfig memory);\\n    function settleKeepConfig() external view returns (KeepConfig memory);\\n\\n    function initialize(IOracleFactory oracleFactory, AggregatorV3Interface chainlinkFeed_, Token18 dsu_) external;\\n    function authorize(IFactory factory) external;\\n    function associate(bytes32 id, bytes32 underlyingId) external;\\n    function toUnderlyingId(bytes32 id) external returns (bytes32);\\n    function fromUnderlyingId(bytes32 underlyingId) external returns (bytes32);\\n    function create(bytes32 id) external returns (IKeeperOracle oracle);\\n    function current() external view returns (uint256);\\n    function granularity() external view returns (Granularity memory);\\n    function updateGranularity(uint256 newGranularity) external;\\n    function commit(bytes32[] memory ids, uint256 version, bytes calldata data) external payable;\\n    function settle(bytes32[] memory ids, IMarket[] memory markets, uint256[] memory versions, uint256[] memory maxCounts) external;\\n}\\n\",\"keccak256\":\"0x1db9f7c9fe8880f7d4f3d04ed80f6c327197c012bc18c72bddfa58cc84c5242d\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-oracle/contracts/interfaces/IKeeperOracle.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/attribute/interfaces/IInstance.sol\\\";\\nimport \\\"@equilibria/perennial-v2/contracts/interfaces/IOracleProvider.sol\\\";\\nimport \\\"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\\\";\\nimport \\\"../Oracle.sol\\\";\\n\\ninterface IKeeperOracle is IOracleProvider, IInstance {\\n    event CallbackRequested(SettlementCallback indexed callback);\\n    event CallbackFulfilled(SettlementCallback indexed callback);\\n\\n    struct SettlementCallback {\\n        /// @dev The market to settle\\n        IMarket market;\\n\\n        /// @dev The account to settle\\n        address account;\\n\\n        /// @dev The version to settle for\\n        uint256 version;\\n    }\\n\\n    struct Global {\\n        /// @dev The latest committed oracle version\\n        uint64 latestVersion;\\n\\n        /// @dev Index in `versions` of the most recent version requested\\n        uint64 currentIndex;\\n\\n        /// @dev Index in `versions` of the latest version a keeper has committed\\n        uint64 latestIndex;\\n    }\\n\\n    // sig: 0xb8499c31\\n    error KeeperOracleVersionOutsideRangeError();\\n    // sig: 0xce9529c8\\n    error KeeperOracleInvalidPriceError();\\n    //sig: 0x4889ef6f\\n    error KeeperOracleInvalidCallbackError();\\n\\n    function initialize() external;\\n    function commit(OracleVersion memory version) external returns (bool);\\n    function settle(IMarket market, uint256 version, uint256 maxCount) external;\\n    function next() external view returns (uint256);\\n    function globalCallbacks(uint256 version) external view returns (address[] memory);\\n    function localCallbacks(uint256 version, IMarket market) external view returns (address[] memory);\\n\\n    function timeout() external view returns (uint256);\\n    function versions(uint256 index) external view returns (uint256);\\n    function global() external view returns (Global memory);\\n}\\n\",\"keccak256\":\"0x019b585f279257d2fce8033e546ab1d487ff55cfb70710a880850c9a6778822b\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-oracle/contracts/interfaces/IOracle.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/attribute/interfaces/IInstance.sol\\\";\\nimport \\\"@equilibria/perennial-v2/contracts/interfaces/IOracleProvider.sol\\\";\\n\\ninterface IOracle is IOracleProvider, IInstance {\\n    // sig: 0x8852e53b\\n    error OracleOutOfSyncError();\\n    // sig: 0x0f7338e5\\n    error OracleOutOfOrderCommitError();\\n\\n    event OracleUpdated(IOracleProvider newProvider);\\n\\n    /// @dev The state for a single epoch\\n    struct Epoch {\\n        /// @dev The oracle provider for this epoch\\n        IOracleProvider provider;\\n\\n        /// @dev The last timestamp that this oracle provider is valid\\n        uint96 timestamp;\\n    }\\n\\n    /// @dev The global state for oracle\\n    struct Global {\\n        /// @dev The current epoch\\n        uint128 current;\\n\\n        /// @dev The latest epoch\\n        uint128 latest;\\n    }\\n\\n    function initialize(IOracleProvider initialProvider) external;\\n    function update(IOracleProvider newProvider) external;\\n}\",\"keccak256\":\"0xaaf53e99cab22c7d0271a4e863c76df405338014d3319697fa7b00e1fe2b20f1\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-oracle/contracts/interfaces/IOracleFactory.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\\\";\\nimport \\\"@equilibria/root/token/types/Token6.sol\\\";\\nimport \\\"@equilibria/root/token/types/Token18.sol\\\";\\nimport \\\"@equilibria/root/attribute/interfaces/IFactory.sol\\\";\\nimport \\\"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\\\";\\nimport \\\"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\\\";\\nimport \\\"./IOracle.sol\\\";\\n\\ninterface IOracleFactory is IOracleProviderFactory, IFactory {\\n    event MaxClaimUpdated(UFixed6 newMaxClaim);\\n    event FactoryRegistered(IOracleProviderFactory factory);\\n    event CallerAuthorized(IFactory caller);\\n\\n    // sig: 0xe7911099\\n    error OracleFactoryInvalidIdError();\\n    // sig: 0xe232e366\\n    error OracleFactoryAlreadyCreatedError();\\n    // sig: 0xbbfaa925\\n    error OracleFactoryNotRegisteredError();\\n    // sig: 0xfeb0e18c\\n    error OracleFactoryNotCreatedError();\\n    // sig: 0x4ddc5544\\n    error OracleFactoryClaimTooLargeError();\\n\\n    function factories(IOracleProviderFactory factory) external view returns (bool);\\n    function initialize(Token18 incentive, Token6 usdc, IEmptySetReserve reserve) external;\\n    function register(IOracleProviderFactory factory) external;\\n    function create(bytes32 id, IOracleProviderFactory factory) external returns (IOracle newOracle);\\n    function update(bytes32 id, IOracleProviderFactory factory) external;\\n    function updateMaxClaim(UFixed6 newClaimAmount) external;\\n    function maxClaim() external view returns (UFixed6);\\n    function claim(UFixed6 amount) external;\\n    function callers(IFactory caller) external view returns (bool);\\n    function fund(IMarket market) external;\\n}\\n\",\"keccak256\":\"0xcababcb48dd553d47acca6f96e66c4571000c207891a7a8cb5672f4bab6fe71c\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.19;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\\\";\\nimport \\\"@equilibria/root/attribute/Instance.sol\\\";\\nimport \\\"../interfaces/IKeeperFactory.sol\\\";\\n\\n/// @title KeeperOracle\\n/// @notice Generic implementation of the IOracle interface for keeper-based oracles.\\n/// @dev One instance per price feed should be deployed. Multiple products may use the same\\n///      KeeperOracle instance if their payoff functions are based on the same underlying oracle.\\n///      This implementation only supports non-negative prices.\\ncontract KeeperOracle is IKeeperOracle, Instance {\\n    using EnumerableSet for EnumerableSet.AddressSet;\\n\\n    /// @dev After this amount of time has passed for a version without being committed, the version can be invalidated.\\n    uint256 public immutable timeout;\\n\\n    /// @dev List of all requested oracle versions\\n    mapping(uint256 => uint256) public versions;\\n\\n    /// @dev The global state of the oracle\\n    Global private _global;\\n\\n    /// @dev Mapping from oracle version to oracle version data\\n    mapping(uint256 => Fixed6) private _prices;\\n\\n    /// @dev Mapping from version to a set of registered markets for settlement callback\\n    mapping(uint256 => EnumerableSet.AddressSet) private _globalCallbacks;\\n\\n    /// @dev Mapping from version and market to a set of registered accounts for settlement callback\\n    mapping(uint256 => mapping(IMarket => EnumerableSet.AddressSet)) private _localCallbacks;\\n\\n    /// @notice Constructs the contract\\n    /// @param timeout_ The timeout for a version to be committed\\n    constructor(uint256 timeout_)  {\\n        timeout = timeout_;\\n    }\\n\\n    /// @notice Initializes the contract state\\n    function initialize() external initializer(1) {\\n        __Instance__initialize();\\n    }\\n\\n    /// @notice Returns the global state of the oracle\\n    /// @return The global state of the oracle\\n    function global() external view returns (Global memory) { return _global; }\\n\\n    /// @notice Returns the global oracle callback set for a version\\n    /// @param version The version to lookup\\n    /// @return The global oracle callback set for the version\\n    function globalCallbacks(uint256 version) external view returns (address[] memory) {\\n        return _globalCallbacks[version].values();\\n    }\\n\\n    /// @notice Returns the local oracle callback set for a version and market\\n    /// @param version The version to lookup\\n    /// @param market The market to lookup\\n    /// @return The local oracle callback set for the version and market\\n    function localCallbacks(uint256 version, IMarket market) external view returns (address[] memory) {\\n        return _localCallbacks[version][market].values();\\n    }\\n\\n    /// @notice Returns the next requested oracle version\\n    /// @dev Returns 0 if no next version is requested\\n    /// @return The next requested oracle version\\n    function next() public view returns (uint256) {\\n        return versions[_global.latestIndex + 1];\\n    }\\n\\n    /// @notice Records a request for a new oracle version\\n    /// @param market The market to callback to\\n    /// @param account The account to callback to\\n    function request(IMarket market, address account) external onlyAuthorized {\\n        uint256 currentTimestamp = current();\\n\\n        _globalCallbacks[currentTimestamp].add(address(market));\\n        _localCallbacks[currentTimestamp][market].add(account);\\n        emit CallbackRequested(SettlementCallback(market, account, currentTimestamp));\\n\\n        if (versions[_global.currentIndex] == currentTimestamp) return;\\n        versions[++_global.currentIndex] = currentTimestamp;\\n        emit OracleProviderVersionRequested(currentTimestamp);\\n    }\\n\\n    /// @notice Returns the latest synced oracle version and the current oracle version\\n    /// @return The latest synced oracle version\\n    /// @return The current oracle version collecting new orders\\n    function status() external view returns (OracleVersion memory, uint256) {\\n        return (latest(), current());\\n    }\\n\\n    /// @notice Returns the latest synced oracle version\\n    /// @return Latest oracle version\\n    function latest() public view returns (OracleVersion memory) {\\n        return at(_global.latestVersion);\\n    }\\n\\n    /// @notice Returns the current oracle version accepting new orders\\n    /// @return Current oracle version\\n    function current() public view returns (uint256) {\\n        return IKeeperFactory(address(factory())).current();\\n    }\\n\\n    /// @notice Returns the oracle version at version `version`\\n    /// @param timestamp The timestamp of which to lookup\\n    /// @return oracleVersion Oracle version at version `version`\\n    function at(uint256 timestamp) public view returns (OracleVersion memory oracleVersion) {\\n        (oracleVersion.timestamp, oracleVersion.price) = (timestamp, _prices[timestamp]);\\n        oracleVersion.valid = !oracleVersion.price.isZero();\\n    }\\n\\n    /// @notice Commits the price to specified version\\n    /// @dev Verification of price happens in the oracle's factory\\n    /// @param version The oracle version to commit\\n    /// @return requested Whether the commit was requested\\n    function commit(OracleVersion memory version) external onlyFactory returns (bool requested) {\\n        if (version.timestamp == 0) revert KeeperOracleVersionOutsideRangeError();\\n        requested = (version.timestamp == next()) ? _commitRequested(version) : _commitUnrequested(version);\\n        _global.latestVersion = uint64(version.timestamp);\\n\\n        for (uint256 i; i < _globalCallbacks[version.timestamp].length(); i++)\\n            _settle(IMarket(_globalCallbacks[version.timestamp].at(i)), address(0));\\n\\n        emit OracleProviderVersionFulfilled(version);\\n    }\\n\\n    /// @notice Performs an asynchronous local settlement callback\\n    /// @dev Distribution of keeper incentive is consolidated in the oracle's factory\\n    /// @param market The market to settle\\n    /// @param version The version to settle\\n    /// @param maxCount The maximum number of settlement callbacks to perform before exiting\\n    function settle(IMarket market, uint256 version, uint256 maxCount) external onlyFactory {\\n        EnumerableSet.AddressSet storage callbacks = _localCallbacks[version][market];\\n\\n        if (_global.latestVersion < version) revert KeeperOracleVersionOutsideRangeError();\\n        if (maxCount == 0) revert KeeperOracleInvalidCallbackError();\\n        if (callbacks.length() == 0) revert KeeperOracleInvalidCallbackError();\\n\\n        for (uint256 i; i < maxCount && callbacks.length() > 0; i++) {\\n            address account = callbacks.at(0);\\n            _settle(market, account);\\n            callbacks.remove(account);\\n            emit CallbackFulfilled(SettlementCallback(market, account, version));\\n        }\\n    }\\n\\n    /// @notice Commits the price to a requested version\\n    /// @dev This commit function will pay out a keeper reward if the committed version is valid\\n    /// @param version The oracle version to commit\\n    /// @return Whether the commit was requested\\n    function _commitRequested(OracleVersion memory version) private returns (bool) {\\n        if (block.timestamp <= (next() + timeout)) {\\n            if (!version.valid) revert KeeperOracleInvalidPriceError();\\n            _prices[version.timestamp] = version.price;\\n        }\\n        _global.latestIndex++;\\n        return true;\\n    }\\n\\n    /// @notice Commits the price to a non-requested version\\n    /// @param version The oracle version to commit\\n    /// @return Whether the commit was requested\\n    function _commitUnrequested(OracleVersion memory version) private returns (bool) {\\n        if (!version.valid) revert KeeperOracleInvalidPriceError();\\n        if (version.timestamp <= _global.latestVersion || (next() != 0 && version.timestamp >= next()))\\n            revert KeeperOracleVersionOutsideRangeError();\\n        _prices[version.timestamp] = version.price;\\n        return false;\\n    }\\n\\n    /// @notice Performs a settlement callback for the account on the market\\n    /// @param market The market to settle\\n    /// @param account The account to settle\\n    function _settle(IMarket market, address account) private {\\n        market.update(account, UFixed6Lib.MAX, UFixed6Lib.MAX, UFixed6Lib.MAX, Fixed6Lib.ZERO, false);\\n    }\\n\\n    /// @dev Only allow authorized callers\\n    modifier onlyAuthorized {\\n        if (!IOracleProviderFactory(address(factory())).authorized(msg.sender)) revert OracleProviderUnauthorizedError();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0xa4cc621f87cd6582a0842989f485ca7fd754b1e7b71a6fac4adb717f378a5f54\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/interfaces/IMarket.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/attribute/interfaces/IInstance.sol\\\";\\nimport \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport \\\"@equilibria/root/token/types/Token18.sol\\\";\\nimport \\\"./IOracleProvider.sol\\\";\\nimport \\\"./IPayoffProvider.sol\\\";\\nimport \\\"../types/OracleVersion.sol\\\";\\nimport \\\"../types/MarketParameter.sol\\\";\\nimport \\\"../types/RiskParameter.sol\\\";\\nimport \\\"../types/Version.sol\\\";\\nimport \\\"../types/Local.sol\\\";\\nimport \\\"../types/Global.sol\\\";\\nimport \\\"../types/Position.sol\\\";\\n\\ninterface IMarket is IInstance {\\n    struct MarketDefinition {\\n        Token18 token;\\n        IOracleProvider oracle;\\n        IPayoffProvider payoff;\\n    }\\n\\n    struct Context {\\n        ProtocolParameter protocolParameter;\\n        MarketParameter marketParameter;\\n        RiskParameter riskParameter;\\n        uint256 currentTimestamp;\\n        OracleVersion latestVersion;\\n        OracleVersion positionVersion;\\n        Global global;\\n        Local local;\\n        PositionContext currentPosition;\\n        PositionContext latestPosition;\\n        UFixed6 previousPendingMagnitude;\\n        Fixed6 pendingCollateral;\\n        UFixed6 pendingOpen;\\n        UFixed6 pendingClose;\\n    }\\n\\n    struct PositionContext {\\n        Position global;\\n        Position local;\\n    }\\n\\n    event Updated(address indexed sender, address indexed account, uint256 version, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect);\\n    event OrderCreated(address indexed account, uint256 version, Order order, Fixed6 collateral);\\n    event PositionProcessed(uint256 indexed fromOracleVersion, uint256 indexed toOracleVersion, uint256 fromPosition, uint256 toPosition, VersionAccumulationResult accumulationResult);\\n    event AccountPositionProcessed(address indexed account, uint256 indexed fromOracleVersion, uint256 indexed toOracleVersion, uint256 fromPosition, uint256 toPosition, LocalAccumulationResult accumulationResult);\\n    event BeneficiaryUpdated(address newBeneficiary);\\n    event CoordinatorUpdated(address newCoordinator);\\n    event FeeClaimed(address indexed account, UFixed6 amount);\\n    event RewardClaimed(address indexed account, UFixed6 amount);\\n    event ParameterUpdated(MarketParameter newParameter);\\n    event RiskParameterUpdated(RiskParameter newRiskParameter);\\n\\n    // sig: 0x0fe90964\\n    error MarketInsufficientLiquidityError();\\n    // sig: 0x00e2b6a8\\n    error MarketInsufficientMarginError();\\n    // sig: 0x442145e5\\n    error MarketInsufficientCollateralError();\\n    // sig: 0xba555da7\\n    error MarketProtectedError();\\n    // sig: 0x6ed43d8e\\n    error MarketMakerOverLimitError();\\n    // sig: 0x29ab4c44\\n    error MarketClosedError();\\n    // sig: 0x07732aee\\n    error MarketCollateralBelowLimitError();\\n    // sig: 0x5bdace60\\n    error MarketOperatorNotAllowedError();\\n    // sig: 0x8a68c1dc\\n    error MarketNotSingleSidedError();\\n    // sig: 0x736f9fda\\n    error MarketOverCloseError();\\n    // sig: 0x935bdc21\\n    error MarketExceedsPendingIdLimitError();\\n    // sig: 0x9bca0625\\n    error MarketNotCoordinatorError();\\n    // sig: 0xb602d086\\n    error MarketNotBeneficiaryError();\\n    // sig: 0x534f7fe6\\n    error MarketInvalidProtectionError();\\n    // sig: 0xab1e3a00\\n    error MarketStalePriceError();\\n    // sig: 0x15f9ae70\\n    error MarketEfficiencyUnderLimitError();\\n    // sig: 0x7302d51a\\n    error MarketInvalidMarketParameterError(uint256 code);\\n    // sig: 0xc5f0e98a\\n    error MarketInvalidRiskParameterError(uint256 code);\\n\\n    // sig: 0x2142bc27\\n    error GlobalStorageInvalidError();\\n    // sig: 0xc83d08ec\\n    error LocalStorageInvalidError();\\n    // sig: 0x7c53e926\\n    error MarketParameterStorageInvalidError();\\n    // sig: 0x98eb4898\\n    error PositionStorageLocalInvalidError();\\n    // sig: 0x7ecd083f\\n    error RiskParameterStorageInvalidError();\\n    // sig: 0xd2777e72\\n    error VersionStorageInvalidError();\\n\\n    function initialize(MarketDefinition calldata definition_) external;\\n    function token() external view returns (Token18);\\n    function oracle() external view returns (IOracleProvider);\\n    function payoff() external view returns (IPayoffProvider);\\n    function positions(address account) external view returns (Position memory);\\n    function pendingPositions(address account, uint256 id) external view returns (Position memory);\\n    function locals(address account) external view returns (Local memory);\\n    function versions(uint256 timestamp) external view returns (Version memory);\\n    function pendingPosition(uint256 id) external view returns (Position memory);\\n    function position() external view returns (Position memory);\\n    function global() external view returns (Global memory);\\n    function update(address account, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect) external;\\n    function parameter() external view returns (MarketParameter memory);\\n    function riskParameter() external view returns (RiskParameter memory);\\n    function updateParameter(address newBeneficiary, address newCoordinator, MarketParameter memory newParameter) external;\\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external;\\n    function claimFee() external;\\n}\\n\",\"keccak256\":\"0xba14f38deb119c92d738f0690f9190e1548270629e2b381e09c348d83f6fb1c2\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/interfaces/IOracleProvider.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../types/OracleVersion.sol\\\";\\nimport \\\"./IMarket.sol\\\";\\n\\n/// @dev OracleVersion Invariants\\n///       - Each newly requested version must be increasing, but does not need to incrementing\\n///         - We recommend using something like timestamps or blocks for versions so that intermediary non-requested\\n///           versions may be posted for the purpose of expedient liquidations\\n///       - Versions are allowed to \\\"fail\\\" and will be marked as .valid = false\\n///       - Versions must be committed in order, i.e. all requested versions prior to latestVersion must be available\\n///       - Non-requested versions may be committed, but will not receive a keeper reward\\n///         - This is useful for immediately liquidating an account with a valid off-chain price in between orders\\n///         - Satisfying the above constraints, only versions more recent than the latest version may be committed\\n///       - Current must always be greater than Latest, never equal\\n///       - Request must register the same current version that was returned by Current within the same transaction\\ninterface IOracleProvider {\\n    // sig: 0x652fafab\\n    error OracleProviderUnauthorizedError();\\n\\n    event OracleProviderVersionRequested(uint256 indexed version);\\n    event OracleProviderVersionFulfilled(OracleVersion version);\\n\\n    function request(IMarket market, address account) external;\\n    function status() external view returns (OracleVersion memory, uint256);\\n    function latest() external view returns (OracleVersion memory);\\n    function current() external view returns (uint256);\\n    function at(uint256 timestamp) external view returns (OracleVersion memory);\\n}\",\"keccak256\":\"0xfb6785a885afe6c3cfbfb556b9a5ac29b6056671029094e2959bdf704e1a85c6\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/interfaces/IOracleProviderFactory.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../types/OracleVersion.sol\\\";\\nimport \\\"./IOracleProvider.sol\\\";\\n\\ninterface IOracleProviderFactory {\\n    event OracleCreated(IOracleProvider indexed oracle, bytes32 indexed id);\\n\\n    function oracles(bytes32 id) external view returns (IOracleProvider);\\n    function authorized(address caller) external view returns (bool);\\n}\",\"keccak256\":\"0x98da1ba35dc599bd3f98a02fc411976176538fd53e9c675c6b833b43c0047434\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/interfaces/IPayoffProvider.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\n\\ninterface IPayoffProvider {\\n    function payoff(Fixed6 price) external pure returns (Fixed6 payoff);\\n}\\n\",\"keccak256\":\"0xda57bdec535b0768c7c25889f5c1d7fbce94acc41ca836b821e5ea9f686f8898\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Global.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/pid/types/PAccumulator6.sol\\\";\\nimport \\\"./ProtocolParameter.sol\\\";\\nimport \\\"./MarketParameter.sol\\\";\\n\\n/// @dev Global type\\nstruct Global {\\n    /// @dev The current position ID\\n    uint256 currentId;\\n\\n    /// @dev The latest position id\\n    uint256 latestId;\\n\\n    /// @dev The accrued protocol fee\\n    UFixed6 protocolFee;\\n\\n    /// @dev The accrued oracle fee\\n    UFixed6 oracleFee;\\n\\n    /// @dev The accrued risk fee\\n    UFixed6 riskFee;\\n\\n    /// @dev The accrued donation\\n    UFixed6 donation;\\n\\n    /// @dev The current PAccumulator state\\n    PAccumulator6 pAccumulator;\\n\\n    /// @dev The latest valid price\\n    Fixed6 latestPrice;\\n}\\nusing GlobalLib for Global global;\\nstruct GlobalStorage { uint256 slot0; uint256 slot1; }\\nusing GlobalStorageLib for GlobalStorage global;\\n\\n/// @title Global\\n/// @notice Holds the global market state\\nlibrary GlobalLib {\\n    /// @notice Increments the fees by `amount` using current parameters\\n    /// @param self The Global object to update\\n    /// @param amount The amount to increment fees by\\n    /// @param keeper The amount to increment the keeper fee by\\n    /// @param marketParameter The current market parameters\\n    /// @param protocolParameter The current protocol parameters\\n    function incrementFees(\\n        Global memory self,\\n        UFixed6 amount,\\n        UFixed6 keeper,\\n        MarketParameter memory marketParameter,\\n        ProtocolParameter memory protocolParameter\\n    ) internal pure {\\n        UFixed6 protocolFeeAmount = amount.mul(protocolParameter.protocolFee);\\n        UFixed6 marketFeeAmount = amount.sub(protocolFeeAmount);\\n\\n        UFixed6 oracleFeeAmount = marketFeeAmount.mul(marketParameter.oracleFee);\\n        UFixed6 riskFeeAmount = marketFeeAmount.mul(marketParameter.riskFee);\\n        UFixed6 donationAmount = marketFeeAmount.sub(oracleFeeAmount).sub(riskFeeAmount);\\n\\n        self.protocolFee = self.protocolFee.add(protocolFeeAmount);\\n        self.oracleFee = self.oracleFee.add(keeper).add(oracleFeeAmount);\\n        self.riskFee = self.riskFee.add(riskFeeAmount);\\n        self.donation = self.donation.add(donationAmount);\\n    }\\n\\n    /// @notice Updates the latest valid price\\n    /// @param self The Global object to update\\n    /// @param latestPrice The new latest valid price\\n    function update(Global memory self, uint256 latestId, Fixed6 latestPrice) internal pure {\\n        self.latestId = latestId;\\n        self.latestPrice = latestPrice;\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the Global struct into storage.\\n///\\n///     struct StoredGlobal {\\n///         /* slot 0 */\\n///         uint32 currentId;           // <= 4.29b\\n///         uint32 latestId;            // <= 4.29b\\n///         uint48 protocolFee;         // <= 281m\\n///         uint48 oracleFee;           // <= 281m\\n///         uint48 riskFee;             // <= 281m\\n///         uint48 donation;            // <= 281m\\n///\\n///         /* slot 1 */\\n///         int32 pAccumulator.value;   // <= 214000%\\n///         int24 pAccumulator.skew;    // <= 838%\\n///         int64 latestPrice;          // <= 9.22t\\n///     }\\n///\\nlibrary GlobalStorageLib {\\n    // sig: 0x2142bc27\\n    error GlobalStorageInvalidError();\\n\\n    function read(GlobalStorage storage self) internal view returns (Global memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n        return Global(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48 - 48 - 48)) >> (256 - 48)),\\n            PAccumulator6(\\n                Fixed6.wrap(int256(slot1 << (256 - 32)) >> (256 - 32)),\\n                Fixed6.wrap(int256(slot1 << (256 - 32 - 24)) >> (256 - 24))\\n            ),\\n            Fixed6.wrap(int256(slot1 << (256 - 32 - 24 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(GlobalStorage storage self, Global memory newValue) internal {\\n        if (newValue.currentId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\\n        if (newValue.latestId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\\n        if (newValue.protocolFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\\n        if (newValue.oracleFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\\n        if (newValue.riskFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\\n        if (newValue.donation.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._value.gt(Fixed6.wrap(type(int32).max))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._value.lt(Fixed6.wrap(type(int32).min))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._skew.gt(Fixed6.wrap(type(int24).max))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._skew.lt(Fixed6.wrap(type(int24).min))) revert GlobalStorageInvalidError();\\n        if (newValue.latestPrice.gt(Fixed6.wrap(type(int64).max))) revert GlobalStorageInvalidError();\\n        if (newValue.latestPrice.lt(Fixed6.wrap(type(int64).min))) revert GlobalStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\\n            uint256(UFixed6.unwrap(newValue.protocolFee) << (256 - 48)) >> (256 - 32 - 32 - 48) |\\n            uint256(UFixed6.unwrap(newValue.oracleFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48) |\\n            uint256(UFixed6.unwrap(newValue.riskFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48 - 48) |\\n            uint256(UFixed6.unwrap(newValue.donation) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48 - 48 - 48);\\n\\n        uint256 encoded1 =\\n            uint256(Fixed6.unwrap(newValue.pAccumulator._value) << (256 - 32)) >> (256 - 32) |\\n            uint256(Fixed6.unwrap(newValue.pAccumulator._skew) << (256 - 24)) >> (256 - 32 - 24) |\\n            uint256(Fixed6.unwrap(newValue.latestPrice) << (256 - 64)) >> (256 - 32 - 24 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x735116c4792736c01e01dab1e0f27498affc6327fc3da2723b5c7c2bff29bf56\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Invalidation.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport \\\"./Position.sol\\\";\\n\\n/// @dev Invalidation type\\nstruct Invalidation {\\n    /// @dev The change in the maker position\\n    Fixed6 maker;\\n\\n    /// @dev The change in the long position\\n    Fixed6 long;\\n\\n    /// @dev The change in the short position\\n    Fixed6 short;\\n}\\nusing InvalidationLib for Invalidation global;\\n\\n/// @title Invalidation\\n/// @notice Holds the state for an account's update invalidation\\nlibrary InvalidationLib {\\n    /// @notice Increments the invalidation accumulator by an invalidation delta\\n    /// @param self The invalidation object to update\\n    /// @param latestPosition The latest position\\n    /// @param newPosition The pending position\\n    function increment(Invalidation memory self, Position memory latestPosition, Position memory newPosition) internal pure {\\n        self.maker = self.maker.add(Fixed6Lib.from(latestPosition.maker).sub(Fixed6Lib.from(newPosition.maker)));\\n        self.long = self.long.add(Fixed6Lib.from(latestPosition.long).sub(Fixed6Lib.from(newPosition.long)));\\n        self.short = self.short.add(Fixed6Lib.from(latestPosition.short).sub(Fixed6Lib.from(newPosition.short)));\\n    }\\n\\n    /// @notice Returns the invalidation delta between two invalidation accumulators\\n    /// @param self The starting invalidation object\\n    /// @param invalidation The ending invalidation object\\n    /// @return delta The invalidation delta\\n    function sub(\\n        Invalidation memory self,\\n        Invalidation memory invalidation\\n    ) internal pure returns (Invalidation memory delta) {\\n        delta.maker = self.maker.sub(invalidation.maker);\\n        delta.long = self.long.sub(invalidation.long);\\n        delta.short = self.short.sub(invalidation.short);\\n    }\\n\\n    /// @notice Replaces the invalidation with a new invalidation\\n    /// @param self The invalidation object to update\\n    /// @param newInvalidation The new invalidation object\\n    function update(Invalidation memory self, Invalidation memory newInvalidation) internal pure {\\n        (self.maker, self.long, self.short) = (newInvalidation.maker, newInvalidation.long, newInvalidation.short);\\n    }\\n}\\n\",\"keccak256\":\"0xc8e6bba84e66e0ff1e5566e2d86570591ea1829ae2ac88d857cabc536a89a67e\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Local.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport \\\"./Version.sol\\\";\\nimport \\\"./Position.sol\\\";\\nimport \\\"./Order.sol\\\";\\nimport \\\"./RiskParameter.sol\\\";\\nimport \\\"./OracleVersion.sol\\\";\\n\\n/// @dev Local type\\nstruct Local {\\n    /// @dev The current position id\\n    uint256 currentId;\\n\\n    /// @dev The latest position id\\n    uint256 latestId;\\n\\n    /// @dev The collateral balance\\n    Fixed6 collateral;\\n\\n    /// @dev The reward balance\\n    UFixed6 reward;\\n\\n    /// @dev The timestamp of the latest protection\\n    uint256 protection;\\n\\n    /// @dev The initiator of the latest protection\\n    address protectionInitiator;\\n\\n    /// @dev The amount of the latest protection fee\\n    UFixed6 protectionAmount;\\n}\\nusing LocalLib for Local global;\\nstruct LocalStorage { uint256 slot0; uint256 slot1; }\\nusing LocalStorageLib for LocalStorage global;\\n\\nstruct LocalAccumulationResult {\\n    Fixed6 collateralAmount;\\n    UFixed6 rewardAmount;\\n    Fixed6 positionFee;\\n    UFixed6 keeper;\\n}\\n\\n/// @title Local\\n/// @notice Holds the local account state\\nlibrary LocalLib {\\n    /// @notice Updates the collateral with the new collateral change\\n    /// @param self The Local object to update\\n    /// @param collateral The amount to update the collateral by\\n    function update(Local memory self, Fixed6 collateral) internal pure {\\n        self.collateral = self.collateral.add(collateral);\\n    }\\n\\n    /// @notice Settled the local from its latest position to next position\\n    /// @param self The Local object to update\\n    /// @param fromPosition The previous latest position\\n    /// @param toPosition The next latest position\\n    /// @param fromVersion The previous latest version\\n    /// @param toVersion The next latest version\\n    /// @return values The accumulation result\\n    function accumulate(\\n        Local memory self,\\n        uint256 latestId,\\n        Position memory fromPosition,\\n        Position memory toPosition,\\n        Version memory fromVersion,\\n        Version memory toVersion\\n    ) internal pure returns (LocalAccumulationResult memory values) {\\n        values.collateralAmount = toVersion.makerValue.accumulated(fromVersion.makerValue, fromPosition.maker)\\n            .add(toVersion.longValue.accumulated(fromVersion.longValue, fromPosition.long))\\n            .add(toVersion.shortValue.accumulated(fromVersion.shortValue, fromPosition.short));\\n        values.rewardAmount = toVersion.makerReward.accumulated(fromVersion.makerReward, fromPosition.maker)\\n            .add(toVersion.longReward.accumulated(fromVersion.longReward, fromPosition.long))\\n            .add(toVersion.shortReward.accumulated(fromVersion.shortReward, fromPosition.short));\\n        values.positionFee = toPosition.fee;\\n        values.keeper = toPosition.keeper;\\n\\n        Fixed6 feeAmount = values.positionFee.add(Fixed6Lib.from(values.keeper));\\n        self.collateral = self.collateral.add(values.collateralAmount).sub(feeAmount);\\n        self.reward = self.reward.add(values.rewardAmount);\\n        self.latestId = latestId;\\n    }\\n\\n    /// @notice Updates the Local to put it into a protected state for liquidation\\n    /// @param self The Local object to update\\n    /// @param latestVersion The latest oracle version\\n    /// @param currentTimestamp The current timestamp\\n    /// @param tryProtect Whether to try to protect the Local\\n    /// @return Whether the protection was protected\\n    function protect(\\n        Local memory self,\\n        RiskParameter memory riskParameter,\\n        OracleVersion memory latestVersion,\\n        uint256 currentTimestamp,\\n        Order memory newOrder,\\n        address initiator,\\n        bool tryProtect\\n    ) internal pure returns (bool) {\\n        if (!tryProtect || self.protection > latestVersion.timestamp) return false;\\n        (self.protection, self.protectionAmount, self.protectionInitiator) =\\n            (currentTimestamp, newOrder.liquidationFee(latestVersion, riskParameter), initiator);\\n        return true;\\n    }\\n\\n    /// @notice Clears the local's reward value\\n    /// @param self The Local object to update\\n    function clearReward(Local memory self) internal pure {\\n        self.reward = UFixed6Lib.ZERO;\\n    }\\n\\n    /// @notice Processes the account's protection if it is valid\\n    /// @param self The Local object to update\\n    /// @param latestPosition The latest account position\\n    /// @param version The latest version\\n    /// @return\\n    function processProtection(\\n        Local memory self,\\n        Position memory latestPosition,\\n        Version memory version\\n    ) internal pure returns (bool) {\\n        if (!version.valid || latestPosition.timestamp != self.protection) return false;\\n        self.collateral = self.collateral.sub(Fixed6Lib.from(self.protectionAmount));\\n        return true;\\n    }\\n\\n    /// @notice Processes the initiator's liquidation fee\\n    /// @param self The Local object to update\\n    /// @param initiateeLocal The Local object to process\\n    function processLiquidationFee(Local memory self, Local memory initiateeLocal) internal pure {\\n        self.collateral = self.collateral.add(Fixed6Lib.from(initiateeLocal.protectionAmount));\\n    }\\n\\n    /// @notice Returns the pending amount of liquidation fee\\n    /// @dev May or may not realize depending on whether the liquidation version is valid\\n    /// @param self The Local object\\n    /// @param latestPosition The latest position\\n    /// @return The pending liquidation fee\\n    function pendingLiquidationFee(\\n        Local memory self,\\n        Position memory latestPosition\\n    ) internal pure returns (UFixed6) {\\n        return self.protection > latestPosition.timestamp ? self.protectionAmount : UFixed6Lib.ZERO;\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the Local struct into storage.\\n///\\n///     struct StoredLocal {\\n///         /* slot 0 */\\n///         uint32 currentId;   // <= 4.29b\\n///         uint32 latestId;    // <= 4.29b\\n///         int64 collateral;   // <= 9.22t\\n///         uint64 reward;      // <= 18.44t\\n///         uint32 protection;  // <= 4.29b\\n///\\n///         /* slot 1 */\\n///         address protectionInitiator;    \\n///         uint64 protectionAmount;        // <= 18.44t\\n///     }\\n///\\nlibrary LocalStorageLib {\\n    // sig: 0xc83d08ec\\n    error LocalStorageInvalidError();\\n\\n    function read(LocalStorage storage self) internal view returns (Local memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n        return Local(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64)),\\n            (uint256(slot0) << (256 - 32 - 32 - 64 - 64 - 32)) >> (256 - 32),\\n            address(uint160(uint256(slot1 << (256 - 160)) >> (256 - 160))),\\n            UFixed6.wrap(uint256(slot1 << (256 - 160 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(LocalStorage storage self, Local memory newValue) internal {\\n        if (newValue.currentId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\\n        if (newValue.latestId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert LocalStorageInvalidError();\\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert LocalStorageInvalidError();\\n        if (newValue.reward.gt(UFixed6.wrap(type(uint64).max))) revert LocalStorageInvalidError();\\n        if (newValue.protection > uint256(type(uint32).max)) revert LocalStorageInvalidError();\\n        if (newValue.protectionAmount.gt(UFixed6.wrap(type(uint64).max))) revert LocalStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\\n            uint256(UFixed6.unwrap(newValue.reward) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64) |\\n            uint256(newValue.protection << (256 - 32)) >> (256 - 32 - 32 - 64 - 64 - 32);\\n        uint256 encoded1 =\\n            uint256(uint256(uint160(newValue.protectionInitiator)) << (256 - 160)) >> (256 - 160) |\\n            uint256(UFixed6.unwrap(newValue.protectionAmount) << (256 - 64)) >> (256 - 160 - 64);\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n        }\\n    }\\n}\",\"keccak256\":\"0xeddf6e1e74868024a5bbcad59fd942721487e5e5b897bdace5ccf1d0eb37e275\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/MarketParameter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/token/types/Token18.sol\\\";\\nimport \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport \\\"@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol\\\";\\nimport \\\"@equilibria/root/pid/types/PController6.sol\\\";\\nimport \\\"../interfaces/IOracleProvider.sol\\\";\\nimport \\\"../interfaces/IPayoffProvider.sol\\\";\\nimport \\\"./ProtocolParameter.sol\\\";\\n\\n/// @dev MarketParameter type\\nstruct MarketParameter {\\n    /// @dev The fee that is taken out of funding\\n    UFixed6 fundingFee;\\n\\n    /// @dev The fee that is taken out of interest\\n    UFixed6 interestFee;\\n\\n    /// @dev The fee that is taken out of maker and taker fees\\n    UFixed6 positionFee;\\n\\n    /// @dev The share of the collected fees that is paid to the oracle\\n    UFixed6 oracleFee;\\n\\n    /// @dev The share of the collected fees that is paid to the risk coordinator\\n    UFixed6 riskFee;\\n\\n    /// @dev The maximum amount of orders that can be pending at one time globally\\n    uint256 maxPendingGlobal;\\n\\n    /// @dev The maximum amount of orders that can be pending at one time per account\\n    uint256 maxPendingLocal;\\n\\n    /// @dev The rate at which the makers receives rewards (share / sec)\\n    UFixed6 makerRewardRate;\\n\\n    /// @dev The rate at which the longs receives rewards (share / sec)\\n    UFixed6 longRewardRate;\\n\\n    /// @dev The rate at which the shorts receives rewards (share / sec)\\n    UFixed6 shortRewardRate;\\n\\n    /// @dev The fixed fee that is charge whenever an oracle request occurs\\n    UFixed6 settlementFee;\\n\\n    /// @dev Whether longs and shorts can always close even when they'd put the market into socialization\\n    bool takerCloseAlways;\\n\\n    /// @dev Whether makers can always close even when they'd put the market into socialization\\n    bool makerCloseAlways;\\n\\n    /// @dev Whether the market is in close-only mode\\n    bool closed;\\n}\\nstruct MarketParameterStorage { uint256 slot0; uint256 slot1; }\\nusing MarketParameterStorageLib for MarketParameterStorage global;\\n\\n/// @dev Manually encodes and decodes the MarketParameter struct into storage.\\n///\\n///    struct StoredMarketParameter {\\n///        /* slot 0 */\\n///        uint24 fundingFee;          // <= 1677%\\n///        uint24 interestFee;         // <= 1677%\\n///        uint24 positionFee;         // <= 1677%\\n///        uint24 oracleFee;           // <= 1677%\\n///        uint24 riskFee;             // <= 1677%\\n///        uint16 maxPendingGlobal;    // <= 65k\\n///        uint16 maxPendingLocal;     // <= 65k\\n///        uint48 settlementFee;       // <= 281m\\n///        uint8 flags;\\n///\\n///        /* slot 1 */\\n///        uint40 makerRewardRate;     // <= 281m / s\\n///        uint40 longRewardRate;      // <= 281m / s\\n///        uint40 shortRewardRate;     // <= 281m / s\\n///    }\\n///\\nlibrary MarketParameterStorageLib {\\n    // sig: 0x7c53e926\\n    error MarketParameterStorageInvalidError();\\n\\n    function read(MarketParameterStorage storage self) external view returns (MarketParameter memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n\\n        uint256 flags = uint256(slot0) >> (256 - 8);\\n        (bool takerCloseAlways, bool makerCloseAlways, bool closed) =\\n            (flags & 0x01 == 0x01, flags & 0x02 == 0x02, flags & 0x04 == 0x04);\\n\\n        return MarketParameter(\\n            UFixed6.wrap(uint256(slot0 << (256 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n            uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16)) >> (256 - 16),\\n            uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16)) >> (256 - 16),\\n            UFixed6.wrap(uint256(slot1 << (256 - 40)) >> (256 - 40)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 40 - 40)) >> (256 - 40)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 40 - 40 - 40)) >> (256 - 40)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 48)) >> (256 - 48)),\\n            takerCloseAlways,\\n            makerCloseAlways,\\n            closed\\n        );\\n    }\\n\\n    function validate(\\n        MarketParameter memory self,\\n        ProtocolParameter memory protocolParameter,\\n        Token18 reward\\n    ) public pure {\\n        if (self.settlementFee.gt(protocolParameter.maxFeeAbsolute)) revert MarketParameterStorageInvalidError();\\n\\n        if (self.fundingFee.max(self.interestFee).max(self.positionFee).gt(protocolParameter.maxCut))\\n            revert MarketParameterStorageInvalidError();\\n\\n        if (self.oracleFee.add(self.riskFee).gt(UFixed6Lib.ONE)) revert MarketParameterStorageInvalidError();\\n\\n        if (\\n            reward.isZero() &&\\n            (!self.makerRewardRate.isZero() || !self.longRewardRate.isZero() || !self.shortRewardRate.isZero())\\n        ) revert MarketParameterStorageInvalidError();\\n    }\\n\\n    function validateAndStore(\\n        MarketParameterStorage storage self,\\n        MarketParameter memory newValue,\\n        ProtocolParameter memory protocolParameter,\\n        Token18 reward\\n    ) external {\\n        validate(newValue, protocolParameter, reward);\\n\\n        if (newValue.maxPendingGlobal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\\n        if (newValue.maxPendingLocal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\\n        if (newValue.makerRewardRate.gt(UFixed6.wrap(type(uint40).max))) revert MarketParameterStorageInvalidError();\\n        if (newValue.longRewardRate.gt(UFixed6.wrap(type(uint40).max))) revert MarketParameterStorageInvalidError();\\n        if (newValue.shortRewardRate.gt(UFixed6.wrap(type(uint40).max))) revert MarketParameterStorageInvalidError();\\n\\n        _store(self, newValue);\\n    }\\n\\n    function _store(MarketParameterStorage storage self, MarketParameter memory newValue) internal {\\n        uint256 flags = (newValue.takerCloseAlways ? 0x01 : 0x00) |\\n            (newValue.makerCloseAlways ? 0x02 : 0x00) |\\n            (newValue.closed ? 0x04 : 0x00);\\n\\n        uint256 encoded0 =\\n            uint256(UFixed6.unwrap(newValue.fundingFee) << (256 - 24)) >> (256 - 24) |\\n            uint256(UFixed6.unwrap(newValue.interestFee) << (256 - 24)) >> (256 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.positionFee) << (256 - 24)) >> (256 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.oracleFee) << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.riskFee) << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(newValue.maxPendingGlobal << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16) |\\n            uint256(newValue.maxPendingLocal << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16) |\\n            uint256(UFixed6.unwrap(newValue.settlementFee) << (256 - 48)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 48) |\\n            uint256(flags << (256 - 8)) >> (256 - 24 - 24 - 24 - 24 - 24 - 32 - 32 - 32 - 32 - 8);\\n        uint256 encoded1 =\\n            uint256(UFixed6.unwrap(newValue.makerRewardRate) << (256 - 40)) >> (256 - 40) |\\n            uint256(UFixed6.unwrap(newValue.longRewardRate) << (256 - 40)) >> (256 - 40 - 40) |\\n            uint256(UFixed6.unwrap(newValue.shortRewardRate) << (256 - 40)) >> (256 - 40 - 40 - 40);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n        }\\n    }\\n}\",\"keccak256\":\"0xce5c3dc4f7cc40c315fb5173b64fd6752763fe798379e887050eb5d70a2ef230\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/OracleVersion.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\n\\n/// @dev A singular oracle version with its corresponding data\\nstruct OracleVersion {\\n    /// @dev the timestamp of the oracle update\\n    uint256 timestamp;\\n\\n    /// @dev The oracle price of the corresponding version\\n    Fixed6 price;\\n\\n    /// @dev Whether the version is valid\\n    bool valid;\\n}\\n\",\"keccak256\":\"0x543d36affe7b862bf72fac9cfb40a639d2b3fe1b32d9181552d523bc64d9a0f7\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Order.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./OracleVersion.sol\\\";\\nimport \\\"./RiskParameter.sol\\\";\\nimport \\\"./MarketParameter.sol\\\";\\nimport \\\"./Position.sol\\\";\\n\\n/// @dev Order type\\nstruct Order {\\n    /// @dev The change in the maker position\\n    Fixed6 maker;\\n\\n    /// @dev The change in the long position\\n    Fixed6 long;\\n\\n    /// @dev The change in the short position\\n    Fixed6 short;\\n\\n    /// @dev The change in the net position\\n    Fixed6 net;\\n\\n    /// @dev The magnitude of the change in the skew\\n    UFixed6 skew;\\n\\n    /// @dev The change of the magnitude in the skew\\n    Fixed6 impact;\\n\\n    /// @dev The change in the utilization=\\n    Fixed6 utilization;\\n\\n    /// @dev The change in the efficiency\\n    Fixed6 efficiency;\\n\\n    /// @dev The fee for the order\\n    Fixed6 fee;\\n\\n    /// @dev The fixed settlement fee for the order\\n    UFixed6 keeper;\\n}\\nusing OrderLib for Order global;\\n\\n/// @title Order\\n/// @notice Holds the state for an account's update order\\nlibrary OrderLib {\\n    /// @notice Computes and sets the fee and keeper once an order is already created\\n    /// @param self The Order object to update\\n    /// @param latestVersion The latest oracle version\\n    /// @param marketParameter The market parameter\\n    /// @param riskParameter The risk parameter\\n    function registerFee(\\n        Order memory self,\\n        OracleVersion memory latestVersion,\\n        MarketParameter memory marketParameter,\\n        RiskParameter memory riskParameter\\n    ) internal pure {\\n        Fixed6 makerFee = Fixed6Lib.from(riskParameter.makerFee)\\n            .add(Fixed6Lib.from(riskParameter.makerImpactFee).mul(self.utilization))\\n            .max(Fixed6Lib.ZERO);\\n        Fixed6 takerFee = Fixed6Lib.from(riskParameter.takerFee)\\n            .add(Fixed6Lib.from(riskParameter.takerSkewFee.mul(self.skew)))\\n            .add(Fixed6Lib.from(riskParameter.takerImpactFee).mul(self.impact))\\n            .max(Fixed6Lib.ZERO);\\n        Fixed6 fee = Fixed6Lib.from(self.maker.abs().mul(latestVersion.price.abs())).mul(makerFee)\\n            .add(Fixed6Lib.from(self.long.abs().add(self.short.abs()).mul(latestVersion.price.abs())).mul(takerFee));\\n\\n        self.fee = marketParameter.closed ? Fixed6Lib.ZERO : fee;\\n        self.keeper = isEmpty(self) ? UFixed6Lib.ZERO : marketParameter.settlementFee;\\n    }\\n\\n    /// @notice Returns whether the order increases any of the account's positions\\n    /// @return Whether the order increases any of the account's positions\\n    function increasesPosition(Order memory self) internal pure returns (bool) {\\n        return increasesMaker(self) || increasesTaker(self);\\n    }\\n\\n    /// @notice Returns whether the order increases the account's long or short positions\\n    /// @return Whether the order increases the account's long or short positions\\n    function increasesTaker(Order memory self) internal pure returns (bool) {\\n        return self.long.gt(Fixed6Lib.ZERO) || self.short.gt(Fixed6Lib.ZERO);\\n    }\\n\\n    /// @notice Returns whether the order increases the account's maker position\\n    /// @return Whether the order increases the account's maker positions\\n    function increasesMaker(Order memory self) internal pure returns (bool) {\\n        return self.maker.gt(Fixed6Lib.ZERO);\\n    }\\n\\n    /// @notice Returns whether the order decreases the liquidity of the market\\n    /// @return Whether the order decreases the liquidity of the market\\n    function decreasesLiquidity(Order memory self) internal pure returns (bool) {\\n        return self.maker.lt(self.net);\\n    }\\n\\n    /// @notice Returns the whether the position is single-sided\\n    /// @param self The position object to check\\n    /// @param currentPosition The current position to check\\n    /// @return Whether the position is single-sided\\n    function singleSided(Order memory self, Position memory currentPosition) internal pure returns (bool) {\\n        return (self.maker.isZero() && self.long.isZero() && currentPosition.maker.isZero() && currentPosition.long.isZero()) ||\\n            (self.long.isZero() && self.short.isZero() && currentPosition.long.isZero() && currentPosition.short.isZero()) ||\\n            (self.short.isZero() && self.maker.isZero() && currentPosition.short.isZero() && currentPosition.maker.isZero());\\n    }\\n\\n    /// @notice Returns whether the order is applicable for liquidity checks\\n    /// @param self The Order object to check\\n    /// @param marketParameter The market parameter\\n    /// @return Whether the order is applicable for liquidity checks\\n    function liquidityCheckApplicable(\\n        Order memory self,\\n        MarketParameter memory marketParameter\\n    ) internal pure returns (bool) {\\n        return !marketParameter.closed &&\\n            ((self.maker.isZero()) || !marketParameter.makerCloseAlways || increasesMaker(self)) &&\\n            ((self.long.isZero() && self.short.isZero()) || !marketParameter.takerCloseAlways || increasesTaker(self));\\n    }\\n\\n    /// @notice Returns the liquidation fee of the position\\n    /// @dev Assumes the order must be single-sided\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @return The liquidation fee of the position\\n    function liquidationFee(\\n        Order memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (UFixed6) {\\n        if (isEmpty(self)) return UFixed6Lib.ZERO;\\n\\n        UFixed6 partialMaintenance = magnitude(self).abs()\\n            .mul(latestVersion.price.abs())\\n            .mul(riskParameter.maintenance)\\n            .max(riskParameter.minMaintenance);\\n\\n        return partialMaintenance.mul(riskParameter.liquidationFee)\\n            .min(riskParameter.maxLiquidationFee)\\n            .max(riskParameter.minLiquidationFee);\\n    }\\n\\n    /// @notice Returns whether the order has no position change\\n    /// @dev Assumes the order must be single-sided\\n    /// @param self The Order object to check\\n    /// @return Whether the order has no position change\\n    function isEmpty(Order memory self) internal pure returns (bool) {\\n        return magnitude(self).isZero();\\n    }\\n\\n    /// @notice Returns the amount of the non-zero side of the order\\n    /// @dev Assumes the order must be single-sided\\n    /// @param self The Order object to check\\n    /// @return The magnitude of the order\\n    function magnitude(Order memory self) internal pure returns (Fixed6) {\\n        return self.maker.add(self.long).add(self.short);\\n    }\\n}\\n\",\"keccak256\":\"0x35bcceaeeb382bc993ed45d55a044937a41a6567144b2d3b67de48b014febdb0\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Position.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./OracleVersion.sol\\\";\\nimport \\\"./RiskParameter.sol\\\";\\nimport \\\"./Order.sol\\\";\\nimport \\\"./Global.sol\\\";\\nimport \\\"./Local.sol\\\";\\nimport \\\"./Invalidation.sol\\\";\\n\\n/// @dev Order type\\nstruct Position {\\n    /// @dev The timestamp of the position\\n    uint256 timestamp;\\n\\n    /// @dev The maker position size\\n    UFixed6 maker;\\n\\n    /// @dev The long position size\\n    UFixed6 long;\\n\\n    /// @dev The short position size\\n    UFixed6 short;\\n\\n    /// @dev The fee for the position (only used for pending positions)\\n    Fixed6 fee;\\n\\n    /// @dev The fixed settlement fee for the position (only used for pending positions)\\n    UFixed6 keeper;\\n\\n    /// @dev The collateral at the time of the position settlement (only used for pending positions)\\n    Fixed6 collateral;\\n\\n    /// @dev The change in collateral during this position (only used for pending positions)\\n    Fixed6 delta;\\n\\n    /// @dev The value of the invalidation accumulator at the time of creation\\n    Invalidation invalidation;\\n}\\nusing PositionLib for Position global;\\nstruct PositionStorageGlobal { uint256 slot0; uint256 slot1; }\\nusing PositionStorageGlobalLib for PositionStorageGlobal global;\\nstruct PositionStorageLocal { uint256 slot0; uint256 slot1; }\\nusing PositionStorageLocalLib for PositionStorageLocal global;\\n\\n/// @title Position\\n/// @notice Holds the state for a position\\nlibrary PositionLib {\\n    /// @notice Returns whether the position is ready to be settled\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @return Whether the position is ready to be settled\\n    function ready(Position memory self, OracleVersion memory latestVersion) internal pure returns (bool) {\\n        return latestVersion.timestamp >= self.timestamp;\\n    }\\n\\n    /// @notice Replaces the position with the new latest position\\n    /// @param self The position object to update\\n    /// @param newPosition The new latest position\\n    function update(Position memory self, Position memory newPosition) internal pure {\\n        (self.timestamp, self.maker, self.long, self.short) = (\\n            newPosition.timestamp,\\n            newPosition.maker,\\n            newPosition.long,\\n            newPosition.short\\n        );\\n    }\\n\\n    /// @notice Updates the current local position with a new order\\n    /// @param self The position object to update\\n    /// @param currentTimestamp The current timestamp\\n    /// @param newMaker The new maker position\\n    /// @param newLong The new long position\\n    /// @param newShort The new short position\\n    /// @return newOrder The new order\\n    function update(\\n        Position memory self,\\n        uint256 currentTimestamp,\\n        UFixed6 newMaker,\\n        UFixed6 newLong,\\n        UFixed6 newShort\\n    ) internal pure returns (Order memory newOrder) {\\n        (newOrder.maker, newOrder.long, newOrder.short) = (\\n            Fixed6Lib.from(newMaker).sub(Fixed6Lib.from(self.maker)),\\n            Fixed6Lib.from(newLong).sub(Fixed6Lib.from(self.long)),\\n            Fixed6Lib.from(newShort).sub(Fixed6Lib.from(self.short))\\n        );\\n\\n        (self.timestamp, self.maker, self.long, self.short) =\\n            (currentTimestamp, newMaker, newLong, newShort);\\n    }\\n\\n    /// @notice Updates the current global position with a new order\\n    /// @param self The position object to update\\n    /// @param currentTimestamp The current timestamp\\n    /// @param order The new order\\n    /// @param riskParameter The current risk parameter\\n    function update(\\n        Position memory self,\\n        uint256 currentTimestamp,\\n        Order memory order,\\n        RiskParameter memory riskParameter\\n    ) internal pure {\\n        // load the computed attributes of the latest position\\n        Fixed6 latestStaticSkew = staticSkew(self, riskParameter);\\n        (order.net, order.efficiency, order.utilization) =\\n            (Fixed6Lib.from(net(self)), Fixed6Lib.from(efficiency(self)), Fixed6Lib.from(utilization(self)));\\n\\n        // update the position's attributes\\n        (self.timestamp, self.maker, self.long, self.short) = (\\n            currentTimestamp,\\n            UFixed6Lib.from(Fixed6Lib.from(self.maker).add(order.maker)),\\n            UFixed6Lib.from(Fixed6Lib.from(self.long).add(order.long)),\\n            UFixed6Lib.from(Fixed6Lib.from(self.short).add(order.short))\\n        );\\n\\n        Fixed6 currentStaticSkew = staticSkew(self, riskParameter);\\n        // update the order's delta attributes with the positions updated attributes\\n        (order.net, order.skew, order.impact, order.efficiency, order.utilization) = (\\n            Fixed6Lib.from(net(self)).sub(order.net),\\n            riskParameter.skewScale.isZero() ? UFixed6Lib.ZERO : order.magnitude().abs().div(riskParameter.skewScale),\\n            currentStaticSkew.eq(latestStaticSkew) ?\\n                Fixed6Lib.ZERO :\\n                latestStaticSkew.add(currentStaticSkew).div(\\n                    Fixed6Lib.from(2 * currentStaticSkew.sub(latestStaticSkew).sign())),\\n            Fixed6Lib.from(efficiency(self)).sub(order.efficiency),\\n            Fixed6Lib.from(utilization(self)).sub(order.utilization)\\n        );\\n    }\\n\\n    /// @notice prepares the position for the next id\\n    /// @param self The position object to update\\n    function prepare(Position memory self) internal pure {\\n        self.fee = Fixed6Lib.ZERO;\\n        self.keeper = UFixed6Lib.ZERO;\\n        self.collateral = Fixed6Lib.ZERO;\\n    }\\n\\n    /// @notice Updates the collateral delta of the position\\n    /// @param self The position object to update\\n    /// @param collateralAmount The amount of collateral change that occurred\\n    function update(Position memory self, Fixed6 collateralAmount) internal pure {\\n        self.delta = self.delta.add(collateralAmount);\\n    }\\n\\n    /// @notice Processes an invalidation of a position\\n    /// @dev Increments the invalidation accumulator by the new position's delta, and resets the fee\\n    /// @param self The position object to update\\n    /// @param newPosition The latest valid position\\n    function invalidate(Position memory self, Position memory newPosition) internal pure {\\n        self.invalidation.increment(self, newPosition);\\n        (newPosition.maker, newPosition.long, newPosition.short, newPosition.fee) =\\n            (self.maker, self.long, self.short, Fixed6Lib.ZERO);\\n    }\\n\\n    // @notice Adjusts the position if any invalidations have occurred\\n    function adjust(Position memory self, Position memory latestPosition) internal pure {\\n        Invalidation memory invalidation = latestPosition.invalidation.sub(self.invalidation);\\n        (self.maker, self.long, self.short) = (\\n            UFixed6Lib.from(Fixed6Lib.from(self.maker).add(invalidation.maker)),\\n            UFixed6Lib.from(Fixed6Lib.from(self.long).add(invalidation.long)),\\n            UFixed6Lib.from(Fixed6Lib.from(self.short).add(invalidation.short))\\n        );\\n    }\\n\\n    /// @notice Processes a sync of the position\\n    /// @dev Moves the timestamp forward to the latest version's timestamp, while resetting the fee and keeper\\n    /// @param self The position object to update\\n    /// @param latestVersion The latest oracle version\\n    function sync(Position memory self, OracleVersion memory latestVersion) internal pure {\\n        (self.timestamp, self.fee, self.keeper) = (latestVersion.timestamp, Fixed6Lib.ZERO, UFixed6Lib.ZERO);\\n    }\\n\\n    /// @notice Registers the fees from a new order\\n    /// @param self The position object to update\\n    /// @param order The new order\\n    function registerFee(Position memory self, Order memory order) internal pure {\\n        self.fee = self.fee.add(order.fee);\\n        self.keeper = self.keeper.add(order.keeper);\\n    }\\n\\n    /// @notice Returns the maximum position size\\n    /// @param self The position object to check\\n    /// @return The maximum position size\\n    function magnitude(Position memory self) internal pure returns (UFixed6) {\\n        return self.long.max(self.short).max(self.maker);\\n    }\\n\\n    /// @notice Returns the maximum taker position size\\n    /// @param self The position object to check\\n    /// @return The maximum taker position size\\n    function major(Position memory self) internal pure returns (UFixed6) {\\n        return self.long.max(self.short);\\n    }\\n\\n    /// @notice Returns the minimum maker position size\\n    /// @param self The position object to check\\n    /// @return The minimum maker position size\\n    function minor(Position memory self) internal pure returns (UFixed6) {\\n        return self.long.min(self.short);\\n    }\\n\\n    /// @notice Returns the difference between the long and short positions\\n    /// @param self The position object to check\\n    /// @return The difference between the long and short positions\\n    function net(Position memory self) internal pure returns (UFixed6) {\\n        return Fixed6Lib.from(self.long).sub(Fixed6Lib.from(self.short)).abs();\\n    }\\n\\n    /// @notice Returns the skew of the position\\n    /// @dev skew = (long - short) / max(long, short)\\n    /// @param self The position object to check\\n    /// @return The skew of the position\\n    function relativeSkew(Position memory self) internal pure returns (Fixed6) {\\n        return _skew(self, major(self));\\n    }\\n\\n    /// @notice Returns the static skew of the position taking into account the skew scale\\n    /// @dev static skew = (long - short) / skewScale\\n    /// @param self The position object to check\\n    /// @param riskParameter The current risk parameter\\n    /// @return The static skew of the position\\n    function staticSkew(Position memory self, RiskParameter memory riskParameter) internal pure returns (Fixed6) {\\n        return _skew(self, riskParameter.skewScale);\\n    }\\n\\n    /// @notice Returns the skew of the position taking into account position socialization\\n    /// @dev Used to calculate the portion of the position that is covered by the maker\\n    /// @param self The position object to check\\n    /// @return The socialized skew of the position\\n    function socializedSkew(Position memory self) internal pure returns (UFixed6) {\\n        return takerSocialized(self).isZero() ?\\n            UFixed6Lib.ZERO :\\n            takerSocialized(self).sub(minor(self)).div(takerSocialized(self));\\n    }\\n\\n    /// @notice Helper function to return the skew of the position given a denominator\\n    /// @param self The position object to check\\n    /// @param denominator The denominator of the skew calculation\\n    /// @return The skew of the position\\n    function _skew(Position memory self, UFixed6 denominator) internal pure returns (Fixed6) {\\n        return denominator.isZero() ?\\n            Fixed6Lib.ZERO :\\n            Fixed6Lib.from(self.long).sub(Fixed6Lib.from(self.short)).div(Fixed6Lib.from(denominator));\\n    }\\n\\n    /// @notice Returns the utilization of the position\\n    /// @dev utilization = major / (maker + minor)\\n    /// @param self The position object to check\\n    /// @return The utilization of the position\\n    function utilization(Position memory self) internal pure returns (UFixed6) {\\n        return major(self).unsafeDiv(self.maker.add(minor(self))).min(UFixed6Lib.ONE);\\n    }\\n\\n    /// @notice Returns the long position with socialization taken into account\\n    /// @param self The position object to check\\n    /// @return The long position with socialization taken into account\\n    function longSocialized(Position memory self) internal pure returns (UFixed6) {\\n        return self.maker.add(self.short).min(self.long);\\n    }\\n\\n    /// @notice Returns the short position with socialization taken into account\\n    /// @param self The position object to check\\n    /// @return The short position with socialization taken into account\\n    function shortSocialized(Position memory self) internal pure returns (UFixed6) {\\n        return self.maker.add(self.long).min(self.short);\\n    }\\n\\n    /// @notice Returns the major position with socialization taken into account\\n    /// @param self The position object to check\\n    /// @return The major position with socialization taken into account\\n    function takerSocialized(Position memory self) internal pure returns (UFixed6) {\\n        return major(self).min(minor(self).add(self.maker));\\n    }\\n\\n    /// @notice Returns the efficiency of the position\\n    /// @dev efficiency = maker / major\\n    /// @param self The position object to check\\n    /// @return The efficiency of the position\\n    function efficiency(Position memory self) internal pure returns (UFixed6) {\\n        return self.maker.unsafeDiv(major(self)).min(UFixed6Lib.ONE);\\n    }\\n\\n    /// @notice Returns the whether the position is socialized\\n    /// @param self The position object to check\\n    /// @return Whether the position is socialized\\n    function socialized(Position memory self) internal pure returns (bool) {\\n        return self.maker.add(self.short).lt(self.long) || self.maker.add(self.long).lt(self.short);\\n    }\\n\\n    /// @notice Returns the maintenance requirement of the position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @return The maintenance requirement of the position\\n    function maintenance(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (UFixed6) {\\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.maintenance, riskParameter.minMaintenance);\\n    }\\n\\n    /// @notice Returns the margin requirement of the position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @return The margin requirement of the position\\n    function margin(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (UFixed6) {\\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.margin, riskParameter.minMargin);\\n    }\\n\\n    /// @notice Returns the maintenance requirement of the position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @return The maintenance requirement of the position\\n    function maintenance(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (UFixed6) {\\n        return maintenance(magnitude(self), latestVersion, riskParameter);\\n    }\\n\\n    /// @notice Returns the margin requirement of the position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @return The margin requirement of the position\\n    function margin(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (UFixed6) {\\n        return margin(magnitude(self), latestVersion, riskParameter);\\n    }\\n\\n    /// @notice Returns the collateral requirement of the position magnitude\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param requirementRatio The ratio requirement to the notional\\n    /// @param requirementFixed The fixed requirement\\n    /// @return The collateral requirement of the position magnitude\\n    function _collateralRequirement(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        UFixed6 requirementRatio,\\n        UFixed6 requirementFixed\\n    ) private pure returns (UFixed6) {\\n        if (positionMagnitude.isZero()) return UFixed6Lib.ZERO;\\n        return positionMagnitude.mul(latestVersion.price.abs()).mul(requirementRatio).max(requirementFixed);\\n    }\\n\\n    /// @notice Returns the whether the position is maintained\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is maintained\\n    function maintained(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return collateral.max(Fixed6Lib.ZERO).gte(Fixed6Lib.from(maintenance(positionMagnitude, latestVersion, riskParameter)));\\n    }\\n\\n    /// @notice Returns the whether the position is margined\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is margined\\n    function margined(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return collateral.max(Fixed6Lib.ZERO).gte(Fixed6Lib.from(margin(positionMagnitude, latestVersion, riskParameter)));\\n    }\\n\\n    /// @notice Returns the whether the position is maintained\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is maintained\\n    function maintained(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return maintained(magnitude(self), latestVersion, riskParameter, collateral);\\n    }\\n\\n    /// @notice Returns the whether the position is margined\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is margined\\n    function margined(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return margined(magnitude(self), latestVersion, riskParameter, collateral);\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the global Position struct into storage.\\n///\\n///     struct StoredPositionGlobal {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         uint48 fee;\\n///         uint48 keeper;\\n///         uint64 long;\\n///         uint64 short;\\n///\\n///         /* slot 1 */\\n///         uint64 maker;\\n///         int64 invalidation.maker;\\n///         int64 invalidation.long;\\n///         int64 invalidation.short;\\n///     }\\n///\\nlibrary PositionStorageGlobalLib {\\n    function read(PositionStorageGlobal storage self) internal view returns (Position memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n        return Position(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 48 - 48 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 48 - 48 - 64 - 64)) >> (256 - 64)),\\n            Fixed6.wrap(int256(slot0   << (256 - 32 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 48 - 48)) >> (256 - 48)),\\n            Fixed6Lib.ZERO,\\n            Fixed6Lib.ZERO,\\n            Invalidation(\\n                Fixed6.wrap(int256(slot1 << (256 - 64 - 64)) >> (256 - 64)),\\n                Fixed6.wrap(int256(slot1 << (256 - 64 - 64 - 64)) >> (256 - 64)),\\n                Fixed6.wrap(int256(slot1 << (256 - 64 - 64 - 64 - 64)) >> (256 - 64))\\n            )\\n        );\\n    }\\n\\n    function store(PositionStorageGlobal storage self, Position memory newValue) internal {\\n        PositionStorageLib.validate(newValue);\\n\\n        if (newValue.maker.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\\n        if (newValue.long.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\\n        if (newValue.short.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\\n            uint256(Fixed6.unwrap(newValue.fee) << (256 - 48)) >> (256 - 32 - 48) |\\n            uint256(UFixed6.unwrap(newValue.keeper) << (256 - 48)) >> (256 - 32 - 48 - 48) |\\n            uint256(UFixed6.unwrap(newValue.long) << (256 - 64)) >> (256 - 32 - 48 - 48 - 64) |\\n            uint256(UFixed6.unwrap(newValue.short) << (256 - 64)) >> (256 - 32 - 48 - 48 - 64 - 64);\\n        uint256 encoded1 =\\n            uint256(UFixed6.unwrap(newValue.maker) << (256 - 64)) >> (256 - 64) |\\n            uint256(Fixed6.unwrap(newValue.invalidation.maker) << (256 - 64)) >> (256 - 64 - 64) |\\n            uint256(Fixed6.unwrap(newValue.invalidation.long) << (256 - 64)) >> (256 - 64 - 64 - 64) |\\n            uint256(Fixed6.unwrap(newValue.invalidation.short) << (256 - 64)) >> (256 - 64 - 64 - 64 - 64);\\n\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n        }\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the local Position struct into storage.\\n///\\n///     struct StoredPositionLocal {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         int48 fee;\\n///         uint48 keeper;\\n///         int64 collateral;\\n///         int64 delta;\\n///\\n///         /* slot 1 */\\n///         uint2 direction;\\n///         uint62 magnitude;\\n///         int64 invalidation.maker;\\n///         int64 invalidation.long;\\n///         int64 invalidation.short;\\n///     }\\n///\\nlibrary PositionStorageLocalLib {\\n    function read(PositionStorageLocal storage self) internal view returns (Position memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n\\n        uint256 direction = uint256(slot1 << (256 - 2)) >> (256 - 2);\\n        UFixed6 magnitude = UFixed6.wrap(uint256(slot1 << (256 - 2 - 62)) >> (256 - 62));\\n\\n        return Position(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            direction == 0 ? magnitude : UFixed6Lib.ZERO,\\n            direction == 1 ? magnitude : UFixed6Lib.ZERO,\\n            direction == 2 ? magnitude : UFixed6Lib.ZERO,\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 48 - 48)) >> (256 - 48)),\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 48 - 48 - 64)) >> (256 - 64)),\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 48 - 48 - 64 - 64)) >> (256 - 64)),\\n            Invalidation(\\n                Fixed6.wrap(int256(slot1 << (256 - 2 - 62 - 64)) >> (256 - 64)),\\n                Fixed6.wrap(int256(slot1 << (256 - 2 - 62 - 64 - 64)) >> (256 - 64)),\\n                Fixed6.wrap(int256(slot1 << (256 - 2 - 62 - 64 - 64 - 64)) >> (256 - 64))\\n            )\\n        );\\n    }\\n\\n    function store(PositionStorageLocal storage self, Position memory newValue) internal {\\n        PositionStorageLib.validate(newValue);\\n\\n        if (newValue.maker.gt(UFixed6.wrap(2 ** 62 - 1))) revert PositionStorageLib.PositionStorageInvalidError();\\n        if (newValue.long.gt(UFixed6.wrap(2 ** 62 - 1))) revert PositionStorageLib.PositionStorageInvalidError();\\n        if (newValue.short.gt(UFixed6.wrap(2 ** 62 - 1))) revert PositionStorageLib.PositionStorageInvalidError();\\n\\n        uint256 direction = newValue.long.isZero() ? (newValue.short.isZero() ? 0 : 2) : 1;\\n\\n        uint256 encoded0 =\\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\\n            uint256(Fixed6.unwrap(newValue.fee) << (256 - 48)) >> (256 - 32 - 48) |\\n            uint256(UFixed6.unwrap(newValue.keeper) << (256 - 48)) >> (256 - 32 - 48 - 48) |\\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 48 - 48 - 64) |\\n            uint256(Fixed6.unwrap(newValue.delta) << (256 - 64)) >> (256 - 32 - 48 - 48 - 64 - 64);\\n        uint256 encoded1 =\\n            uint256(direction << (256 - 2)) >> (256 - 2) |\\n            uint256(UFixed6.unwrap(newValue.magnitude()) << (256 - 62)) >> (256 - 2 - 62) |\\n            uint256(Fixed6.unwrap(newValue.invalidation.maker) << (256 - 64)) >> (256 - 2 - 62 - 64) |\\n            uint256(Fixed6.unwrap(newValue.invalidation.long) << (256 - 64)) >> (256 - 2 - 62 - 64 - 64) |\\n            uint256(Fixed6.unwrap(newValue.invalidation.short) << (256 - 64)) >> (256 - 2 - 62 - 64 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n        }\\n    }\\n}\\n\\nlibrary PositionStorageLib {\\n    // sig: 0x52a8a97f\\n    error PositionStorageInvalidError();\\n\\n    function validate(Position memory newValue) internal pure {\\n        if (newValue.timestamp > type(uint32).max) revert PositionStorageInvalidError();\\n        if (newValue.fee.gt(Fixed6.wrap(type(int48).max))) revert PositionStorageInvalidError();\\n        if (newValue.fee.lt(Fixed6.wrap(type(int48).min))) revert PositionStorageInvalidError();\\n        if (newValue.keeper.gt(UFixed6.wrap(type(uint48).max))) revert PositionStorageInvalidError();\\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert PositionStorageInvalidError();\\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert PositionStorageInvalidError();\\n        if (newValue.delta.gt(Fixed6.wrap(type(int64).max))) revert PositionStorageInvalidError();\\n        if (newValue.delta.lt(Fixed6.wrap(type(int64).min))) revert PositionStorageInvalidError();\\n        if (newValue.invalidation.maker.gt(Fixed6.wrap(type(int64).max))) revert PositionStorageInvalidError();\\n        if (newValue.invalidation.maker.lt(Fixed6.wrap(type(int64).min))) revert PositionStorageInvalidError();\\n        if (newValue.invalidation.long.gt(Fixed6.wrap(type(int64).max))) revert PositionStorageInvalidError();\\n        if (newValue.invalidation.long.lt(Fixed6.wrap(type(int64).min))) revert PositionStorageInvalidError();\\n        if (newValue.invalidation.short.gt(Fixed6.wrap(type(int64).max))) revert PositionStorageInvalidError();\\n        if (newValue.invalidation.short.lt(Fixed6.wrap(type(int64).min))) revert PositionStorageInvalidError();\\n    }\\n}\",\"keccak256\":\"0x27a3da6ee0eb30db2e0e42773739086b9d8a0d0aad16d9ea4d0b2d85259d14a4\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/ProtocolParameter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\n\\n/// @dev ProtocolParameter type\\nstruct ProtocolParameter {\\n    /// @dev The share of the market fees that are retained by the protocol before being distributed\\n    UFixed6 protocolFee;\\n\\n    /// @dev The maximum for market fee parameters\\n    UFixed6 maxFee;\\n\\n    /// @dev The maximum for market absolute fee parameters\\n    UFixed6 maxFeeAbsolute;\\n\\n    /// @dev The maximum for market cut parameters\\n    UFixed6 maxCut;\\n\\n    /// @dev The maximum for market rate parameters\\n    UFixed6 maxRate;\\n\\n    /// @dev The minimum for market maintenance parameters\\n    UFixed6 minMaintenance;\\n\\n    /// @dev The minimum for market efficiency parameters\\n    UFixed6 minEfficiency;\\n}\\nstruct StoredProtocolParameter {\\n    /* slot 0 */\\n    uint24 protocolFee;        // <= 1677%\\n    uint24 maxFee;             // <= 1677%\\n    uint48 maxFeeAbsolute;     // <= 281m\\n    uint24 maxCut;             // <= 1677%\\n    uint32 maxRate;            // <= 429496%\\n    uint24 minMaintenance;     // <= 1677%\\n    uint24 minEfficiency;      // <= 1677%\\n}\\nstruct ProtocolParameterStorage { StoredProtocolParameter value; }\\nusing ProtocolParameterStorageLib for ProtocolParameterStorage global;\\n\\nlibrary ProtocolParameterStorageLib {\\n    // sig: 0x4dc1bc59\\n    error ProtocolParameterStorageInvalidError();\\n\\n    function read(ProtocolParameterStorage storage self) internal view returns (ProtocolParameter memory) {\\n        StoredProtocolParameter memory value = self.value;\\n        return ProtocolParameter(\\n            UFixed6.wrap(uint256(value.protocolFee)),\\n            UFixed6.wrap(uint256(value.maxFee)),\\n            UFixed6.wrap(uint256(value.maxFeeAbsolute)),\\n            UFixed6.wrap(uint256(value.maxCut)),\\n            UFixed6.wrap(uint256(value.maxRate)),\\n            UFixed6.wrap(uint256(value.minMaintenance)),\\n            UFixed6.wrap(uint256(value.minEfficiency))\\n        );\\n    }\\n\\n    function validate(ProtocolParameter memory self) internal pure {\\n        if (self.protocolFee.gt(self.maxCut)) revert ProtocolParameterStorageInvalidError();\\n        if (self.maxCut.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\\n    }\\n\\n    function validateAndStore(ProtocolParameterStorage storage self, ProtocolParameter memory newValue) internal {\\n        validate(newValue);\\n\\n        if (newValue.maxFee.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.maxFeeAbsolute.gt(UFixed6.wrap(type(uint48).max))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.maxRate.gt(UFixed6.wrap(type(uint32).max))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.minMaintenance.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.minEfficiency.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\\n\\n        self.value = StoredProtocolParameter(\\n            uint24(UFixed6.unwrap(newValue.protocolFee)),\\n            uint24(UFixed6.unwrap(newValue.maxFee)),\\n            uint48(UFixed6.unwrap(newValue.maxFeeAbsolute)),\\n            uint24(UFixed6.unwrap(newValue.maxCut)),\\n            uint32(UFixed6.unwrap(newValue.maxRate)),\\n            uint24(UFixed6.unwrap(newValue.minMaintenance)),\\n            uint24(UFixed6.unwrap(newValue.minEfficiency))\\n        );\\n    }\\n}\",\"keccak256\":\"0x1421f24c2a0098bf570ce1c6cfc2dff6e7a28376154cab4552dd32a651c27e0b\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/RiskParameter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport \\\"@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol\\\";\\nimport \\\"@equilibria/root/pid/types/PController6.sol\\\";\\nimport \\\"../interfaces/IOracleProvider.sol\\\";\\nimport \\\"../interfaces/IPayoffProvider.sol\\\";\\nimport \\\"./ProtocolParameter.sol\\\";\\n\\n/// @dev RiskParameter type\\nstruct RiskParameter {\\n    /// @dev The minimum amount of collateral required to open a new position as a percentage of notional\\n    UFixed6 margin;\\n\\n    /// @dev The minimum amount of collateral that must be maintained as a percentage of notional\\n    UFixed6 maintenance;\\n\\n    /// @dev The percentage fee on the notional that is charged when a long or short position is open or closed\\n    UFixed6 takerFee;\\n\\n    /// @dev The additional percentage that is added scaled by the change in skew\\n    UFixed6 takerSkewFee;\\n\\n    /// @dev The additional percentage that is added scaled by the change in impact\\n    UFixed6 takerImpactFee;\\n\\n    /// @dev The percentage fee on the notional that is charged when a maker position is open or closed\\n    UFixed6 makerFee;\\n\\n    /// @dev The additional percentage that is added scaled by the change in utilization\\n    UFixed6 makerImpactFee;\\n\\n    /// @dev The maximum amount of maker positions that opened\\n    UFixed6 makerLimit;\\n\\n    /// @dev The minimum limit of the efficiency metric\\n    UFixed6 efficiencyLimit;\\n\\n    /// @dev The percentage fee on the notional that is charged when a position is liquidated\\n    UFixed6 liquidationFee;\\n\\n    /// @dev The minimum fixed amount that is charged when a position is liquidated\\n    UFixed6 minLiquidationFee;\\n\\n    /// @dev The maximum fixed amount that is charged when a position is liquidated\\n    UFixed6 maxLiquidationFee;\\n\\n    /// @dev The utilization curve that is used to compute maker interest\\n    UJumpRateUtilizationCurve6 utilizationCurve;\\n\\n    /// @dev The p controller that is used to compute long-short funding\\n    PController6 pController;\\n\\n    /// @dev The minimum fixed amount that is required to open a position\\n    UFixed6 minMargin;\\n\\n    /// @dev The minimum fixed amount that is required for maintenance\\n    UFixed6 minMaintenance;\\n\\n    /// @dev Scale that is used to calculate the skew % for orders\\n    UFixed6 skewScale;\\n\\n    /// @dev The maximum amount of time since the latest oracle version that update may still be called\\n    uint256 staleAfter;\\n\\n    /// @dev Whether or not the maker should always receive positive funding\\n    bool makerReceiveOnly;\\n}\\nstruct RiskParameterStorage { uint256 slot0; uint256 slot1; uint256 slot2; }\\nusing RiskParameterStorageLib for RiskParameterStorage global;\\n\\n//    struct StoredRiskParameter {\\n//        /* slot 0 */\\n//        uint24 margin;                              // <= 1677%\\n//        uint24 maintenance;                         // <= 1677%\\n//        uint24 takerFee;                            // <= 1677%\\n//        uint24 takerSkewFee;                        // <= 1677%\\n//        uint24 takerImpactFee;                      // <= 1677%\\n//        uint24 makerFee;                            // <= 1677%\\n//        uint24 makerImpactFee;                      // <= 1677%\\n//        uint64 makerLimit;                          // <= 18.44t\\n//        uint24 efficiencyLimit;                     // <= 1677%\\n//\\n//        /* slot 1 */\\n//        uint24 liquidationFee;                      // <= 1677%\\n//        uint48 minLiquidationFee;                   // <= 281mn\\n//        uint64 skewScale;                           // <= 18.44t\\n//        uint32 utilizationCurveMinRate;             // <= 214748%\\n//        uint32 utilizationCurveMaxRate;             // <= 214748%\\n//        uint32 utilizationCurveTargetRate;          // <= 214748%\\n//        uint24 utilizationCurveTargetUtilization;   // <= 1677%\\n//\\n//        /* slot 2 */\\n//        uint48 pControllerK;                        // <= 281m\\n//        uint32 pControllerMax;                      // <= 214748%\\n//        uint48 minMargin;                           // <= 281m\\n//        uint48 minMaintenance;                      // <= 281m\\n//        uint48 maxLiquidationFee;                   // <= 281mn\\n//        uint24 staleAfter;                          // <= 16m s\\n//        bool makerReceiveOnly;\\n//    }\\nlibrary RiskParameterStorageLib {\\n    // sig: 0x7ecd083f\\n    error RiskParameterStorageInvalidError();\\n\\n    function read(RiskParameterStorage storage self) external view returns (RiskParameter memory) {\\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\\n        return RiskParameter(\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 64 - 24)) >> (256 - 24)),\\n\\n            UFixed6.wrap(uint256(       slot1 << (256 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(       slot1 << (256 - 24 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48)) >> (256 - 48)),\\n            UJumpRateUtilizationCurve6(\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 64 - 32)) >> (256 - 32)),\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 64 - 32 - 32)) >> (256 - 32)),\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 64 - 32 - 32 - 32)) >> (256 - 32)),\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 64 - 32 - 32 - 32 - 24)) >> (256 - 24))\\n            ),\\n\\n            PController6(\\n                UFixed6.wrap(uint256(   slot2 << (256 - 48)) >> (256 - 48)),\\n                UFixed6.wrap(uint256(   slot2 << (256 - 48 - 32)) >> (256 - 32))\\n            ),\\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(       slot1 << (256 - 24 - 48 - 64)) >> (256 - 64)),\\n                         uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48 - 24)) >> (256 - 24),\\n            0 !=        (uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 48 - 24 - 8)) >> (256 - 8))\\n        );\\n    }\\n\\n    function validate(RiskParameter memory self, ProtocolParameter memory protocolParameter) public pure {\\n        if (\\n            self.takerFee.max(self.takerSkewFee).max(self.takerImpactFee).max(self.makerFee).max(self.makerImpactFee)\\n            .gt(protocolParameter.maxFee)\\n        ) revert RiskParameterStorageInvalidError();\\n\\n        if (\\n            self.minLiquidationFee.max(self.maxLiquidationFee).max(self.minMargin).max(self.minMaintenance)\\n            .gt(protocolParameter.maxFeeAbsolute)\\n        ) revert RiskParameterStorageInvalidError();\\n\\n        if (self.liquidationFee.gt(protocolParameter.maxCut)) revert RiskParameterStorageInvalidError();\\n\\n        if (\\n            self.utilizationCurve.minRate.max(self.utilizationCurve.maxRate).max(self.utilizationCurve.targetRate).max(self.pController.max)\\n            .gt(protocolParameter.maxRate)\\n        ) revert RiskParameterStorageInvalidError();\\n\\n        if (self.maintenance.lt(protocolParameter.minMaintenance)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.margin.lt(self.maintenance)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.efficiencyLimit.lt(protocolParameter.minEfficiency)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.utilizationCurve.targetUtilization.gt(UFixed6Lib.ONE)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.minMaintenance.lt(self.minLiquidationFee)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.minMargin.lt(self.minMaintenance)) revert RiskParameterStorageInvalidError();\\n    }\\n\\n    function validateAndStore(\\n        RiskParameterStorage storage self,\\n        RiskParameter memory newValue,\\n        ProtocolParameter memory protocolParameter\\n    ) external {\\n        validate(newValue, protocolParameter);\\n\\n        if (newValue.margin.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.efficiencyLimit.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.makerLimit.gt(UFixed6.wrap(type(uint64).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.pController.k.gt(UFixed6.wrap(type(uint48).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.skewScale.gt(UFixed6.wrap(type(uint64).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.staleAfter > uint256(type(uint24).max)) revert RiskParameterStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(UFixed6.unwrap(newValue.margin)             << (256 - 24)) >> (256 - 24) |\\n            uint256(UFixed6.unwrap(newValue.maintenance)        << (256 - 24)) >> (256 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.takerFee)           << (256 - 24)) >> (256 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.takerSkewFee)       << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.takerImpactFee)     << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.makerFee)           << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.makerImpactFee)     << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.makerLimit)         << (256 - 64)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 64) |\\n            uint256(UFixed6.unwrap(newValue.efficiencyLimit)    << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 64 - 24);\\n\\n        uint256 encoded1 =\\n            uint256(UFixed6.unwrap(newValue.liquidationFee)                     << (256 - 24)) >> (256 - 24) |\\n            uint256(UFixed6.unwrap(newValue.minLiquidationFee)                  << (256 - 48)) >> (256 - 24 - 48) |\\n            uint256(UFixed6.unwrap(newValue.skewScale)                          << (256 - 64)) >> (256 - 24 - 48 - 64) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.minRate)           << (256 - 32)) >> (256 - 24 - 48 - 64 - 32) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.maxRate)           << (256 - 32)) >> (256 - 24 - 48 - 64 - 32 - 32) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetRate)        << (256 - 32)) >> (256 - 24 - 48 - 64 - 32 - 32 - 32) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetUtilization) << (256 - 24)) >> (256 - 24 - 48 - 64 - 32 - 32 - 32 - 24);\\n\\n        uint256 encoded2 =\\n            uint256(UFixed6.unwrap(newValue.pController.k)                  << (256 - 48)) >> (256 - 48) |\\n            uint256(UFixed6.unwrap(newValue.pController.max)                << (256 - 32)) >> (256 - 48 - 32) |\\n            uint256(UFixed6.unwrap(newValue.minMargin)                      << (256 - 48)) >> (256 - 48 - 32 - 48) |\\n            uint256(UFixed6.unwrap(newValue.minMaintenance)                 << (256 - 48)) >> (256 - 48 - 32 - 48 - 48) |\\n            uint256(UFixed6.unwrap(newValue.maxLiquidationFee)              << (256 - 48)) >> (256 - 48 - 32 - 48 - 48 - 48) |\\n            uint256(newValue.staleAfter                                     << (256 - 24)) >> (256 - 48 - 32 - 48 - 48 - 48 - 24) |\\n            uint256((newValue.makerReceiveOnly ? uint256(1) : uint256(0))   << (256 - 8))  >> (256 - 48 - 32 - 48 - 48 - 48 - 24 - 8);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n            sstore(add(self.slot, 2), encoded2)\\n        }\\n    }\\n}\",\"keccak256\":\"0xcdb4572d27d20c71cf16586c3119e8b6fe485ab10d02c55b14036543c486bf7a\",\"license\":\"Apache-2.0\"},\"@equilibria/perennial-v2/contracts/types/Version.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@equilibria/root/accumulator/types/Accumulator6.sol\\\";\\nimport \\\"@equilibria/root/accumulator/types/UAccumulator6.sol\\\";\\nimport \\\"./ProtocolParameter.sol\\\";\\nimport \\\"./MarketParameter.sol\\\";\\nimport \\\"./RiskParameter.sol\\\";\\nimport \\\"./Global.sol\\\";\\nimport \\\"./Position.sol\\\";\\n\\n/// @dev Version type\\nstruct Version {\\n    /// @dev whether this version had a valid oracle price\\n    bool valid;\\n\\n    /// @dev The maker accumulator value\\n    Accumulator6 makerValue;\\n\\n    /// @dev The long accumulator value\\n    Accumulator6 longValue;\\n\\n    /// @dev The short accumulator value\\n    Accumulator6 shortValue;\\n\\n    /// @dev The maker reward accumulator value\\n    UAccumulator6 makerReward;\\n\\n    /// @dev The long reward accumulator value\\n    UAccumulator6 longReward;\\n\\n    /// @dev The short reward accumulator value\\n    UAccumulator6 shortReward;\\n}\\nusing VersionLib for Version global;\\nstruct VersionStorage { uint256 slot0; uint256 slot1; }\\nusing VersionStorageLib for VersionStorage global;\\n\\n/// @dev Individual accumulation values\\nstruct VersionAccumulationResult {\\n    Fixed6 positionFeeMaker;\\n    UFixed6 positionFeeFee;\\n\\n    Fixed6 fundingMaker;\\n    Fixed6 fundingLong;\\n    Fixed6 fundingShort;\\n    UFixed6 fundingFee;\\n\\n    Fixed6 interestMaker;\\n    Fixed6 interestLong;\\n    Fixed6 interestShort;\\n    UFixed6 interestFee;\\n\\n    Fixed6 pnlMaker;\\n    Fixed6 pnlLong;\\n    Fixed6 pnlShort;\\n\\n    UFixed6 rewardMaker;\\n    UFixed6 rewardLong;\\n    UFixed6 rewardShort;\\n}\\n\\n///@title Version\\n/// @notice Library that manages global versioned accumulator state.\\n/// @dev Manages two accumulators: value and reward. The value accumulator measures the change in position value\\n///      over time, while the reward accumulator measures the change in position ownership over time.\\nlibrary VersionLib {\\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\\n    /// @param self The Version object to update\\n    /// @param global The global state\\n    /// @param fromPosition The previous latest position\\n    /// @param toPosition The next latest position\\n    /// @param fromOracleVersion The previous latest oracle version\\n    /// @param toOracleVersion The next latest oracle version\\n    /// @param marketParameter The market parameter\\n    /// @param riskParameter The risk parameter\\n    /// @return values The accumulation result\\n    /// @return totalFee The total fee accumulated\\n    function accumulate(\\n        Version memory self,\\n        Global memory global,\\n        Position memory fromPosition,\\n        Position memory toPosition,\\n        OracleVersion memory fromOracleVersion,\\n        OracleVersion memory toOracleVersion,\\n        MarketParameter memory marketParameter,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (VersionAccumulationResult memory values, UFixed6 totalFee) {\\n        // record validity\\n        self.valid = toOracleVersion.valid;\\n\\n        // accumulate position fee\\n        (values.positionFeeMaker, values.positionFeeFee) =\\n            _accumulatePositionFee(self, fromPosition, toPosition, marketParameter);\\n\\n        // if closed, don't accrue anything else\\n        if (marketParameter.closed) return (values, values.positionFeeFee);\\n\\n        // accumulate funding\\n        _FundingValues memory fundingValues = _accumulateFunding(\\n            self,\\n            global,\\n            fromPosition,\\n            toPosition,\\n            fromOracleVersion,\\n            toOracleVersion,\\n            marketParameter,\\n            riskParameter\\n        );\\n        (values.fundingMaker, values.fundingLong, values.fundingShort, values.fundingFee) = (\\n            fundingValues.fundingMaker,\\n            fundingValues.fundingLong,\\n            fundingValues.fundingShort,\\n            fundingValues.fundingFee\\n        );\\n\\n        // accumulate interest\\n        (values.interestMaker, values.interestLong, values.interestShort, values.interestFee) =\\n            _accumulateInterest(self, fromPosition, fromOracleVersion, toOracleVersion, marketParameter, riskParameter);\\n\\n        // accumulate P&L\\n        (values.pnlMaker, values.pnlLong, values.pnlShort) =\\n            _accumulatePNL(self, fromPosition, fromOracleVersion, toOracleVersion);\\n\\n        return (values, values.positionFeeFee.add(values.fundingFee).add(values.interestFee));\\n    }\\n\\n    /// @notice Globally accumulates position fees since last oracle update\\n    /// @param self The Version object to update\\n    /// @param fromPosition The previous latest position\\n    /// @param toPosition The next latest position\\n    /// @param marketParameter The market parameter\\n    /// @return positionFeeMaker The maker's position fee\\n    /// @return positionFeeFee The protocol's position fee\\n    function _accumulatePositionFee(\\n        Version memory self,\\n        Position memory fromPosition,\\n        Position memory toPosition,\\n        MarketParameter memory marketParameter\\n    ) private pure returns (Fixed6 positionFeeMaker, UFixed6 positionFeeFee) {\\n        UFixed6 toPositionFeeAbs = toPosition.fee.abs();\\n        // If there are no makers to distribute the taker's position fee to, give it to the protocol\\n        if (fromPosition.maker.isZero()) return (Fixed6Lib.ZERO, toPositionFeeAbs);\\n\\n        positionFeeFee = marketParameter.positionFee.mul(toPositionFeeAbs);\\n        positionFeeMaker = toPosition.fee.sub(Fixed6Lib.from(positionFeeFee));\\n\\n        self.makerValue.increment(positionFeeMaker, fromPosition.maker);\\n    }\\n\\n    /// @dev Internal struct to bypass stack depth limit\\n    struct _FundingValues {\\n        Fixed6 fundingMaker;\\n        Fixed6 fundingLong;\\n        Fixed6 fundingShort;\\n        UFixed6 fundingFee;\\n    }\\n\\n    /// @notice Globally accumulates all long-short funding since last oracle update\\n    /// @param self The Version object to update\\n    /// @param global The global state\\n    /// @param fromPosition The previous latest position\\n    /// @param toPosition The next latest position\\n    /// @param fromOracleVersion The previous latest oracle version\\n    /// @param toOracleVersion The next latest oracle version\\n    /// @param marketParameter The market parameter\\n    /// @param riskParameter The risk parameter\\n    /// @return fundingValues The funding values accumulated\\n    function _accumulateFunding(\\n        Version memory self,\\n        Global memory global,\\n        Position memory fromPosition,\\n        Position memory toPosition,\\n        OracleVersion memory fromOracleVersion,\\n        OracleVersion memory toOracleVersion,\\n        MarketParameter memory marketParameter,\\n        RiskParameter memory riskParameter\\n    ) private pure returns (_FundingValues memory fundingValues) {\\n        // Compute long-short funding rate\\n        Fixed6 funding = global.pAccumulator.accumulate(\\n            riskParameter.pController,\\n            toPosition.staticSkew(riskParameter).min(Fixed6Lib.ONE).max(Fixed6Lib.NEG_ONE),\\n            fromOracleVersion.timestamp,\\n            toOracleVersion.timestamp,\\n            fromPosition.takerSocialized().mul(fromOracleVersion.price.abs())\\n        );\\n\\n        // Handle maker receive-only status\\n        if (riskParameter.makerReceiveOnly && funding.sign() != fromPosition.relativeSkew().sign())\\n            funding = funding.mul(Fixed6Lib.NEG_ONE);\\n\\n        // Initialize long and short funding\\n        (fundingValues.fundingLong, fundingValues.fundingShort) = (Fixed6Lib.NEG_ONE.mul(funding), funding);\\n\\n        // Compute fee spread\\n        fundingValues.fundingFee = funding.abs().mul(marketParameter.fundingFee);\\n        Fixed6 fundingSpread = Fixed6Lib.from(fundingValues.fundingFee).div(Fixed6Lib.from(2));\\n\\n        // Adjust funding with spread\\n        (fundingValues.fundingLong, fundingValues.fundingShort) = (\\n            fundingValues.fundingLong.sub(Fixed6Lib.from(fundingValues.fundingFee)).add(fundingSpread),\\n            fundingValues.fundingShort.sub(fundingSpread)\\n        );\\n\\n        // Redirect net portion of minor's side to maker\\n        if (fromPosition.long.gt(fromPosition.short)) {\\n            fundingValues.fundingMaker = fundingValues.fundingShort.mul(Fixed6Lib.from(fromPosition.socializedSkew()));\\n            fundingValues.fundingShort = fundingValues.fundingShort.sub(fundingValues.fundingMaker);\\n        }\\n        if (fromPosition.short.gt(fromPosition.long)) {\\n            fundingValues.fundingMaker = fundingValues.fundingLong.mul(Fixed6Lib.from(fromPosition.socializedSkew()));\\n            fundingValues.fundingLong = fundingValues.fundingLong.sub(fundingValues.fundingMaker);\\n        }\\n\\n        self.makerValue.increment(fundingValues.fundingMaker, fromPosition.maker);\\n        self.longValue.increment(fundingValues.fundingLong, fromPosition.long);\\n        self.shortValue.increment(fundingValues.fundingShort, fromPosition.short);\\n    }\\n\\n    /// @notice Globally accumulates all maker interest since last oracle update\\n    /// @param self The Version object to update\\n    /// @param position The previous latest position\\n    /// @param fromOracleVersion The previous latest oracle version\\n    /// @param toOracleVersion The next latest oracle version\\n    /// @param marketParameter The market parameter\\n    /// @param riskParameter The risk parameter\\n    /// @return interestMaker The total interest accrued by makers\\n    /// @return interestLong The total interest accrued by longs\\n    /// @return interestShort The total interest accrued by shorts\\n    /// @return interestFee The total fee accrued from interest accumulation\\n    function _accumulateInterest(\\n        Version memory self,\\n        Position memory position,\\n        OracleVersion memory fromOracleVersion,\\n        OracleVersion memory toOracleVersion,\\n        MarketParameter memory marketParameter,\\n        RiskParameter memory riskParameter\\n    ) private pure returns (Fixed6 interestMaker, Fixed6 interestLong, Fixed6 interestShort, UFixed6 interestFee) {\\n        UFixed6 notional = position.long.add(position.short).min(position.maker).mul(fromOracleVersion.price.abs());\\n\\n        // Compute maker interest\\n        UFixed6 interest = riskParameter.utilizationCurve.accumulate(\\n            position.utilization(),\\n            fromOracleVersion.timestamp,\\n            toOracleVersion.timestamp,\\n            notional\\n        );\\n\\n        // Compute fee\\n        interestFee = interest.mul(marketParameter.interestFee);\\n\\n        // Adjust long and short funding with spread\\n        interestLong = Fixed6Lib.from(\\n            position.major().isZero() ?\\n            interest :\\n            interest.muldiv(position.long, position.long.add(position.short))\\n        );\\n        interestShort = Fixed6Lib.from(interest).sub(interestLong);\\n        interestMaker = Fixed6Lib.from(interest.sub(interestFee));\\n\\n        interestLong = interestLong.mul(Fixed6Lib.NEG_ONE);\\n        interestShort = interestShort.mul(Fixed6Lib.NEG_ONE);\\n        self.makerValue.increment(interestMaker, position.maker);\\n        self.longValue.increment(interestLong, position.long);\\n        self.shortValue.increment(interestShort, position.short);\\n    }\\n\\n    /// @notice Globally accumulates position profit & loss since last oracle update\\n    /// @param self The Version object to update\\n    /// @param position The previous latest position\\n    /// @param fromOracleVersion The previous latest oracle version\\n    /// @param toOracleVersion The next latest oracle version\\n    /// @return pnlMaker The total pnl accrued by makers\\n    /// @return pnlLong The total pnl accrued by longs\\n    /// @return pnlShort The total pnl accrued by shorts\\n    function _accumulatePNL(\\n        Version memory self,\\n        Position memory position,\\n        OracleVersion memory fromOracleVersion,\\n        OracleVersion memory toOracleVersion\\n    ) private pure returns (Fixed6 pnlMaker, Fixed6 pnlLong, Fixed6 pnlShort) {\\n        pnlLong = toOracleVersion.price.sub(fromOracleVersion.price)\\n            .mul(Fixed6Lib.from(position.longSocialized()));\\n        pnlShort = fromOracleVersion.price.sub(toOracleVersion.price)\\n            .mul(Fixed6Lib.from(position.shortSocialized()));\\n        pnlMaker = pnlLong.add(pnlShort).mul(Fixed6Lib.NEG_ONE);\\n\\n        self.longValue.increment(pnlLong, position.long);\\n        self.shortValue.increment(pnlShort, position.short);\\n        self.makerValue.increment(pnlMaker, position.maker);\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the Version struct into storage.\\n///\\n///     struct StoredVersion {\\n///         /* slot 0 */\\n///         bool valid;\\n///         int64 makerValue;\\n///         int64 longValue;\\n///         int64 shortValue;\\n///\\n///         /* slot 1 */\\n///         uint64 makerReward;\\n///         uint64 longReward;\\n///         uint64 shortReward;\\n///     }\\n///\\nlibrary VersionStorageLib {\\n    // sig: 0xd2777e72\\n    error VersionStorageInvalidError();\\n\\n    function read(VersionStorage storage self) internal view returns (Version memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n        return Version(\\n            (uint256(slot0 << (256 - 8)) >> (256 - 8)) != 0,\\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64)) >> (256 - 64))),\\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64)) >> (256 - 64))),\\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64)) >> (256 - 64))),\\n            UAccumulator6(UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64))),\\n            UAccumulator6(UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64))),\\n            UAccumulator6(UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64)) >> (256 - 64)))\\n        );\\n    }\\n\\n    function store(VersionStorage storage self, Version memory newValue) internal {\\n        if (newValue.makerValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\\n        if (newValue.makerValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\\n        if (newValue.longValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\\n        if (newValue.longValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\\n        if (newValue.shortValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\\n        if (newValue.shortValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\\n        if (newValue.makerReward._value.gt(UFixed6.wrap(type(uint64).max))) revert VersionStorageInvalidError();\\n        if (newValue.longReward._value.gt(UFixed6.wrap(type(uint64).max))) revert VersionStorageInvalidError();\\n        if (newValue.shortReward._value.gt(UFixed6.wrap(type(uint64).max))) revert VersionStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256((newValue.valid ? uint256(1) : uint256(0)) << (256 - 8)) >> (256 - 8) |\\n            uint256(Fixed6.unwrap(newValue.makerValue._value) << (256 - 64)) >> (256 - 8 - 64) |\\n            uint256(Fixed6.unwrap(newValue.longValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64) |\\n            uint256(Fixed6.unwrap(newValue.shortValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64 - 64);\\n        uint256 encoded1 =\\n            uint256(UFixed6.unwrap(newValue.makerReward._value) << (256 - 64)) >> (256 - 64) |\\n            uint256(UFixed6.unwrap(newValue.longReward._value) << (256 - 64)) >> (256 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.shortReward._value) << (256 - 64)) >> (256 - 64 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf187ded04ee3f77292993768c75e2a4d0d313cf4c8fd0a648be359586950fec5\",\"license\":\"Apache-2.0\"},\"@equilibria/root/accumulator/types/Accumulator6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\n\\n/// @dev Accumulator6 type\\nstruct Accumulator6 {\\n    Fixed6 _value;\\n}\\n\\nusing Accumulator6Lib for Accumulator6 global;\\nstruct StoredAccumulator6 {\\n    int256 _value;\\n}\\nstruct Accumulator6Storage { StoredAccumulator6 value; }\\nusing Accumulator6StorageLib for Accumulator6Storage global;\\n\\n\\n/**\\n * @title Accumulator6Lib\\n * @notice Library that surfaces math operations for the signed Accumulator type.\\n * @dev This accumulator tracks cumulative changes to a value over time. Using the `accumulated` function, one\\n * can determine how much a value has changed between two points in time. The `increment` and `decrement` functions\\n * can be used to update the accumulator.\\n */\\nlibrary Accumulator6Lib {\\n    /**\\n     * Returns how much has been accumulated between two accumulators\\n     * @param self The current point of the accumulation to compare with `from`\\n     * @param from The starting point of the accumulation\\n     * @param total Demoninator of the ratio (see `increment` and `decrement` functions)\\n     */\\n    function accumulated(Accumulator6 memory self, Accumulator6 memory from, UFixed6 total) internal pure returns (Fixed6) {\\n        return _mul(self._value.sub(from._value), total);\\n    }\\n\\n    /**\\n     * @notice Increments an accumulator by a given ratio\\n     * @dev Always rounds down in order to prevent overstating the accumulated value\\n     * @param self The accumulator to increment\\n     * @param amount Numerator of the ratio\\n     * @param total Denominator of the ratio\\n     */\\n    function increment(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\\n        if (amount.isZero()) return;\\n        self._value = self._value.add(_div(amount, total));\\n    }\\n\\n    /**\\n     * @notice Decrements an accumulator by a given ratio\\n     * @dev Always rounds down in order to prevent overstating the accumulated value\\n     * @param self The accumulator to decrement\\n     * @param amount Numerator of the ratio\\n     * @param total Denominator of the ratio\\n     */\\n    function decrement(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\\n        if (amount.isZero()) return;\\n        self._value = self._value.add(_div(amount.mul(Fixed6Lib.NEG_ONE), total));\\n    }\\n\\n    function _div(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\\n        return amount.sign() == -1 ? amount.divOut(Fixed6Lib.from(total)) : amount.div(Fixed6Lib.from(total));\\n    }\\n\\n    function _mul(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\\n        return amount.sign() == -1 ? amount.mulOut(Fixed6Lib.from(total)) : amount.mul(Fixed6Lib.from(total));\\n    }\\n}\\n\\nlibrary Accumulator6StorageLib {\\n    function read(Accumulator6Storage storage self) internal view returns (Accumulator6 memory) {\\n        StoredAccumulator6 memory storedValue = self.value;\\n        return Accumulator6(Fixed6.wrap(int256(storedValue._value)));\\n    }\\n\\n    function store(Accumulator6Storage storage self, Accumulator6 memory newValue) internal {\\n        self.value = StoredAccumulator6(Fixed6.unwrap(newValue._value));\\n    }\\n}\\n\",\"keccak256\":\"0x21202b20328506bda86043889dca7b699732a9bf6ec735cc50ac8a444e643724\",\"license\":\"Apache-2.0\"},\"@equilibria/root/accumulator/types/UAccumulator6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/UFixed6.sol\\\";\\n\\n/// @dev UAccumulator6 type\\nstruct UAccumulator6 {\\n    UFixed6 _value;\\n}\\n\\nusing UAccumulator6Lib for UAccumulator6 global;\\nstruct StoredUAccumulator6 {\\n    uint256 _value;\\n}\\nstruct UAccumulator6Storage { StoredUAccumulator6 value; }\\nusing UAccumulator6StorageLib for UAccumulator6Storage global;\\n\\n\\n/**\\n * @title UAccumulator6Lib\\n * @notice Library that surfaces math operations for the unsigned Accumulator type.\\n * @dev This accumulator tracks cumulative changes to a monotonically increasing value over time. Using the `accumulated` function, one\\n * can determine how much a value has changed between two points in time. The `increment` function can be used to update the accumulator.\\n */\\nlibrary UAccumulator6Lib {\\n    /**\\n     * Returns how much has been accumulated between two accumulators\\n     * @param self The current point of the accumulation to compare with `from`\\n     * @param from The starting point of the accumulation\\n     * @param total Demoninator of the ratio (see `increment` function)\\n     */\\n    function accumulated(UAccumulator6 memory self, UAccumulator6 memory from, UFixed6 total) internal pure returns (UFixed6) {\\n        return self._value.sub(from._value).mul(total);\\n    }\\n\\n    /**\\n     * @notice Increments an accumulator by a given ratio\\n     * @dev Always rounds down in order to prevent overstating the accumulated value\\n     * @param self The accumulator to increment\\n     * @param amount Numerator of the ratio\\n     * @param total Denominator of the ratio\\n     */\\n    function increment(UAccumulator6 memory self, UFixed6 amount, UFixed6 total) internal pure {\\n        if (amount.isZero()) return;\\n        self._value = self._value.add(amount.div(total));\\n    }\\n}\\n\\nlibrary UAccumulator6StorageLib {\\n    function read(UAccumulator6Storage storage self) internal view returns (UAccumulator6 memory) {\\n        StoredUAccumulator6 memory storedValue = self.value;\\n        return UAccumulator6(UFixed6.wrap(uint256(storedValue._value)));\\n    }\\n\\n    function store(UAccumulator6Storage storage self, UAccumulator6 memory newValue) internal {\\n        self.value = StoredUAccumulator6(UFixed6.unwrap(newValue._value));\\n    }\\n}\\n\",\"keccak256\":\"0x6c8f1e358099c02e441e396172c0d8920e85185946a72eff0af9a678588d0636\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport \\\"./interfaces/IInitializable.sol\\\";\\nimport \\\"../storage/Storage.sol\\\";\\n\\n/**\\n * @title Initializable\\n * @notice Library to manage the initialization lifecycle of upgradeable contracts\\n * @dev `Initializable.sol` allows the creation of pseudo-constructors for upgradeable contracts. One\\n *      `initializer` should be declared per top-level contract. Child contracts can use the `onlyInitializer`\\n *      modifier to tag their internal initialization functions to ensure that they can only be called\\n *      from a top-level `initializer` or a constructor.\\n */\\nabstract contract Initializable is IInitializable {\\n    /// @dev The initialized flag\\n    Uint256Storage private constant _version = Uint256Storage.wrap(keccak256(\\\"equilibria.root.Initializable.version\\\"));\\n\\n    /// @dev The initializing flag\\n    BoolStorage private constant _initializing = BoolStorage.wrap(keccak256(\\\"equilibria.root.Initializable.initializing\\\"));\\n\\n    /// @dev Can only be called once per version, `version` is 1-indexed\\n    modifier initializer(uint256 version) {\\n        if (version == 0) revert InitializableZeroVersionError();\\n        if (_version.read() >= version) revert InitializableAlreadyInitializedError(version);\\n\\n        _version.store(version);\\n        _initializing.store(true);\\n\\n        _;\\n\\n        _initializing.store(false);\\n        emit Initialized(version);\\n    }\\n\\n    /// @dev Can only be called from an initializer or constructor\\n    modifier onlyInitializer() {\\n        if (!_constructing() && !_initializing.read()) revert InitializableNotInitializingError();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Returns whether the contract is currently being constructed\\n     * @dev {Address.isContract} returns false for contracts currently in the process of being constructed\\n     * @return Whether the contract is currently being constructed\\n     */\\n    function _constructing() private view returns (bool) {\\n        return !Address.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0xaae151abc669fe2ec33a80e4e62da1849b7863034aeb9c16122c728d041cfb0b\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/Instance.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../storage/Storage.sol\\\";\\nimport \\\"./interfaces/IInstance.sol\\\";\\nimport \\\"./Initializable.sol\\\";\\n\\n/// @title Instance\\n/// @notice An abstract contract that is created and managed by a factory\\nabstract contract Instance is IInstance, Initializable {\\n    /// @dev The factory address storage slot\\n    AddressStorage private constant _factory = AddressStorage.wrap(keccak256(\\\"equilibria.root.Instance.factory\\\"));\\n\\n    /// @notice Returns the factory that created this instance\\n    /// @return The factory that created this instance\\n    function factory() public view returns (IFactory) { return IFactory(_factory.read()); }\\n\\n    /// @notice Initializes the contract setting `msg.sender` as the factory\\n    function __Instance__initialize() internal onlyInitializer {\\n        _factory.store(msg.sender);\\n    }\\n\\n    /// @notice Only allow the owner defined by the factory to call the function\\n    modifier onlyOwner {\\n        if (msg.sender != factory().owner()) revert InstanceNotOwnerError(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Only allow the factory to call the function\\n    modifier onlyFactory {\\n        if (msg.sender != address(factory())) revert InstanceNotFactoryError(msg.sender);\\n        _;\\n    }\\n\\n    /// @notice Only allow the function to be called when the factory is not paused\\n    modifier whenNotPaused {\\n        if (factory().paused()) revert InstancePausedError();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x4350fbc81d27a2470de4ee319e036f69153f6f42e163b912d5fa458400e774ac\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\\\";\\nimport \\\"./IPausable.sol\\\";\\nimport \\\"./IInstance.sol\\\";\\n\\ninterface IFactory is IBeacon, IOwnable, IPausable {\\n    event InstanceRegistered(IInstance indexed instance);\\n\\n    error FactoryNotInstanceError();\\n\\n    function instances(IInstance instance) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x64c821ff5b6ff536a295bc0a24bf76dac44cd67b89183d224903f9fe1d6d3e65\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IInitializable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\ninterface IInitializable {\\n    error InitializableZeroVersionError();\\n    error InitializableAlreadyInitializedError(uint256 version);\\n    error InitializableNotInitializingError();\\n\\n    event Initialized(uint256 version);\\n}\\n\",\"keccak256\":\"0xa626c401aab111b5ccdaa280b4d0137e2f4261a71796cd89a1435025083b4035\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IInstance.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IFactory.sol\\\";\\nimport \\\"./IInitializable.sol\\\";\\n\\ninterface IInstance is IInitializable {\\n    error InstanceNotOwnerError(address sender);\\n    error InstanceNotFactoryError(address sender);\\n    error InstancePausedError();\\n\\n    function factory() external view returns (IFactory);\\n}\\n\",\"keccak256\":\"0x9c25e710af0e06bde4bc5b63a8fb4c020a55e7f2dc93ca061d0b74318cd4a8a0\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IKept.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { AggregatorV3Interface } from \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\\\";\\nimport \\\"../interfaces/IInitializable.sol\\\";\\nimport \\\"../../number/types/UFixed18.sol\\\";\\nimport \\\"../../token/types/Token18.sol\\\";\\n\\ninterface IKept is IInitializable {\\n    struct KeepConfig {\\n        UFixed18 multiplierBase;\\n        uint256 bufferBase;\\n        UFixed18 multiplierCalldata;\\n        uint256 bufferCalldata;\\n    }\\n\\n    event KeeperCall(address indexed sender, uint256 applicableGas, uint256 applicableValue, UFixed18 baseFee, UFixed18 calldataFee, UFixed18 keeperFee);\\n\\n    function ethTokenOracleFeed() external view returns (AggregatorV3Interface);\\n    function keeperToken() external view returns (Token18);\\n}\\n\",\"keccak256\":\"0xf4e1f5a6d115bca2636223d6516ddec2b92c9f587b416a737aff120fd02d6c5d\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IInitializable.sol\\\";\\n\\ninterface IOwnable is IInitializable {\\n    event OwnerUpdated(address indexed newOwner);\\n    event PendingOwnerUpdated(address indexed newPendingOwner);\\n\\n    error OwnableNotOwnerError(address sender);\\n    error OwnableNotPendingOwnerError(address sender);\\n\\n    function owner() external view returns (address);\\n    function pendingOwner() external view returns (address);\\n    function updatePendingOwner(address newPendingOwner) external;\\n    function acceptOwner() external;\\n}\\n\",\"keccak256\":\"0x0f451927a2ccfc0771d38d9dcdeae79aec5ee6170b6009f1616505d83aff8733\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IPausable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IInitializable.sol\\\";\\nimport \\\"./IOwnable.sol\\\";\\n\\ninterface IPausable is IInitializable, IOwnable {\\n    event PauserUpdated(address indexed newPauser);\\n    event Paused();\\n    event Unpaused();\\n\\n    error PausablePausedError();\\n    error PausableNotPauserError(address sender);\\n\\n    function pauser() external view returns (address);\\n    function paused() external view returns (bool);\\n    function updatePauser(address newPauser) external;\\n    function pause() external;\\n    function unpause() external;\\n}\\n\",\"keccak256\":\"0x8ae48b036875291c763787ba6730d56f4a9cb30d7d4132ec8711544b99689338\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/NumberMath.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\n\\n/**\\n * @title NumberMath\\n * @notice Library for additional math functions that are not included in the OpenZeppelin libraries.\\n */\\nlibrary NumberMath {\\n    error DivisionByZero();\\n\\n    /**\\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Dividend\\n     * @param b Divisor\\n     * @return Resulting quotient\\n     */\\n    function divOut(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) revert DivisionByZero();\\n        return Math.ceilDiv(a, b);\\n    }\\n\\n    /**\\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Dividend\\n     * @param b Divisor\\n     * @return Resulting quotient\\n     */\\n    function divOut(int256 a, int256 b) internal pure returns (int256) {\\n        return sign(a) * sign(b) * int256(divOut(SignedMath.abs(a), SignedMath.abs(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the sign of an int256\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a int256 to find the sign of\\n     * @return Sign of the int256\\n     */\\n    function sign(int256 a) internal pure returns (int256) {\\n        if (a > 0) return 1;\\n        if (a < 0) return -1;\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x8d3578ce6e74ee6589ba0468e2c539ef1eb51d6687b508e637620926eb8396b4\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/Fixed18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed6.sol\\\";\\nimport \\\"./UFixed18.sol\\\";\\n\\n/// @dev Fixed18 type\\ntype Fixed18 is int256;\\nusing Fixed18Lib for Fixed18 global;\\ntype Fixed18Storage is bytes32;\\nusing Fixed18StorageLib for Fixed18Storage global;\\n\\n/**\\n * @title Fixed18Lib\\n * @notice Library for the signed fixed-decimal type.\\n */\\nlibrary Fixed18Lib {\\n    error Fixed18OverflowError(uint256 value);\\n\\n    int256 private constant BASE = 1e18;\\n    Fixed18 public constant ZERO = Fixed18.wrap(0);\\n    Fixed18 public constant ONE = Fixed18.wrap(BASE);\\n    Fixed18 public constant NEG_ONE = Fixed18.wrap(-1 * BASE);\\n    Fixed18 public constant MAX = Fixed18.wrap(type(int256).max);\\n    Fixed18 public constant MIN = Fixed18.wrap(type(int256).min);\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\\n     * @param a Unsigned fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed18 a) internal pure returns (Fixed18) {\\n        uint256 value = UFixed18.unwrap(a);\\n        if (value > uint256(type(int256).max)) revert Fixed18OverflowError(value);\\n        return Fixed18.wrap(int256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\\n     * @param s Sign\\n     * @param m Unsigned fixed-decimal magnitude\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {\\n        if (s > 0) return from(m);\\n        if (s < 0) {\\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\\n            // which is the only value that would overflow when negated. Therefore,\\n            // we can safely negate from(m) without checking for overflow.\\n            unchecked { return Fixed18.wrap(-1 * Fixed18.unwrap(from(m))); }\\n        }\\n        return ZERO;\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a signed integer\\n     * @param a Signed number\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 a) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\\n     * @param a Base-6 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed6 a) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed6.unwrap(a) * 1e12);\\n    }\\n\\n    /**\\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\\n     * @param a Signed fixed-decimal\\n     * @return Whether the signed fixed-decimal is zero.\\n     */\\n    function isZero(Fixed18 a) internal pure returns (bool) {\\n        return Fixed18.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting summed signed fixed-decimal\\n     */\\n    function add(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) + Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts signed fixed-decimal `b` from `a`\\n     * @param a Signed fixed-decimal to subtract from\\n     * @param b Signed fixed-decimal to subtract\\n     * @return Resulting subtracted signed fixed-decimal\\n     */\\n    function sub(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) - Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mul(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mulOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function div(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * BASE / Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function divOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\\n        return muldiv(a, Fixed18.wrap(b), Fixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\\n        return muldivOut(a, Fixed18.wrap(b), Fixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / Fixed18.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), Fixed18.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the signed fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(Fixed18 a, Fixed18 b) internal pure returns (uint256) {\\n        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First signed number\\n     * @param b Second signed number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(int256 a, int256 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(SignedMath.min(Fixed18.unwrap(a), Fixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(SignedMath.max(Fixed18.unwrap(a), Fixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Signed fixed-decimal\\n     * @return Truncated signed number\\n     */\\n    function truncate(Fixed18 a) internal pure returns (int256) {\\n        return Fixed18.unwrap(a) / BASE;\\n    }\\n\\n    /**\\n     * @notice Returns the sign of the signed fixed-decimal\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a Signed fixed-decimal\\n     * @return Sign of the signed fixed-decimal\\n     */\\n    function sign(Fixed18 a) internal pure returns (int256) {\\n        if (Fixed18.unwrap(a) > 0) return 1;\\n        if (Fixed18.unwrap(a) < 0) return -1;\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Returns the absolute value of the signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return Absolute value of the signed fixed-decimal\\n     */\\n    function abs(Fixed18 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(SignedMath.abs(Fixed18.unwrap(a)));\\n    }\\n}\\n\\nlibrary Fixed18StorageLib {\\n    function read(Fixed18Storage self) internal view returns (Fixed18 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Fixed18Storage self, Fixed18 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdd3541bc1dbe5ca81f996a1ed5a05a7b8c74247426aab221d1a8f37be91d0e4f\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/Fixed6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed18.sol\\\";\\nimport \\\"./UFixed6.sol\\\";\\n\\n/// @dev Fixed6 type\\ntype Fixed6 is int256;\\nusing Fixed6Lib for Fixed6 global;\\ntype Fixed6Storage is bytes32;\\nusing Fixed6StorageLib for Fixed6Storage global;\\n\\n/**\\n * @title Fixed6Lib\\n * @notice Library for the signed fixed-decimal type.\\n */\\nlibrary Fixed6Lib {\\n    error Fixed6OverflowError(uint256 value);\\n\\n    int256 private constant BASE = 1e6;\\n    Fixed6 public constant ZERO = Fixed6.wrap(0);\\n    Fixed6 public constant ONE = Fixed6.wrap(BASE);\\n    Fixed6 public constant NEG_ONE = Fixed6.wrap(-1 * BASE);\\n    Fixed6 public constant MAX = Fixed6.wrap(type(int256).max);\\n    Fixed6 public constant MIN = Fixed6.wrap(type(int256).min);\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\\n     * @param a Unsigned fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed6 a) internal pure returns (Fixed6) {\\n        uint256 value = UFixed6.unwrap(a);\\n        if (value > uint256(type(int256).max)) revert Fixed6OverflowError(value);\\n        return Fixed6.wrap(int256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\\n     * @param s Sign\\n     * @param m Unsigned fixed-decimal magnitude\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 s, UFixed6 m) internal pure returns (Fixed6) {\\n        if (s > 0) return from(m);\\n        if (s < 0) {\\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\\n            // which is the only value that would overflow when negated. Therefore,\\n            // we can safely negate from(m) without checking for overflow.\\n            unchecked { return Fixed6.wrap(-1 * Fixed6.unwrap(from(m))); }\\n        }\\n        return ZERO;\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a signed integer\\n     * @param a Signed number\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 a) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\\n     * @param a Base-18 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed18 a) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed18.unwrap(a) / 1e12);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\\n     * @param a Base-18 signed fixed-decimal\\n     * @param roundOut Whether to round the result away from zero if there is a remainder\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed18 a, bool roundOut) internal pure returns (Fixed6) {\\n        return roundOut ? Fixed6.wrap(NumberMath.divOut(Fixed18.unwrap(a), 1e12)): from(a);\\n    }\\n\\n    /**\\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\\n     * @param a Signed fixed-decimal\\n     * @return Whether the signed fixed-decimal is zero.\\n     */\\n    function isZero(Fixed6 a) internal pure returns (bool) {\\n        return Fixed6.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting summed signed fixed-decimal\\n     */\\n    function add(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) + Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts signed fixed-decimal `b` from `a`\\n     * @param a Signed fixed-decimal to subtract from\\n     * @param b Signed fixed-decimal to subtract\\n     * @return Resulting subtracted signed fixed-decimal\\n     */\\n    function sub(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) - Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mul(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mulOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function div(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * BASE / Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function divOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\\n        return muldiv(a, Fixed6.wrap(b), Fixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\\n        return muldivOut(a, Fixed6.wrap(b), Fixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / Fixed6.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), Fixed6.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the signed fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(Fixed6 a, Fixed6 b) internal pure returns (uint256) {\\n        (int256 au, int256 bu) = (Fixed6.unwrap(a), Fixed6.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First signed number\\n     * @param b Second signed number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(int256 a, int256 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(SignedMath.min(Fixed6.unwrap(a), Fixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(SignedMath.max(Fixed6.unwrap(a), Fixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Signed fixed-decimal\\n     * @return Truncated signed number\\n     */\\n    function truncate(Fixed6 a) internal pure returns (int256) {\\n        return Fixed6.unwrap(a) / BASE;\\n    }\\n\\n    /**\\n     * @notice Returns the sign of the signed fixed-decimal\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a Signed fixed-decimal\\n     * @return Sign of the signed fixed-decimal\\n     */\\n    function sign(Fixed6 a) internal pure returns (int256) {\\n        if (Fixed6.unwrap(a) > 0) return 1;\\n        if (Fixed6.unwrap(a) < 0) return -1;\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Returns the absolute value of the signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return Absolute value of the signed fixed-decimal\\n     */\\n    function abs(Fixed6 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(SignedMath.abs(Fixed6.unwrap(a)));\\n    }\\n}\\n\\nlibrary Fixed6StorageLib {\\n    function read(Fixed6Storage self) internal view returns (Fixed6 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Fixed6Storage self, Fixed6 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xba2715da2fdf9393cc5e3ce7f9a38f7bfd3b271dcbf9a7fac5245f7c3ecc4522\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/UFixed18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed18.sol\\\";\\nimport \\\"./UFixed6.sol\\\";\\n\\n/// @dev UFixed18 type\\ntype UFixed18 is uint256;\\nusing UFixed18Lib for UFixed18 global;\\ntype UFixed18Storage is bytes32;\\nusing UFixed18StorageLib for UFixed18Storage global;\\n\\n/**\\n * @title UFixed18Lib\\n * @notice Library for the unsigned fixed-decimal type.\\n */\\nlibrary UFixed18Lib {\\n    error UFixed18UnderflowError(int256 value);\\n\\n    uint256 private constant BASE = 1e18;\\n    UFixed18 public constant ZERO = UFixed18.wrap(0);\\n    UFixed18 public constant ONE = UFixed18.wrap(BASE);\\n    UFixed18 public constant MAX = UFixed18.wrap(type(uint256).max);\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(Fixed18 a) internal pure returns (UFixed18) {\\n        int256 value = Fixed18.unwrap(a);\\n        if (value < 0) revert UFixed18UnderflowError(value);\\n        return UFixed18.wrap(uint256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\\n     * @param a Unsigned number\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(uint256 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\\n     * @param a Base-6 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed6 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed6.unwrap(a) * 1e12);\\n    }\\n\\n    /**\\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\\n     * @param a Unsigned fixed-decimal\\n     * @return Whether the unsigned fixed-decimal is zero.\\n     */\\n    function isZero(UFixed18 a) internal pure returns (bool) {\\n        return UFixed18.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting summed unsigned fixed-decimal\\n     */\\n    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mul(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mulOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function div(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * BASE / UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function divOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * BASE, UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\\n        return muldiv(a, UFixed18.wrap(b), UFixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\\n        return muldivOut(a, UFixed18.wrap(b), UFixed18.wrap(c));\\n    }\\n\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / UFixed18.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), UFixed18.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(UFixed18 a, UFixed18 b) internal pure returns (uint256) {\\n        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First unsigned number\\n     * @param b Second unsigned number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(Math.min(UFixed18.unwrap(a), UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(Math.max(UFixed18.unwrap(a), UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Unsigned fixed-decimal\\n     * @return Truncated unsigned number\\n     */\\n    function truncate(UFixed18 a) internal pure returns (uint256) {\\n        return UFixed18.unwrap(a) / BASE;\\n    }\\n}\\n\\nlibrary UFixed18StorageLib {\\n    function read(UFixed18Storage self) internal view returns (UFixed18 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(UFixed18Storage self, UFixed18 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x8497089d30704af15ad095173e6e32dd38ef8f6213b8eca613182aec02d90fd4\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/UFixed6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed6.sol\\\";\\nimport \\\"./UFixed18.sol\\\";\\n\\n/// @dev UFixed6 type\\ntype UFixed6 is uint256;\\nusing UFixed6Lib for UFixed6 global;\\ntype UFixed6Storage is bytes32;\\nusing UFixed6StorageLib for UFixed6Storage global;\\n\\n/**\\n * @title UFixed6Lib\\n * @notice Library for the unsigned fixed-decimal type.\\n */\\nlibrary UFixed6Lib {\\n    error UFixed6UnderflowError(int256 value);\\n\\n    uint256 private constant BASE = 1e6;\\n    UFixed6 public constant ZERO = UFixed6.wrap(0);\\n    UFixed6 public constant ONE = UFixed6.wrap(BASE);\\n    UFixed6 public constant MAX = UFixed6.wrap(type(uint256).max);\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(Fixed6 a) internal pure returns (UFixed6) {\\n        int256 value = Fixed6.unwrap(a);\\n        if (value < 0) revert UFixed6UnderflowError(value);\\n        return UFixed6.wrap(uint256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\\n     * @param a Unsigned number\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(uint256 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\\n     * @param a Base-18 unsigned fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(UFixed18 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed18.unwrap(a) / 1e12);\\n    }\\n\\n    /**\\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\\n     * @param a Base-18 unsigned fixed-decimal\\n     * @param roundOut Whether to round the result away from zero if there is a remainder\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(UFixed18 a, bool roundOut) internal pure returns (UFixed6) {\\n        return roundOut ? UFixed6.wrap(NumberMath.divOut(UFixed18.unwrap(a), 1e12)): from(a);\\n    }\\n\\n    /**\\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\\n     * @param a Unsigned fixed-decimal\\n     * @return Whether the unsigned fixed-decimal is zero.\\n     */\\n    function isZero(UFixed6 a) internal pure returns (bool) {\\n        return UFixed6.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting summed unsigned fixed-decimal\\n     */\\n    function add(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) + UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function sub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) - UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mul(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mulOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function div(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * BASE / UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function divOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * BASE, UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\\n        return muldiv(a, UFixed6.wrap(b), UFixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\\n        return muldivOut(a, UFixed6.wrap(b), UFixed6.wrap(c));\\n    }\\n\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / UFixed6.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), UFixed6.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(UFixed6 a, UFixed6 b) internal pure returns (uint256) {\\n        (uint256 au, uint256 bu) = (UFixed6.unwrap(a), UFixed6.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First unsigned number\\n     * @param b Second unsigned number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(Math.min(UFixed6.unwrap(a), UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(Math.max(UFixed6.unwrap(a), UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Unsigned fixed-decimal\\n     * @return Truncated unsigned number\\n     */\\n    function truncate(UFixed6 a) internal pure returns (uint256) {\\n        return UFixed6.unwrap(a) / BASE;\\n    }\\n}\\n\\nlibrary UFixed6StorageLib {\\n    function read(UFixed6Storage self) internal view returns (UFixed6 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(UFixed6Storage self, UFixed6 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0b5d83bc38b4587bafd397b45b953154e12065ba3d5b755d52727dd92949b055\",\"license\":\"Apache-2.0\"},\"@equilibria/root/pid/types/PAccumulator6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\nimport \\\"./PController6.sol\\\";\\n\\n/// @dev PAccumulator6 type\\nstruct PAccumulator6 {\\n    Fixed6 _value;\\n    Fixed6 _skew;\\n}\\nusing PAccumulator6Lib for PAccumulator6 global;\\n\\n/// @title PAccumulator6Lib\\n/// @notice Accumulator for a the fixed 6-decimal PID controller. This holds the \\\"last seen state\\\" of the PID controller\\n///         and works in conjunction with the PController6 to compute the current rate.\\n/// @dev This implementation is specifically a P controller, with I_k and D_k both set to 0. In between updates, it\\n///      continues to accumulate at a linear rate based on the previous skew, but the rate is capped at the max value.\\n///      Once the rate hits the max value, it will continue to accumulate at the max value until the next update.\\nlibrary PAccumulator6Lib {\\n    /// @notice Accumulates the rate against notional given the prior and current state\\n    /// @param self The controller accumulator\\n    /// @param controller The controller configuration\\n    /// @param skew The current skew\\n    /// @param fromTimestamp The timestamp of the prior accumulation\\n    /// @param toTimestamp The current timestamp\\n    /// @param notional The notional to accumulate against\\n    /// @return accumulated The total accumulated amount\\n    function accumulate(\\n        PAccumulator6 memory self,\\n        PController6 memory controller,\\n        Fixed6 skew,\\n        uint256 fromTimestamp,\\n        uint256 toTimestamp,\\n        UFixed6 notional\\n    ) internal pure returns (Fixed6 accumulated) {\\n        // compute new value and intercept\\n        (Fixed6 newValue, UFixed6 interceptTimestamp) =\\n            controller.compute(self._value, self._skew, fromTimestamp, toTimestamp);\\n\\n        // accumulate rate within max\\n        accumulated = _accumulate(\\n            self._value.add(newValue),\\n            UFixed6Lib.from(fromTimestamp),\\n            interceptTimestamp,\\n            notional\\n        ).div(Fixed6Lib.from(2)); // rate = self._value + newValue / 2 -> divide here for added precision\\n\\n        // accumulate rate outside of max\\n        accumulated = _accumulate(\\n            newValue,\\n            interceptTimestamp,\\n            UFixed6Lib.from(toTimestamp),\\n            notional\\n        ).add(accumulated);\\n\\n        // update values\\n        self._value = newValue;\\n        self._skew = skew;\\n    }\\n\\n    /// @notice Helper function to accumulate a singular rate against notional\\n    /// @param rate The rate to accumulate\\n    /// @param fromTimestamp The timestamp to accumulate from\\n    /// @param toTimestamp The timestamp to accumulate to\\n    /// @param notional The notional to accumulate against\\n    /// @return The accumulated amount\\n    function _accumulate(\\n        Fixed6 rate,\\n        UFixed6 fromTimestamp,\\n        UFixed6 toTimestamp,\\n        UFixed6 notional\\n    ) private pure returns (Fixed6) {\\n        return rate\\n            .mul(Fixed6Lib.from(toTimestamp.sub(fromTimestamp)))\\n            .mul(Fixed6Lib.from(notional))\\n            .div(Fixed6Lib.from(365 days));\\n    }\\n}\\n\",\"keccak256\":\"0xf374a9997426cc90141334cdc8f8d3d62758be7eaefd21c5885742cc18d79a3a\",\"license\":\"Apache-2.0\"},\"@equilibria/root/pid/types/PController6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\n\\n/// @dev PController6 type\\nstruct PController6 {\\n    UFixed6 k;\\n    UFixed6 max;\\n}\\nusing PController6Lib for PController6 global;\\n\\n/// @title PController6Lib\\n/// @notice Configuration for a the fixed 6-decimal PID controller.\\n/// @dev Each second, the PID controller's value is incremented by `skew / k`, with `max` as the maximum value.\\nlibrary PController6Lib {\\n    /// @notice compute the new value and intercept timestamp based on the prior controller state\\n    /// @dev `interceptTimestamp` will never exceed `toTimestamp`\\n    /// @param self the controller configuration\\n    /// @param value the prior value\\n    /// @param skew The prior skew\\n    /// @param fromTimestamp The prior timestamp\\n    /// @param toTimestamp The current timestamp\\n    /// @return newValue the new value\\n    /// @return interceptTimestamp the timestamp at which the value will be at the max\\n    function compute(\\n        PController6 memory self,\\n        Fixed6 value,\\n        Fixed6 skew,\\n        uint256 fromTimestamp,\\n        uint256 toTimestamp\\n    ) internal pure returns (Fixed6 newValue, UFixed6 interceptTimestamp) {\\n        // compute the new value without considering the max\\n        Fixed6 newValueUncapped = value.add(\\n            Fixed6Lib.from(int256(toTimestamp - fromTimestamp))\\n                .mul(skew)\\n                .div(Fixed6Lib.from(self.k))\\n        );\\n\\n        // cap the new value at the max\\n        newValue = Fixed6Lib.from(newValueUncapped.sign(), self.max.min(newValueUncapped.abs()));\\n\\n        // compute distance and range to the resultant value\\n        (UFixed6 distance, Fixed6 range) = (UFixed6Lib.from(toTimestamp - fromTimestamp), newValueUncapped.sub(value));\\n\\n        // compute the amount of buffer into the value is outside the max\\n        UFixed6 buffer = value.abs().gt(self.max) ?\\n            UFixed6Lib.ZERO :\\n            Fixed6Lib.from(range.sign(), self.max).sub(value).abs();\\n\\n        // compute the timestamp at which the value will be at the max\\n        interceptTimestamp = range.isZero() ?\\n            UFixed6Lib.from(toTimestamp) :\\n            UFixed6Lib.from(fromTimestamp).add(distance.muldiv(buffer, range.abs())).min(UFixed6Lib.from(toTimestamp));\\n    }\\n}\\n\",\"keccak256\":\"0xcf8baa97540b3a38e0daa82d80267b9df9deaeb229efacb49ee74200cae345d4\",\"license\":\"Apache-2.0\"},\"@equilibria/root/storage/Storage.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../number/types/UFixed18.sol\\\";\\n\\n/// @dev Stored boolean slot\\ntype BoolStorage is bytes32;\\nusing BoolStorageLib for BoolStorage global;\\n\\n/// @dev Stored uint256 slot\\ntype Uint256Storage is bytes32;\\nusing Uint256StorageLib for Uint256Storage global;\\n\\n/// @dev Stored int256 slot\\ntype Int256Storage is bytes32;\\nusing Int256StorageLib for Int256Storage global;\\n\\n/// @dev Stored address slot\\ntype AddressStorage is bytes32;\\nusing AddressStorageLib for AddressStorage global;\\n\\n/// @dev Stored bytes32 slot\\ntype Bytes32Storage is bytes32;\\nusing Bytes32StorageLib for Bytes32Storage global;\\n\\n/**\\n * @title BoolStorageLib\\n * @notice Library to manage storage and retrieval of a boolean at a fixed storage slot\\n */\\nlibrary BoolStorageLib {\\n    /**\\n     * @notice Retrieves the stored value\\n     * @param self Storage slot\\n     * @return value Stored bool value\\n     */\\n    function read(BoolStorage self) internal view returns (bool value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    /**\\n     * @notice Stores the value at the specific slot\\n     * @param self Storage slot\\n     * @param value boolean value to store\\n     */\\n    function store(BoolStorage self, bool value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\\n/**\\n * @title Uint256StorageLib\\n * @notice Library to manage storage and retrieval of an uint256 at a fixed storage slot\\n */\\nlibrary Uint256StorageLib {\\n    /**\\n     * @notice Retrieves the stored value\\n     * @param self Storage slot\\n     * @return value Stored uint256 value\\n     */\\n    function read(Uint256Storage self) internal view returns (uint256 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    /**\\n     * @notice Stores the value at the specific slot\\n     * @param self Storage slot\\n     * @param value uint256 value to store\\n     */\\n    function store(Uint256Storage self, uint256 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\\n/**\\n * @title Int256StorageLib\\n * @notice Library to manage storage and retrieval of an int256 at a fixed storage slot\\n */\\nlibrary Int256StorageLib {\\n    /**\\n     * @notice Retrieves the stored value\\n     * @param self Storage slot\\n     * @return value Stored int256 value\\n     */\\n    function read(Int256Storage self) internal view returns (int256 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    /**\\n     * @notice Stores the value at the specific slot\\n     * @param self Storage slot\\n     * @param value int256 value to store\\n     */\\n    function store(Int256Storage self, int256 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\\n/**\\n * @title AddressStorageLib\\n * @notice Library to manage storage and retrieval of an address at a fixed storage slot\\n */\\nlibrary AddressStorageLib {\\n    /**\\n     * @notice Retrieves the stored value\\n     * @param self Storage slot\\n     * @return value Stored address value\\n     */\\n    function read(AddressStorage self) internal view returns (address value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    /**\\n     * @notice Stores the value at the specific slot\\n     * @param self Storage slot\\n     * @param value address value to store\\n     */\\n    function store(AddressStorage self, address value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\\n/**\\n * @title Bytes32StorageLib\\n * @notice Library to manage storage and retrieval of a bytes32 at a fixed storage slot\\n */\\nlibrary Bytes32StorageLib {\\n    /**\\n     * @notice Retrieves the stored value\\n     * @param self Storage slot\\n     * @return value Stored bytes32 value\\n     */\\n    function read(Bytes32Storage self) internal view returns (bytes32 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    /**\\n     * @notice Stores the value at the specific slot\\n     * @param self Storage slot\\n     * @param value bytes32 value to store\\n     */\\n    function store(Bytes32Storage self, bytes32 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf904e2f3ded161530d179eca7f405de56db377f4770e236589940b943ef0dee9\",\"license\":\"Apache-2.0\"},\"@equilibria/root/token/types/Token18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../../number/types/UFixed18.sol\\\";\\n\\n/// @dev Token18\\ntype Token18 is address;\\nusing Token18Lib for Token18 global;\\ntype Token18Storage is bytes32;\\nusing Token18StorageLib for Token18Storage global;\\n\\n/**\\n * @title Token18Lib\\n * @notice Library to manage 18-decimal ERC20s that is compliant with the fixed-decimal types.\\n * @dev Maintains significant gas savings over other Token implementations since no conversion take place\\n */\\nlibrary Token18Lib {\\n    using SafeERC20 for IERC20;\\n\\n    Token18 public constant ZERO = Token18.wrap(address(0));\\n\\n    /**\\n     * @notice Returns whether a token is the zero address\\n     * @param self Token to check for\\n     * @return Whether the token is the zero address\\n     */\\n    function isZero(Token18 self) internal pure returns (bool) {\\n        return Token18.unwrap(self) == Token18.unwrap(ZERO);\\n    }\\n\\n    /**\\n     * @notice Returns whether the two tokens are equal\\n     * @param a First token to compare\\n     * @param b Second token to compare\\n     * @return Whether the two tokens are equal\\n     */\\n    function eq(Token18 a, Token18 b) internal pure returns (bool) {\\n        return Token18.unwrap(a) ==  Token18.unwrap(b);\\n    }\\n\\n    /**\\n     * @notice Approves `grantee` to spend infinite tokens from the caller\\n     * @dev Uses `approve` rather than `safeApprove` since the race condition\\n     *      in safeApprove does not apply when going to an infinite approval\\n     * @param self Token to grant approval\\n     * @param grantee Address to allow spending\\n     */\\n    function approve(Token18 self, address grantee) internal {\\n        IERC20(Token18.unwrap(self)).approve(grantee, type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice Approves `grantee` to spend `amount` tokens from the caller\\n     * @dev There are important race conditions to be aware of when using this function\\n            with values other than 0. This will revert if moving from non-zero to non-zero amounts\\n            See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a55b7d13722e7ce850b626da2313f3e66ca1d101/contracts/token/ERC20/IERC20.sol#L57\\n     * @param self Token to grant approval\\n     * @param grantee Address to allow spending\\n     * @param amount Amount of tokens to approve to spend\\n     */\\n    function approve(Token18 self, address grantee, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeApprove(grantee, UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers all held tokens from the caller to the `recipient`\\n     * @param self Token to transfer\\n     * @param recipient Address to receive the tokens\\n     */\\n    function push(Token18 self, address recipient) internal {\\n        push(self, recipient, balanceOf(self, address(this)));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the caller to the `recipient`\\n     * @param self Token to transfer\\n     * @param recipient Address to transfer tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function push(Token18 self, address recipient, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeTransfer(recipient, UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the `benefactor` to the caller\\n     * @dev Reverts if trying to pull Ether\\n     * @param self Token to transfer\\n     * @param benefactor Address to transfer tokens from\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function pull(Token18 self, address benefactor, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, address(this), UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`\\n     * @dev Reverts if trying to pull Ether\\n     * @param self Token to transfer\\n     * @param benefactor Address to transfer tokens from\\n     * @param recipient Address to transfer tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function pullTo(Token18 self, address benefactor, address recipient, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, recipient, UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Returns the name of the token\\n     * @param self Token to check for\\n     * @return Token name\\n     */\\n    function name(Token18 self) internal view returns (string memory) {\\n        return IERC20Metadata(Token18.unwrap(self)).name();\\n    }\\n\\n    /**\\n     * @notice Returns the symbol of the token\\n     * @param self Token to check for\\n     * @return Token symbol\\n     */\\n    function symbol(Token18 self) internal view returns (string memory) {\\n        return IERC20Metadata(Token18.unwrap(self)).symbol();\\n    }\\n\\n    /**\\n     * @notice Returns the `self` token balance of the caller\\n     * @param self Token to check for\\n     * @return Token balance of the caller\\n     */\\n    function balanceOf(Token18 self) internal view returns (UFixed18) {\\n        return balanceOf(self, address(this));\\n    }\\n\\n    /**\\n     * @notice Returns the `self` token balance of `account`\\n     * @param self Token to check for\\n     * @param account Account to check\\n     * @return Token balance of the account\\n     */\\n    function balanceOf(Token18 self, address account) internal view returns (UFixed18) {\\n        return UFixed18.wrap(IERC20(Token18.unwrap(self)).balanceOf(account));\\n    }\\n}\\n\\nlibrary Token18StorageLib {\\n    function read(Token18Storage self) internal view returns (Token18 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Token18Storage self, Token18 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa3f5e199ddf06e17cb492c99dc44a36d01cff8c28b4c57a62c1a330014d20ff7\",\"license\":\"Apache-2.0\"},\"@equilibria/root/token/types/Token6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\n\\n/// @dev Token6\\ntype Token6 is address;\\nusing Token6Lib for Token6 global;\\ntype Token6Storage is bytes32;\\nusing Token6StorageLib for Token6Storage global;\\n\\n/**\\n * @title Token6Lib\\n * @notice Library to manage 6-decimal ERC20s that is compliant with the fixed-decimal types.\\n */\\nlibrary Token6Lib {\\n    using SafeERC20 for IERC20;\\n\\n    Token6 public constant ZERO = Token6.wrap(address(0));\\n\\n    /**\\n     * @notice Returns whether a token is the zero address\\n     * @param self Token to check for\\n     * @return Whether the token is the zero address\\n     */\\n    function isZero(Token6 self) internal pure returns (bool) {\\n        return Token6.unwrap(self) == Token6.unwrap(ZERO);\\n    }\\n\\n    /**\\n     * @notice Returns whether the two tokens are equal\\n     * @param a First token to compare\\n     * @param b Second token to compare\\n     * @return Whether the two tokens are equal\\n     */\\n    function eq(Token6 a, Token6 b) internal pure returns (bool) {\\n        return Token6.unwrap(a) ==  Token6.unwrap(b);\\n    }\\n\\n    /**\\n     * @notice Approves `grantee` to spend infinite tokens from the caller\\n     * @dev Uses `approve` rather than `safeApprove` since the race condition\\n     *      in safeApprove does not apply when going to an infinite approval\\n     * @param self Token to grant approval\\n     * @param self Token to grant approval\\n     * @param grantee Address to allow spending\\n     */\\n    function approve(Token6 self, address grantee) internal {\\n        IERC20(Token6.unwrap(self)).approve(grantee, type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice Approves `grantee` to spend `amount` tokens from the caller\\n     * @dev There are important race conditions to be aware of when using this function\\n            with values other than 0. This will revert if moving from non-zero to non-zero amounts\\n            See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a55b7d13722e7ce850b626da2313f3e66ca1d101/contracts/token/ERC20/IERC20.sol#L57\\n     * @param self Token to grant approval\\n     * @param self Token to grant approval\\n     * @param grantee Address to allow spending\\n     * @param amount Amount of tokens to approve to spend\\n     */\\n    function approve(Token6 self, address grantee, UFixed6 amount) internal {\\n        IERC20(Token6.unwrap(self)).safeApprove(grantee, UFixed6.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers all held tokens from the caller to the `recipient`\\n     * @param self Token to transfer\\n     * @param recipient Address to receive the tokens\\n     */\\n    function push(Token6 self, address recipient) internal {\\n        push(self, recipient, balanceOf(self, address(this)));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the caller to the `recipient`\\n     * @param self Token to transfer\\n     * @param recipient Address to transfer tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function push(Token6 self, address recipient, UFixed6 amount) internal {\\n        IERC20(Token6.unwrap(self)).safeTransfer(recipient, UFixed6.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the `benefactor` to the caller\\n     * @dev Reverts if trying to pull Ether\\n     * @param self Token to transfer\\n     * @param benefactor Address to transfer tokens from\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function pull(Token6 self, address benefactor, UFixed6 amount) internal {\\n        IERC20(Token6.unwrap(self)).safeTransferFrom(benefactor, address(this), UFixed6.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`\\n     * @dev Reverts if trying to pull Ether\\n     * @param self Token to transfer\\n     * @param benefactor Address to transfer tokens from\\n     * @param recipient Address to transfer tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function pullTo(Token6 self, address benefactor, address recipient, UFixed6 amount) internal {\\n        IERC20(Token6.unwrap(self)).safeTransferFrom(benefactor, recipient, UFixed6.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Returns the name of the token\\n     * @param self Token to check for\\n     * @return Token name\\n     */\\n    function name(Token6 self) internal view returns (string memory) {\\n        return IERC20Metadata(Token6.unwrap(self)).name();\\n    }\\n\\n    /**\\n     * @notice Returns the symbol of the token\\n     * @param self Token to check for\\n     * @return Token symbol\\n     */\\n    function symbol(Token6 self) internal view returns (string memory) {\\n        return IERC20Metadata(Token6.unwrap(self)).symbol();\\n    }\\n\\n    /**\\n     * @notice Returns the `self` token balance of the caller\\n     * @param self Token to check for\\n     * @return Token balance of the caller\\n     */\\n    function balanceOf(Token6 self) internal view returns (UFixed6) {\\n        return balanceOf(self, address(this));\\n    }\\n\\n    /**\\n     * @notice Returns the `self` token balance of `account`\\n     * @param self Token to check for\\n     * @param account Account to check\\n     * @return Token balance of the account\\n     */\\n    function balanceOf(Token6 self, address account) internal view returns (UFixed6) {\\n        return UFixed6.wrap(IERC20(Token6.unwrap(self)).balanceOf(account));\\n    }\\n}\\n\\nlibrary Token6StorageLib {\\n    function read(Token6Storage self) internal view returns (Token6 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Token6Storage self, Token6 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0a2ea7d48448061db8614172d11a48f97229b7341b1e83413d2622f9dd55f623\",\"license\":\"Apache-2.0\"},\"@equilibria/root/utilization/CurveMath6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../number/types/UFixed6.sol\\\";\\nimport \\\"../number/types/Fixed6.sol\\\";\\n\\n/**\\n * @title CurveMath6\\n * @notice Library for managing math operations for utilization curves.\\n */\\nlibrary CurveMath6 {\\n    error CurveMath6OutOfBoundsError();\\n\\n    /**\\n     * @notice Computes a linear interpolation between two points\\n     * @param startX First point's x-coordinate\\n     * @param startY First point's y-coordinate\\n     * @param endX Second point's x-coordinate\\n     * @param endY Second point's y-coordinate\\n     * @param targetX x-coordinate to interpolate\\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\\n     */\\n    function linearInterpolation(\\n        UFixed6 startX,\\n        Fixed6 startY,\\n        UFixed6 endX,\\n        Fixed6 endY,\\n        UFixed6 targetX\\n    ) internal pure returns (Fixed6) {\\n        if (targetX.lt(startX) || targetX.gt(endX)) revert CurveMath6OutOfBoundsError();\\n\\n        UFixed6 xRange = endX.sub(startX);\\n        Fixed6 yRange = endY.sub(startY);\\n        UFixed6 xRatio = targetX.sub(startX).div(xRange);\\n        return yRange.mul(Fixed6Lib.from(xRatio)).add(startY);\\n    }\\n\\n    /**\\n     * @notice Computes a linear interpolation between two points\\n     * @param startX First point's x-coordinate\\n     * @param startY First point's y-coordinate\\n     * @param endX Second point's x-coordinate\\n     * @param endY Second point's y-coordinate\\n     * @param targetX x-coordinate to interpolate\\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\\n     */\\n    function linearInterpolation(\\n        UFixed6 startX,\\n        UFixed6 startY,\\n        UFixed6 endX,\\n        UFixed6 endY,\\n        UFixed6 targetX\\n    ) internal pure returns (UFixed6) {\\n        return UFixed6Lib.from(linearInterpolation(startX, Fixed6Lib.from(startY), endX, Fixed6Lib.from(endY), targetX));\\n    }\\n}\\n\",\"keccak256\":\"0xb2fc0e4473772b0a48f7282ac06bf1e86cea7cf0c788e406692e2d723633d549\",\"license\":\"Apache-2.0\"},\"@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../CurveMath6.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\n\\n/// @dev UJumpRateUtilizationCurve6 type\\nstruct UJumpRateUtilizationCurve6 {\\n    UFixed6 minRate;\\n    UFixed6 maxRate;\\n    UFixed6 targetRate;\\n    UFixed6 targetUtilization;\\n}\\nusing UJumpRateUtilizationCurve6Lib for UJumpRateUtilizationCurve6 global;\\n\\n/**\\n * @title UJumpRateUtilizationCurve6Lib\\n * @notice Library for the unsigned base-6 Jump Rate utilization curve type\\n */\\nlibrary UJumpRateUtilizationCurve6Lib {\\n    /**\\n     * @notice Computes the corresponding rate for a utilization ratio\\n     * @param utilization The utilization ratio\\n     * @return The corresponding rate\\n     */\\n    function compute(UJumpRateUtilizationCurve6 memory self, UFixed6 utilization) internal pure returns (UFixed6) {\\n        if (utilization.lt(self.targetUtilization)) {\\n            return CurveMath6.linearInterpolation(\\n                UFixed6Lib.ZERO,\\n                self.minRate,\\n                self.targetUtilization,\\n                self.targetRate,\\n                utilization\\n            );\\n        }\\n        if (utilization.lt(UFixed6Lib.ONE)) {\\n            return CurveMath6.linearInterpolation(\\n                self.targetUtilization,\\n                self.targetRate,\\n                UFixed6Lib.ONE,\\n                self.maxRate,\\n                utilization\\n            );\\n        }\\n        return self.maxRate;\\n    }\\n\\n    function accumulate(\\n        UJumpRateUtilizationCurve6 memory self,\\n        UFixed6 utilization,\\n        uint256 fromTimestamp,\\n        uint256 toTimestamp,\\n        UFixed6 notional\\n    ) internal pure returns (UFixed6) {\\n        return compute(self, utilization)\\n            .mul(UFixed6Lib.from(toTimestamp - fromTimestamp))\\n            .mul(notional)\\n            .div(UFixed6Lib.from(365 days));\\n    }\\n}\\n\",\"keccak256\":\"0xfc568a2f1a98e3659a2f4142f916e057fe6bf1ac70feb04ced81072d742c22e7\",\"license\":\"Apache-2.0\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9b72f93be69ca894d8492c244259615c4a742afc8d63720dbc8bb81087d9b238\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Library for managing\\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\\n * types.\\n *\\n * Sets have the following properties:\\n *\\n * - Elements are added, removed, and checked for existence in constant time\\n * (O(1)).\\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\\n *\\n * ```\\n * contract Example {\\n *     // Add the library methods\\n *     using EnumerableSet for EnumerableSet.AddressSet;\\n *\\n *     // Declare a set state variable\\n *     EnumerableSet.AddressSet private mySet;\\n * }\\n * ```\\n *\\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\\n * and `uint256` (`UintSet`) are supported.\\n *\\n * [WARNING]\\n * ====\\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\\n * unusable.\\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\\n *\\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\\n * array of EnumerableSet.\\n * ====\\n */\\nlibrary EnumerableSet {\\n    // To implement this library for multiple types with as little code\\n    // repetition as possible, we write it in terms of a generic Set type with\\n    // bytes32 values.\\n    // The Set implementation uses private functions, and user-facing\\n    // implementations (such as AddressSet) are just wrappers around the\\n    // underlying Set.\\n    // This means that we can only create new EnumerableSets for types that fit\\n    // in bytes32.\\n\\n    struct Set {\\n        // Storage of set values\\n        bytes32[] _values;\\n        // Position of the value in the `values` array, plus 1 because index 0\\n        // means a value is not in the set.\\n        mapping(bytes32 => uint256) _indexes;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function _add(Set storage set, bytes32 value) private returns (bool) {\\n        if (!_contains(set, value)) {\\n            set._values.push(value);\\n            // The value is stored at length-1, but we add 1 to all indexes\\n            // and use 0 as a sentinel value\\n            set._indexes[value] = set._values.length;\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\\n        // We read and store the value's index to prevent multiple reads from the same storage slot\\n        uint256 valueIndex = set._indexes[value];\\n\\n        if (valueIndex != 0) {\\n            // Equivalent to contains(set, value)\\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\\n            // This modifies the order of the array, as noted in {at}.\\n\\n            uint256 toDeleteIndex = valueIndex - 1;\\n            uint256 lastIndex = set._values.length - 1;\\n\\n            if (lastIndex != toDeleteIndex) {\\n                bytes32 lastValue = set._values[lastIndex];\\n\\n                // Move the last value to the index where the value to delete is\\n                set._values[toDeleteIndex] = lastValue;\\n                // Update the index for the moved value\\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\\n            }\\n\\n            // Delete the slot where the moved value was stored\\n            set._values.pop();\\n\\n            // Delete the index for the deleted slot\\n            delete set._indexes[value];\\n\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\\n        return set._indexes[value] != 0;\\n    }\\n\\n    /**\\n     * @dev Returns the number of values on the set. O(1).\\n     */\\n    function _length(Set storage set) private view returns (uint256) {\\n        return set._values.length;\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\\n        return set._values[index];\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function _values(Set storage set) private view returns (bytes32[] memory) {\\n        return set._values;\\n    }\\n\\n    // Bytes32Set\\n\\n    struct Bytes32Set {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _add(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\\n        return _remove(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\\n        return _contains(set._inner, value);\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(Bytes32Set storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\\n        return _at(set._inner, index);\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        bytes32[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // AddressSet\\n\\n    struct AddressSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(AddressSet storage set, address value) internal returns (bool) {\\n        return _add(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(AddressSet storage set, address value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(AddressSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\\n        return address(uint160(uint256(_at(set._inner, index))));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(AddressSet storage set) internal view returns (address[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        address[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n\\n    // UintSet\\n\\n    struct UintSet {\\n        Set _inner;\\n    }\\n\\n    /**\\n     * @dev Add a value to a set. O(1).\\n     *\\n     * Returns true if the value was added to the set, that is if it was not\\n     * already present.\\n     */\\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _add(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Removes a value from a set. O(1).\\n     *\\n     * Returns true if the value was removed from the set, that is if it was\\n     * present.\\n     */\\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\\n        return _remove(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns true if the value is in the set. O(1).\\n     */\\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\\n        return _contains(set._inner, bytes32(value));\\n    }\\n\\n    /**\\n     * @dev Returns the number of values in the set. O(1).\\n     */\\n    function length(UintSet storage set) internal view returns (uint256) {\\n        return _length(set._inner);\\n    }\\n\\n    /**\\n     * @dev Returns the value stored at position `index` in the set. O(1).\\n     *\\n     * Note that there are no guarantees on the ordering of values inside the\\n     * array, and it may change when more values are added or removed.\\n     *\\n     * Requirements:\\n     *\\n     * - `index` must be strictly less than {length}.\\n     */\\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\\n        return uint256(_at(set._inner, index));\\n    }\\n\\n    /**\\n     * @dev Return the entire set in an array\\n     *\\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\\n     */\\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\\n        bytes32[] memory store = _values(set._inner);\\n        uint256[] memory result;\\n\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            result := store\\n        }\\n\\n        return result;\\n    }\\n}\\n\",\"keccak256\":\"0xc3ff3f5c4584e1d9a483ad7ced51ab64523201f4e3d3c65293e4ca8aeb77a961\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a03461006157601f61161038819003918201601f19168301916001600160401b03831184841017610066578084926020946040528339810103126100615751608052604051611593908161007d823960805181818161046701526109720152f35b600080fd5b634e487b7160e01b600052604160045260246000fdfe60406080815260048036101561001457600080fd5b600091823560e01c8063200d2ed214610e3f5780633537d3fa14610cfe5780633c4c6a2814610a245780634c8fe526146109e957806352bfe7891461099557806370dea79a1461093c5780638129fc1c146107fd57806387aee00e146107b85780638fdd5947146103a85780639fa6a6e314610366578063a05f9906146102df578063b17141d414610236578063c45a0155146101c0578063e0886f901461015b5763fdff89ed146100c557600080fd5b3461015757602091827ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261015357358352600382528083209281518093808654928381520195835280832092905b82821061013c57610138868661012e828b0383610f52565b5191829182610f93565b0390f35b835487529586019560019384019390910190610116565b8380fd5b8280fd5b5082346101bd5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101bd57506101bb61019c606093356112a4565b9151809260408091805184526020810151602085015201511515910152565bf35b80fd5b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102325760209073ffffffffffffffffffffffffffffffffffffffff7f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b54169051908152f35b5080fd5b503461015757807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101575760243573ffffffffffffffffffffffffffffffffffffffff81168091036101535782358452602092835281842090845282528083209281518093808654928381520195835280832092905b8282106102c857610138868661012e828b0383610f52565b8354875295860195600193840193909101906102b0565b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102325760609061031a610fe4565b5080519061032782610ef3565b60015467ffffffffffffffff908180821694858152818560208301928286831c168452019360801c168352845195865251166020850152511690820152f35b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610232576020906103a16111f0565b9051908152f35b50346101575760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101575780516103e381610ef3565b82358152602093848201602480358252604480359283151584036107b45786860193845273ffffffffffffffffffffffffffffffffffffffff93847f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b541633036107865786511561075e578651610458611003565b036106dd57610465611003565b7f000000000000000000000000000000000000000000000000000000000000000081018091116106b257421115610670575b50506001547fffffffffffffffff0000000000000000ffffffffffffffffffffffffffffffff77ffffffffffffffff000000000000000000000000000000006104ec67ffffffffffffffff8460801c1661105e565b60801b169116176001556001965b67ffffffffffffffff865116936001947fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008654161785558486905b61058c575b8a8a8a7fec385e1ce54a8e9d6a576269ae097576195191e829639205064f4172cd4254c560608c6105838451809260408091805184526020810151602085015201511515910152565ba1519015158152f35b875187526003808c528988205482101561066a578290895189526105b2838c8b206112fc565b9054911b1c16803b156106665787809160c48c51809481937f91eece28000000000000000000000000000000000000000000000000000000008352818a8401527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808d850152808c85015260648401528160848401528160a48401525af1801561065c5790610647929161064d575b506112cf565b85610535565b61065690610f3e565b38610641565b8a513d8a823e3d90fd5b8780fd5b5061053a565b511561068a57518551855260028952868520553880610497565b8787517fce9529c8000000000000000000000000000000000000000000000000000000008152fd5b848760118c7f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b511561068a57855167ffffffffffffffff600154161080159061073b575b610713575185518552600289528685205583966104fa565b8787517fb8499c31000000000000000000000000000000000000000000000000000000008152fd5b50610744611003565b151580156106fb57508551610757611003565b11156106fb565b8888517fb8499c31000000000000000000000000000000000000000000000000000000008152fd5b87517f864ec51e00000000000000000000000000000000000000000000000000000000815233818b01528490fd5b8480fd5b5090346101575760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261015757602092829135815280845220549051908152f35b50903461015757827ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610157577f6fee9688c285c5c5c97d6a1a29adced674e6b2ad0888b8ad2116b58a8b3ea24860018154101561090c5760019055303b151580610905575b6108de575060207fbe9b076dc5b65990cca9dd9d7366682482e7817a6f6bc7f4faf4dc32af497f3291337f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b55837f2801b00eb06461cf9fcb9758b5fafd884ff06a86177386f73b6c49f0bf5a5af0555160018152a180f35b90517fb9a621e1000000000000000000000000000000000000000000000000000000008152fd5b5082610866565b50600160249251917f3db738da000000000000000000000000000000000000000000000000000000008352820152fd5b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261023257602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610232576060906109d0610fe4565b506101bb61019c67ffffffffffffffff600154166112a4565b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610232576020906103a1611003565b50346101575760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261015757610a5c610ecb565b90602490813591604480359573ffffffffffffffffffffffffffffffffffffffff90817f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b54163303610ccf5785895260209281845282868b20981697888b528452858a20926001998867ffffffffffffffff8c541610610ca7578015610c7f57845415610c7f578b8b5b610aee578c80f35b81811080610c75575b15610c7157855415610c4657858d528c8388822054168c3b15610232578982828f8a8f60c4928c86925197889687957f91eece280000000000000000000000000000000000000000000000000000000087528601527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9182809287015285015260648401528160848401528160a48401525af18015610c3c578e8e8e858e610bd18f98610c279b9a997fda047edd71891c1b3d6c5798c36a45e6f8d127c20d1a3173394a85d7d20fe70599610c1f99610c2d575b50611404565b50825194610bde86610ef3565b8552840152820152606090604080519173ffffffffffffffffffffffffffffffffffffffff8082511684526020820151166020840152015160408201522090565b9180a26112cf565b8b610ae6565b610c3690610f3e565b38610bcb565b8c513d85823e3d90fd5b878d6032877f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b8c80f35b5085541515610af7565b8388517f4889ef6f000000000000000000000000000000000000000000000000000000008152fd5b8388517fb8499c31000000000000000000000000000000000000000000000000000000008152fd5b83908551907f864ec51e0000000000000000000000000000000000000000000000000000000082523390820152fd5b5082903461023257807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261023257610d37610ecb565b6024359173ffffffffffffffffffffffffffffffffffffffff80841684036107b45760206024917f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b54168351928380927fb9181611000000000000000000000000000000000000000000000000000000008252338b8301525afa908115610e35578591610dfb575b5015610dd3575090610dd091611077565b80f35b8490517f652fafab000000000000000000000000000000000000000000000000000000008152fd5b90506020813d8211610e2d575b81610e1560209383610f52565b810103126107b4575180151581036107b45786610dbf565b3d9150610e08565b82513d87823e3d90fd5b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261023257608090610e7a610fe4565b50610e83610fe4565b50610e9967ffffffffffffffff600154166112a4565b90610ec4610ea56111f0565b9151809360408091805184526020810151602085015201511515910152565b6060820152f35b6004359073ffffffffffffffffffffffffffffffffffffffff82168203610eee57565b600080fd5b6060810190811067ffffffffffffffff821117610f0f57604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b67ffffffffffffffff8111610f0f57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610f0f57604052565b6020908160408183019282815285518094520193019160005b828110610fba575050505090565b835173ffffffffffffffffffffffffffffffffffffffff1685529381019392810192600101610fac565b60405190610ff182610ef3565b60006040838281528260208201520152565b67ffffffffffffffff600181815460801c160181811161102f5716600052600060205260406000205490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b67ffffffffffffffff80911690811461102f5760010190565b61107f6111f0565b91600090838252611129602093600385526040926110d8848620926110bc73ffffffffffffffffffffffffffffffffffffffff8092168095611343565b5088875260048852858720848852885285872092168092611343565b508351916110e583610ef3565b8252858201528583820152606090604080519173ffffffffffffffffffffffffffffffffffffffff8082511684526020820151166020840152015160408201522090565b7fb9af0ac6e0a644ab539eb460932d707159b3369e5f30f3d9aa26d6eb6535c2a98380a26001549067ffffffffffffffff938483831c16908185528481528683862054146111e7577f0bde08c9a082227535f7f1dd9bbb37ae1735f37377422d16744f0ffce41cf01295879461119f879461105e565b907fffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff6fffffffffffffffff000000000000000083881b169116176001551682525282205580a2565b50505050505050565b6004602073ffffffffffffffffffffffffffffffffffffffff7f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b5416604051928380927f9fa6a6e30000000000000000000000000000000000000000000000000000000082525afa9081156112985760009161126a575090565b906020823d8211611290575b8161128360209383610f52565b810103126101bd57505190565b3d9150611276565b6040513d6000823e3d90fd5b906112ad610fe4565b9180600052600260205260406000205490816020850152835215156040830152565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff811461102f5760010190565b80548210156113145760005260206000200190600090565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b919060018301600090828252806020526040822054156000146113fe57845494680100000000000000008610156113d157836113c161138c886001604098999a018555846112fc565b81939154907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9060031b92831b921b19161790565b9055549382526020522055600190565b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526041600452fd5b50925050565b90600182019060009281845282602052604084205490811515600014611556577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff91828101818111611529578254908482019182116114fc578082036114c7575b5050508054801561149a5782019161147d83836112fc565b909182549160031b1b191690555582526020526040812055600190565b6024867f4e487b710000000000000000000000000000000000000000000000000000000081526031600452fd5b6114e76114d761138c93866112fc565b90549060031b1c928392866112fc565b90558652846020526040862055388080611465565b6024887f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b6024877f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b505050509056fea264697066735822122091d12b4d59d187ebd683a3e893ed763a47ca6150fbd6bb06765aac95d618970b64736f6c63430008130033",
  "deployedBytecode": "0x60406080815260048036101561001457600080fd5b600091823560e01c8063200d2ed214610e3f5780633537d3fa14610cfe5780633c4c6a2814610a245780634c8fe526146109e957806352bfe7891461099557806370dea79a1461093c5780638129fc1c146107fd57806387aee00e146107b85780638fdd5947146103a85780639fa6a6e314610366578063a05f9906146102df578063b17141d414610236578063c45a0155146101c0578063e0886f901461015b5763fdff89ed146100c557600080fd5b3461015757602091827ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261015357358352600382528083209281518093808654928381520195835280832092905b82821061013c57610138868661012e828b0383610f52565b5191829182610f93565b0390f35b835487529586019560019384019390910190610116565b8380fd5b8280fd5b5082346101bd5760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101bd57506101bb61019c606093356112a4565b9151809260408091805184526020810151602085015201511515910152565bf35b80fd5b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102325760209073ffffffffffffffffffffffffffffffffffffffff7f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b54169051908152f35b5080fd5b503461015757807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101575760243573ffffffffffffffffffffffffffffffffffffffff81168091036101535782358452602092835281842090845282528083209281518093808654928381520195835280832092905b8282106102c857610138868661012e828b0383610f52565b8354875295860195600193840193909101906102b0565b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126102325760609061031a610fe4565b5080519061032782610ef3565b60015467ffffffffffffffff908180821694858152818560208301928286831c168452019360801c168352845195865251166020850152511690820152f35b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610232576020906103a16111f0565b9051908152f35b50346101575760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126101575780516103e381610ef3565b82358152602093848201602480358252604480359283151584036107b45786860193845273ffffffffffffffffffffffffffffffffffffffff93847f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b541633036107865786511561075e578651610458611003565b036106dd57610465611003565b7f000000000000000000000000000000000000000000000000000000000000000081018091116106b257421115610670575b50506001547fffffffffffffffff0000000000000000ffffffffffffffffffffffffffffffff77ffffffffffffffff000000000000000000000000000000006104ec67ffffffffffffffff8460801c1661105e565b60801b169116176001556001965b67ffffffffffffffff865116936001947fffffffffffffffffffffffffffffffffffffffffffffffff00000000000000008654161785558486905b61058c575b8a8a8a7fec385e1ce54a8e9d6a576269ae097576195191e829639205064f4172cd4254c560608c6105838451809260408091805184526020810151602085015201511515910152565ba1519015158152f35b875187526003808c528988205482101561066a578290895189526105b2838c8b206112fc565b9054911b1c16803b156106665787809160c48c51809481937f91eece28000000000000000000000000000000000000000000000000000000008352818a8401527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808d850152808c85015260648401528160848401528160a48401525af1801561065c5790610647929161064d575b506112cf565b85610535565b61065690610f3e565b38610641565b8a513d8a823e3d90fd5b8780fd5b5061053a565b511561068a57518551855260028952868520553880610497565b8787517fce9529c8000000000000000000000000000000000000000000000000000000008152fd5b848760118c7f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b511561068a57855167ffffffffffffffff600154161080159061073b575b610713575185518552600289528685205583966104fa565b8787517fb8499c31000000000000000000000000000000000000000000000000000000008152fd5b50610744611003565b151580156106fb57508551610757611003565b11156106fb565b8888517fb8499c31000000000000000000000000000000000000000000000000000000008152fd5b87517f864ec51e00000000000000000000000000000000000000000000000000000000815233818b01528490fd5b8480fd5b5090346101575760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261015757602092829135815280845220549051908152f35b50903461015757827ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610157577f6fee9688c285c5c5c97d6a1a29adced674e6b2ad0888b8ad2116b58a8b3ea24860018154101561090c5760019055303b151580610905575b6108de575060207fbe9b076dc5b65990cca9dd9d7366682482e7817a6f6bc7f4faf4dc32af497f3291337f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b55837f2801b00eb06461cf9fcb9758b5fafd884ff06a86177386f73b6c49f0bf5a5af0555160018152a180f35b90517fb9a621e1000000000000000000000000000000000000000000000000000000008152fd5b5082610866565b50600160249251917f3db738da000000000000000000000000000000000000000000000000000000008352820152fd5b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261023257602090517f00000000000000000000000000000000000000000000000000000000000000008152f35b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610232576060906109d0610fe4565b506101bb61019c67ffffffffffffffff600154166112a4565b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610232576020906103a1611003565b50346101575760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261015757610a5c610ecb565b90602490813591604480359573ffffffffffffffffffffffffffffffffffffffff90817f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b54163303610ccf5785895260209281845282868b20981697888b528452858a20926001998867ffffffffffffffff8c541610610ca7578015610c7f57845415610c7f578b8b5b610aee578c80f35b81811080610c75575b15610c7157855415610c4657858d528c8388822054168c3b15610232578982828f8a8f60c4928c86925197889687957f91eece280000000000000000000000000000000000000000000000000000000087528601527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9182809287015285015260648401528160848401528160a48401525af18015610c3c578e8e8e858e610bd18f98610c279b9a997fda047edd71891c1b3d6c5798c36a45e6f8d127c20d1a3173394a85d7d20fe70599610c1f99610c2d575b50611404565b50825194610bde86610ef3565b8552840152820152606090604080519173ffffffffffffffffffffffffffffffffffffffff8082511684526020820151166020840152015160408201522090565b9180a26112cf565b8b610ae6565b610c3690610f3e565b38610bcb565b8c513d85823e3d90fd5b878d6032877f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b8c80f35b5085541515610af7565b8388517f4889ef6f000000000000000000000000000000000000000000000000000000008152fd5b8388517fb8499c31000000000000000000000000000000000000000000000000000000008152fd5b83908551907f864ec51e0000000000000000000000000000000000000000000000000000000082523390820152fd5b5082903461023257807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261023257610d37610ecb565b6024359173ffffffffffffffffffffffffffffffffffffffff80841684036107b45760206024917f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b54168351928380927fb9181611000000000000000000000000000000000000000000000000000000008252338b8301525afa908115610e35578591610dfb575b5015610dd3575090610dd091611077565b80f35b8490517f652fafab000000000000000000000000000000000000000000000000000000008152fd5b90506020813d8211610e2d575b81610e1560209383610f52565b810103126107b4575180151581036107b45786610dbf565b3d9150610e08565b82513d87823e3d90fd5b83823461023257817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261023257608090610e7a610fe4565b50610e83610fe4565b50610e9967ffffffffffffffff600154166112a4565b90610ec4610ea56111f0565b9151809360408091805184526020810151602085015201511515910152565b6060820152f35b6004359073ffffffffffffffffffffffffffffffffffffffff82168203610eee57565b600080fd5b6060810190811067ffffffffffffffff821117610f0f57604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b67ffffffffffffffff8111610f0f57604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff821117610f0f57604052565b6020908160408183019282815285518094520193019160005b828110610fba575050505090565b835173ffffffffffffffffffffffffffffffffffffffff1685529381019392810192600101610fac565b60405190610ff182610ef3565b60006040838281528260208201520152565b67ffffffffffffffff600181815460801c160181811161102f5716600052600060205260406000205490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b67ffffffffffffffff80911690811461102f5760010190565b61107f6111f0565b91600090838252611129602093600385526040926110d8848620926110bc73ffffffffffffffffffffffffffffffffffffffff8092168095611343565b5088875260048852858720848852885285872092168092611343565b508351916110e583610ef3565b8252858201528583820152606090604080519173ffffffffffffffffffffffffffffffffffffffff8082511684526020820151166020840152015160408201522090565b7fb9af0ac6e0a644ab539eb460932d707159b3369e5f30f3d9aa26d6eb6535c2a98380a26001549067ffffffffffffffff938483831c16908185528481528683862054146111e7577f0bde08c9a082227535f7f1dd9bbb37ae1735f37377422d16744f0ffce41cf01295879461119f879461105e565b907fffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff6fffffffffffffffff000000000000000083881b169116176001551682525282205580a2565b50505050505050565b6004602073ffffffffffffffffffffffffffffffffffffffff7f0aec74a1754fb10877b53c31a29be82096082042eb1fb374ec96fac88c0e621b5416604051928380927f9fa6a6e30000000000000000000000000000000000000000000000000000000082525afa9081156112985760009161126a575090565b906020823d8211611290575b8161128360209383610f52565b810103126101bd57505190565b3d9150611276565b6040513d6000823e3d90fd5b906112ad610fe4565b9180600052600260205260406000205490816020850152835215156040830152565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff811461102f5760010190565b80548210156113145760005260206000200190600090565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b919060018301600090828252806020526040822054156000146113fe57845494680100000000000000008610156113d157836113c161138c886001604098999a018555846112fc565b81939154907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9060031b92831b921b19161790565b9055549382526020522055600190565b6024837f4e487b710000000000000000000000000000000000000000000000000000000081526041600452fd5b50925050565b90600182019060009281845282602052604084205490811515600014611556577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff91828101818111611529578254908482019182116114fc578082036114c7575b5050508054801561149a5782019161147d83836112fc565b909182549160031b1b191690555582526020526040812055600190565b6024867f4e487b710000000000000000000000000000000000000000000000000000000081526031600452fd5b6114e76114d761138c93866112fc565b90549060031b1c928392866112fc565b90558652846020526040862055388080611465565b6024887f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b6024877f4e487b710000000000000000000000000000000000000000000000000000000081526011600452fd5b505050509056fea264697066735822122091d12b4d59d187ebd683a3e893ed763a47ca6150fbd6bb06765aac95d618970b64736f6c63430008130033",
  "devdoc": {
    "details": "One instance per price feed should be deployed. Multiple products may use the same      KeeperOracle instance if their payoff functions are based on the same underlying oracle.      This implementation only supports non-negative prices.",
    "kind": "dev",
    "methods": {
      "at(uint256)": {
        "params": {
          "timestamp": "The timestamp of which to lookup"
        },
        "returns": {
          "oracleVersion": "Oracle version at version `version`"
        }
      },
      "commit((uint256,int256,bool))": {
        "details": "Verification of price happens in the oracle's factory",
        "params": {
          "version": "The oracle version to commit"
        },
        "returns": {
          "requested": "Whether the commit was requested"
        }
      },
      "constructor": {
        "params": {
          "timeout_": "The timeout for a version to be committed"
        }
      },
      "current()": {
        "returns": {
          "_0": "Current oracle version"
        }
      },
      "factory()": {
        "returns": {
          "_0": "The factory that created this instance"
        }
      },
      "global()": {
        "returns": {
          "_0": "The global state of the oracle"
        }
      },
      "globalCallbacks(uint256)": {
        "params": {
          "version": "The version to lookup"
        },
        "returns": {
          "_0": "The global oracle callback set for the version"
        }
      },
      "latest()": {
        "returns": {
          "_0": "Latest oracle version"
        }
      },
      "localCallbacks(uint256,address)": {
        "params": {
          "market": "The market to lookup",
          "version": "The version to lookup"
        },
        "returns": {
          "_0": "The local oracle callback set for the version and market"
        }
      },
      "next()": {
        "details": "Returns 0 if no next version is requested",
        "returns": {
          "_0": "The next requested oracle version"
        }
      },
      "request(address,address)": {
        "params": {
          "account": "The account to callback to",
          "market": "The market to callback to"
        }
      },
      "settle(address,uint256,uint256)": {
        "details": "Distribution of keeper incentive is consolidated in the oracle's factory",
        "params": {
          "market": "The market to settle",
          "maxCount": "The maximum number of settlement callbacks to perform before exiting",
          "version": "The version to settle"
        }
      },
      "status()": {
        "returns": {
          "_0": "The latest synced oracle version",
          "_1": "The current oracle version collecting new orders"
        }
      }
    },
    "stateVariables": {
      "_global": {
        "details": "The global state of the oracle"
      },
      "_globalCallbacks": {
        "details": "Mapping from version to a set of registered markets for settlement callback"
      },
      "_localCallbacks": {
        "details": "Mapping from version and market to a set of registered accounts for settlement callback"
      },
      "_prices": {
        "details": "Mapping from oracle version to oracle version data"
      },
      "timeout": {
        "details": "After this amount of time has passed for a version without being committed, the version can be invalidated."
      },
      "versions": {
        "details": "List of all requested oracle versions"
      }
    },
    "title": "KeeperOracle",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "at(uint256)": {
        "notice": "Returns the oracle version at version `version`"
      },
      "commit((uint256,int256,bool))": {
        "notice": "Commits the price to specified version"
      },
      "constructor": {
        "notice": "Constructs the contract"
      },
      "current()": {
        "notice": "Returns the current oracle version accepting new orders"
      },
      "factory()": {
        "notice": "Returns the factory that created this instance"
      },
      "global()": {
        "notice": "Returns the global state of the oracle"
      },
      "globalCallbacks(uint256)": {
        "notice": "Returns the global oracle callback set for a version"
      },
      "initialize()": {
        "notice": "Initializes the contract state"
      },
      "latest()": {
        "notice": "Returns the latest synced oracle version"
      },
      "localCallbacks(uint256,address)": {
        "notice": "Returns the local oracle callback set for a version and market"
      },
      "next()": {
        "notice": "Returns the next requested oracle version"
      },
      "request(address,address)": {
        "notice": "Records a request for a new oracle version"
      },
      "settle(address,uint256,uint256)": {
        "notice": "Performs an asynchronous local settlement callback"
      },
      "status()": {
        "notice": "Returns the latest synced oracle version and the current oracle version"
      }
    },
    "notice": "Generic implementation of the IOracle interface for keeper-based oracles.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 4785,
        "contract": "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol:KeeperOracle",
        "label": "versions",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_uint256,t_uint256)"
      },
      {
        "astId": 4789,
        "contract": "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol:KeeperOracle",
        "label": "_global",
        "offset": 0,
        "slot": "1",
        "type": "t_struct(Global)3766_storage"
      },
      {
        "astId": 4795,
        "contract": "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol:KeeperOracle",
        "label": "_prices",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_uint256,t_userDefinedValueType(Fixed6)26679)"
      },
      {
        "astId": 4801,
        "contract": "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol:KeeperOracle",
        "label": "_globalCallbacks",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_uint256,t_struct(AddressSet)36716_storage)"
      },
      {
        "astId": 4810,
        "contract": "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol:KeeperOracle",
        "label": "_localCallbacks",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_uint256,t_mapping(t_contract(IMarket)14755,t_struct(AddressSet)36716_storage))"
      }
    ],
    "types": {
      "t_array(t_bytes32)dyn_storage": {
        "base": "t_bytes32",
        "encoding": "dynamic_array",
        "label": "bytes32[]",
        "numberOfBytes": "32"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IMarket)14755": {
        "encoding": "inplace",
        "label": "contract IMarket",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes32,t_uint256)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_contract(IMarket)14755,t_struct(AddressSet)36716_storage)": {
        "encoding": "mapping",
        "key": "t_contract(IMarket)14755",
        "label": "mapping(contract IMarket => struct EnumerableSet.AddressSet)",
        "numberOfBytes": "32",
        "value": "t_struct(AddressSet)36716_storage"
      },
      "t_mapping(t_uint256,t_mapping(t_contract(IMarket)14755,t_struct(AddressSet)36716_storage))": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => mapping(contract IMarket => struct EnumerableSet.AddressSet))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_contract(IMarket)14755,t_struct(AddressSet)36716_storage)"
      },
      "t_mapping(t_uint256,t_struct(AddressSet)36716_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct EnumerableSet.AddressSet)",
        "numberOfBytes": "32",
        "value": "t_struct(AddressSet)36716_storage"
      },
      "t_mapping(t_uint256,t_uint256)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_uint256,t_userDefinedValueType(Fixed6)26679)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => Fixed6)",
        "numberOfBytes": "32",
        "value": "t_userDefinedValueType(Fixed6)26679"
      },
      "t_struct(AddressSet)36716_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableSet.AddressSet",
        "members": [
          {
            "astId": 36715,
            "contract": "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol:KeeperOracle",
            "label": "_inner",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(Set)36401_storage"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_struct(Global)3766_storage": {
        "encoding": "inplace",
        "label": "struct IKeeperOracle.Global",
        "members": [
          {
            "astId": 3759,
            "contract": "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol:KeeperOracle",
            "label": "latestVersion",
            "offset": 0,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 3762,
            "contract": "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol:KeeperOracle",
            "label": "currentIndex",
            "offset": 8,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 3765,
            "contract": "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol:KeeperOracle",
            "label": "latestIndex",
            "offset": 16,
            "slot": "0",
            "type": "t_uint64"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Set)36401_storage": {
        "encoding": "inplace",
        "label": "struct EnumerableSet.Set",
        "members": [
          {
            "astId": 36396,
            "contract": "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol:KeeperOracle",
            "label": "_values",
            "offset": 0,
            "slot": "0",
            "type": "t_array(t_bytes32)dyn_storage"
          },
          {
            "astId": 36400,
            "contract": "@equilibria/perennial-v2-oracle/contracts/keeper/KeeperOracle.sol:KeeperOracle",
            "label": "_indexes",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_bytes32,t_uint256)"
          }
        ],
        "numberOfBytes": "64"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_userDefinedValueType(Fixed6)26679": {
        "encoding": "inplace",
        "label": "Fixed6",
        "numberOfBytes": "32"
      }
    }
  }
}
