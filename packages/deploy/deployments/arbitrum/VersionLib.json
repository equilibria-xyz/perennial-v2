{
  "address": "0xcf64b7C235F819A3bE0BB47C8dF014003eF1Bc43",
  "abi": [
    {
      "inputs": [],
      "name": "Adiabatic6ZeroScaleError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CurveMath6OutOfBoundsError",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DivisionByZero",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "Fixed6OverflowError",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "int256",
          "name": "value",
          "type": "int256"
        }
      ],
      "name": "UFixed6UnderflowError",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "orderId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "timestamp",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "orders",
              "type": "uint256"
            },
            {
              "internalType": "Fixed6",
              "name": "collateral",
              "type": "int256"
            },
            {
              "internalType": "UFixed6",
              "name": "makerPos",
              "type": "uint256"
            },
            {
              "internalType": "UFixed6",
              "name": "makerNeg",
              "type": "uint256"
            },
            {
              "internalType": "UFixed6",
              "name": "longPos",
              "type": "uint256"
            },
            {
              "internalType": "UFixed6",
              "name": "longNeg",
              "type": "uint256"
            },
            {
              "internalType": "UFixed6",
              "name": "shortPos",
              "type": "uint256"
            },
            {
              "internalType": "UFixed6",
              "name": "shortNeg",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "protection",
              "type": "uint256"
            },
            {
              "internalType": "UFixed6",
              "name": "makerReferral",
              "type": "uint256"
            },
            {
              "internalType": "UFixed6",
              "name": "takerReferral",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct Order",
          "name": "order",
          "type": "tuple"
        },
        {
          "components": [
            {
              "internalType": "UFixed6",
              "name": "tradeFee",
              "type": "uint256"
            },
            {
              "internalType": "UFixed6",
              "name": "subtractiveFee",
              "type": "uint256"
            },
            {
              "internalType": "Fixed6",
              "name": "tradeOffset",
              "type": "int256"
            },
            {
              "internalType": "Fixed6",
              "name": "tradeOffsetMaker",
              "type": "int256"
            },
            {
              "internalType": "UFixed6",
              "name": "tradeOffsetMarket",
              "type": "uint256"
            },
            {
              "internalType": "Fixed6",
              "name": "adiabaticExposure",
              "type": "int256"
            },
            {
              "internalType": "Fixed6",
              "name": "adiabaticExposureMaker",
              "type": "int256"
            },
            {
              "internalType": "Fixed6",
              "name": "adiabaticExposureMarket",
              "type": "int256"
            },
            {
              "internalType": "Fixed6",
              "name": "fundingMaker",
              "type": "int256"
            },
            {
              "internalType": "Fixed6",
              "name": "fundingLong",
              "type": "int256"
            },
            {
              "internalType": "Fixed6",
              "name": "fundingShort",
              "type": "int256"
            },
            {
              "internalType": "UFixed6",
              "name": "fundingFee",
              "type": "uint256"
            },
            {
              "internalType": "Fixed6",
              "name": "interestMaker",
              "type": "int256"
            },
            {
              "internalType": "Fixed6",
              "name": "interestLong",
              "type": "int256"
            },
            {
              "internalType": "Fixed6",
              "name": "interestShort",
              "type": "int256"
            },
            {
              "internalType": "UFixed6",
              "name": "interestFee",
              "type": "uint256"
            },
            {
              "internalType": "Fixed6",
              "name": "pnlMaker",
              "type": "int256"
            },
            {
              "internalType": "Fixed6",
              "name": "pnlLong",
              "type": "int256"
            },
            {
              "internalType": "Fixed6",
              "name": "pnlShort",
              "type": "int256"
            },
            {
              "internalType": "UFixed6",
              "name": "settlementFee",
              "type": "uint256"
            },
            {
              "internalType": "UFixed6",
              "name": "liquidationFee",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct VersionAccumulationResult",
          "name": "accumulationResult",
          "type": "tuple"
        }
      ],
      "name": "PositionProcessed",
      "type": "event"
    }
  ],
  "transactionHash": "0x98aade05bf6880b780bd44c49ac18f6507a5fbfaf407f82516cb05897d88e23a",
  "receipt": {
    "to": null,
    "from": "0x66a7fDB96C583c59597de16d8b2B989231415339",
    "contractAddress": "0xcf64b7C235F819A3bE0BB47C8dF014003eF1Bc43",
    "transactionIndex": 3,
    "gasUsed": "6531737",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x720f61f298c81ff556120a3a8e48c19fd644e49d59d551df39bd70a1c27ef3c8",
    "transactionHash": "0x98aade05bf6880b780bd44c49ac18f6507a5fbfaf407f82516cb05897d88e23a",
    "logs": [],
    "blockNumber": 266573629,
    "cumulativeGasUsed": "7076962",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 2,
  "solcInputHash": "345aa42b382a18d880d44eca35498289",
  "metadata": "{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"Adiabatic6ZeroScaleError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CurveMath6OutOfBoundsError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DivisionByZero\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Fixed6OverflowError\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"int256\",\"name\":\"value\",\"type\":\"int256\"}],\"name\":\"UFixed6UnderflowError\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"orderId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"timestamp\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"orders\",\"type\":\"uint256\"},{\"internalType\":\"Fixed6\",\"name\":\"collateral\",\"type\":\"int256\"},{\"internalType\":\"UFixed6\",\"name\":\"makerPos\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"makerNeg\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"longPos\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"longNeg\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"shortPos\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"shortNeg\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"protection\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"makerReferral\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"takerReferral\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct Order\",\"name\":\"order\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"UFixed6\",\"name\":\"tradeFee\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"subtractiveFee\",\"type\":\"uint256\"},{\"internalType\":\"Fixed6\",\"name\":\"tradeOffset\",\"type\":\"int256\"},{\"internalType\":\"Fixed6\",\"name\":\"tradeOffsetMaker\",\"type\":\"int256\"},{\"internalType\":\"UFixed6\",\"name\":\"tradeOffsetMarket\",\"type\":\"uint256\"},{\"internalType\":\"Fixed6\",\"name\":\"adiabaticExposure\",\"type\":\"int256\"},{\"internalType\":\"Fixed6\",\"name\":\"adiabaticExposureMaker\",\"type\":\"int256\"},{\"internalType\":\"Fixed6\",\"name\":\"adiabaticExposureMarket\",\"type\":\"int256\"},{\"internalType\":\"Fixed6\",\"name\":\"fundingMaker\",\"type\":\"int256\"},{\"internalType\":\"Fixed6\",\"name\":\"fundingLong\",\"type\":\"int256\"},{\"internalType\":\"Fixed6\",\"name\":\"fundingShort\",\"type\":\"int256\"},{\"internalType\":\"UFixed6\",\"name\":\"fundingFee\",\"type\":\"uint256\"},{\"internalType\":\"Fixed6\",\"name\":\"interestMaker\",\"type\":\"int256\"},{\"internalType\":\"Fixed6\",\"name\":\"interestLong\",\"type\":\"int256\"},{\"internalType\":\"Fixed6\",\"name\":\"interestShort\",\"type\":\"int256\"},{\"internalType\":\"UFixed6\",\"name\":\"interestFee\",\"type\":\"uint256\"},{\"internalType\":\"Fixed6\",\"name\":\"pnlMaker\",\"type\":\"int256\"},{\"internalType\":\"Fixed6\",\"name\":\"pnlLong\",\"type\":\"int256\"},{\"internalType\":\"Fixed6\",\"name\":\"pnlShort\",\"type\":\"int256\"},{\"internalType\":\"UFixed6\",\"name\":\"settlementFee\",\"type\":\"uint256\"},{\"internalType\":\"UFixed6\",\"name\":\"liquidationFee\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct VersionAccumulationResult\",\"name\":\"accumulationResult\",\"type\":\"tuple\"}],\"name\":\"PositionProcessed\",\"type\":\"event\"}],\"devdoc\":{\"details\":\"(external-safe): this library is safe to externalize\",\"kind\":\"dev\",\"methods\":{},\"title\":\"VersionLib\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"accumulate(IMarket.Context,IMarket.SettlementContext,uint256,Order,Guarantee,OracleVersion,OracleReceipt)\":{\"notice\":\"Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\"}},\"notice\":\"Manages the logic for the global order accumulation\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"@perennial/core/contracts/libs/VersionLib.sol\":\"VersionLib\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@equilibria/root/accumulator/types/Accumulator6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\n\\n/// @dev Accumulator6 type\\nstruct Accumulator6 {\\n    Fixed6 _value;\\n}\\n\\nusing Accumulator6Lib for Accumulator6 global;\\nstruct StoredAccumulator6 {\\n    int256 _value;\\n}\\nstruct Accumulator6Storage { StoredAccumulator6 value; }\\nusing Accumulator6StorageLib for Accumulator6Storage global;\\n\\n\\n/**\\n * @title Accumulator6Lib\\n * @notice Library that surfaces math operations for the signed Accumulator type.\\n * @dev This accumulator tracks cumulative changes to a value over time. Using the `accumulated` function, one\\n * can determine how much a value has changed between two points in time. The `increment` and `decrement` functions\\n * can be used to update the accumulator.\\n */\\nlibrary Accumulator6Lib {\\n    /**\\n     * Returns how much has been accumulated between two accumulators\\n     * @param self The current point of the accumulation to compare with `from`\\n     * @param from The starting point of the accumulation\\n     * @param total Demoninator of the ratio (see `increment` and `decrement` functions)\\n     */\\n    function accumulated(Accumulator6 memory self, Accumulator6 memory from, UFixed6 total) internal pure returns (Fixed6) {\\n        return _mul(self._value.sub(from._value), total);\\n    }\\n\\n    /**\\n     * @notice Increments an accumulator by a given ratio\\n     * @dev Always rounds down in order to prevent overstating the accumulated value\\n     * @param self The accumulator to increment\\n     * @param amount Numerator of the ratio\\n     * @param total Denominator of the ratio\\n     */\\n    function increment(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\\n        if (amount.isZero()) return;\\n        self._value = self._value.add(_div(amount, total));\\n    }\\n\\n    /**\\n     * @notice Decrements an accumulator by a given ratio\\n     * @dev Always rounds down in order to prevent overstating the accumulated value\\n     * @param self The accumulator to decrement\\n     * @param amount Numerator of the ratio\\n     * @param total Denominator of the ratio\\n     */\\n    function decrement(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\\n        if (amount.isZero()) return;\\n        self._value = self._value.add(_div(amount.mul(Fixed6Lib.NEG_ONE), total));\\n    }\\n\\n    function _div(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\\n        return amount.sign() == -1 ? amount.divOut(Fixed6Lib.from(total)) : amount.div(Fixed6Lib.from(total));\\n    }\\n\\n    function _mul(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\\n        return amount.sign() == -1 ? amount.mulOut(Fixed6Lib.from(total)) : amount.mul(Fixed6Lib.from(total));\\n    }\\n}\\n\\nlibrary Accumulator6StorageLib {\\n    function read(Accumulator6Storage storage self) internal view returns (Accumulator6 memory) {\\n        StoredAccumulator6 memory storedValue = self.value;\\n        return Accumulator6(Fixed6.wrap(int256(storedValue._value)));\\n    }\\n\\n    function store(Accumulator6Storage storage self, Accumulator6 memory newValue) internal {\\n        self.value = StoredAccumulator6(Fixed6.unwrap(newValue._value));\\n    }\\n}\\n\",\"keccak256\":\"0x21202b20328506bda86043889dca7b699732a9bf6ec735cc50ac8a444e643724\",\"license\":\"Apache-2.0\"},\"@equilibria/root/adiabatic/AdiabaticMath6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../number/types/UFixed6.sol\\\";\\nimport \\\"../number/types/Fixed6.sol\\\";\\n\\n/**\\n * @title AdiabaticMath6\\n * @notice Library for managing math operations for adiabatic fees.\\n */\\nlibrary AdiabaticMath6 {\\n    error Adiabatic6ZeroScaleError();\\n\\n    /// @notice Computes the base fees for an order\\n    /// @param fee The linear fee percentage\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The linear fee in underlying terms\\n    function linearFee(UFixed6 fee, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return change.abs().mul(price).mul(fee);\\n    }\\n\\n    /// @notice Computes the base fees for an order\\n    /// @param scale The scale of the skew\\n    /// @param fee The proportional fee percentage\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The proportional fee in underlying terms\\n    function proportionalFee(UFixed6 scale, UFixed6 fee, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return change.abs().mul(price).muldiv(change.abs(), scale).mul(fee);\\n    }\\n\\n    /// @notice Computes the adiabatic fee from a latest skew and change in skew over a linear function\\n    /// @param scale The scale of the skew\\n    /// @param adiabaticFee The adiabatic fee percentage\\n    /// @param latest The latest skew in asset terms\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The adiabatic fee in underlying terms\\n    function linearCompute(\\n        UFixed6 scale,\\n        UFixed6 adiabaticFee,\\n        Fixed6 latest,\\n        Fixed6 change,\\n        UFixed6 price\\n    ) internal pure returns (Fixed6) {\\n        if (latest.isZero() && change.isZero()) return Fixed6Lib.ZERO;\\n        if (scale.isZero()) revert Adiabatic6ZeroScaleError();\\n\\n        // normalize for skew scale\\n        (Fixed6 latestScaled, Fixed6 changeScaled) =\\n            (latest.div(Fixed6Lib.from(scale)), change.div(Fixed6Lib.from(scale)));\\n\\n        // adiabatic fee = notional * fee percentage * mean of skew range\\n        return change.mul(Fixed6Lib.from(price)).mul(Fixed6Lib.from(adiabaticFee))\\n            .mul(_linearMean(latestScaled, latestScaled.add(changeScaled)));\\n    }\\n\\n    /// @notice Finds the mean value of the function f(x) = x over `from` to `to`\\n    /// @param from The lower bound\\n    /// @param to The upper bound\\n    /// @return The mean value\\n    function _linearMean(Fixed6 from, Fixed6 to) private pure returns (Fixed6) {\\n        return from.add(to).div(Fixed6Lib.from(2));\\n    }\\n}\\n\",\"keccak256\":\"0x9fea7ff94667e1ce3c4666940d21ad2fcc57058ec456f326e35f98b59a724433\",\"license\":\"Apache-2.0\"},\"@equilibria/root/adiabatic/types/LinearAdiabatic6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\nimport \\\"../AdiabaticMath6.sol\\\";\\n\\n/// @dev LinearAdiabatic6 type\\nstruct LinearAdiabatic6 {\\n    UFixed6 linearFee;\\n    UFixed6 proportionalFee;\\n    UFixed6 adiabaticFee;\\n    UFixed6 scale;\\n}\\nusing LinearAdiabatic6Lib for LinearAdiabatic6 global;\\n\\n/**\\n * @title LinearAdiabatic6Lib\\n * @notice Library that that manages the linear adiabatic fee algorithm\\n * @dev This algorithm specifies an adiatatic fee over the function:\\n *\\n *      f(skew) = adiabaticFee * skew\\n *\\n *      This is used to reward or penalize actions that move skew up or down this curve accordingly with net-zero\\n *      value to the system with respect to the underlying asset.\\n */\\nlibrary LinearAdiabatic6Lib {\\n    /// @notice Computes the adiabatic fee from a latest skew and change in skew\\n    /// @param self The adiabatic configuration\\n    /// @param latest The latest skew in asset terms\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The adiabatic fee in underlying terms\\n    function compute(\\n        LinearAdiabatic6 memory self,\\n        Fixed6 latest,\\n        Fixed6 change,\\n        UFixed6 price\\n    ) internal pure returns (Fixed6) {\\n        return AdiabaticMath6.linearCompute(\\n            self.scale,\\n            self.adiabaticFee,\\n            latest,\\n            change,\\n            price\\n        );\\n    }\\n\\n    /// @notice Computes the latest exposure along with all fees\\n    /// @param self The adiabatic configuration\\n    /// @param latest The latest skew in asset terms\\n    /// @return The latest total exposure in asset terms\\n    function exposure(LinearAdiabatic6 memory self, Fixed6 latest) internal pure returns (Fixed6) {\\n        return compute(self, Fixed6Lib.ZERO, latest, UFixed6Lib.ONE);\\n    }\\n\\n    /// @dev Computes the change in exposure from a new configuration\\n    /// @param self The latest fee configuration\\n    /// @param newConfig The new fee configuration\\n    /// @param latest The latest skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The update fee in underlying terms\\n    function exposure(\\n        LinearAdiabatic6 memory self,\\n        LinearAdiabatic6 memory newConfig,\\n        Fixed6 latest,\\n        UFixed6 price\\n    ) internal pure returns (Fixed6) {\\n        return compute(newConfig, Fixed6Lib.ZERO, latest, price).sub(compute(self, Fixed6Lib.ZERO, latest, price));\\n    }\\n\\n    /// @notice Computes the linear fee\\n    /// @param self The adiabatic configuration\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The linear fee in underlying terms\\n    function linear(LinearAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return AdiabaticMath6.linearFee(self.linearFee, change, price);\\n    }\\n\\n    /// @notice Computes the proportional fee\\n    /// @param self The adiabatic configuration\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The proportional fee in underlying terms\\n    function proportional(LinearAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return AdiabaticMath6.proportionalFee(self.scale, self.proportionalFee, change, price);\\n    }\\n\\n    /// @notice Computes the adiabatic fee\\n    /// @param self The adiabatic configuration\\n    /// @param latest The latest skew in asset terms\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The adiabatic fee in underlying terms\\n    function adiabatic(\\n        LinearAdiabatic6 memory self,\\n        Fixed6 latest,\\n        Fixed6 change,\\n        UFixed6 price\\n    ) internal pure returns (Fixed6) {\\n        return compute(self, latest, change, price);\\n    }\\n}\\n\",\"keccak256\":\"0x5cb33ae31f4c44194e9fd8576eb15af0e29c0ff7cb91fd54c1f8010f125993a6\",\"license\":\"Apache-2.0\"},\"@equilibria/root/adiabatic/types/NoopAdiabatic6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\nimport \\\"../AdiabaticMath6.sol\\\";\\n\\n/// @dev NoopAdiabatic6 type\\nstruct NoopAdiabatic6 {\\n    UFixed6 linearFee;\\n    UFixed6 proportionalFee;\\n    UFixed6 scale;\\n}\\nusing NoopAdiabatic6Lib for NoopAdiabatic6 global;\\n\\n/**\\n * @title NoopAdiabatic6Lib\\n * @notice Library that that manages the no-op adiabatic fee algorithm\\n * @dev This algorithm specifies a fee schedule without an adiabatic fee. This is used for fees that need unsigned\\n *      fee impact without a signed shift fee based on skew.\\n */\\nlibrary NoopAdiabatic6Lib {\\n    /// @notice Computes the linear fee\\n    /// @param self The adiabatic configuration\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The linear fee in underlying terms\\n    function linear(NoopAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return AdiabaticMath6.linearFee(self.linearFee, change, price);\\n    }\\n\\n    /// @notice Computes the proportional fee\\n    /// @param self The adiabatic configuration\\n    /// @param change The change in skew in asset terms\\n    /// @param price The price of the underlying asset\\n    /// @return The proportional fee in underlying terms\\n    function proportional(NoopAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\\n        return AdiabaticMath6.proportionalFee(self.scale, self.proportionalFee, change, price);\\n    }\\n}\\n\",\"keccak256\":\"0x711415003ec7bbb170c5d6afc7ccb884b059dab8c4908d930573ccaa4c22ed9d\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\\\";\\nimport \\\"./IPausable.sol\\\";\\nimport \\\"./IInstance.sol\\\";\\n\\ninterface IFactory is IBeacon, IOwnable, IPausable {\\n    event InstanceRegistered(IInstance indexed instance);\\n\\n    error FactoryNotInstanceError();\\n\\n    function instances(IInstance instance) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x64c821ff5b6ff536a295bc0a24bf76dac44cd67b89183d224903f9fe1d6d3e65\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IInitializable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\ninterface IInitializable {\\n    error InitializableZeroVersionError();\\n    error InitializableAlreadyInitializedError(uint256 version);\\n    error InitializableNotInitializingError();\\n\\n    event Initialized(uint256 version);\\n}\\n\",\"keccak256\":\"0xa626c401aab111b5ccdaa280b4d0137e2f4261a71796cd89a1435025083b4035\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IInstance.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IFactory.sol\\\";\\nimport \\\"./IInitializable.sol\\\";\\n\\ninterface IInstance is IInitializable {\\n    error InstanceNotOwnerError(address sender);\\n    error InstanceNotFactoryError(address sender);\\n    error InstancePausedError();\\n\\n    function factory() external view returns (IFactory);\\n}\\n\",\"keccak256\":\"0x9c25e710af0e06bde4bc5b63a8fb4c020a55e7f2dc93ca061d0b74318cd4a8a0\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IOwnable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IInitializable.sol\\\";\\n\\ninterface IOwnable is IInitializable {\\n    event OwnerUpdated(address indexed newOwner);\\n    event PendingOwnerUpdated(address indexed newPendingOwner);\\n\\n    error OwnableNotOwnerError(address sender);\\n    error OwnableNotPendingOwnerError(address sender);\\n    error OwnableAlreadyInitializedError();\\n\\n    function owner() external view returns (address);\\n    function pendingOwner() external view returns (address);\\n    function updatePendingOwner(address newPendingOwner) external;\\n    function acceptOwner() external;\\n}\\n\",\"keccak256\":\"0x6b3d8a25d98d049ba4cfdbf36dd7f0e8b9ab8c3d514c2b2b730b459e0092717a\",\"license\":\"Apache-2.0\"},\"@equilibria/root/attribute/interfaces/IPausable.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"./IInitializable.sol\\\";\\nimport \\\"./IOwnable.sol\\\";\\n\\ninterface IPausable is IInitializable, IOwnable {\\n    event PauserUpdated(address indexed newPauser);\\n    event Paused();\\n    event Unpaused();\\n\\n    error PausablePausedError();\\n    error PausableNotPauserError(address sender);\\n\\n    function pauser() external view returns (address);\\n    function paused() external view returns (bool);\\n    function updatePauser(address newPauser) external;\\n    function pause() external;\\n    function unpause() external;\\n}\\n\",\"keccak256\":\"0x8ae48b036875291c763787ba6730d56f4a9cb30d7d4132ec8711544b99689338\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/NumberMath.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\n\\n/**\\n * @title NumberMath\\n * @notice Library for additional math functions that are not included in the OpenZeppelin libraries.\\n */\\nlibrary NumberMath {\\n    error DivisionByZero();\\n\\n    /**\\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Dividend\\n     * @param b Divisor\\n     * @return Resulting quotient\\n     */\\n    function divOut(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (b == 0) revert DivisionByZero();\\n        return Math.ceilDiv(a, b);\\n    }\\n\\n    /**\\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Dividend\\n     * @param b Divisor\\n     * @return Resulting quotient\\n     */\\n    function divOut(int256 a, int256 b) internal pure returns (int256) {\\n        return sign(a) * sign(b) * int256(divOut(SignedMath.abs(a), SignedMath.abs(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the sign of an int256\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a int256 to find the sign of\\n     * @return Sign of the int256\\n     */\\n    function sign(int256 a) internal pure returns (int256) {\\n        if (a > 0) return 1;\\n        if (a < 0) return -1;\\n        return 0;\\n    }\\n}\\n\",\"keccak256\":\"0x8d3578ce6e74ee6589ba0468e2c539ef1eb51d6687b508e637620926eb8396b4\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/Fixed18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed6.sol\\\";\\nimport \\\"./UFixed18.sol\\\";\\n\\n/// @dev Fixed18 type\\ntype Fixed18 is int256;\\nusing Fixed18Lib for Fixed18 global;\\ntype Fixed18Storage is bytes32;\\nusing Fixed18StorageLib for Fixed18Storage global;\\n\\n/**\\n * @title Fixed18Lib\\n * @notice Library for the signed fixed-decimal type.\\n */\\nlibrary Fixed18Lib {\\n    error Fixed18OverflowError(uint256 value);\\n\\n    int256 private constant BASE = 1e18;\\n    Fixed18 public constant ZERO = Fixed18.wrap(0);\\n    Fixed18 public constant ONE = Fixed18.wrap(BASE);\\n    Fixed18 public constant NEG_ONE = Fixed18.wrap(-1 * BASE);\\n    Fixed18 public constant MAX = Fixed18.wrap(type(int256).max);\\n    Fixed18 public constant MIN = Fixed18.wrap(type(int256).min);\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\\n     * @param a Unsigned fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed18 a) internal pure returns (Fixed18) {\\n        uint256 value = UFixed18.unwrap(a);\\n        if (value > uint256(type(int256).max)) revert Fixed18OverflowError(value);\\n        return Fixed18.wrap(int256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\\n     * @param s Sign\\n     * @param m Unsigned fixed-decimal magnitude\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {\\n        if (s > 0) return from(m);\\n        if (s < 0) {\\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\\n            // which is the only value that would overflow when negated. Therefore,\\n            // we can safely negate from(m) without checking for overflow.\\n            unchecked { return Fixed18.wrap(-1 * Fixed18.unwrap(from(m))); }\\n        }\\n        return ZERO;\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a signed integer\\n     * @param a Signed number\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 a) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\\n     * @param a Base-6 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed6 a) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed6.unwrap(a) * 1e12);\\n    }\\n\\n    /**\\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\\n     * @param a Signed fixed-decimal\\n     * @return Whether the signed fixed-decimal is zero.\\n     */\\n    function isZero(Fixed18 a) internal pure returns (bool) {\\n        return Fixed18.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting summed signed fixed-decimal\\n     */\\n    function add(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) + Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts signed fixed-decimal `b` from `a`\\n     * @param a Signed fixed-decimal to subtract from\\n     * @param b Signed fixed-decimal to subtract\\n     * @return Resulting subtracted signed fixed-decimal\\n     */\\n    function sub(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) - Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mul(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mulOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function div(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * BASE / Fixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function divOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\\n        return muldiv(a, Fixed18.wrap(b), Fixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\\n        return muldivOut(a, Fixed18.wrap(b), Fixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / Fixed18.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), Fixed18.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the signed fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(Fixed18 a, Fixed18 b) internal pure returns (uint256) {\\n        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First signed number\\n     * @param b Second signed number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(int256 a, int256 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(SignedMath.min(Fixed18.unwrap(a), Fixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\\n        return Fixed18.wrap(SignedMath.max(Fixed18.unwrap(a), Fixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Signed fixed-decimal\\n     * @return Truncated signed number\\n     */\\n    function truncate(Fixed18 a) internal pure returns (int256) {\\n        return Fixed18.unwrap(a) / BASE;\\n    }\\n\\n    /**\\n     * @notice Returns the sign of the signed fixed-decimal\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a Signed fixed-decimal\\n     * @return Sign of the signed fixed-decimal\\n     */\\n    function sign(Fixed18 a) internal pure returns (int256) {\\n        if (Fixed18.unwrap(a) > 0) return 1;\\n        if (Fixed18.unwrap(a) < 0) return -1;\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Returns the absolute value of the signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return Absolute value of the signed fixed-decimal\\n     */\\n    function abs(Fixed18 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(SignedMath.abs(Fixed18.unwrap(a)));\\n    }\\n}\\n\\nlibrary Fixed18StorageLib {\\n    function read(Fixed18Storage self) internal view returns (Fixed18 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Fixed18Storage self, Fixed18 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xdd3541bc1dbe5ca81f996a1ed5a05a7b8c74247426aab221d1a8f37be91d0e4f\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/Fixed6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/SignedMath.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed18.sol\\\";\\nimport \\\"./UFixed6.sol\\\";\\n\\n/// @dev Fixed6 type\\ntype Fixed6 is int256;\\nusing Fixed6Lib for Fixed6 global;\\ntype Fixed6Storage is bytes32;\\nusing Fixed6StorageLib for Fixed6Storage global;\\n\\n/**\\n * @title Fixed6Lib\\n * @notice Library for the signed fixed-decimal type.\\n */\\nlibrary Fixed6Lib {\\n    error Fixed6OverflowError(uint256 value);\\n\\n    int256 private constant BASE = 1e6;\\n    Fixed6 public constant ZERO = Fixed6.wrap(0);\\n    Fixed6 public constant ONE = Fixed6.wrap(BASE);\\n    Fixed6 public constant NEG_ONE = Fixed6.wrap(-1 * BASE);\\n    Fixed6 public constant MAX = Fixed6.wrap(type(int256).max);\\n    Fixed6 public constant MIN = Fixed6.wrap(type(int256).min);\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\\n     * @param a Unsigned fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed6 a) internal pure returns (Fixed6) {\\n        uint256 value = UFixed6.unwrap(a);\\n        if (value > uint256(type(int256).max)) revert Fixed6OverflowError(value);\\n        return Fixed6.wrap(int256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\\n     * @param s Sign\\n     * @param m Unsigned fixed-decimal magnitude\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 s, UFixed6 m) internal pure returns (Fixed6) {\\n        if (s > 0) return from(m);\\n        if (s < 0) {\\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\\n            // which is the only value that would overflow when negated. Therefore,\\n            // we can safely negate from(m) without checking for overflow.\\n            unchecked { return Fixed6.wrap(-1 * Fixed6.unwrap(from(m))); }\\n        }\\n        return ZERO;\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a signed integer\\n     * @param a Signed number\\n     * @return New signed fixed-decimal\\n     */\\n    function from(int256 a) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\\n     * @param a Base-18 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed18 a) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed18.unwrap(a) / 1e12);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\\n     * @param a Base-18 signed fixed-decimal\\n     * @param roundOut Whether to round the result away from zero if there is a remainder\\n     * @return New signed fixed-decimal\\n     */\\n    function from(Fixed18 a, bool roundOut) internal pure returns (Fixed6) {\\n        return roundOut ? Fixed6.wrap(NumberMath.divOut(Fixed18.unwrap(a), 1e12)): from(a);\\n    }\\n\\n    /**\\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\\n     * @param a Signed fixed-decimal\\n     * @return Whether the signed fixed-decimal is zero.\\n     */\\n    function isZero(Fixed6 a) internal pure returns (bool) {\\n        return Fixed6.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting summed signed fixed-decimal\\n     */\\n    function add(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) + Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts signed fixed-decimal `b` from `a`\\n     * @param a Signed fixed-decimal to subtract from\\n     * @param b Signed fixed-decimal to subtract\\n     * @return Resulting subtracted signed fixed-decimal\\n     */\\n    function sub(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) - Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mul(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Resulting multiplied signed fixed-decimal\\n     */\\n    function mulOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function div(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * BASE / Fixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @param a Signed fixed-decimal to divide\\n     * @param b Signed fixed-decimal to divide by\\n     * @return Resulting divided signed fixed-decimal\\n     */\\n    function divOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        if (isZero(b)) {\\n            if (gt(a, ZERO)) return MAX;\\n            if (lt(a, ZERO)) return MIN;\\n            return ONE;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\\n        return muldiv(a, Fixed6.wrap(b), Fixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed number to multiply by\\n     * @param c Signed number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\\n        return muldivOut(a, Fixed6.wrap(b), Fixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / Fixed6.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First signed fixed-decimal\\n     * @param b Signed fixed-decimal to multiply by\\n     * @param c Signed fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), Fixed6.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the signed fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(Fixed6 a, Fixed6 b) internal pure returns (uint256) {\\n        (int256 au, int256 bu) = (Fixed6.unwrap(a), Fixed6.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First signed number\\n     * @param b Second signed number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(int256 a, int256 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(SignedMath.min(Fixed6.unwrap(a), Fixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\\n     * @param a First signed fixed-decimal\\n     * @param b Second signed fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\\n        return Fixed6.wrap(SignedMath.max(Fixed6.unwrap(a), Fixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Signed fixed-decimal\\n     * @return Truncated signed number\\n     */\\n    function truncate(Fixed6 a) internal pure returns (int256) {\\n        return Fixed6.unwrap(a) / BASE;\\n    }\\n\\n    /**\\n     * @notice Returns the sign of the signed fixed-decimal\\n     * @dev Returns: -1 for negative\\n     *                0 for zero\\n     *                1 for positive\\n     * @param a Signed fixed-decimal\\n     * @return Sign of the signed fixed-decimal\\n     */\\n    function sign(Fixed6 a) internal pure returns (int256) {\\n        if (Fixed6.unwrap(a) > 0) return 1;\\n        if (Fixed6.unwrap(a) < 0) return -1;\\n        return 0;\\n    }\\n\\n    /**\\n     * @notice Returns the absolute value of the signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return Absolute value of the signed fixed-decimal\\n     */\\n    function abs(Fixed6 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(SignedMath.abs(Fixed6.unwrap(a)));\\n    }\\n}\\n\\nlibrary Fixed6StorageLib {\\n    function read(Fixed6Storage self) internal view returns (Fixed6 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Fixed6Storage self, Fixed6 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xba2715da2fdf9393cc5e3ce7f9a38f7bfd3b271dcbf9a7fac5245f7c3ecc4522\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/UFixed18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed18.sol\\\";\\nimport \\\"./UFixed6.sol\\\";\\n\\n/// @dev UFixed18 type\\ntype UFixed18 is uint256;\\nusing UFixed18Lib for UFixed18 global;\\ntype UFixed18Storage is bytes32;\\nusing UFixed18StorageLib for UFixed18Storage global;\\n\\n/**\\n * @title UFixed18Lib\\n * @notice Library for the unsigned fixed-decimal type.\\n */\\nlibrary UFixed18Lib {\\n    error UFixed18UnderflowError(int256 value);\\n\\n    uint256 private constant BASE = 1e18;\\n    UFixed18 public constant ZERO = UFixed18.wrap(0);\\n    UFixed18 public constant ONE = UFixed18.wrap(BASE);\\n    UFixed18 public constant MAX = UFixed18.wrap(type(uint256).max);\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(Fixed18 a) internal pure returns (UFixed18) {\\n        int256 value = Fixed18.unwrap(a);\\n        if (value < 0) revert UFixed18UnderflowError(value);\\n        return UFixed18.wrap(uint256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @dev Does not revert on underflow, instead returns `ZERO`\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function unsafeFrom(Fixed18 a) internal pure returns (UFixed18) {\\n        return a.lt(Fixed18Lib.ZERO) ? ZERO : from(a);\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\\n     * @param a Unsigned number\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(uint256 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\\n     * @param a Base-6 signed fixed-decimal\\n     * @return New signed fixed-decimal\\n     */\\n    function from(UFixed6 a) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed6.unwrap(a) * 1e12);\\n    }\\n\\n    /**\\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\\n     * @param a Unsigned fixed-decimal\\n     * @return Whether the unsigned fixed-decimal is zero.\\n     */\\n    function isZero(UFixed18 a) internal pure returns (bool) {\\n        return UFixed18.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting summed unsigned fixed-decimal\\n     */\\n    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on underflow, instead returns `ZERO`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function unsafeSub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return gt(b, a) ? ZERO : sub(a, b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mul(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mulOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function div(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * BASE / UFixed18.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function divOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * BASE, UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\\n        return muldiv(a, UFixed18.wrap(b), UFixed18.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\\n        return muldivOut(a, UFixed18.wrap(b), UFixed18.wrap(c));\\n    }\\n\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / UFixed18.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), UFixed18.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(UFixed18 a, UFixed18 b) internal pure returns (uint256) {\\n        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First unsigned number\\n     * @param b Second unsigned number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(Math.min(UFixed18.unwrap(a), UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\\n        return UFixed18.wrap(Math.max(UFixed18.unwrap(a), UFixed18.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Unsigned fixed-decimal\\n     * @return Truncated unsigned number\\n     */\\n    function truncate(UFixed18 a) internal pure returns (uint256) {\\n        return UFixed18.unwrap(a) / BASE;\\n    }\\n}\\n\\nlibrary UFixed18StorageLib {\\n    function read(UFixed18Storage self) internal view returns (UFixed18 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(UFixed18Storage self, UFixed18 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x42ce82e3622fdea0b8044a68a25f6df5102b3a25e1d26a2aaec1f928815c1d56\",\"license\":\"Apache-2.0\"},\"@equilibria/root/number/types/UFixed6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/utils/math/Math.sol\\\";\\nimport \\\"../NumberMath.sol\\\";\\nimport \\\"./Fixed6.sol\\\";\\nimport \\\"./UFixed18.sol\\\";\\n\\n/// @dev UFixed6 type\\ntype UFixed6 is uint256;\\nusing UFixed6Lib for UFixed6 global;\\ntype UFixed6Storage is bytes32;\\nusing UFixed6StorageLib for UFixed6Storage global;\\n\\n/**\\n * @title UFixed6Lib\\n * @notice Library for the unsigned fixed-decimal type.\\n */\\nlibrary UFixed6Lib {\\n    error UFixed6UnderflowError(int256 value);\\n\\n    uint256 private constant BASE = 1e6;\\n    UFixed6 public constant ZERO = UFixed6.wrap(0);\\n    UFixed6 public constant ONE = UFixed6.wrap(BASE);\\n    UFixed6 public constant MAX = UFixed6.wrap(type(uint256).max);\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(Fixed6 a) internal pure returns (UFixed6) {\\n        int256 value = Fixed6.unwrap(a);\\n        if (value < 0) revert UFixed6UnderflowError(value);\\n        return UFixed6.wrap(uint256(value));\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\\n     * @dev Does not revert on underflow, instead returns `ZERO`\\n     * @param a Signed fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function unsafeFrom(Fixed6 a) internal pure returns (UFixed6) {\\n        return a.lt(Fixed6Lib.ZERO) ? ZERO : from(a);\\n    }\\n\\n    /**\\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\\n     * @param a Unsigned number\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(uint256 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(a * BASE);\\n    }\\n\\n    /**\\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\\n     * @param a Base-18 unsigned fixed-decimal\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(UFixed18 a) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed18.unwrap(a) / 1e12);\\n    }\\n\\n    /**\\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\\n     * @param a Base-18 unsigned fixed-decimal\\n     * @param roundOut Whether to round the result away from zero if there is a remainder\\n     * @return New unsigned fixed-decimal\\n     */\\n    function from(UFixed18 a, bool roundOut) internal pure returns (UFixed6) {\\n        return roundOut ? UFixed6.wrap(NumberMath.divOut(UFixed18.unwrap(a), 1e12)): from(a);\\n    }\\n\\n    /**\\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\\n     * @param a Unsigned fixed-decimal\\n     * @return Whether the unsigned fixed-decimal is zero.\\n     */\\n    function isZero(UFixed6 a) internal pure returns (bool) {\\n        return UFixed6.unwrap(a) == 0;\\n    }\\n\\n    /**\\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting summed unsigned fixed-decimal\\n     */\\n    function add(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) + UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function sub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) - UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Subtracts unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on underflow, instead returns `ZERO`\\n     * @param a Unsigned fixed-decimal to subtract from\\n     * @param b Unsigned fixed-decimal to subtract\\n     * @return Resulting subtracted unsigned fixed-decimal\\n     */\\n    function unsafeSub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return gt(b, a) ? ZERO : sub(a, b);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mul(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / BASE);\\n    }\\n\\n    /**\\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Resulting multiplied unsigned fixed-decimal\\n     */\\n    function mulOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), BASE));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function div(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * BASE / UFixed6.unwrap(b));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function divOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * BASE, UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDiv(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return div(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\\n     * @param a Unsigned fixed-decimal to divide\\n     * @param b Unsigned fixed-decimal to divide by\\n     * @return Resulting divided unsigned fixed-decimal\\n     */\\n    function unsafeDivOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        if (isZero(b)) {\\n            return isZero(a) ? ONE : MAX;\\n        } else {\\n            return divOut(a, b);\\n        }\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\\n        return muldiv(a, UFixed6.wrap(b), UFixed6.wrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned number to multiply by\\n     * @param c Unsigned number to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\\n        return muldivOut(a, UFixed6.wrap(b), UFixed6.wrap(c));\\n    }\\n\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldiv(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / UFixed6.unwrap(c));\\n    }\\n\\n    /**\\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\\n     * @param a First unsigned fixed-decimal\\n     * @param b Unsigned fixed-decimal to multiply by\\n     * @param c Unsigned fixed-decimal to divide by\\n     * @return Resulting computation\\n     */\\n    function muldivOut(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), UFixed6.unwrap(c)));\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is equal to `b`\\n     */\\n    function eq(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 1;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than `b`\\n     */\\n    function gt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 2;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than `b`\\n     */\\n    function lt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return compare(a, b) == 0;\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is greater than or equal to `b`\\n     */\\n    function gte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return gt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Whether `a` is less than or equal to `b`\\n     */\\n    function lte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\\n        return lt(a, b) || eq(a, b);\\n    }\\n\\n    /**\\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\\n     * @dev Returns: 2 for greater than\\n     *               1 for equal to\\n     *               0 for less than\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Compare result of `a` and `b`\\n     */\\n    function compare(UFixed6 a, UFixed6 b) internal pure returns (uint256) {\\n        (uint256 au, uint256 bu) = (UFixed6.unwrap(a), UFixed6.unwrap(b));\\n        if (au > bu) return 2;\\n        if (au < bu) return 0;\\n        return 1;\\n    }\\n\\n    /**\\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\\n     * @param a First unsigned number\\n     * @param b Second unsigned number\\n     * @return Ratio of `a` over `b`\\n     */\\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(a * BASE / b);\\n    }\\n\\n    /**\\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Minimum of `a` and `b`\\n     */\\n    function min(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(Math.min(UFixed6.unwrap(a), UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\\n     * @param a First unsigned fixed-decimal\\n     * @param b Second unsigned fixed-decimal\\n     * @return Maximum of `a` and `b`\\n     */\\n    function max(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\\n        return UFixed6.wrap(Math.max(UFixed6.unwrap(a), UFixed6.unwrap(b)));\\n    }\\n\\n    /**\\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\\n     * @param a Unsigned fixed-decimal\\n     * @return Truncated unsigned number\\n     */\\n    function truncate(UFixed6 a) internal pure returns (uint256) {\\n        return UFixed6.unwrap(a) / BASE;\\n    }\\n}\\n\\nlibrary UFixed6StorageLib {\\n    function read(UFixed6Storage self) internal view returns (UFixed6 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(UFixed6Storage self, UFixed6 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x378f6c0e6a0e8b534c019d99ddaecada9816e4c8ae66deba59bee92ac13ddc7f\",\"license\":\"Apache-2.0\"},\"@equilibria/root/pid/types/PAccumulator6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\nimport \\\"./PController6.sol\\\";\\n\\n/// @dev PAccumulator6 type\\nstruct PAccumulator6 {\\n    Fixed6 _value;\\n    Fixed6 _skew;\\n}\\nusing PAccumulator6Lib for PAccumulator6 global;\\n\\n/// @title PAccumulator6Lib\\n/// @notice Accumulator for a the fixed 6-decimal PID controller. This holds the \\\"last seen state\\\" of the PID controller\\n///         and works in conjunction with the PController6 to compute the current rate.\\n/// @dev This implementation is specifically a P controller, with I_k and D_k both set to 0. In between updates, it\\n///      continues to accumulate at a linear rate based on the previous skew, but the rate is capped at the max value.\\n///      Once the rate hits the max value, it will continue to accumulate at the max value until the next update.\\nlibrary PAccumulator6Lib {\\n    /// @notice Accumulates the rate against notional given the prior and current state\\n    /// @param self The controller accumulator\\n    /// @param controller The controller configuration\\n    /// @param skew The current skew\\n    /// @param fromTimestamp The timestamp of the prior accumulation\\n    /// @param toTimestamp The current timestamp\\n    /// @param notional The notional to accumulate against\\n    /// @return accumulated The total accumulated amount\\n    function accumulate(\\n        PAccumulator6 memory self,\\n        PController6 memory controller,\\n        Fixed6 skew,\\n        uint256 fromTimestamp,\\n        uint256 toTimestamp,\\n        UFixed6 notional\\n    ) internal pure returns (Fixed6 accumulated) {\\n        // compute new value and intercept\\n        (Fixed6 newValue, UFixed6 interceptTimestamp) =\\n            controller.compute(self._value, self._skew, fromTimestamp, toTimestamp);\\n\\n        // accumulate rate within max\\n        accumulated = _accumulate(\\n            self._value.add(newValue),\\n            UFixed6Lib.from(fromTimestamp),\\n            interceptTimestamp,\\n            notional\\n        ).div(Fixed6Lib.from(2)); // rate = self._value + newValue / 2 -> divide here for added precision\\n\\n        // accumulate rate outside of max\\n        accumulated = _accumulate(\\n            newValue,\\n            interceptTimestamp,\\n            UFixed6Lib.from(toTimestamp),\\n            notional\\n        ).add(accumulated);\\n\\n        // update values\\n        self._value = newValue;\\n        self._skew = skew;\\n    }\\n\\n    /// @notice Helper function to accumulate a singular rate against notional\\n    /// @param rate The rate to accumulate\\n    /// @param fromTimestamp The timestamp to accumulate from\\n    /// @param toTimestamp The timestamp to accumulate to\\n    /// @param notional The notional to accumulate against\\n    /// @return The accumulated amount\\n    function _accumulate(\\n        Fixed6 rate,\\n        UFixed6 fromTimestamp,\\n        UFixed6 toTimestamp,\\n        UFixed6 notional\\n    ) private pure returns (Fixed6) {\\n        return rate\\n            .mul(Fixed6Lib.from(toTimestamp.sub(fromTimestamp)))\\n            .mul(Fixed6Lib.from(notional))\\n            .div(Fixed6Lib.from(365 days));\\n    }\\n}\\n\",\"keccak256\":\"0xf374a9997426cc90141334cdc8f8d3d62758be7eaefd21c5885742cc18d79a3a\",\"license\":\"Apache-2.0\"},\"@equilibria/root/pid/types/PController6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../../number/types/Fixed6.sol\\\";\\n\\n/// @dev PController6 type\\nstruct PController6 {\\n    UFixed6 k;\\n    Fixed6 min;\\n    Fixed6 max;\\n}\\nusing PController6Lib for PController6 global;\\n\\n/// @title PController6Lib\\n/// @notice Configuration for a the fixed 6-decimal PID controller.\\n/// @dev Each second, the PID controller's value is incremented by `skew / k`, with `max` as the maximum value.\\nlibrary PController6Lib {\\n    /// @notice compute the new value and intercept timestamp based on the prior controller state\\n    /// @dev `interceptTimestamp` will never exceed `toTimestamp`\\n    /// @param self the controller configuration\\n    /// @param value the prior value\\n    /// @param skew The prior skew\\n    /// @param fromTimestamp The prior timestamp\\n    /// @param toTimestamp The current timestamp\\n    /// @return newValue the new value\\n    /// @return interceptTimestamp the timestamp at which the value will be at the max\\n    function compute(\\n        PController6 memory self,\\n        Fixed6 value,\\n        Fixed6 skew,\\n        uint256 fromTimestamp,\\n        uint256 toTimestamp\\n    ) internal pure returns (Fixed6 newValue, UFixed6 interceptTimestamp) {\\n        // compute the new value without considering the max\\n        Fixed6 newValueUncapped = value.add(\\n            Fixed6Lib.from(int256(toTimestamp - fromTimestamp))\\n                .mul(skew)\\n                .div(Fixed6Lib.from(self.k))\\n        );\\n\\n        // cap the new value between min and max\\n        newValue = newValueUncapped.min(self.max).max(self.min);\\n\\n        // compute distance and range to the resultant value\\n        (UFixed6 distance, Fixed6 range) = (UFixed6Lib.from(toTimestamp - fromTimestamp), newValueUncapped.sub(value));\\n\\n        // compute the amount of buffer until the value is outside the max\\n        UFixed6 buffer = value.gt(self.max) || value.lt(self.min) ?\\n            UFixed6Lib.ZERO :\\n            (range.sign() > 0 ? self.max : self.min).sub(value).abs();\\n\\n        // compute the timestamp at which the value will be at the max\\n        interceptTimestamp = range.isZero() ?\\n            UFixed6Lib.from(toTimestamp) :\\n            UFixed6Lib.from(fromTimestamp).add(distance.muldiv(buffer, range.abs())).min(UFixed6Lib.from(toTimestamp));\\n    }\\n}\\n\",\"keccak256\":\"0xd1248bd4e011e66105f6da85d63e767f2ca4a26365a177ee9322d5a4007aed0c\",\"license\":\"Apache-2.0\"},\"@equilibria/root/token/types/Token18.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport \\\"../../number/types/UFixed18.sol\\\";\\n\\n/// @dev Token18\\ntype Token18 is address;\\nusing Token18Lib for Token18 global;\\ntype Token18Storage is bytes32;\\nusing Token18StorageLib for Token18Storage global;\\n\\n/**\\n * @title Token18Lib\\n * @notice Library to manage 18-decimal ERC20s that is compliant with the fixed-decimal types.\\n * @dev Maintains significant gas savings over other Token implementations since no conversion take place\\n */\\nlibrary Token18Lib {\\n    using SafeERC20 for IERC20;\\n\\n    Token18 public constant ZERO = Token18.wrap(address(0));\\n\\n    /**\\n     * @notice Returns whether a token is the zero address\\n     * @param self Token to check for\\n     * @return Whether the token is the zero address\\n     */\\n    function isZero(Token18 self) internal pure returns (bool) {\\n        return Token18.unwrap(self) == Token18.unwrap(ZERO);\\n    }\\n\\n    /**\\n     * @notice Returns whether the two tokens are equal\\n     * @param a First token to compare\\n     * @param b Second token to compare\\n     * @return Whether the two tokens are equal\\n     */\\n    function eq(Token18 a, Token18 b) internal pure returns (bool) {\\n        return Token18.unwrap(a) ==  Token18.unwrap(b);\\n    }\\n\\n    /**\\n     * @notice Approves `grantee` to spend infinite tokens from the caller\\n     * @dev Uses `approve` rather than `safeApprove` since the race condition\\n     *      in safeApprove does not apply when going to an infinite approval\\n     * @param self Token to grant approval\\n     * @param grantee Address to allow spending\\n     */\\n    function approve(Token18 self, address grantee) internal {\\n        IERC20(Token18.unwrap(self)).approve(grantee, type(uint256).max);\\n    }\\n\\n    /**\\n     * @notice Approves `grantee` to spend `amount` tokens from the caller\\n     * @dev There are important race conditions to be aware of when using this function\\n            with values other than 0. This will revert if moving from non-zero to non-zero amounts\\n            See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a55b7d13722e7ce850b626da2313f3e66ca1d101/contracts/token/ERC20/IERC20.sol#L57\\n     * @param self Token to grant approval\\n     * @param grantee Address to allow spending\\n     * @param amount Amount of tokens to approve to spend\\n     */\\n    function approve(Token18 self, address grantee, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeApprove(grantee, UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers all held tokens from the caller to the `recipient`\\n     * @param self Token to transfer\\n     * @param recipient Address to receive the tokens\\n     */\\n    function push(Token18 self, address recipient) internal {\\n        push(self, recipient, balanceOf(self, address(this)));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the caller to the `recipient`\\n     * @param self Token to transfer\\n     * @param recipient Address to transfer tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function push(Token18 self, address recipient, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeTransfer(recipient, UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the `benefactor` to the caller\\n     * @dev Reverts if trying to pull Ether\\n     * @param self Token to transfer\\n     * @param benefactor Address to transfer tokens from\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function pull(Token18 self, address benefactor, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, address(this), UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`\\n     * @dev Reverts if trying to pull Ether\\n     * @param self Token to transfer\\n     * @param benefactor Address to transfer tokens from\\n     * @param recipient Address to transfer tokens to\\n     * @param amount Amount of tokens to transfer\\n     */\\n    function pullTo(Token18 self, address benefactor, address recipient, UFixed18 amount) internal {\\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, recipient, UFixed18.unwrap(amount));\\n    }\\n\\n    /**\\n     * @notice Returns the name of the token\\n     * @param self Token to check for\\n     * @return Token name\\n     */\\n    function name(Token18 self) internal view returns (string memory) {\\n        return IERC20Metadata(Token18.unwrap(self)).name();\\n    }\\n\\n    /**\\n     * @notice Returns the symbol of the token\\n     * @param self Token to check for\\n     * @return Token symbol\\n     */\\n    function symbol(Token18 self) internal view returns (string memory) {\\n        return IERC20Metadata(Token18.unwrap(self)).symbol();\\n    }\\n\\n    /**\\n     * @notice Returns the `self` token balance of the caller\\n     * @param self Token to check for\\n     * @return Token balance of the caller\\n     */\\n    function balanceOf(Token18 self) internal view returns (UFixed18) {\\n        return balanceOf(self, address(this));\\n    }\\n\\n    /**\\n     * @notice Returns the `self` token balance of `account`\\n     * @param self Token to check for\\n     * @param account Account to check\\n     * @return Token balance of the account\\n     */\\n    function balanceOf(Token18 self, address account) internal view returns (UFixed18) {\\n        return UFixed18.wrap(IERC20(Token18.unwrap(self)).balanceOf(account));\\n    }\\n\\n    /**\\n     * @notice Returns the `self` total supply\\n     * @param self Token to check for\\n     * @return The total supply of the token\\n     */\\n    function totalSupply(Token18 self) internal view returns (UFixed18) {\\n        return UFixed18.wrap(IERC20(Token18.unwrap(self)).totalSupply());\\n    }\\n}\\n\\nlibrary Token18StorageLib {\\n    function read(Token18Storage self) internal view returns (Token18 value) {\\n        assembly (\\\"memory-safe\\\") {\\n            value := sload(self)\\n        }\\n    }\\n\\n    function store(Token18Storage self, Token18 value) internal {\\n        assembly (\\\"memory-safe\\\") {\\n            sstore(self, value)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf8598d9147d6bbf219d30a8bc3ea0a272170761e2a5368cd09df28e9c478c637\",\"license\":\"Apache-2.0\"},\"@equilibria/root/utilization/CurveMath6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../number/types/UFixed6.sol\\\";\\nimport \\\"../number/types/Fixed6.sol\\\";\\n\\n/**\\n * @title CurveMath6\\n * @notice Library for managing math operations for utilization curves.\\n */\\nlibrary CurveMath6 {\\n    error CurveMath6OutOfBoundsError();\\n\\n    /**\\n     * @notice Computes a linear interpolation between two points\\n     * @param startX First point's x-coordinate\\n     * @param startY First point's y-coordinate\\n     * @param endX Second point's x-coordinate\\n     * @param endY Second point's y-coordinate\\n     * @param targetX x-coordinate to interpolate\\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\\n     */\\n    function linearInterpolation(\\n        UFixed6 startX,\\n        Fixed6 startY,\\n        UFixed6 endX,\\n        Fixed6 endY,\\n        UFixed6 targetX\\n    ) internal pure returns (Fixed6) {\\n        if (targetX.lt(startX) || targetX.gt(endX)) revert CurveMath6OutOfBoundsError();\\n\\n        UFixed6 xRange = endX.sub(startX);\\n        Fixed6 yRange = endY.sub(startY);\\n        UFixed6 xRatio = targetX.sub(startX).div(xRange);\\n        return yRange.mul(Fixed6Lib.from(xRatio)).add(startY);\\n    }\\n\\n    /**\\n     * @notice Computes a linear interpolation between two points\\n     * @param startX First point's x-coordinate\\n     * @param startY First point's y-coordinate\\n     * @param endX Second point's x-coordinate\\n     * @param endY Second point's y-coordinate\\n     * @param targetX x-coordinate to interpolate\\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\\n     */\\n    function linearInterpolation(\\n        UFixed6 startX,\\n        UFixed6 startY,\\n        UFixed6 endX,\\n        UFixed6 endY,\\n        UFixed6 targetX\\n    ) internal pure returns (UFixed6) {\\n        return UFixed6Lib.from(linearInterpolation(startX, Fixed6Lib.from(startY), endX, Fixed6Lib.from(endY), targetX));\\n    }\\n}\\n\",\"keccak256\":\"0xb2fc0e4473772b0a48f7282ac06bf1e86cea7cf0c788e406692e2d723633d549\",\"license\":\"Apache-2.0\"},\"@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport \\\"../CurveMath6.sol\\\";\\nimport \\\"../../number/types/UFixed6.sol\\\";\\n\\n/// @dev UJumpRateUtilizationCurve6 type\\nstruct UJumpRateUtilizationCurve6 {\\n    UFixed6 minRate;\\n    UFixed6 maxRate;\\n    UFixed6 targetRate;\\n    UFixed6 targetUtilization;\\n}\\nusing UJumpRateUtilizationCurve6Lib for UJumpRateUtilizationCurve6 global;\\n\\n/**\\n * @title UJumpRateUtilizationCurve6Lib\\n * @notice Library for the unsigned base-6 Jump Rate utilization curve type\\n */\\nlibrary UJumpRateUtilizationCurve6Lib {\\n    /**\\n     * @notice Computes the corresponding rate for a utilization ratio\\n     * @param utilization The utilization ratio\\n     * @return The corresponding rate\\n     */\\n    function compute(UJumpRateUtilizationCurve6 memory self, UFixed6 utilization) internal pure returns (UFixed6) {\\n        if (utilization.lt(self.targetUtilization)) {\\n            return CurveMath6.linearInterpolation(\\n                UFixed6Lib.ZERO,\\n                self.minRate,\\n                self.targetUtilization,\\n                self.targetRate,\\n                utilization\\n            );\\n        }\\n        if (utilization.lt(UFixed6Lib.ONE)) {\\n            return CurveMath6.linearInterpolation(\\n                self.targetUtilization,\\n                self.targetRate,\\n                UFixed6Lib.ONE,\\n                self.maxRate,\\n                utilization\\n            );\\n        }\\n        return self.maxRate;\\n    }\\n\\n    function accumulate(\\n        UJumpRateUtilizationCurve6 memory self,\\n        UFixed6 utilization,\\n        uint256 fromTimestamp,\\n        uint256 toTimestamp,\\n        UFixed6 notional\\n    ) internal pure returns (UFixed6) {\\n        return compute(self, utilization)\\n            .mul(UFixed6Lib.from(toTimestamp - fromTimestamp))\\n            .mul(notional)\\n            .div(UFixed6Lib.from(365 days));\\n    }\\n}\\n\",\"keccak256\":\"0xfc568a2f1a98e3659a2f4142f916e057fe6bf1ac70feb04ced81072d742c22e7\",\"license\":\"Apache-2.0\"},\"@equilibria/root/verifier/types/Common.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\n/// @notice Fields which need to be hashed in any EIP712 action\\nstruct Common {\\n    /// @dev The target account of the message (usually the account on behalf of which the action is being performed)\\n    address account;\\n    /// @dev EOA signing the message (usually either the account or a delegate of the account)\\n    address signer;\\n    /// @dev ensures the message is unique to a particular protocol version, chain, and verifier\\n    address domain;\\n    /// @dev per-sender nonce which is automatically cancelled upon validation\\n    uint256 nonce;\\n    /// @dev per-sender nonce which must be manually cancelled with a GroupCancellation message\\n    uint256 group;\\n    /// @dev prevents this message from having the intended effect after a specified timestamp\\n    uint256 expiry;\\n}\\nusing CommonLib for Common global;\\n\\n/// @title CommonLib\\n/// @notice Library collecting fields which need to be hashed in any EIP712 message\\nlibrary CommonLib {\\n    /// @dev used to verify a signed message\\n    bytes32 constant public STRUCT_HASH =\\n        keccak256(\\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\");\\n\\n    /// @dev used to create a signed message\\n    function hash(Common memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, self.account, self.signer, self.domain, self.nonce, self.group, self.expiry));\\n    }\\n}\\n\",\"keccak256\":\"0x0f5a75ca2064a624dae4e7f6c6b494dcc8ec560e5775ec8055dd91471f6cb93b\",\"license\":\"Apache-2.0\"},\"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\\n */\\ninterface IBeacon {\\n    /**\\n     * @dev Must return an address that can be used as a delegate call target.\\n     *\\n     * {BeaconProxy} will check that this address is a contract.\\n     */\\n    function implementation() external view returns (address);\\n}\\n\",\"keccak256\":\"0xd50a3421ac379ccb1be435fa646d66a65c986b4924f0849839f08692f39dde61\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x9750c6b834f7b43000631af5cc30001c5f547b3ceb3635488f140f60e897ea6b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xf41ca991f30855bf80ffd11e9347856a517b977f0a6c2d52e6421a99b7840329\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/draft-IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    function safeTransfer(\\n        IERC20 token,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(\\n        IERC20 token,\\n        address from,\\n        address to,\\n        uint256 value\\n    ) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(\\n        IERC20 token,\\n        address spender,\\n        uint256 value\\n    ) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            uint256 newAllowance = oldAllowance - value;\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n        }\\n    }\\n\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) {\\n            // Return data is optional\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9b72f93be69ca894d8492c244259615c4a742afc8d63720dbc8bb81087d9b238\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf96f969e24029d43d0df89e59d365f277021dac62b48e1c1e3ebe0acdd7f1ca1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator\\n    ) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1);\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(\\n        uint256 x,\\n        uint256 y,\\n        uint256 denominator,\\n        Rounding rounding\\n    ) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10**64) {\\n                value /= 10**64;\\n                result += 64;\\n            }\\n            if (value >= 10**32) {\\n                value /= 10**32;\\n                result += 32;\\n            }\\n            if (value >= 10**16) {\\n                value /= 10**16;\\n                result += 16;\\n            }\\n            if (value >= 10**8) {\\n                value /= 10**8;\\n                result += 8;\\n            }\\n            if (value >= 10**4) {\\n                value /= 10**4;\\n                result += 4;\\n            }\\n            if (value >= 10**2) {\\n                value /= 10**2;\\n                result += 2;\\n            }\\n            if (value >= 10**1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa1e8e83cd0087785df04ac79fb395d9f3684caeaf973d9e2c71caef723a3a5d6\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"@perennial/core/contracts/interfaces/IMarket.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { IInstance } from \\\"@equilibria/root/attribute/interfaces/IInstance.sol\\\";\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { Token18 } from \\\"@equilibria/root/token/types/Token18.sol\\\";\\nimport { Intent } from \\\"@perennial/verifier/contracts/types/Intent.sol\\\";\\nimport { IOracleProvider } from \\\"./IOracleProvider.sol\\\";\\nimport { OracleVersion } from \\\"../types/OracleVersion.sol\\\";\\nimport { MarketParameter } from \\\"../types/MarketParameter.sol\\\";\\nimport { RiskParameter } from \\\"../types/RiskParameter.sol\\\";\\nimport { Version } from \\\"../types/Version.sol\\\";\\nimport { Local } from \\\"../types/Local.sol\\\";\\nimport { Global } from \\\"../types/Global.sol\\\";\\nimport { Position } from \\\"../types/Position.sol\\\";\\nimport { Checkpoint } from \\\"../types/Checkpoint.sol\\\";\\nimport { Order } from \\\"../types/Order.sol\\\";\\nimport { Guarantee } from \\\"../types/Guarantee.sol\\\";\\nimport { VersionAccumulationResult } from \\\"../libs/VersionLib.sol\\\";\\nimport { CheckpointAccumulationResult } from \\\"../libs/CheckpointLib.sol\\\";\\n\\ninterface IMarket is IInstance {\\n    struct MarketDefinition {\\n        Token18 token;\\n        IOracleProvider oracle;\\n    }\\n\\n    struct Context {\\n        address account;\\n        MarketParameter marketParameter;\\n        RiskParameter riskParameter;\\n        OracleVersion latestOracleVersion;\\n        uint256 currentTimestamp;\\n        Global global;\\n        Local local;\\n        Position latestPositionGlobal;\\n        Position latestPositionLocal;\\n        Order pendingGlobal;\\n        Order pendingLocal;\\n    }\\n\\n    struct SettlementContext {\\n        Version latestVersion;\\n        Checkpoint latestCheckpoint;\\n        OracleVersion orderOracleVersion;\\n    }\\n\\n    struct UpdateContext {\\n        bool operator;\\n        bool signer;\\n        address liquidator;\\n        address orderReferrer;\\n        UFixed6 orderReferralFee;\\n        address guaranteeReferrer;\\n        UFixed6 guaranteeReferralFee;\\n        Order orderGlobal;\\n        Order orderLocal;\\n        Position currentPositionGlobal;\\n        Position currentPositionLocal;\\n        Guarantee guaranteeGlobal;\\n        Guarantee guaranteeLocal;\\n        UFixed6 collateralization;\\n    }\\n\\n    event OrderCreated(address indexed account, Order order, Guarantee guarantee, address liquidator, address orderReferrer, address guaranteeReferrer);\\n    event PositionProcessed(uint256 orderId, Order order, VersionAccumulationResult accumulationResult);\\n    event AccountPositionProcessed(address indexed account, uint256 orderId, Order order, CheckpointAccumulationResult accumulationResult);\\n    event BeneficiaryUpdated(address newBeneficiary);\\n    event CoordinatorUpdated(address newCoordinator);\\n    /// @notice Fee earned by an account was transferred from market to a receiver\\n    /// @param account User who earned the fee\\n    /// @param receiver Delegated operator of the account, or the account itself\\n    /// @param amount Collateral transferred from market to receiver\\n    event FeeClaimed(address indexed account, address indexed receiver, UFixed6 amount);\\n    event ExposureClaimed(address indexed account, Fixed6 amount);\\n    event ParameterUpdated(MarketParameter newParameter);\\n    event RiskParameterUpdated(RiskParameter newRiskParameter);\\n\\n    // sig: 0x0fe90964\\n    error MarketInsufficientLiquidityError();\\n    // sig: 0x00e2b6a8\\n    error MarketInsufficientMarginError();\\n    // sig: 0x442145e5\\n    error MarketInsufficientCollateralError();\\n    // sig: 0xba555da7\\n    error MarketProtectedError();\\n    // sig: 0x6ed43d8e\\n    error MarketMakerOverLimitError();\\n    // sig: 0x29ab4c44\\n    error MarketClosedError();\\n    // sig: 0x07732aee\\n    error MarketCollateralBelowLimitError();\\n    // sig: 0x5bdace60\\n    error MarketOperatorNotAllowedError();\\n    // sig: 0x8a68c1dc\\n    error MarketNotSingleSidedError();\\n    // sig: 0x736f9fda\\n    error MarketOverCloseError();\\n    // sig: 0x935bdc21\\n    error MarketExceedsPendingIdLimitError();\\n    // sig: 0x9bca0625\\n    error MarketNotCoordinatorError();\\n    // sig: 0xb602d086\\n    error MarketNotBeneficiaryError();\\n    // sig: 0x3222db45\\n    /// @custom:error Sender is not authorized to interact with markets on behalf of the account\\n    error MarketNotOperatorError();\\n    // sig: 0x534f7fe6\\n    error MarketInvalidProtectionError();\\n    // sig: 0xab1e3a00\\n    error MarketStalePriceError();\\n    // sig: 0x15f9ae70\\n    error MarketEfficiencyUnderLimitError();\\n    // sig: 0x7302d51a\\n    error MarketInvalidMarketParameterError(uint256 code);\\n    // sig: 0xc5f0e98a\\n    error MarketInvalidRiskParameterError(uint256 code);\\n    // sig: 0x9dbdc5fd\\n    error MarketInvalidReferrerError();\\n    // sig: 0x5c5cb438\\n    error MarketSettleOnlyError();\\n    // sig: 0x1e9d2296\\n    error MarketInvalidIntentFeeError();\\n    // sig: 0xaf5dfc8f\\n    error MarketIntentPriceDeviationError();\\n\\n    // sig: 0x2142bc27\\n    error GlobalStorageInvalidError();\\n    // sig: 0xc83d08ec\\n    error LocalStorageInvalidError();\\n    // sig: 0x7c53e926\\n    error MarketParameterStorageInvalidError();\\n    // sig: 0x98eb4898\\n    error PositionStorageLocalInvalidError();\\n    // sig: 0x7ecd083f\\n    error RiskParameterStorageInvalidError();\\n    // sig: 0xd2777e72\\n    error VersionStorageInvalidError();\\n\\n    function initialize(MarketDefinition calldata definition_) external;\\n    function migrate() external;\\n    function token() external view returns (Token18);\\n    function oracle() external view returns (IOracleProvider);\\n    function beneficiary() external view returns (address);\\n    function coordinator() external view returns (address);\\n    function positions(address account) external view returns (Position memory);\\n    function pendingOrders(address account, uint256 id) external view returns (Order memory);\\n    function guarantees(address account, uint256 id) external view returns (Guarantee memory);\\n    function pendings(address account) external view returns (Order memory);\\n    function locals(address account) external view returns (Local memory);\\n    function versions(uint256 timestamp) external view returns (Version memory);\\n    function position() external view returns (Position memory);\\n    function pendingOrder(uint256 id) external view returns (Order memory);\\n    function guarantee(uint256 id) external view returns (Guarantee memory);\\n    function pending() external view returns (Order memory);\\n    function global() external view returns (Global memory);\\n    function checkpoints(address account, uint256 version) external view returns (Checkpoint memory);\\n    function liquidators(address account, uint256 id) external view returns (address);\\n    function orderReferrers(address account, uint256 id) external view returns (address);\\n    function guaranteeReferrers(address account, uint256 id) external view returns (address);\\n    function settle(address account) external;\\n    function update(address account, Intent calldata intent, bytes memory signature) external;\\n    function update(address account, Fixed6 amount, Fixed6 collateral, address referrer) external;\\n    function update(address account, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect) external;\\n    function update(address account, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect, address referrer) external;\\n    function parameter() external view returns (MarketParameter memory);\\n    function riskParameter() external view returns (RiskParameter memory);\\n    function updateBeneficiary(address newBeneficiary) external;\\n    function updateCoordinator(address newCoordinator) external;\\n    function updateParameter(MarketParameter memory newParameter) external;\\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external;\\n    function claimFee(address account) external returns (UFixed6);\\n}\\n\",\"keccak256\":\"0xdcdf4c5c48b95ea6253b5d7f5054289d7fe54433dd54b82c5da585cf0ae357e6\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/interfaces/IOracleProvider.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { OracleReceipt } from \\\"../types/OracleReceipt.sol\\\";\\nimport { OracleVersion } from \\\"../types/OracleVersion.sol\\\";\\nimport { IMarket } from \\\"./IMarket.sol\\\";\\n\\n/// @dev OracleVersion Invariants\\n///       - Version are requested at a timestamp, the current timestamp is determined by the oracle\\n///         - The current timestamp may not be equal to block.timestamp, for example when batching timestamps\\n///       - Versions are allowed to \\\"fail\\\" and will be marked as .valid = false\\n///         - Invalid versions will always include the latest valid price as its price field\\n///       - Versions must be committed in order, i.e. all requested versions prior to latestVersion must be available\\n///       - Non-requested versions may be committed, but will not receive a settlement fee\\n///         - This is useful for immediately liquidating an account with a valid off-chain price in between orders\\n///         - Satisfying the above constraints, only versions more recent than the latest version may be committed\\n///       - Current must always be greater than Latest, never equal\\ninterface IOracleProvider {\\n    // sig: 0x652fafab\\n    error OracleProviderUnauthorizedError();\\n\\n    event OracleProviderVersionRequested(uint256 indexed version, bool newPrice);\\n    event OracleProviderVersionFulfilled(OracleVersion version);\\n\\n    function request(IMarket market, address account) external;\\n    function status() external view returns (OracleVersion memory, uint256);\\n    function latest() external view returns (OracleVersion memory);\\n    function current() external view returns (uint256);\\n    function at(uint256 timestamp) external view returns (OracleVersion memory, OracleReceipt memory);\\n}\",\"keccak256\":\"0xf5f11c678eb5bc91447ef0d919e2dd9dfa266985cd58597e3ee87fe3fca335c9\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/libs/CheckpointLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Accumulator6 } from \\\"@equilibria/root/accumulator/types/Accumulator6.sol\\\";\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6, Fixed6Lib } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { IMarket } from \\\"../interfaces/IMarket.sol\\\";\\nimport { Position } from \\\"../types/Position.sol\\\";\\nimport { Order } from \\\"../types/Order.sol\\\";\\nimport { Version } from \\\"../types/Version.sol\\\";\\nimport { Checkpoint } from \\\"../types/Checkpoint.sol\\\";\\nimport { Guarantee } from \\\"../types/Guarantee.sol\\\";\\n\\nstruct CheckpointAccumulationResponse {\\n    /// @dev Total Collateral change due to collateral, price override, and trade fee and offset\\n    Fixed6 collateral;\\n\\n    /// @dev Liquidation fee accumulated for this checkpoint (only if the order is protected)\\n    UFixed6 liquidationFee;\\n\\n    /// @dev Subtractive fee accumulated from the previous position to the next position (this amount is included in the linear fee)\\n    UFixed6 subtractiveFee;\\n\\n    /// @dev Solver fee accumulated the previous position to the next position (this amount is included in the linear fee)\\n    UFixed6 solverFee;\\n}\\n\\nstruct CheckpointAccumulationResult {\\n    /// @dev Total Collateral change due to pnl, funding, and interest from the previous position to the next position\\n    Fixed6 collateral;\\n\\n    /// @dev Collateral change from the difference between the price override and underlying market price\\n    Fixed6 priceOverride;\\n\\n    /// @dev Trade fee accumulated for this checkpoint\\n    UFixed6 tradeFee;\\n\\n    /// @dev Trade price impact accumulated for this checkpoint\\n    Fixed6 offset;\\n\\n    /// @dev Settlement fee charged for this checkpoint\\n    UFixed6 settlementFee;\\n\\n    /// @dev Liquidation fee accumulated for this checkpoint (only if the order is protected)\\n    UFixed6 liquidationFee;\\n\\n    /// @dev Subtractive fee accumulated from the previous position to the next position (this amount is included in the linear fee)\\n    UFixed6 subtractiveFee;\\n\\n    /// @dev Solver fee accumulated the previous position to the next position (this amount is included in the linear fee)\\n    UFixed6 solverFee;\\n}\\n\\n/// @title CheckpointLib\\n/// @dev (external-safe): this library is safe to externalize\\n/// @notice Manages the logic for the local order accumulation\\nlibrary CheckpointLib {\\n    /// @notice Accumulate pnl and fees from the latest position to next position\\n    /// @param order The next order\\n    /// @param fromVersion The previous latest version\\n    /// @param toVersion The next latest version\\n    /// @return next The next checkpoint\\n    /// @return response The accumulated pnl and fees\\n    function accumulate(\\n        IMarket.Context memory context,\\n        IMarket.SettlementContext memory settlementContext,\\n        uint256 orderId,\\n        Order memory order,\\n        Guarantee memory guarantee,\\n        Version memory fromVersion,\\n        Version memory toVersion\\n    ) external returns (Checkpoint memory next, CheckpointAccumulationResponse memory) {\\n        CheckpointAccumulationResult memory result;\\n\\n        // accumulate\\n        result.collateral = _accumulateCollateral(context.latestPositionLocal, fromVersion, toVersion);\\n        result.priceOverride = _accumulatePriceOverride(guarantee, toVersion);\\n        (result.tradeFee, result.subtractiveFee, result.solverFee) = _accumulateFee(order, guarantee, toVersion);\\n        result.offset = _accumulateOffset(order, guarantee, toVersion);\\n        result.settlementFee = _accumulateSettlementFee(order, guarantee, toVersion);\\n        result.liquidationFee = _accumulateLiquidationFee(order, toVersion);\\n\\n        // update checkpoint\\n        next.collateral = settlementContext.latestCheckpoint.collateral\\n            .sub(settlementContext.latestCheckpoint.tradeFee)                       // trade fee processed post settlement\\n            .sub(Fixed6Lib.from(settlementContext.latestCheckpoint.settlementFee)); // settlement / liquidation fee processed post settlement\\n        next.collateral = next.collateral\\n            .add(settlementContext.latestCheckpoint.transfer)                       // deposit / withdrawal processed post settlement\\n            .add(result.collateral)                                                 // incorporate collateral change at this settlement\\n            .add(result.priceOverride);                                             // incorporate price override pnl at this settlement\\n        next.transfer = order.collateral;\\n        next.tradeFee = Fixed6Lib.from(result.tradeFee).add(result.offset);\\n        next.settlementFee = result.settlementFee.add(result.liquidationFee);\\n\\n        emit IMarket.AccountPositionProcessed(context.account, orderId, order, result);\\n\\n        return (next, _response(result));\\n    }\\n\\n    /// @notice Converts the accumulation result into a response\\n    /// @param result The accumulation result\\n    /// @return response The accumulation response\\n    function _response(\\n        CheckpointAccumulationResult memory result\\n    ) private pure returns (CheckpointAccumulationResponse memory response) {\\n        response.collateral = result.collateral\\n            .add(result.priceOverride)\\n            .sub(Fixed6Lib.from(result.tradeFee))\\n            .sub(result.offset)\\n            .sub(Fixed6Lib.from(result.settlementFee));\\n        response.liquidationFee = result.liquidationFee;\\n        response.subtractiveFee = result.subtractiveFee;\\n        response.solverFee = result.solverFee;\\n    }\\n\\n    /// @notice Accumulate pnl, funding, and interest from the latest position to next position\\n    /// @param fromPosition The previous latest position\\n    /// @param fromVersion The previous latest version\\n    /// @param toVersion The next version\\n    function _accumulateCollateral(\\n        Position memory fromPosition,\\n        Version memory fromVersion,\\n        Version memory toVersion\\n    ) private pure returns (Fixed6) {\\n        return toVersion.makerValue.accumulated(fromVersion.makerValue, fromPosition.maker)\\n            .add(toVersion.longValue.accumulated(fromVersion.longValue, fromPosition.long))\\n            .add(toVersion.shortValue.accumulated(fromVersion.shortValue, fromPosition.short));\\n    }\\n\\n    /// @notice Accumulate trade fees for the next position\\n    /// @param order The next order\\n    /// @param guarantee The next guarantee\\n    /// @param toVersion The next version\\n    function _accumulateFee(\\n        Order memory order,\\n        Guarantee memory guarantee,\\n        Version memory toVersion\\n    ) private pure returns (UFixed6 tradeFee, UFixed6 subtractiveFee, UFixed6 solverFee) {\\n        UFixed6 takerTotal = order.takerTotal().sub(guarantee.takerFee);\\n\\n        // accumulate total trade fees on maker and taker orders\\n        UFixed6 makerFee = Fixed6Lib.ZERO\\n            .sub(toVersion.makerFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()))\\n            .abs();\\n        UFixed6 takerFee = Fixed6Lib.ZERO\\n            .sub(toVersion.takerFee.accumulated(Accumulator6(Fixed6Lib.ZERO), takerTotal))\\n            .abs();\\n\\n        // compute portion of trade fees that are subtractive\\n        UFixed6 makerSubtractiveFee = order.makerTotal().isZero() ?\\n            UFixed6Lib.ZERO :\\n            makerFee.muldiv(order.makerReferral, order.makerTotal());\\n        UFixed6 takerSubtractiveFee = takerTotal.isZero() ?\\n            UFixed6Lib.ZERO :\\n            takerFee.muldiv(order.takerReferral, takerTotal);\\n\\n        // compute portion of subtractive fees that are solver fees\\n        solverFee = takerTotal.isZero() ?\\n            UFixed6Lib.ZERO :\\n            takerFee.muldiv(guarantee.referral, takerTotal); // guarantee.referral is instantiated as a subset of order.takerReferral\\n\\n        tradeFee = makerFee.add(takerFee);\\n        subtractiveFee = makerSubtractiveFee.add(takerSubtractiveFee).sub(solverFee);\\n\\n    }\\n\\n    /// @notice Accumulate price offset for the next position\\n    /// @dev This includes adjustment for linear, proportional, and adiabatic order fees\\n    /// @param order The next order\\n    /// @param guarantee The next guarantee\\n    /// @param toVersion The next version\\n    function _accumulateOffset(\\n        Order memory order,\\n        Guarantee memory guarantee,\\n        Version memory toVersion\\n    ) private pure returns (Fixed6) {\\n        (UFixed6 takerPos, UFixed6 takerNeg) =\\n            (order.takerPos().sub(guarantee.takerPos), order.takerNeg().sub(guarantee.takerNeg));\\n\\n        return Fixed6Lib.ZERO\\n            .sub(toVersion.makerOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()))\\n            .sub(toVersion.takerPosOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), takerPos))\\n            .sub(toVersion.takerNegOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), takerNeg));\\n    }\\n\\n\\n    /// @notice Accumulate settlement fees for the next position\\n    /// @param order The next order\\n    /// @param guarantee The next guarantee\\n    /// @param toVersion The next version\\n    function _accumulateSettlementFee(\\n        Order memory order,\\n        Guarantee memory guarantee,\\n        Version memory toVersion\\n    ) private pure returns (UFixed6) {\\n        uint256 orders = order.orders - guarantee.orders;\\n\\n        return toVersion.settlementFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.from(orders)).abs();\\n    }\\n\\n    /// @notice Accumulate liquidation fees for the next position\\n    /// @param order The next order\\n    /// @param toVersion The next version\\n    function _accumulateLiquidationFee(\\n        Order memory order,\\n        Version memory toVersion\\n    ) private pure returns (UFixed6) {\\n        if (!order.protected()) return UFixed6Lib.ZERO;\\n        return toVersion.liquidationFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.ONE).abs();\\n    }\\n\\n    /// @notice Accumulate price override pnl for the next position\\n    /// @param guarantee The next guarantee\\n    /// @param toVersion The next version\\n    function _accumulatePriceOverride(\\n        Guarantee memory guarantee,\\n        Version memory toVersion\\n    ) private pure returns (Fixed6) {\\n        if (!toVersion.valid) return Fixed6Lib.ZERO;\\n        return guarantee.priceAdjustment(toVersion.price);\\n    }\\n}\\n\",\"keccak256\":\"0xbc5a626bbb7b0d6255f5e86964db1114dd447334fb1bb82e3463a682637ff02e\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/libs/VersionLib.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6, Fixed6Lib } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { IMarket } from \\\"../interfaces/IMarket.sol\\\";\\nimport { MarketParameter } from \\\"../types/MarketParameter.sol\\\";\\nimport { RiskParameter } from \\\"../types/RiskParameter.sol\\\";\\nimport { Global } from \\\"../types/Global.sol\\\";\\nimport { Position } from \\\"../types/Position.sol\\\";\\nimport { Order } from \\\"../types/Order.sol\\\";\\nimport { Guarantee } from \\\"../types/Guarantee.sol\\\";\\nimport { Version } from \\\"../types/Version.sol\\\";\\nimport { OracleVersion } from \\\"../types/OracleVersion.sol\\\";\\nimport { OracleReceipt } from \\\"../types/OracleReceipt.sol\\\";\\n\\n/// @dev The response of the version accumulation\\n///      Contains only select fee information needed for the downstream market contract\\n///      Returned by the accumulate function\\nstruct VersionAccumulationResponse {\\n    /// @dev The total market fee charged including (tradeFee, tradeOffsetMarket, fundingFee, interestFee)\\n    UFixed6 marketFee;\\n\\n    /// @dev The settlement fee charged\\n    UFixed6 settlementFee;\\n\\n    /// @dev The market's adiabatic exposure\\n    Fixed6 marketExposure;\\n}\\n\\n/// @dev The result of the version accumulation\\n///      Contains all the accumulated values for the version\\n///      Emitted via the PositionProcessed event\\nstruct VersionAccumulationResult {\\n    /// @dev The trade fee charged\\n    UFixed6 tradeFee;\\n\\n    /// @dev The subtractive fee charged\\n    UFixed6 subtractiveFee;\\n\\n    /// @dev The total price impact of the trade (including linear, proportional, and adiabatic)\\n    Fixed6 tradeOffset;\\n\\n    /// @dev The portion of the trade offset that the makers receive\\n    Fixed6 tradeOffsetMaker;\\n\\n    /// @dev The portion of the trade offset that the market receives (if there are no makers)\\n    UFixed6 tradeOffsetMarket;\\n\\n    /// @dev The adiabatic exposure accrued\\n    Fixed6 adiabaticExposure;\\n\\n    /// @dev The adiabatic exposure accrued by makers\\n    Fixed6 adiabaticExposureMaker;\\n\\n    /// @dev The adiabatic exposure accrued by the market\\n    Fixed6 adiabaticExposureMarket;\\n\\n    /// @dev Funding accrued by makers\\n    Fixed6 fundingMaker;\\n\\n    /// @dev Funding accrued by longs\\n    Fixed6 fundingLong;\\n\\n    /// @dev Funding accrued by shorts\\n    Fixed6 fundingShort;\\n\\n    /// @dev Funding received by the protocol\\n    UFixed6 fundingFee;\\n\\n    /// @dev Interest accrued by makers\\n    Fixed6 interestMaker;\\n\\n    /// @dev Interest accrued by longs\\n    Fixed6 interestLong;\\n\\n    /// @dev Interest accrued by shorts\\n    Fixed6 interestShort;\\n\\n    /// @dev Interest received by the protocol\\n    UFixed6 interestFee;\\n\\n    /// @dev Price-based profit/loss accrued by makers\\n    Fixed6 pnlMaker;\\n\\n    /// @dev Price-based profit/loss accrued by longs\\n    Fixed6 pnlLong;\\n\\n    /// @dev Price-based profit/loss accrued by shorts\\n    Fixed6 pnlShort;\\n\\n    /// @dev Total settlement fee charged\\n    UFixed6 settlementFee;\\n\\n    /// @dev Snapshot of the riskParameter.liquidationFee at the version (0 if not valid)\\n    UFixed6 liquidationFee;\\n}\\n\\n/// @dev The in-memory context for the version accumulation\\nstruct VersionAccumulationContext {\\n    Global global;\\n    Position fromPosition;\\n    uint256 orderId;\\n    Order order;\\n    Guarantee guarantee;\\n    OracleVersion fromOracleVersion;\\n    OracleVersion toOracleVersion;\\n    OracleReceipt toOracleReceipt;\\n    MarketParameter marketParameter;\\n    RiskParameter riskParameter;\\n}\\n\\n/// @title VersionLib\\n/// @dev (external-safe): this library is safe to externalize\\n/// @notice Manages the logic for the global order accumulation\\nlibrary VersionLib {\\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\\n    function accumulate(\\n        IMarket.Context memory context,\\n        IMarket.SettlementContext memory settlementContext,\\n        uint256 newOrderId,\\n        Order memory newOrder,\\n        Guarantee memory newGuarantee,\\n        OracleVersion memory oracleVersion,\\n        OracleReceipt memory oracleReceipt\\n    ) external returns (Version memory next, Global memory nextGlobal, VersionAccumulationResponse memory response) {\\n        VersionAccumulationContext memory accumulationContext = VersionAccumulationContext(\\n            context.global,\\n            context.latestPositionGlobal,\\n            newOrderId,\\n            newOrder,\\n            newGuarantee,\\n            settlementContext.orderOracleVersion,\\n            oracleVersion,\\n            oracleReceipt,\\n            context.marketParameter,\\n            context.riskParameter\\n        );\\n\\n        return _accumulate(settlementContext.latestVersion, accumulationContext);\\n    }\\n\\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\\n    /// @param self The Version object to update\\n    /// @param context The accumulation context\\n    /// @return next The accumulated version\\n    /// @return nextGlobal The next global state\\n    /// @return response The accumulation response\\n    function _accumulate(\\n        Version memory self,\\n        VersionAccumulationContext memory context\\n    ) private returns (Version memory next, Global memory nextGlobal, VersionAccumulationResponse memory response) {\\n        VersionAccumulationResult memory result;\\n\\n        // setup next accumulators\\n        _next(self, next);\\n\\n        // record oracle version\\n        (next.valid, next.price) = (context.toOracleVersion.valid, context.toOracleVersion.price);\\n        context.global.latestPrice = context.toOracleVersion.price;\\n\\n        // accumulate settlement fee\\n        result.settlementFee = _accumulateSettlementFee(next, context);\\n\\n        // accumulate liquidation fee\\n        result.liquidationFee = _accumulateLiquidationFee(next, context);\\n\\n        // accumulate fee\\n        _accumulateFee(next, context, result);\\n\\n        // accumulate linear fee\\n        _accumulateLinearFee(next, context, result);\\n\\n        // accumulate proportional fee\\n        _accumulateProportionalFee(next, context, result);\\n\\n        // accumulate adiabatic exposure\\n        _accumulateAdiabaticExposure(next, context, result);\\n\\n        // accumulate adiabatic fee\\n        _accumulateAdiabaticFee(next, context, result);\\n\\n        // if closed, don't accrue anything else\\n        if (context.marketParameter.closed) return _return(context, result, next);\\n\\n        // accumulate funding\\n        (result.fundingMaker, result.fundingLong, result.fundingShort, result.fundingFee) =\\n            _accumulateFunding(next, context);\\n\\n        // accumulate interest\\n        (result.interestMaker, result.interestLong, result.interestShort, result.interestFee) =\\n            _accumulateInterest(next, context);\\n\\n        // accumulate P&L\\n        (result.pnlMaker, result.pnlLong, result.pnlShort) = _accumulatePNL(next, context);\\n\\n        return _return(context, result, next);\\n    }\\n\\n    function _return(\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result,\\n        Version memory next\\n    ) private returns (Version memory, Global memory, VersionAccumulationResponse memory) {\\n        emit IMarket.PositionProcessed(context.orderId, context.order, result);\\n\\n        return (next, context.global, _response(result));\\n    }\\n\\n    /// @notice Converts the accumulation result into a response\\n    /// @param result The accumulation result\\n    /// @return response The accumulation response\\n    function _response(\\n        VersionAccumulationResult memory result\\n    ) private pure returns (VersionAccumulationResponse memory response) {\\n        response.marketFee = result.tradeFee\\n            .add(result.tradeOffsetMarket)\\n            .add(result.fundingFee)\\n            .add(result.interestFee);\\n        response.settlementFee = result.settlementFee;\\n        response.marketExposure = result.adiabaticExposureMarket;\\n    }\\n\\n    /// @notice Copies over the version-over-version accumulators to prepare the next version\\n    /// @param self The Version object to update\\n    function _next(Version memory self, Version memory next) internal pure {\\n        next.makerValue._value = self.makerValue._value;\\n        next.longValue._value = self.longValue._value;\\n        next.shortValue._value = self.shortValue._value;\\n    }\\n\\n    /// @notice Globally accumulates settlement fees since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateSettlementFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context\\n    ) private pure returns (UFixed6 settlementFee) {\\n        uint256 orders = context.order.orders - context.guarantee.orders;\\n        settlementFee = orders == 0 ? UFixed6Lib.ZERO : context.toOracleReceipt.settlementFee;\\n        next.settlementFee.decrement(Fixed6Lib.from(settlementFee), UFixed6Lib.from(orders));\\n    }\\n\\n    /// @notice Globally accumulates hypothetical liquidation fee since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateLiquidationFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context\\n    ) private pure returns (UFixed6 liquidationFee) {\\n        liquidationFee = context.toOracleVersion.valid ?\\n            context.toOracleReceipt.settlementFee.mul(context.riskParameter.liquidationFee) :\\n            UFixed6Lib.ZERO;\\n        next.liquidationFee.decrement(Fixed6Lib.from(liquidationFee), UFixed6Lib.ONE);\\n    }\\n\\n    /// @notice Globally accumulates linear fees since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result\\n    ) private pure {\\n        UFixed6 makerFee = context.order.makerTotal()\\n            .mul(context.toOracleVersion.price.abs())\\n            .mul(context.marketParameter.makerFee);\\n        next.makerFee.decrement(Fixed6Lib.from(makerFee), context.order.makerTotal());\\n        UFixed6 makerSubtractiveFee = context.order.makerTotal().isZero() ?\\n            UFixed6Lib.ZERO :\\n            makerFee.muldiv(context.order.makerReferral, context.order.makerTotal());\\n\\n        UFixed6 takerTotal = context.order.takerTotal().sub(context.guarantee.takerFee);\\n        UFixed6 takerFee = takerTotal\\n            .mul(context.toOracleVersion.price.abs())\\n            .mul(context.marketParameter.takerFee);\\n        next.takerFee.decrement(Fixed6Lib.from(takerFee), takerTotal);\\n        UFixed6 takerSubtractiveFee = takerTotal.isZero() ?\\n            UFixed6Lib.ZERO :\\n            takerFee.muldiv(context.order.takerReferral, takerTotal);\\n\\n        result.tradeFee = result.tradeFee.add(makerFee).add(takerFee).sub(makerSubtractiveFee).sub(takerSubtractiveFee);\\n        result.subtractiveFee = result.subtractiveFee.add(makerSubtractiveFee).add(takerSubtractiveFee);\\n    }\\n\\n    /// @notice Globally accumulates linear fees since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateLinearFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result\\n    ) private pure {\\n        UFixed6 makerLinearFee = context.riskParameter.makerFee.linear(\\n            Fixed6Lib.from(context.order.makerTotal()),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.makerOffset.decrement(Fixed6Lib.from(makerLinearFee), context.order.makerTotal());\\n\\n        UFixed6 takerPosTotal = context.order.takerPos().sub(context.guarantee.takerPos);\\n        UFixed6 takerPosLinearFee = context.riskParameter.takerFee.linear(\\n            Fixed6Lib.from(takerPosTotal),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerPosOffset.decrement(Fixed6Lib.from(takerPosLinearFee), takerPosTotal);\\n\\n        UFixed6 takerNegTotal = context.order.takerNeg().sub(context.guarantee.takerNeg);\\n        UFixed6 takerNegLinearFee = context.riskParameter.takerFee.linear(\\n            Fixed6Lib.from(takerNegTotal),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerNegOffset.decrement(Fixed6Lib.from(takerNegLinearFee), takerNegTotal);\\n\\n        UFixed6 linearFee = makerLinearFee.add(takerPosLinearFee).add(takerNegLinearFee);\\n        UFixed6 marketFee = context.fromPosition.maker.isZero() ? linearFee : UFixed6Lib.ZERO;\\n        UFixed6 makerFee = linearFee.sub(marketFee);\\n        next.makerValue.increment(Fixed6Lib.from(makerFee), context.fromPosition.maker);\\n\\n        result.tradeOffset = result.tradeOffset.add(Fixed6Lib.from(linearFee));\\n        result.tradeOffsetMaker = result.tradeOffsetMaker.add(Fixed6Lib.from(makerFee));\\n        result.tradeOffsetMarket = result.tradeOffsetMarket.add(marketFee);\\n    }\\n\\n    /// @notice Globally accumulates proportional fees since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateProportionalFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result\\n    ) private pure {\\n        UFixed6 makerProportionalFee = context.riskParameter.makerFee.proportional(\\n            Fixed6Lib.from(context.order.makerTotal()),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.makerOffset.decrement(Fixed6Lib.from(makerProportionalFee), context.order.makerTotal());\\n\\n        UFixed6 takerPos = context.order.takerPos().sub(context.guarantee.takerPos);\\n        UFixed6 takerPosProportionalFee = context.riskParameter.takerFee.proportional(\\n            Fixed6Lib.from(takerPos),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerPosOffset.decrement(Fixed6Lib.from(takerPosProportionalFee), takerPos);\\n\\n        UFixed6 takerNeg = context.order.takerNeg().sub(context.guarantee.takerNeg);\\n        UFixed6 takerNegProportionalFee = context.riskParameter.takerFee.proportional(\\n            Fixed6Lib.from(takerNeg),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerNegOffset.decrement(Fixed6Lib.from(takerNegProportionalFee), takerNeg);\\n\\n        UFixed6 proportionalFee = makerProportionalFee.add(takerPosProportionalFee).add(takerNegProportionalFee);\\n        UFixed6 marketFee = context.fromPosition.maker.isZero() ? proportionalFee : UFixed6Lib.ZERO;\\n        UFixed6 makerFee = proportionalFee.sub(marketFee);\\n        next.makerValue.increment(Fixed6Lib.from(makerFee), context.fromPosition.maker);\\n\\n        result.tradeOffset = result.tradeOffset.add(Fixed6Lib.from(proportionalFee));\\n        result.tradeOffsetMaker = result.tradeOffsetMaker.add(Fixed6Lib.from(makerFee));\\n        result.tradeOffsetMarket = result.tradeOffsetMarket.add(marketFee);\\n    }\\n\\n    /// @notice Globally accumulates adiabatic fees since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    function _accumulateAdiabaticFee(\\n        Version memory next,\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result\\n    ) private pure {\\n        Fixed6 adiabaticFee;\\n\\n        // position fee from positive skew taker orders\\n        UFixed6 takerPos = context.order.takerPos().sub(context.guarantee.takerPos);\\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\\n            context.fromPosition.skew(),\\n            Fixed6Lib.from(takerPos),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerPosOffset.decrement(adiabaticFee, takerPos);\\n        result.tradeOffset = result.tradeOffset.add(adiabaticFee);\\n\\n        // position fee from negative skew taker orders\\n        UFixed6 takerNeg = context.order.takerNeg().sub(context.guarantee.takerNeg);\\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\\n            context.fromPosition.skew().add(Fixed6Lib.from(takerPos)),\\n            Fixed6Lib.from(-1, takerNeg),\\n            context.toOracleVersion.price.abs()\\n        );\\n        next.takerNegOffset.decrement(adiabaticFee, takerNeg);\\n        result.tradeOffset = result.tradeOffset.add(adiabaticFee);\\n    }\\n\\n    /// @notice Globally accumulates single component of the position fees exposure since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    /// @param result The accumulation result\\n    function _accumulateAdiabaticExposure(\\n        Version memory next,\\n        VersionAccumulationContext memory context,\\n        VersionAccumulationResult memory result\\n    ) private pure {\\n        Fixed6 exposure = context.riskParameter.takerFee.exposure(context.fromPosition.skew());\\n\\n        Fixed6 adiabaticExposure = context.toOracleVersion.price.sub(context.fromOracleVersion.price).mul(exposure);\\n        Fixed6 adiabaticExposureMaker = adiabaticExposure.mul(Fixed6Lib.NEG_ONE);\\n        Fixed6 adiabaticExposureMarket = context.fromPosition.maker.isZero() ? adiabaticExposureMaker : Fixed6Lib.ZERO;\\n        adiabaticExposureMaker = adiabaticExposureMaker.sub(adiabaticExposureMarket);\\n        next.makerValue.increment(adiabaticExposureMaker, context.fromPosition.maker);\\n\\n        result.adiabaticExposure = adiabaticExposure;\\n        result.adiabaticExposureMarket = adiabaticExposureMarket;\\n        result.adiabaticExposureMaker = adiabaticExposureMaker;\\n    }\\n\\n    /// @notice Globally accumulates all long-short funding since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    /// @return fundingMaker The total funding accrued by makers\\n    /// @return fundingLong The total funding accrued by longs\\n    /// @return fundingShort The total funding accrued by shorts\\n    /// @return fundingFee The total fee accrued from funding accumulation\\n    function _accumulateFunding(Version memory next, VersionAccumulationContext memory context) private pure returns (\\n        Fixed6 fundingMaker,\\n        Fixed6 fundingLong,\\n        Fixed6 fundingShort,\\n        UFixed6 fundingFee\\n    ) {\\n        Fixed6 toSkew = context.toOracleVersion.valid ?\\n            context.fromPosition.skew().add(context.order.long()).sub(context.order.short()) :\\n            context.fromPosition.skew();\\n\\n        // Compute long-short funding rate\\n        Fixed6 funding = context.global.pAccumulator.accumulate(\\n            context.riskParameter.pController,\\n            toSkew.unsafeDiv(Fixed6Lib.from(context.riskParameter.takerFee.scale)).min(Fixed6Lib.ONE).max(Fixed6Lib.NEG_ONE),\\n            context.fromOracleVersion.timestamp,\\n            context.toOracleVersion.timestamp,\\n            context.fromPosition.takerSocialized().mul(context.fromOracleVersion.price.abs())\\n        );\\n\\n        // Handle maker receive-only status\\n        if (context.riskParameter.makerReceiveOnly && funding.sign() != context.fromPosition.skew().sign())\\n            funding = funding.mul(Fixed6Lib.NEG_ONE);\\n\\n        // Initialize long and short funding\\n        (fundingLong, fundingShort) = (Fixed6Lib.NEG_ONE.mul(funding), funding);\\n\\n        // Compute fee spread\\n        fundingFee = funding.abs().mul(context.marketParameter.fundingFee);\\n        Fixed6 fundingSpread = Fixed6Lib.from(fundingFee).div(Fixed6Lib.from(2));\\n\\n        // Adjust funding with spread\\n        (fundingLong, fundingShort) = (\\n            fundingLong.sub(Fixed6Lib.from(fundingFee)).add(fundingSpread),\\n            fundingShort.sub(fundingSpread)\\n        );\\n\\n        // Redirect net portion of minor's side to maker\\n        if (context.fromPosition.long.gt(context.fromPosition.short)) {\\n            fundingMaker = fundingShort.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\\n            fundingShort = fundingShort.sub(fundingMaker);\\n        }\\n        if (context.fromPosition.short.gt(context.fromPosition.long)) {\\n            fundingMaker = fundingLong.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\\n            fundingLong = fundingLong.sub(fundingMaker);\\n        }\\n\\n        next.makerValue.increment(fundingMaker, context.fromPosition.maker);\\n        next.longValue.increment(fundingLong, context.fromPosition.long);\\n        next.shortValue.increment(fundingShort, context.fromPosition.short);\\n    }\\n\\n    /// @notice Globally accumulates all maker interest since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    /// @return interestMaker The total interest accrued by makers\\n    /// @return interestLong The total interest accrued by longs\\n    /// @return interestShort The total interest accrued by shorts\\n    /// @return interestFee The total fee accrued from interest accumulation\\n    function _accumulateInterest(\\n        Version memory next,\\n        VersionAccumulationContext memory context\\n    ) private pure returns (Fixed6 interestMaker, Fixed6 interestLong, Fixed6 interestShort, UFixed6 interestFee) {\\n        UFixed6 notional = context.fromPosition.long.add(context.fromPosition.short).min(context.fromPosition.maker).mul(context.fromOracleVersion.price.abs());\\n\\n        // Compute maker interest\\n        UFixed6 interest = context.riskParameter.utilizationCurve.accumulate(\\n            context.fromPosition.utilization(context.riskParameter),\\n            context.fromOracleVersion.timestamp,\\n            context.toOracleVersion.timestamp,\\n            notional\\n        );\\n\\n        // Compute fee\\n        interestFee = interest.mul(context.marketParameter.interestFee);\\n\\n        // Adjust long and short funding with spread\\n        interestLong = Fixed6Lib.from(\\n            context.fromPosition.major().isZero() ?\\n            interest :\\n            interest.muldiv(context.fromPosition.long, context.fromPosition.long.add(context.fromPosition.short))\\n        );\\n        interestShort = Fixed6Lib.from(interest).sub(interestLong);\\n        interestMaker = Fixed6Lib.from(interest.sub(interestFee));\\n\\n        interestLong = interestLong.mul(Fixed6Lib.NEG_ONE);\\n        interestShort = interestShort.mul(Fixed6Lib.NEG_ONE);\\n        next.makerValue.increment(interestMaker, context.fromPosition.maker);\\n        next.longValue.increment(interestLong, context.fromPosition.long);\\n        next.shortValue.increment(interestShort, context.fromPosition.short);\\n    }\\n\\n    /// @notice Globally accumulates position profit & loss since last oracle update\\n    /// @param next The Version object to update\\n    /// @param context The accumulation context\\n    /// @return pnlMaker The total pnl accrued by makers\\n    /// @return pnlLong The total pnl accrued by longs\\n    /// @return pnlShort The total pnl accrued by shorts\\n    function _accumulatePNL(\\n        Version memory next,\\n        VersionAccumulationContext memory context\\n    ) private pure returns (Fixed6 pnlMaker, Fixed6 pnlLong, Fixed6 pnlShort) {\\n        pnlLong = context.toOracleVersion.price.sub(context.fromOracleVersion.price)\\n            .mul(Fixed6Lib.from(context.fromPosition.longSocialized()));\\n        pnlShort = context.fromOracleVersion.price.sub(context.toOracleVersion.price)\\n            .mul(Fixed6Lib.from(context.fromPosition.shortSocialized()));\\n        pnlMaker = pnlLong.add(pnlShort).mul(Fixed6Lib.NEG_ONE);\\n\\n        next.longValue.increment(pnlLong, context.fromPosition.long);\\n        next.shortValue.increment(pnlShort, context.fromPosition.short);\\n        next.makerValue.increment(pnlMaker, context.fromPosition.maker);\\n    }\\n}\\n\",\"keccak256\":\"0xebdfab129d0a1960356087eef7ee3cb250d76c82679340fed208e4c5003ba4aa\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/Checkpoint.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\n\\n/// @dev Checkpoint type\\nstruct Checkpoint {\\n    /// @dev The trade fee that the order incurred at the checkpoint settlement\\n    Fixed6 tradeFee;\\n\\n    // @dev The settlement and liquidation fee that the order incurred at the checkpoint settlement\\n    UFixed6 settlementFee;\\n\\n    /// @dev The amount deposited or withdrawn at the checkpoint settlement\\n    Fixed6 transfer;\\n\\n    /// @dev The collateral at the time of the checkpoint settlement\\n    Fixed6 collateral;\\n}\\nstruct CheckpointStorage { uint256 slot0; }\\nusing CheckpointStorageLib for CheckpointStorage global;\\n\\n/// @dev Manually encodes and decodes the Checkpoint struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredCheckpoint {\\n///         /* slot 0 */\\n///         int48 tradeFee;\\n///         uint48 settlementFee;\\n///         int64 transfer;\\n///         int64 collateral;\\n///     }\\n///\\nlibrary CheckpointStorageLib {\\n    // sig: 0xba85116a\\n    error CheckpointStorageInvalidError();\\n\\n    function read(CheckpointStorage storage self) internal view returns (Checkpoint memory) {\\n        uint256 slot0 = self.slot0;\\n        return Checkpoint(\\n            Fixed6.wrap(int256(slot0 << (256 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 48 - 48)) >> (256 - 48)),\\n            Fixed6.wrap(int256(slot0 << (256 - 48 - 48 - 64)) >> (256 - 64)),\\n            Fixed6.wrap(int256(slot0 << (256 - 48 - 48 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(CheckpointStorage storage self, Checkpoint memory newValue) external {\\n        if (newValue.tradeFee.gt(Fixed6.wrap(type(int48).max))) revert CheckpointStorageInvalidError();\\n        if (newValue.tradeFee.lt(Fixed6.wrap(type(int48).min))) revert CheckpointStorageInvalidError();\\n        if (newValue.settlementFee.gt(UFixed6.wrap(type(uint48).max))) revert CheckpointStorageInvalidError();\\n        if (newValue.transfer.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\\n        if (newValue.transfer.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(Fixed6.unwrap(newValue.tradeFee)        << (256 - 48)) >> (256 - 48) |\\n            uint256(UFixed6.unwrap(newValue.settlementFee)  << (256 - 48)) >> (256 - 48 - 48) |\\n            uint256(Fixed6.unwrap(newValue.transfer)        << (256 - 64)) >> (256 - 48 - 48 - 64) |\\n            uint256(Fixed6.unwrap(newValue.collateral)      << (256 - 64)) >> (256 - 48 - 48 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x0ad6eb83fdb2f7d27401939a18cf1e2bb56359f177210d2670113f36bd8943b3\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/Global.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { PAccumulator6 } from \\\"@equilibria/root/pid/types/PAccumulator6.sol\\\";\\nimport { MarketParameter } from \\\"./MarketParameter.sol\\\";\\nimport { RiskParameter } from \\\"./RiskParameter.sol\\\";\\nimport { Position } from \\\"./Position.sol\\\";\\nimport { OracleVersion } from \\\"./OracleVersion.sol\\\";\\nimport { OracleReceipt } from \\\"./OracleReceipt.sol\\\";\\nimport { VersionAccumulationResponse } from \\\"../libs/VersionLib.sol\\\";\\n\\n/// @dev Global type\\nstruct Global {\\n    /// @dev The current position ID\\n    uint256 currentId;\\n\\n    /// @dev The latest position id\\n    uint256 latestId;\\n\\n    /// @dev The accrued protocol fee\\n    UFixed6 protocolFee;\\n\\n    /// @dev The accrued oracle fee\\n    UFixed6 oracleFee;\\n\\n    /// @dev The accrued risk fee\\n    UFixed6 riskFee;\\n\\n    /// @dev The latest valid price in the market\\n    Fixed6 latestPrice;\\n\\n    /// @dev The accumulated market exposure\\n    Fixed6 exposure;\\n\\n    /// @dev The current PAccumulator state\\n    PAccumulator6 pAccumulator;\\n}\\nusing GlobalLib for Global global;\\nstruct GlobalStorage { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing GlobalStorageLib for GlobalStorage global;\\n\\n/// @title Global\\n/// @dev (external-unsafe): this library must be used internally only\\n/// @notice Holds the global market state\\nlibrary GlobalLib {\\n    /// @notice Updates market exposure based on a change in the risk parameter configuration\\n    /// @param self The Global object to update\\n    /// @param latestRiskParameter The latest risk parameter configuration\\n    /// @param newRiskParameter The new risk parameter configuration\\n    /// @param latestPosition The latest position\\n    function update(\\n        Global memory self,\\n        RiskParameter memory latestRiskParameter,\\n        RiskParameter memory newRiskParameter,\\n        Position memory latestPosition\\n    ) internal pure {\\n        Fixed6 exposureChange = latestRiskParameter.takerFee\\n            .exposure(newRiskParameter.takerFee, latestPosition.skew(), self.latestPrice.abs());\\n        self.exposure = self.exposure.sub(exposureChange);\\n    }\\n\\n    /// @notice Increments the fees by `amount` using current parameters\\n    /// @dev Computes the fees based on the current market parameters\\n    ///      market fee -> trade fee + market's trade offset + funding fee + interest fee\\n    ///        1. oracle fee taken out as a percentage of what's left of market fee\\n    ///        2. risk fee taken out as a percentage of what's left of market fee\\n    ///        3. protocol fee is what's left of market fee\\n    /// @param self The Global object to update\\n    /// @param newLatestId The new latest position id\\n    /// @param accumulation The accumulation result\\n    /// @param marketParameter The current market parameters\\n    /// @param oracleReceipt The receipt of the corresponding oracle version\\n    function update(\\n        Global memory self,\\n        uint256 newLatestId,\\n        VersionAccumulationResponse memory accumulation,\\n        MarketParameter memory marketParameter,\\n        OracleReceipt memory oracleReceipt\\n    ) internal pure {\\n        UFixed6 marketFee = accumulation.marketFee;\\n\\n        UFixed6 oracleFee = marketFee.mul(oracleReceipt.oracleFee);\\n        marketFee = marketFee.sub(oracleFee);\\n\\n        UFixed6 riskFee = marketFee.mul(marketParameter.riskFee);\\n        marketFee = marketFee.sub(riskFee);\\n\\n        self.latestId = newLatestId;\\n        self.protocolFee = self.protocolFee.add(marketFee);\\n        self.oracleFee = self.oracleFee.add(accumulation.settlementFee).add(oracleFee);\\n        self.riskFee = self.riskFee.add(riskFee);\\n        self.exposure = self.exposure.add(accumulation.marketExposure);\\n    }\\n\\n    /// @notice Overrides the price of the oracle with the latest global version if it is empty\\n    /// @param self The Global object to read from\\n    /// @param oracleVersion The oracle version to update\\n    function overrideIfZero(Global memory self, OracleVersion memory oracleVersion) internal pure {\\n        if (oracleVersion.price.isZero()) oracleVersion.price = self.latestPrice;\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the Global struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredGlobal {\\n///         /* slot 0 */\\n///         uint32 currentId;           // <= 4.29b\\n///         uint32 latestId;            // <= 4.29b\\n///         uint48 protocolFee;         // <= 281m\\n///         uint48 oracleFee;           // <= 281m\\n///         uint48 riskFee;             // <= 281m\\n///\\n///         /* slot 1 */\\n///         int32 pAccumulator.value;   // <= 214000%\\n///         int24 pAccumulator.skew;    // <= 838%\\n///         int64 latestPrice;          // <= 9.22t\\n///         int64 exposure;             // <= 9.22t\\n///     }\\n///\\nlibrary GlobalStorageLib {\\n    // sig: 0x2142bc27\\n    error GlobalStorageInvalidError();\\n\\n    function read(GlobalStorage storage self) internal view returns (Global memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n        return Global(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48 - 48)) >> (256 - 48)),\\n            Fixed6.wrap(int256(slot1 << (256 - 32 - 24 - 64)) >> (256 - 64)),\\n            Fixed6.wrap(int256(slot1 << (256 - 32 - 24 - 64 - 64)) >> (256 - 64)),\\n            PAccumulator6(\\n                Fixed6.wrap(int256(slot1 << (256 - 32)) >> (256 - 32)),\\n                Fixed6.wrap(int256(slot1 << (256 - 32 - 24)) >> (256 - 24))\\n            )\\n        );\\n    }\\n\\n    function store(GlobalStorage storage self, Global memory newValue) external {\\n        if (newValue.currentId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\\n        if (newValue.latestId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\\n        if (newValue.protocolFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\\n        if (newValue.oracleFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\\n        if (newValue.riskFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\\n        if (newValue.latestPrice.gt(Fixed6.wrap(type(int64).max))) revert GlobalStorageInvalidError();\\n        if (newValue.latestPrice.lt(Fixed6.wrap(type(int64).min))) revert GlobalStorageInvalidError();\\n        if (newValue.exposure.gt(Fixed6.wrap(type(int64).max))) revert GlobalStorageInvalidError();\\n        if (newValue.exposure.lt(Fixed6.wrap(type(int64).min))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._value.gt(Fixed6.wrap(type(int32).max))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._value.lt(Fixed6.wrap(type(int32).min))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._skew.gt(Fixed6.wrap(type(int24).max))) revert GlobalStorageInvalidError();\\n        if (newValue.pAccumulator._skew.lt(Fixed6.wrap(type(int24).min))) revert GlobalStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\\n            uint256(UFixed6.unwrap(newValue.protocolFee) << (256 - 48)) >> (256 - 32 - 32 - 48) |\\n            uint256(UFixed6.unwrap(newValue.oracleFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48) |\\n            uint256(UFixed6.unwrap(newValue.riskFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48 - 48);\\n\\n        uint256 encoded1 =\\n            uint256(Fixed6.unwrap(newValue.pAccumulator._value) << (256 - 32)) >> (256 - 32) |\\n            uint256(Fixed6.unwrap(newValue.pAccumulator._skew) << (256 - 24)) >> (256 - 32 - 24) |\\n            uint256(Fixed6.unwrap(newValue.latestPrice) << (256 - 64)) >> (256 - 32 - 24 - 64) |\\n            uint256(Fixed6.unwrap(newValue.exposure) << (256 - 64)) >> (256 - 32 - 24 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x02b12c7bb4632602f9be6d29a60885150b96c99212d88ba4e4253baae13ca86e\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/Guarantee.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6, Fixed6Lib } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { Order } from \\\"./Order.sol\\\";\\n\\n/// @dev Guarantee type\\nstruct Guarantee {\\n    /// @dev The quantity of guarantees that that will be exempt from the settlement fee\\n    uint256 orders;\\n\\n    /// @dev The notional of the magnitude with the price override (local only)\\n    Fixed6 notional;\\n\\n    /// @dev The positive skew (open long / close short) guarantee size\\n    UFixed6 takerPos;\\n\\n    /// @dev The negative skew (close long / open short) guarantee size\\n    UFixed6 takerNeg;\\n\\n    /// @dev The magnitude of the guarantee that be exempt from the trade fee\\n    UFixed6 takerFee;\\n\\n    /// @dev The referral fee multiplied by the size applicable to the referral (local only)\\n    UFixed6 referral;\\n}\\nusing GuaranteeLib for Guarantee global;\\nstruct GuaranteeStorageGlobal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing GuaranteeStorageGlobalLib for GuaranteeStorageGlobal global;\\nstruct GuaranteeStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing GuaranteeStorageLocalLib for GuaranteeStorageLocal global;\\n\\n/// @title Guarantee\\n/// @dev (external-unsafe): this library must be used internally only\\n/// @notice Holds the state for an account's update guarantee\\nlibrary GuaranteeLib {\\n    /// @notice Prepares the next guarantee from the current guarantee\\n    /// @param self The guarantee object to update\\n    function next(Guarantee memory self) internal pure  {\\n        invalidate(self);\\n        self.orders = 0;\\n    }\\n\\n    /// @notice Invalidates the guarantee\\n    /// @param self The guarantee object to update\\n    function invalidate(Guarantee memory self) internal pure {\\n        (self.takerPos, self.takerNeg, self.notional, self.takerFee, self.referral) =\\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, Fixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\\n    }\\n\\n    /// @notice Creates a new guarantee from an order\\n    /// @param order The order to create the guarantee from\\n    /// @param priceOverride The price override\\n    /// @param referralFee The the percentage of the subtractive fee to take as a solver referral fee\\n    /// @param chargeSettlementFee Whether the order will still be charged the settlement fee\\n    /// @param chargeTradeFee Whether the order will still be charged the trade fee\\n    /// @return newGuarantee The resulting guarantee\\n    function from(\\n        Order memory order,\\n        Fixed6 priceOverride,\\n        UFixed6 referralFee,\\n        bool chargeSettlementFee,\\n        bool chargeTradeFee\\n    ) internal pure returns (Guarantee memory newGuarantee) {\\n        // maker orders and one intent order per fill will be required to pay the settlement fee\\n        if (!order.takerTotal().isZero() && !chargeSettlementFee) newGuarantee.orders = order.orders;\\n\\n        (newGuarantee.takerPos, newGuarantee.takerNeg) =\\n            (order.longPos.add(order.shortNeg), order.longNeg.add(order.shortPos));\\n        newGuarantee.takerFee = chargeTradeFee ? UFixed6Lib.ZERO : order.takerTotal();\\n\\n        newGuarantee.notional = taker(newGuarantee).mul(priceOverride);\\n        newGuarantee.referral = order.takerReferral.mul(referralFee);\\n    }\\n\\n    /// @notice Returns the taker delta of the guarantee\\n    /// @param self The guarantee object to check\\n    /// @return The taker delta of the guarantee\\n    function taker(Guarantee memory self) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(self.takerPos).sub(Fixed6Lib.from(self.takerNeg));\\n    }\\n\\n    /// @notice Returns the total taker delta of the guarantee\\n    /// @param self The guarantee object to check\\n    /// @return The total taker delta of the guarantee\\n    function takerTotal(Guarantee memory self) internal pure returns (UFixed6) {\\n        return self.takerPos.add(self.takerNeg);\\n    }\\n\\n    /// @notice Returns the collateral adjusted due to the price override\\n    /// @param self The guarantee object to check\\n    /// @param price The oracle price to compare to the price override\\n    /// @return The collateral adjusted due to the price override\\n    function priceAdjustment(Guarantee memory self, Fixed6 price) internal pure returns (Fixed6) {\\n        return self.taker().mul(price).sub(self.notional);\\n    }\\n\\n    /// @notice Returns the price deviation of the guarantee from the oracle price\\n    /// @dev The price deviation is the difference between the prices over the closest price to zero\\n    ///      Only supports new guarantees for updates, does not work for aggregated guarantees (local / global)\\n    /// @param self The guarantee object to check\\n    /// @param price The oracle price to compare\\n    /// @return The price deviation of the guarantee from the oracle price\\n    function priceDeviation(Guarantee memory self, Fixed6 price) internal pure returns (UFixed6) {\\n        if (takerTotal(self).isZero()) return UFixed6Lib.ZERO;\\n\\n        Fixed6 guaranteePrice = self.notional.div(taker(self));\\n        return guaranteePrice.sub(price).abs().unsafeDiv(guaranteePrice.abs().min(price.abs()));\\n    }\\n\\n    /// @notice Updates the current global guarantee with a new local guarantee\\n    /// @param self The guarantee object to update\\n    /// @param guarantee The new guarantee\\n    function add(Guarantee memory self, Guarantee memory guarantee) internal pure {\\n        self.orders = self.orders + guarantee.orders;\\n        (self.notional, self.takerPos, self.takerNeg, self.takerFee, self.referral) = (\\n            self.notional.add(guarantee.notional),\\n            self.takerPos.add(guarantee.takerPos),\\n            self.takerNeg.add(guarantee.takerNeg),\\n            self.takerFee.add(guarantee.takerFee),\\n            self.referral.add(guarantee.referral)\\n        );\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the global Guarantee struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredGuaranteeGlobal {\\n///         /* slot 0 */\\n///         uint32 orders;\\n///         uint64 takerPos;\\n///         uint64 takerNeg;\\n///         uint64 takerFee;\\n///     }\\n///\\nlibrary GuaranteeStorageGlobalLib {\\n    function read(GuaranteeStorageGlobal storage self) internal view returns (Guarantee memory) {\\n        uint256 slot0 = self.slot0;\\n        return Guarantee(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            Fixed6Lib.ZERO,\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64 - 64)) >> (256 - 64)),\\n            UFixed6Lib.ZERO\\n        );\\n    }\\n\\n    function store(GuaranteeStorageGlobal storage self, Guarantee memory newValue) internal {\\n        GuaranteeStorageLib.validate(newValue);\\n\\n        uint256 encoded0 =\\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32) |\\n            uint256(UFixed6.unwrap(newValue.takerPos) << (256 - 64)) >> (256 - 32 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerNeg) << (256 - 64)) >> (256 - 32 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 64)) >> (256 - 32 - 64 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n        }\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the local Guarantee struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredGuaranteeLocal {\\n///         /* slot 0 */\\n///         uint32 orders;\\n///         int64 notional;\\n///         uint64 takerPos;\\n///         uint64 takerNeg;\\n///\\n///         /* slot 1 */\\n///         uint64 takerFee;\\n///         uint64 referral;\\n///     }\\n///\\nlibrary GuaranteeStorageLocalLib {\\n    function read(GuaranteeStorageLocal storage self) internal view returns (Guarantee memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n        return Guarantee(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(GuaranteeStorageLocal storage self, Guarantee memory newValue) internal {\\n        GuaranteeStorageLib.validate(newValue);\\n\\n        if (newValue.notional.gt(Fixed6.wrap(type(int64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n        if (newValue.notional.lt(Fixed6.wrap(type(int64).min))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n        if (newValue.referral.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32) |\\n            uint256(Fixed6.unwrap(newValue.notional) << (256 - 64)) >> (256 - 32 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerPos) << (256 - 64)) >> (256 - 32 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerNeg) << (256 - 64)) >> (256 - 32 - 64 - 64 - 64);\\n        uint256 encode1 =\\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 64)) >> (256 - 64) |\\n            uint256(UFixed6.unwrap(newValue.referral) << (256 - 64)) >> (256 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encode1)\\n        }\\n    }\\n}\\n\\nlibrary GuaranteeStorageLib {\\n    // sig: 0xfd030f36\\n    error GuaranteeStorageInvalidError();\\n\\n    function validate(Guarantee memory newValue) internal pure {\\n        if (newValue.orders > type(uint32).max) revert GuaranteeStorageInvalidError();\\n        if (newValue.takerPos.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n        if (newValue.takerNeg.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n        if (newValue.takerFee.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\\n    }\\n}\",\"keccak256\":\"0x2245f89c6f35a2e5c1281de1513b9c758457ebacb16e6f21a410c5a4ae6af5f4\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/Local.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6, Fixed6Lib } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { CheckpointAccumulationResponse } from \\\"../libs/CheckpointLib.sol\\\";\\n\\n/// @dev Local type\\nstruct Local {\\n    /// @dev The current position id\\n    uint256 currentId;\\n\\n    /// @dev The latest position id\\n    uint256 latestId;\\n\\n    /// @dev The collateral balance\\n    Fixed6 collateral;\\n\\n    /// @dev The claimable balance\\n    UFixed6 claimable;\\n}\\nusing LocalLib for Local global;\\nstruct LocalStorage { uint256 slot0; uint256 slot1; }\\nusing LocalStorageLib for LocalStorage global;\\n\\n/// @title Local\\n/// @dev (external-unsafe): this library must be used internally only\\n/// @notice Holds the local account state\\nlibrary LocalLib {\\n    /// @notice Updates the collateral with the new deposit or withdrwal\\n    /// @param self The Local object to update\\n    /// @param transfer The amount to update the collateral by\\n    function update(Local memory self, Fixed6 transfer) internal pure {\\n        self.collateral = self.collateral.add(transfer);\\n    }\\n\\n    /// @notice Updates the collateral with the new collateral change\\n    /// @param self The Local object to update\\n    /// @param accumulation The accumulation result\\n    function update(\\n        Local memory self,\\n        uint256 newId,\\n        CheckpointAccumulationResponse memory accumulation\\n    ) internal pure {\\n        self.collateral = self.collateral.add(accumulation.collateral).sub(Fixed6Lib.from(accumulation.liquidationFee));\\n        self.latestId = newId;\\n    }\\n\\n    /// @notice Updates the claimable with the new amount\\n    /// @param self The Local object to update\\n    /// @param amount The amount to update the claimable by\\n    function credit(Local memory self, UFixed6 amount) internal pure {\\n        self.claimable = self.claimable.add(amount);\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the Local struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredLocal {\\n///         /* slot 0 */\\n///         uint32 currentId;       // <= 4.29b\\n///         uint32 latestId;        // <= 4.29b\\n///         int64 collateral;       // <= 9.22t\\n///         uint64 claimable;       // <= 18.44t\\n///         bytes4 __DEPRECATED;    // UNSAFE UNTIL RESET\\n///     }\\n///\\nlibrary LocalStorageLib {\\n    // sig: 0xc83d08ec\\n    error LocalStorageInvalidError();\\n\\n    function read(LocalStorage storage self) internal view returns (Local memory) {\\n        uint256 slot0 = self.slot0;\\n        return Local(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(LocalStorage storage self, Local memory newValue) internal {\\n        if (newValue.currentId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\\n        if (newValue.latestId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert LocalStorageInvalidError();\\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert LocalStorageInvalidError();\\n        if (newValue.claimable.gt(UFixed6.wrap(type(uint64).max))) revert LocalStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\\n            uint256(UFixed6.unwrap(newValue.claimable) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n        }\\n    }\\n}\",\"keccak256\":\"0x370257a809e38deb61e04d0af40041a178cab825e3eac9dac1e46970c00d3d5c\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/MarketParameter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { ProtocolParameter } from \\\"./ProtocolParameter.sol\\\";\\n\\n/// @dev MarketParameter type\\nstruct MarketParameter {\\n    /// @dev The fee that is taken out of funding\\n    UFixed6 fundingFee;\\n\\n    /// @dev The fee that is taken out of interest\\n    UFixed6 interestFee;\\n\\n    /// @dev The fee that is taken out of maker and taker fees\\n    UFixed6 makerFee;\\n\\n    /// @dev The fee that is taken out of maker and taker fees\\n    UFixed6 takerFee;\\n\\n    /// @dev The share of the collected fees that is paid to the risk coordinator\\n    UFixed6 riskFee;\\n\\n    /// @dev The maximum amount of orders that can be pending at one time globally\\n    uint256 maxPendingGlobal;\\n\\n    /// @dev The maximum amount of orders that can be pending at one time per account\\n    uint256 maxPendingLocal;\\n\\n    /// @dev The maximum deviation percentage from the oracle price that is allowed for an intent price override\\n    UFixed6 maxPriceDeviation;\\n\\n    /// @dev Whether the market is in close-only mode\\n    bool closed;\\n\\n     /// @dev Whether the market is in settle-only mode\\n    bool settle;\\n}\\nstruct MarketParameterStorage { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing MarketParameterStorageLib for MarketParameterStorage global;\\n\\n/// @dev Manually encodes and decodes the MarketParameter struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///    struct StoredMarketParameter {\\n///        /* slot 0 */\\n///        uint24 fundingFee;          // <= 1677%\\n///        uint24 interestFee;         // <= 1677%\\n///        uint24 makerFee;            // <= 1677%\\n///        uint24 takerFee;            // <= 1677%\\n///        uint24 riskFee;             // <= 1677%\\n///        uint16 maxPendingGlobal;    // <= 65k\\n///        uint16 maxPendingLocal;     // <= 65k\\n///        uint24 maxPriceDeviation;   // <= 1677%\\n///        uint24 __unallocated__;\\n///        uint8 flags;\\n///    }\\n///\\nlibrary MarketParameterStorageLib {\\n    // sig: 0x7c53e926\\n    error MarketParameterStorageInvalidError();\\n\\n    function read(MarketParameterStorage storage self) internal view returns (MarketParameter memory) {\\n        uint256 slot0 = self.slot0;\\n\\n        uint256 flags = uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 24 - 24 - 8)) >> (256 - 8);\\n        (bool closed, bool settle) =\\n            (flags & 0x04 == 0x04, flags & 0x08 == 0x08);\\n\\n        return MarketParameter(\\n            UFixed6.wrap(uint256(slot0 << (256 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n                         uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16)) >> (256 - 16),\\n                         uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16)) >> (256 - 16),\\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 24)) >> (256 - 24)),\\n            closed,\\n            settle\\n        );\\n    }\\n\\n    function validate(MarketParameter memory self, ProtocolParameter memory protocolParameter) private pure {\\n        if (self.fundingFee.max(self.interestFee).max(self.makerFee).max(self.takerFee).gt(protocolParameter.maxCut))\\n            revert MarketParameterStorageInvalidError();\\n\\n        if (self.riskFee.gt(UFixed6Lib.ONE))\\n            revert MarketParameterStorageInvalidError();\\n    }\\n\\n    function validateAndStore(\\n        MarketParameterStorage storage self,\\n        MarketParameter memory newValue,\\n        ProtocolParameter memory protocolParameter\\n    ) external {\\n        validate(newValue, protocolParameter);\\n\\n        if (newValue.maxPendingGlobal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\\n        if (newValue.maxPendingLocal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\\n        if (newValue.maxPriceDeviation.gt(UFixed6.wrap(type(uint24).max))) revert MarketParameterStorageInvalidError();\\n\\n        _store(self, newValue);\\n    }\\n\\n    function _store(MarketParameterStorage storage self, MarketParameter memory newValue) private {\\n        uint256 flags = (newValue.closed ? 0x04 : 0x00) |\\n            (newValue.settle ? 0x08 : 0x00);\\n\\n        uint256 encoded0 =\\n            uint256(UFixed6.unwrap(newValue.fundingFee)         << (256 - 24)) >> (256 - 24) |\\n            uint256(UFixed6.unwrap(newValue.interestFee)        << (256 - 24)) >> (256 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.makerFee)           << (256 - 24)) >> (256 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.takerFee)           << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.riskFee)            << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(newValue.maxPendingGlobal                   << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16) |\\n            uint256(newValue.maxPendingLocal                    << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16) |\\n            uint256(UFixed6.unwrap(newValue.maxPriceDeviation)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 24) |\\n            uint256(flags                                       << (256 - 8))  >> (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 24 - 24 - 8);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n        }\\n    }\\n}\",\"keccak256\":\"0x160a1db9dc6ced3b4e91ae62337c9cd91352a2c101d8bd8e82b6e2fedc91eda2\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/OracleReceipt.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6 } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\n\\n/// @dev The cost receipt of for a corresponding oracle version\\nstruct OracleReceipt {\\n    /// @dev The fixed settlement fee of the request\\n    UFixed6 settlementFee;\\n\\n    /// @dev The relative oracle fee percentage of the request\\n    UFixed6 oracleFee;\\n}\\n\",\"keccak256\":\"0x686ef41f5b492f41fdbfe8b27afd42beac4d70b08e90e6f93e6ecffbe9b175a2\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/OracleVersion.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\n\\n/// @dev A singular oracle version with its corresponding data\\nstruct OracleVersion {\\n    /// @dev the timestamp of the oracle update\\n    uint256 timestamp;\\n\\n    /// @dev The oracle price of the corresponding version\\n    Fixed6 price;\\n\\n    /// @dev Whether the version is valid\\n    bool valid;\\n}\\n\",\"keccak256\":\"0xb483b9610ccd5ac6733a6af6b88dd477e8fa2fad5cd9ab548a74cf71ac76a642\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/Order.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Fixed6, Fixed6Lib } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { OracleVersion } from \\\"./OracleVersion.sol\\\";\\nimport { Position } from \\\"./Position.sol\\\";\\nimport { MarketParameter } from \\\"./MarketParameter.sol\\\";\\n\\n/// @dev Order type\\nstruct Order {\\n    /// @dev The timestamp of the order\\n    uint256 timestamp;\\n\\n    /// @dev The quantity of orders that are included in this order\\n    uint256 orders;\\n\\n    /// @dev The change in the collateral\\n    Fixed6 collateral;\\n\\n    /// @dev The positive skew maker order size\\n    UFixed6 makerPos;\\n\\n    /// @dev The negative skew maker order size\\n    UFixed6 makerNeg;\\n\\n    /// @dev The positive skew long order size\\n    UFixed6 longPos;\\n\\n    /// @dev The negative skew long order size\\n    UFixed6 longNeg;\\n\\n    /// @dev The positive skew short order size\\n    UFixed6 shortPos;\\n\\n    /// @dev The negative skew short order size\\n    UFixed6 shortNeg;\\n\\n    /// @dev The protection status semaphore (local only)\\n    uint256 protection;\\n\\n    /// @dev The referral fee multiplied by the size applicable to the referral\\n    UFixed6 makerReferral;\\n\\n    /// @dev The referral fee multiplied by the size applicable to the referral\\n    UFixed6 takerReferral;\\n}\\nusing OrderLib for Order global;\\nstruct OrderStorageGlobal { uint256 slot0; uint256 slot1; uint256 slot2; } // SECURITY: must remain at (3) slots\\nusing OrderStorageGlobalLib for OrderStorageGlobal global;\\nstruct OrderStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing OrderStorageLocalLib for OrderStorageLocal global;\\n\\n/// @title Order\\n/// @dev (external-unsafe): this library must be used internally only\\n/// @notice Holds the state for an account's update order\\nlibrary OrderLib {\\n    /// @notice Returns whether the order is ready to be settled\\n    /// @param self The order object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @return Whether the order is ready to be settled\\n    function ready(Order memory self, OracleVersion memory latestVersion) internal pure returns (bool) {\\n        return latestVersion.timestamp >= self.timestamp;\\n    }\\n\\n    /// @notice Prepares the next order from the current order\\n    /// @param self The order object to update\\n    /// @param timestamp The current timestamp\\n    function next(Order memory self, uint256 timestamp) internal pure  {\\n        invalidate(self);\\n        (self.timestamp, self.orders, self.collateral, self.protection) = (timestamp, 0, Fixed6Lib.ZERO, 0);\\n    }\\n\\n    /// @notice Invalidates the order\\n    /// @param self The order object to update\\n    function invalidate(Order memory self) internal pure {\\n        (self.makerReferral, self.takerReferral) =\\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO);\\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) =\\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\\n    }\\n\\n    /// @notice Creates a new order from the an intent order request\\n    /// @param timestamp The current timestamp\\n    /// @param position The current position\\n    /// @param amount The magnitude and direction of the order\\n    /// @param collateral The change in the collateral\\n    /// @param referralFee The referral fee\\n    /// @return newOrder The resulting order\\n    function from(\\n        uint256 timestamp,\\n        Position memory position,\\n        Fixed6 amount,\\n        Fixed6 collateral,\\n        UFixed6 referralFee\\n    ) internal pure returns (Order memory newOrder) {\\n        newOrder.timestamp = timestamp;\\n        newOrder.collateral = collateral;\\n        newOrder.orders = amount.isZero() ? 0 : 1;\\n        newOrder.takerReferral = amount.abs().mul(referralFee);\\n\\n        // If the order is not counter to the current position, it is opening\\n        if (amount.sign() == 0 || position.skew().sign() == 0 || position.skew().sign() == amount.sign()) {\\n            newOrder.longPos = amount.max(Fixed6Lib.ZERO).abs();\\n            newOrder.shortPos = amount.min(Fixed6Lib.ZERO).abs();\\n\\n        // If the order is counter to the current position, it is closing\\n        } else {\\n            newOrder.shortNeg = amount.max(Fixed6Lib.ZERO).abs();\\n            newOrder.longNeg = amount.min(Fixed6Lib.ZERO).abs();\\n        }\\n    }\\n\\n    /// @notice Creates a new order from the current position and an update request\\n    /// @param timestamp The current timestamp\\n    /// @param position The current position\\n    /// @param collateral The change in the collateral\\n    /// @param newMaker The new maker\\n    /// @param newLong The new long\\n    /// @param newShort The new short\\n    /// @param protect Whether to protect the order\\n    /// @param referralFee The referral fee\\n    /// @return newOrder The resulting order\\n    function from(\\n        uint256 timestamp,\\n        Position memory position,\\n        Fixed6 collateral,\\n        UFixed6 newMaker,\\n        UFixed6 newLong,\\n        UFixed6 newShort,\\n        bool protect,\\n        UFixed6 referralFee\\n    ) internal pure returns (Order memory newOrder) {\\n        (Fixed6 makerAmount, Fixed6 longAmount, Fixed6 shortAmount) = (\\n            Fixed6Lib.from(newMaker).sub(Fixed6Lib.from(position.maker)),\\n            Fixed6Lib.from(newLong).sub(Fixed6Lib.from(position.long)),\\n            Fixed6Lib.from(newShort).sub(Fixed6Lib.from(position.short))\\n        );\\n\\n        UFixed6 referral = makerAmount.abs().add(longAmount.abs()).add(shortAmount.abs()).mul(referralFee);\\n\\n        newOrder = Order(\\n            timestamp,\\n            0,\\n            collateral,\\n            makerAmount.max(Fixed6Lib.ZERO).abs(),\\n            makerAmount.min(Fixed6Lib.ZERO).abs(),\\n            longAmount.max(Fixed6Lib.ZERO).abs(),\\n            longAmount.min(Fixed6Lib.ZERO).abs(),\\n            shortAmount.max(Fixed6Lib.ZERO).abs(),\\n            shortAmount.min(Fixed6Lib.ZERO).abs(),\\n            protect ? 1 : 0,\\n            makerAmount.isZero() ? UFixed6Lib.ZERO : referral,\\n            makerAmount.isZero() ? referral : UFixed6Lib.ZERO\\n        );\\n        if (!isEmpty(newOrder)) newOrder.orders = 1;\\n    }\\n\\n    /// @notice Returns whether the order increases any of the account's positions\\n    /// @return Whether the order increases any of the account's positions\\n    function increasesPosition(Order memory self) internal pure returns (bool) {\\n        return increasesMaker(self) || increasesTaker(self);\\n    }\\n\\n    /// @notice Returns whether the order increases the account's long or short positions\\n    /// @return Whether the order increases the account's long or short positions\\n    function increasesTaker(Order memory self) internal pure returns (bool) {\\n        return !self.longPos.isZero() || !self.shortPos.isZero();\\n    }\\n\\n    /// @notice Returns whether the order increases the account's maker position\\n    /// @return Whether the order increases the account's maker positions\\n    function increasesMaker(Order memory self) internal pure returns (bool) {\\n        return !self.makerPos.isZero();\\n    }\\n\\n    /// @notice Returns whether the order decreases the liquidity of the market\\n    /// @return Whether the order decreases the liquidity of the market\\n    function decreasesLiquidity(Order memory self, Position memory currentPosition) internal pure returns (bool) {\\n        Fixed6 currentSkew = currentPosition.skew();\\n        Fixed6 latestSkew = currentSkew.sub(long(self)).add(short(self));\\n        return !self.makerNeg.isZero() || currentSkew.abs().gt(latestSkew.abs());\\n    }\\n\\n    /// @notice Returns whether the order decreases the efficieny of the market\\n    /// @dev Decreased efficiency ratio intuitively means that the market is \\\"more efficient\\\" on an OI to LP basis.\\n    /// @return Whether the order decreases the liquidity of the market\\n    function decreasesEfficiency(Order memory self, Position memory currentPosition) internal pure returns (bool) {\\n        UFixed6 currentMajor = currentPosition.major();\\n        UFixed6 latestMajor = UFixed6Lib.from(Fixed6Lib.from(currentPosition.long).sub(long(self)))\\n            .max(UFixed6Lib.from(Fixed6Lib.from(currentPosition.short).sub(short(self))));\\n        return !self.makerNeg.isZero() || currentMajor.gt(latestMajor);\\n    }\\n\\n    /// @notice Returns whether the order is applicable for liquidity checks\\n    /// @param self The Order object to check\\n    /// @param marketParameter The market parameter\\n    /// @return Whether the order is applicable for liquidity checks\\n    function liquidityCheckApplicable(\\n        Order memory self,\\n        MarketParameter memory marketParameter\\n    ) internal pure returns (bool) {\\n        return !marketParameter.closed &&\\n        // not \\\"a taker order that is increasing\\\" ->\\n        // not (any of the following)\\n        //  - taker is empty (not a taker order)\\n        //  - taker is increasing (position going more long or short)\\n            ((long(self).isZero() && short(self).isZero()) || increasesTaker(self));\\n    }\\n\\n    /// @notice Returns whether the order is protected\\n    /// @param self The order object to check\\n    /// @return Whether the order is protected\\n    function protected(Order memory self) internal pure returns (bool) {\\n        return self.protection != 0;\\n    }\\n\\n    /// @notice Returns whether the order is empty\\n    /// @param self The order object to check\\n    /// @return Whether the order is empty\\n    function isEmpty(Order memory self) internal pure returns (bool) {\\n        return pos(self).isZero() && neg(self).isZero();\\n    }\\n\\n     /// @notice Returns the direction of the order\\n    /// @dev 0 = maker, 1 = long, 2 = short\\n    /// @param self The position object to check\\n    /// @return The direction of the position\\n    function direction(Order memory self) internal pure returns (uint256) {\\n        if (!self.longPos.isZero() || !self.longNeg.isZero()) return 1;\\n        if (!self.shortPos.isZero() || !self.shortNeg.isZero()) return 2;\\n\\n        return 0;\\n    }\\n\\n    /// @notice Returns the magnitude of the order\\n    /// @param self The order object to check\\n    /// @return The magnitude of the order\\n    function magnitude(Order memory self) internal pure returns (Fixed6) {\\n        return maker(self).add(long(self)).add(short(self));\\n    }\\n\\n    /// @notice Returns the maker delta of the order\\n    /// @param self The order object to check\\n    /// @return The maker delta of the order\\n    function maker(Order memory self) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(self.makerPos).sub(Fixed6Lib.from(self.makerNeg));\\n    }\\n\\n    /// @notice Returns the long delta of the order\\n    /// @param self The order object to check\\n    /// @return The long delta of the order\\n    function long(Order memory self) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(self.longPos).sub(Fixed6Lib.from(self.longNeg));\\n    }\\n\\n    /// @notice Returns the short delta of the order\\n    /// @param self The order object to check\\n    /// @return The short delta of the order\\n    function short(Order memory self) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(self.shortPos).sub(Fixed6Lib.from(self.shortNeg));\\n    }\\n\\n    /// @notice Returns the positive taker delta of the order\\n    /// @param self The order object to check\\n    /// @return The positive taker delta of the order\\n    function takerPos(Order memory self) internal pure returns (UFixed6) {\\n        return self.longPos.add(self.shortNeg);\\n    }\\n\\n    /// @notice Returns the negative taker delta of the order\\n    /// @param self The order object to check\\n    /// @return The negative taker delta of the order\\n    function takerNeg(Order memory self) internal pure returns (UFixed6) {\\n        return self.shortPos.add(self.longNeg);\\n    }\\n\\n    /// @notice Returns the total maker delta of the order\\n    /// @param self The order object to check\\n    /// @return The total maker delta of the order\\n    function makerTotal(Order memory self) internal pure returns (UFixed6) {\\n        return self.makerPos.add(self.makerNeg);\\n    }\\n\\n    /// @notice Returns the total taker delta of the order\\n    /// @param self The order object to check\\n    /// @return The total taker delta of the order\\n    function takerTotal(Order memory self) internal pure returns (UFixed6) {\\n        return self.takerPos().add(self.takerNeg());\\n    }\\n\\n    /// @notice Returns the positive delta of the order\\n    /// @param self The order object to check\\n    /// @return The positive delta of the order\\n    function pos(Order memory self) internal pure returns (UFixed6) {\\n        return self.makerPos.add(self.longPos).add(self.shortPos);\\n    }\\n\\n    /// @notice Returns the positive delta of the order\\n    /// @param self The order object to check\\n    /// @return The positive delta of the order\\n    function neg(Order memory self) internal pure returns (UFixed6) {\\n        return self.makerNeg.add(self.longNeg).add(self.shortNeg);\\n    }\\n\\n    /// @notice Updates the current global order with a new local order\\n    /// @param self The order object to update\\n    /// @param order The new order\\n    function add(Order memory self, Order memory order) internal pure {\\n        (self.orders, self.collateral, self.protection, self.makerReferral, self.takerReferral) = (\\n            self.orders + order.orders,\\n            self.collateral.add(order.collateral),\\n            self.protection + order.protection,\\n            self.makerReferral.add(order.makerReferral),\\n            self.takerReferral.add(order.takerReferral)\\n        );\\n\\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) = (\\n            self.makerPos.add(order.makerPos),\\n            self.makerNeg.add(order.makerNeg),\\n            self.longPos.add(order.longPos),\\n            self.longNeg.add(order.longNeg),\\n            self.shortPos.add(order.shortPos),\\n            self.shortNeg.add(order.shortNeg)\\n        );\\n    }\\n\\n    /// @notice Subtracts the latest local order from current global order\\n    /// @param self The order object to update\\n    /// @param order The latest order\\n    function sub(Order memory self, Order memory order) internal pure {\\n        (self.orders, self.collateral, self.protection, self.makerReferral, self.takerReferral) = (\\n            self.orders - order.orders,\\n            self.collateral.sub(order.collateral),\\n            self.protection - order.protection,\\n            self.makerReferral.sub(order.makerReferral),\\n            self.takerReferral.sub(order.takerReferral)\\n        );\\n\\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) = (\\n            self.makerPos.sub(order.makerPos),\\n            self.makerNeg.sub(order.makerNeg),\\n            self.longPos.sub(order.longPos),\\n            self.longNeg.sub(order.longNeg),\\n            self.shortPos.sub(order.shortPos),\\n            self.shortNeg.sub(order.shortNeg)\\n        );\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the global Order struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredOrderGlobal {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         uint32 orders;\\n///         int64 collateral;\\n///         uint64 makerPos;\\n///         uint64 makerNeg;\\n///\\n///         /* slot 1 */\\n///         uint64 longPos;\\n///         uint64 longNeg;\\n///         uint64 shortPos;\\n///         uint64 shortNeg;\\n///\\n///         /* slot 2 */\\n///         uint64 takerReferral;\\n///         uint64 makerReferral;\\n///     }\\n///\\nlibrary OrderStorageGlobalLib {\\n    function read(OrderStorageGlobal storage self) internal view returns (Order memory) {\\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\\n\\n        return Order(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64 - 64)) >> (256 - 64)),\\n            0,\\n            UFixed6.wrap(uint256(slot2 << (256 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot2 << (256 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(OrderStorageGlobal storage self, Order memory newValue) internal {\\n        OrderStorageLib.validate(newValue);\\n\\n        if (newValue.makerPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.makerNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.longPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.longNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.shortPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.shortNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32 - 32) |\\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\\n            uint256(UFixed6.unwrap(newValue.makerPos) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.makerNeg) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64 - 64);\\n        uint256 encoded1 =\\n            uint256(UFixed6.unwrap(newValue.longPos) << (256 - 64)) >> (256 - 64) |\\n            uint256(UFixed6.unwrap(newValue.longNeg) << (256 - 64)) >> (256 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.shortPos) << (256 - 64)) >> (256 - 64 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.shortNeg) << (256 - 64)) >> (256 - 64 - 64 - 64 - 64);\\n        uint256 encoded2 =\\n            uint256(UFixed6.unwrap(newValue.makerReferral) << (256 - 64)) >> (256 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerReferral) << (256 - 64)) >> (256 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n            sstore(add(self.slot, 2), encoded2)\\n        }\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the local Order struct into storage.\\n///\\n///     struct StoredOrderLocal {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         uint32 orders;\\n///         int64 collateral;\\n///         uint2 direction;\\n///         uint62 magnitudePos;\\n///         uint62 magnitudeNeg;\\n///         uint1 protection;\\n///\\n///         /* slot 1 */\\n///         uint64 takerReferral;\\n///         uint64 makerReferral;\\n///     }\\n///\\nlibrary OrderStorageLocalLib {\\n    function read(OrderStorageLocal storage self) internal view returns (Order memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n\\n        uint256 direction = uint256(slot0 << (256 - 32 - 32 - 64 - 2)) >> (256 - 2);\\n        UFixed6 magnitudePos = UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62)) >> (256 - 62));\\n        UFixed6 magnitudeNeg = UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62 - 62)) >> (256 - 62));\\n\\n        return Order(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\\n            direction == 0 ? magnitudePos : UFixed6Lib.ZERO,\\n            direction == 0 ? magnitudeNeg : UFixed6Lib.ZERO,\\n            direction == 1 ? magnitudePos : UFixed6Lib.ZERO,\\n            direction == 1 ? magnitudeNeg : UFixed6Lib.ZERO,\\n            direction == 2 ? magnitudePos : UFixed6Lib.ZERO,\\n            direction == 2 ? magnitudeNeg : UFixed6Lib.ZERO,\\n            uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62 - 62 - 1)) >> (256 - 1),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(OrderStorageLocal storage self, Order memory newValue) internal {\\n        OrderStorageLib.validate(newValue);\\n\\n        (UFixed6 magnitudePos, UFixed6 magnitudeNeg) = (newValue.pos(), newValue.neg());\\n\\n        if (magnitudePos.gt(UFixed6.wrap(2 ** 62 - 1))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (magnitudeNeg.gt(UFixed6.wrap(2 ** 62 - 1))) revert OrderStorageLib.OrderStorageInvalidError();\\n        if (newValue.protection > 1) revert OrderStorageLib.OrderStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32 - 32) |\\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\\n            uint256(newValue.direction() << (256 - 2)) >> (256 - 32 - 32 - 64 - 2) |\\n            uint256(UFixed6.unwrap(magnitudePos) << (256 - 62)) >> (256 - 32 - 32 - 64 - 2 - 62) |\\n            uint256(UFixed6.unwrap(magnitudeNeg) << (256 - 62)) >> (256 - 32 - 32 - 64 - 2 - 62 - 62) |\\n            uint256(newValue.protection << (256 - 1)) >> (256 - 32 - 32 - 64 - 2 - 62 - 62 - 1);\\n        uint256 encoded1 =\\n            uint256(UFixed6.unwrap(newValue.makerReferral) << (256 - 64)) >> (256 - 64) |\\n            uint256(UFixed6.unwrap(newValue.takerReferral) << (256 - 64)) >> (256 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n        }\\n    }\\n}\\n\\nlibrary OrderStorageLib {\\n    // sig: 0x67e45965\\n    error OrderStorageInvalidError();\\n\\n    function validate(Order memory newValue) internal pure {\\n        if (newValue.timestamp > type(uint32).max) revert OrderStorageInvalidError();\\n        if (newValue.orders > type(uint32).max) revert OrderStorageInvalidError();\\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert OrderStorageInvalidError();\\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert OrderStorageInvalidError();\\n        if (newValue.makerReferral.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageInvalidError();\\n        if (newValue.takerReferral.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageInvalidError();\\n    }\\n}\",\"keccak256\":\"0x2e505298c6af9d7b0ca6ce81b2f684afc2d869ce389c505d4a8543faf50b14e9\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/Position.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6, Fixed6Lib } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { OracleVersion } from \\\"./OracleVersion.sol\\\";\\nimport { RiskParameter } from \\\"./RiskParameter.sol\\\";\\nimport { Order } from \\\"./Order.sol\\\";\\n\\n/// @dev Position type\\nstruct Position {\\n    /// @dev The timestamp of the position\\n    uint256 timestamp;\\n\\n    /// @dev The maker position size\\n    UFixed6 maker;\\n\\n    /// @dev The long position size\\n    UFixed6 long;\\n\\n    /// @dev The short position size\\n    UFixed6 short;\\n}\\nusing PositionLib for Position global;\\nstruct PositionStorageGlobal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing PositionStorageGlobalLib for PositionStorageGlobal global;\\nstruct PositionStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\\nusing PositionStorageLocalLib for PositionStorageLocal global;\\n\\n/// @title Position\\n/// @dev (external-unsafe): this library must be used internally only\\n/// @notice Holds the state for a position\\nlibrary PositionLib {\\n    /// @notice Returns a cloned copy of the position\\n    /// @param self The position object to clone\\n    /// @return A cloned copy of the position\\n    function clone(Position memory self) internal pure returns (Position memory) {\\n        return Position(self.timestamp, self.maker, self.long, self.short);\\n    }\\n\\n    /// @notice Updates the position with a new order\\n    /// @param self The position object to update\\n    /// @param order The new order\\n    function update(Position memory self, Order memory order) internal pure {\\n        self.timestamp = order.timestamp;\\n\\n        (self.maker, self.long, self.short) = (\\n            UFixed6Lib.from(Fixed6Lib.from(self.maker).add(order.maker())),\\n            UFixed6Lib.from(Fixed6Lib.from(self.long).add(order.long())),\\n            UFixed6Lib.from(Fixed6Lib.from(self.short).add(order.short()))\\n        );\\n    }\\n\\n    /// @notice Returns the direction of the position\\n    /// @dev 0 = maker, 1 = long, 2 = short\\n    /// @param self The position object to check\\n    /// @return The direction of the position\\n    function direction(Position memory self) internal pure returns (uint256) {\\n        return self.long.isZero() ? (self.short.isZero() ? 0 : 2) : 1;\\n    }\\n\\n    /// @notice Returns the maximum position size\\n    /// @param self The position object to check\\n    /// @return The maximum position size\\n    function magnitude(Position memory self) internal pure returns (UFixed6) {\\n        return self.long.max(self.short).max(self.maker);\\n    }\\n\\n    /// @notice Returns the maximum taker position size\\n    /// @param self The position object to check\\n    /// @return The maximum taker position size\\n    function major(Position memory self) internal pure returns (UFixed6) {\\n        return self.long.max(self.short);\\n    }\\n\\n    /// @notice Returns the minimum maker position size\\n    /// @param self The position object to check\\n    /// @return The minimum maker position size\\n    function minor(Position memory self) internal pure returns (UFixed6) {\\n        return self.long.min(self.short);\\n    }\\n\\n    /// @notice Returns the skew of the position\\n    /// @param self The position object to check\\n    /// @return The skew of the position\\n    function skew(Position memory self) internal pure returns (Fixed6) {\\n        return Fixed6Lib.from(self.long).sub(Fixed6Lib.from(self.short));\\n    }\\n\\n    /// @notice Returns the utilization of the position\\n    /// @dev utilization = major / (maker + minor)\\n    /// @param self The position object to check\\n    /// @param riskParameter The current risk parameter\\n    /// @return The utilization of the position\\n    function utilization(Position memory self, RiskParameter memory riskParameter) internal pure returns (UFixed6) {\\n        // long-short net utilization of the maker position\\n        UFixed6 netUtilization = major(self).unsafeDiv(self.maker.add(minor(self)));\\n\\n        // efficiency limit utilization of the maker position\\n        UFixed6 efficiencyUtilization = major(self).mul(riskParameter.efficiencyLimit).unsafeDiv(self.maker);\\n\\n        // maximum of the two utilizations, capped at 100%\\n        return netUtilization.max(efficiencyUtilization).min(UFixed6Lib.ONE);\\n    }\\n\\n    /// @notice Returns the portion of the position that is covered by the maker\\n    /// @param self The position object to check\\n    /// @return The portion of the position that is covered by the maker\\n    function socializedMakerPortion(Position memory self) internal pure returns (UFixed6) {\\n        return takerSocialized(self).isZero() ?\\n            UFixed6Lib.ZERO :\\n            takerSocialized(self).sub(minor(self)).div(takerSocialized(self));\\n    }\\n\\n    /// @notice Returns the long position with socialization taken into account\\n    /// @param self The position object to check\\n    /// @return The long position with socialization taken into account\\n    function longSocialized(Position memory self) internal pure returns (UFixed6) {\\n        return self.maker.add(self.short).min(self.long);\\n    }\\n\\n    /// @notice Returns the short position with socialization taken into account\\n    /// @param self The position object to check\\n    /// @return The short position with socialization taken into account\\n    function shortSocialized(Position memory self) internal pure returns (UFixed6) {\\n        return self.maker.add(self.long).min(self.short);\\n    }\\n\\n    /// @notice Returns the major position with socialization taken into account\\n    /// @param self The position object to check\\n    /// @return The major position with socialization taken into account\\n    function takerSocialized(Position memory self) internal pure returns (UFixed6) {\\n        return major(self).min(minor(self).add(self.maker));\\n    }\\n\\n    /// @notice Returns the efficiency of the position\\n    /// @dev efficiency = maker / major\\n    /// @param self The position object to check\\n    /// @return The efficiency of the position\\n    function efficiency(Position memory self) internal pure returns (UFixed6) {\\n        return self.maker.unsafeDiv(major(self)).min(UFixed6Lib.ONE);\\n    }\\n\\n    /// @notice Returns the whether the position is socialized\\n    /// @param self The position object to check\\n    /// @return Whether the position is socialized\\n    function socialized(Position memory self) internal pure returns (bool) {\\n        return self.maker.add(self.short).lt(self.long) || self.maker.add(self.long).lt(self.short);\\n    }\\n\\n    /// @notice Returns the whether the position is single-sided\\n    /// @param self The position object to check\\n    /// @return Whether the position is single-sided\\n    function singleSided(Position memory self) internal pure returns (bool) {\\n        return magnitude(self).eq(self.long.add(self.short).add(self.maker));\\n    }\\n\\n    /// @notice Returns the whether the position is empty\\n    /// @param self The position object to check\\n    /// @return Whether the position is empty\\n    function empty(Position memory self) internal pure returns (bool) {\\n        return magnitude(self).isZero();\\n    }\\n\\n    /// @notice Returns the maintenance requirement of the position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @return The maintenance requirement of the position\\n    function maintenance(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (UFixed6) {\\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.maintenance, riskParameter.minMaintenance);\\n    }\\n\\n    /// @notice Returns the margin requirement of the position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateralization The collateralization requirement override provided by the caller\\n    /// @return The margin requirement of the position\\n    function margin(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        UFixed6 collateralization\\n    ) internal pure returns (UFixed6) {\\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.margin.max(collateralization), riskParameter.minMargin);\\n    }\\n\\n    /// @notice Returns the maintenance requirement of the position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @return The maintenance requirement of the position\\n    function maintenance(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (UFixed6) {\\n        return maintenance(magnitude(self), latestVersion, riskParameter);\\n    }\\n\\n    /// @notice Returns the margin requirement of the position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @return The margin requirement of the position\\n    function margin(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter\\n    ) internal pure returns (UFixed6) {\\n        return margin(magnitude(self), latestVersion, riskParameter, UFixed6Lib.ZERO);\\n    }\\n\\n    /// @notice Returns the collateral requirement of the position magnitude\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param requirementRatio The ratio requirement to the notional\\n    /// @param requirementFixed The fixed requirement\\n    /// @return The collateral requirement of the position magnitude\\n    function _collateralRequirement(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        UFixed6 requirementRatio,\\n        UFixed6 requirementFixed\\n    ) private pure returns (UFixed6) {\\n        if (positionMagnitude.isZero()) return UFixed6Lib.ZERO;\\n        return positionMagnitude.mul(latestVersion.price.abs()).mul(requirementRatio).max(requirementFixed);\\n    }\\n\\n    /// @notice Returns the whether the position is maintained\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is maintained\\n    function maintained(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return UFixed6Lib.unsafeFrom(collateral).gte(maintenance(positionMagnitude, latestVersion, riskParameter));\\n    }\\n\\n    /// @notice Returns the whether the position is margined\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param positionMagnitude The position magnitude value to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateralization The collateralization requirement override provided by the caller\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is margined\\n    function margined(\\n        UFixed6 positionMagnitude,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        UFixed6 collateralization,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return UFixed6Lib.unsafeFrom(collateral).gte(margin(positionMagnitude, latestVersion, riskParameter, collateralization));\\n    }\\n\\n    /// @notice Returns the whether the position is maintained\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is maintained\\n    function maintained(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return maintained(magnitude(self), latestVersion, riskParameter, collateral);\\n    }\\n\\n    /// @notice Returns the whether the position is margined\\n    /// @dev shortfall is considered solvent for 0-position\\n    /// @param self The position object to check\\n    /// @param latestVersion The latest oracle version\\n    /// @param riskParameter The current risk parameter\\n    /// @param collateralization The collateralization requirement override provided by the caller\\n    /// @param collateral The current account's collateral\\n    /// @return Whether the position is margined\\n    function margined(\\n        Position memory self,\\n        OracleVersion memory latestVersion,\\n        RiskParameter memory riskParameter,\\n        UFixed6 collateralization,\\n        Fixed6 collateral\\n    ) internal pure returns (bool) {\\n        return margined(magnitude(self), latestVersion, riskParameter, collateralization, collateral);\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the global Position struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredPositionGlobal {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         uint32 __unallocated__;\\n///         uint64 maker;\\n///         uint64 long;\\n///         uint64 short;\\n///\\n///         /* slot 1 */\\n///         uint64 maker (deprecated);\\n///         uint192 __unallocated__;\\n///     }\\n///\\nlibrary PositionStorageGlobalLib {\\n    function read(PositionStorageGlobal storage self) internal view returns (Position memory) {\\n        uint256 slot0 = self.slot0;\\n        return Position(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64)),\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64 - 64)) >> (256 - 64))\\n        );\\n    }\\n\\n    function store(PositionStorageGlobal storage self, Position memory newValue) public {\\n        PositionStorageLib.validate(newValue);\\n\\n        if (newValue.maker.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\\n        if (newValue.long.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\\n        if (newValue.short.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\\n            uint256(UFixed6.unwrap(newValue.maker) << (256 - 64)) >> (256 - 32 - 32 - 64) |\\n            uint256(UFixed6.unwrap(newValue.long) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64) |\\n            uint256(UFixed6.unwrap(newValue.short) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64 - 64);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n        }\\n    }\\n\\n    function migrate(PositionStorageGlobal storage self) external {\\n        Position memory position = read(self);\\n        uint256 slot1 = self.slot1;\\n        UFixed6 deprecatedMaker = UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64));\\n\\n        // only migrate if the deprecated maker is set and new maker is unset to avoid double-migration\\n        if (deprecatedMaker.isZero() || !position.maker.isZero())\\n            revert PositionStorageLib.PositionStorageInvalidMigrationError();\\n\\n        position.maker = deprecatedMaker;\\n        store(self, position);\\n        assembly {\\n            sstore(add(self.slot, 1), 0) // Part of the v2.3 migration. Can be removed once migration is complete.\\n        }\\n    }\\n}\\n\\n/// @dev Manually encodes and decodes the local Position struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredPositionLocal (v0) {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         uint216 __unallocated__;\\n///         uint8 layout;\\n///\\n///         /* slot 1 */\\n///         uint2 direction;\\n///         uint62 magnitude;\\n///         uint192 __unallocated__;\\n///     }\\n///\\n///     note: fresh Positions will still default to v0 until they are saved to, but this is safe because\\n///           slot1 is still reserved and will return correct default values.\\n///\\n///     struct StoredPositionLocal (v1) {\\n///         /* slot 0 */\\n///         uint32 timestamp;\\n///         uint2 direction;\\n///         uint62 magnitude;\\n///         uint152 __unallocated__;\\n///         uint8 layout; // v2.3 migration -- can remove once all accounts have been migrated\\n///     }\\n///\\nlibrary PositionStorageLocalLib {\\n    function read(PositionStorageLocal storage self) internal view returns (Position memory) {\\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\\n        uint256 layout = uint256(slot0 << (256 - 32 - 216 - 8)) >> (256 - 8);\\n\\n        uint256 direction = layout == 0 ?\\n            uint256(slot1 << (256 - 2)) >> (256 - 2) :\\n            uint256(slot0 << (256 - 32 - 2)) >> (256 - 2);\\n        UFixed6 magnitude = layout == 0 ?\\n            UFixed6.wrap(uint256(slot1 << (256 - 2 - 62)) >> (256 - 62)) :\\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 2 - 62)) >> (256 - 62));\\n\\n        return Position(\\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\\n            direction == 0 ? magnitude : UFixed6Lib.ZERO,\\n            direction == 1 ? magnitude : UFixed6Lib.ZERO,\\n            direction == 2 ? magnitude : UFixed6Lib.ZERO\\n        );\\n    }\\n\\n    function store(PositionStorageLocal storage self, Position memory newValue) external {\\n        PositionStorageLib.validate(newValue);\\n\\n        uint256 layout = 1;\\n        UFixed6 magnitude = newValue.magnitude();\\n\\n        if (magnitude.gt(UFixed6.wrap(2 ** 62 - 1))) revert PositionStorageLib.PositionStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\\n            uint256(newValue.direction() << (256 - 2)) >> (256 - 32 - 2) |\\n            uint256(UFixed6.unwrap(magnitude) << (256 - 62)) >> (256 - 32 - 2 - 62) |\\n            uint256(layout << (256 - 8)) >> (256 - 32 - 2 - 62 - 152 - 8);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), 0) // Part of the v2.3 migration. Can be removed once migration is complete.\\n        }\\n    }\\n}\\n\\nlibrary PositionStorageLib {\\n    // sig: 0x52a8a97f\\n    error PositionStorageInvalidError();\\n    // sig: 0x1bacb3a2\\n    error PositionStorageInvalidMigrationError();\\n\\n    function validate(Position memory newValue) internal pure {\\n        if (newValue.timestamp > type(uint32).max) revert PositionStorageInvalidError();\\n    }\\n}\",\"keccak256\":\"0x1eddd2dd3bcb4c817848b727f9425fbea82452458821d40222e635f534674a8d\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/ProtocolParameter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\n\\n/// @dev ProtocolParameter type\\nstruct ProtocolParameter {\\n    /// @dev The maximum for market fee parameters\\n    UFixed6 maxFee;\\n\\n    /// @dev The maximum for liquidationFee market parameter\\n    UFixed6 maxLiquidationFee;\\n\\n    /// @dev The maximum for market cut parameters\\n    UFixed6 maxCut;\\n\\n    /// @dev The maximum for market rate parameters\\n    UFixed6 maxRate;\\n\\n    /// @dev The minimum for market maintenance parameters\\n    UFixed6 minMaintenance;\\n\\n    /// @dev The minimum for market efficiency parameters\\n    UFixed6 minEfficiency;\\n\\n    /// @dev The default referrer fee percentage for orders\\n    UFixed6 referralFee;\\n\\n    /// @dev The minimum ratio between scale vs makerLimit / efficiencyLimit\\n    UFixed6 minScale;\\n\\n    /// @dev The maximum for parameter restricting maximum time between oracle version and update\\n    uint256 maxStaleAfter;\\n}\\nstruct StoredProtocolParameter {\\n    /* slot 0 (29) */\\n    uint24 maxFee;                  // <= 1677%\\n    uint32 maxLiquidationFee;       // <= 4294\\n    uint24 maxCut;                  // <= 1677%\\n    uint32 maxRate;                 // <= 214748% (capped at 31 bits to accommodate int32 rates)\\n    uint24 minMaintenance;          // <= 1677%\\n    uint24 minEfficiency;           // <= 1677%\\n    uint24 referralFee;             // <= 1677%\\n    uint24 minScale;                // <= 1677%\\n    uint24 maxStaleAfter;           // <= 4660 hours\\n}\\nstruct ProtocolParameterStorage { StoredProtocolParameter value; } // SECURITY: must remain at (1) slots\\nusing ProtocolParameterStorageLib for ProtocolParameterStorage global;\\n\\n/// @dev (external-safe): this library is safe to externalize\\nlibrary ProtocolParameterStorageLib {\\n    // sig: 0x4dc1bc59\\n    error ProtocolParameterStorageInvalidError();\\n\\n    function read(ProtocolParameterStorage storage self) internal view returns (ProtocolParameter memory) {\\n        StoredProtocolParameter memory value = self.value;\\n        return ProtocolParameter(\\n            UFixed6.wrap(uint256(value.maxFee)),\\n            UFixed6.wrap(uint256(value.maxLiquidationFee)),\\n            UFixed6.wrap(uint256(value.maxCut)),\\n            UFixed6.wrap(uint256(value.maxRate)),\\n            UFixed6.wrap(uint256(value.minMaintenance)),\\n            UFixed6.wrap(uint256(value.minEfficiency)),\\n            UFixed6.wrap(uint256(value.referralFee)),\\n            UFixed6.wrap(uint256(value.minScale)),\\n            uint24(value.maxStaleAfter)\\n        );\\n    }\\n\\n    function validate(ProtocolParameter memory self) internal pure {\\n        if (self.maxCut.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\\n        if (self.referralFee.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\\n        if (self.minScale.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\\n    }\\n\\n    function validateAndStore(ProtocolParameterStorage storage self, ProtocolParameter memory newValue) internal {\\n        validate(newValue);\\n\\n        if (newValue.maxFee.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.maxLiquidationFee.gt(UFixed6.wrap(type(uint32).max))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.maxRate.gt(UFixed6.wrap(type(uint32).max / 2))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.minMaintenance.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.minEfficiency.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\\n        if (newValue.maxStaleAfter > uint256(type(uint24).max)) revert ProtocolParameterStorageInvalidError();\\n\\n        self.value = StoredProtocolParameter(\\n            uint24(UFixed6.unwrap(newValue.maxFee)),\\n            uint32(UFixed6.unwrap(newValue.maxLiquidationFee)),\\n            uint24(UFixed6.unwrap(newValue.maxCut)),\\n            uint32(UFixed6.unwrap(newValue.maxRate)),\\n            uint24(UFixed6.unwrap(newValue.minMaintenance)),\\n            uint24(UFixed6.unwrap(newValue.minEfficiency)),\\n            uint24(UFixed6.unwrap(newValue.referralFee)),\\n            uint24(UFixed6.unwrap(newValue.minScale)),\\n            uint24(newValue.maxStaleAfter)\\n        );\\n    }\\n}\",\"keccak256\":\"0x22972640cf3e95e20b8105ffdcae759bdc768b1827ae8113ff71cfa9b624848a\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/RiskParameter.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { UJumpRateUtilizationCurve6 } from \\\"@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol\\\";\\nimport { PController6 } from \\\"@equilibria/root/pid/types/PController6.sol\\\";\\nimport { LinearAdiabatic6 } from \\\"@equilibria/root/adiabatic/types/LinearAdiabatic6.sol\\\";\\nimport { NoopAdiabatic6 } from \\\"@equilibria/root/adiabatic/types/NoopAdiabatic6.sol\\\";\\nimport { ProtocolParameter } from \\\"./ProtocolParameter.sol\\\";\\n\\n/// @dev RiskParameter type\\nstruct RiskParameter {\\n    /// @dev The minimum amount of collateral required to open a new position as a percentage of notional\\n    UFixed6 margin;\\n\\n    /// @dev The minimum amount of collateral that must be maintained as a percentage of notional\\n    UFixed6 maintenance;\\n\\n    /// @dev The taker impact fee\\n    LinearAdiabatic6 takerFee;\\n\\n    /// @dev The maker fee configuration\\n    NoopAdiabatic6 makerFee;\\n\\n    /// @dev The maximum amount of maker positions that opened\\n    UFixed6 makerLimit;\\n\\n    /// @dev The minimum limit of the efficiency metric\\n    UFixed6 efficiencyLimit;\\n\\n    /// @dev Multiple of the settlement fee charged when a position is liquidated\\n    UFixed6 liquidationFee;\\n\\n    /// @dev The utilization curve that is used to compute maker interest\\n    UJumpRateUtilizationCurve6 utilizationCurve;\\n\\n    /// @dev The p controller that is used to compute long-short funding\\n    PController6 pController;\\n\\n    /// @dev The minimum fixed amount that is required to open a position\\n    UFixed6 minMargin;\\n\\n    /// @dev The minimum fixed amount that is required for maintenance\\n    UFixed6 minMaintenance;\\n\\n    /// @dev The maximum amount of time since the latest oracle version that update may still be called\\n    uint256 staleAfter;\\n\\n    /// @dev Whether or not the maker should always receive positive funding\\n    bool makerReceiveOnly;\\n}\\nstruct RiskParameterStorage { uint256 slot0; uint256 slot1; uint256 slot2; } // SECURITY: must remain at (3) slots\\nusing RiskParameterStorageLib for RiskParameterStorage global;\\n\\n/// @dev Manually encodes and decodes the local Position struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///    struct StoredRiskParameter {\\n///        /* slot 0 */ (30)\\n///        uint24 margin;                              // <= 1677%\\n///        uint24 maintenance;                         // <= 1677%\\n///        uint24 takerLinearFee;                      // <= 1677%\\n///        uint24 takerProportionalFee;                // <= 1677%\\n///        uint24 takerAdiabaticFee;                   // <= 1677% (must maintain location due to updateRiskParameter)\\n///        uint24 makerLinearFee;                      // <= 1677%\\n///        uint24 makerProportionalFee;                // <= 1677%\\n///        uint48 makerLimit;                          // <= 281t (no decimals)\\n///        uint24 efficiencyLimit;                     // <= 1677%\\n///\\n///        /* slot 1 */ (31)\\n///        bytes3 __unallocated__;\\n///        uint48 makerSkewScale;                      // <= 281t (no decimals) (must maintain location due to updateRiskParameter)\\n///        uint48 takerSkewScale;                      // <= 281t (no decimals) (must maintain location due to updateRiskParameter)\\n///        uint24 utilizationCurveMinRate;             // <= 1677%\\n///        uint24 utilizationCurveMaxRate;             // <= 1677%\\n///        uint24 utilizationCurveTargetRate;          // <= 1677%\\n///        uint24 utilizationCurveTargetUtilization;   // <= 1677%\\n///        int32 pControllerMin;                       // <= 214748%\\n///\\n///        /* slot 2 */ (30)\\n///        uint48 pControllerK;                        // <= 281m\\n///        int32 pControllerMax;                       // <= 214748%\\n///        uint48 minMargin;                           // <= 281m\\n///        uint48 minMaintenance;                      // <= 281m\\n///        uint32 liquidationFee;                      // <= 4294\\n///        uint24 staleAfter;                          // <= 16m s\\n///        bool makerReceiveOnly;\\n///    }\\nlibrary RiskParameterStorageLib {\\n    // sig: 0x7ecd083f\\n    error RiskParameterStorageInvalidError();\\n\\n    function read(RiskParameterStorage storage self) internal view returns (RiskParameter memory) {\\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\\n        return RiskParameter(\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24)) >> (256 - 24)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24)) >> (256 - 24)),\\n            LinearAdiabatic6(\\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6Lib.from(uint256(slot1 << (256 - 24 - 48 - 48)) >> (256 - 48))\\n            ),\\n            NoopAdiabatic6(\\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6Lib.from(uint256(slot1 << (256 - 24 - 48)) >> (256 - 48))\\n            ),\\n            UFixed6Lib.from(uint256(    slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48 - 24)) >> (256 - 24)),\\n\\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 32)) >> (256 - 32)),\\n            UJumpRateUtilizationCurve6(\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24)) >> (256 - 24)),\\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24)) >> (256 - 24))\\n            ),\\n\\n            PController6(\\n                UFixed6.wrap(uint256(   slot2 << (256 - 48)) >> (256 - 48)),\\n                Fixed6.wrap(int256(     slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24 - 32)) >> (256 - 32)),\\n                Fixed6.wrap(int256(     slot2 << (256 - 48 - 32)) >> (256 - 32))\\n            ),\\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48)) >> (256 - 48)),\\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48)) >> (256 - 48)),\\n                         uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 32 - 24)) >> (256 - 24),\\n            0 !=        (uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 32 - 24 - 8)) >> (256 - 8))\\n        );\\n    }\\n\\n    function validate(RiskParameter memory self, ProtocolParameter memory protocolParameter) private pure {\\n        if (\\n            self.takerFee.linearFee.max(self.takerFee.proportionalFee).max(self.takerFee.adiabaticFee)\\n                .max(self.makerFee.linearFee).max(self.makerFee.proportionalFee)\\n                .gt(protocolParameter.maxFee)\\n        ) revert RiskParameterStorageInvalidError();\\n\\n        if (self.liquidationFee.gt(protocolParameter.maxLiquidationFee)) revert RiskParameterStorageInvalidError();\\n\\n        if (\\n            self.utilizationCurve.minRate.max(self.utilizationCurve.maxRate).max(self.utilizationCurve.targetRate)\\n                .max(self.pController.max.abs()).max(self.pController.min.abs())\\n                .gt(protocolParameter.maxRate)\\n        ) revert RiskParameterStorageInvalidError();\\n\\n        if (self.staleAfter > protocolParameter.maxStaleAfter) revert RiskParameterStorageInvalidError();\\n\\n        if (self.maintenance.lt(protocolParameter.minMaintenance)) revert RiskParameterStorageInvalidError();\\n        if (self.maintenance.gt(UFixed6Lib.ONE)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.margin.lt(self.maintenance)) revert RiskParameterStorageInvalidError();\\n        if (self.margin.gt(UFixed6Lib.ONE)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.efficiencyLimit.lt(protocolParameter.minEfficiency)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.utilizationCurve.targetUtilization.gt(UFixed6Lib.ONE)) revert RiskParameterStorageInvalidError();\\n\\n        if (self.minMargin.lt(self.minMaintenance)) revert RiskParameterStorageInvalidError();\\n\\n        (UFixed6 makerLimitTruncated, UFixed6 takerFeeScaleTruncated, UFixed6 makerFeeScaleTruncated) = (\\n            UFixed6Lib.from(self.makerLimit.truncate()),\\n            UFixed6Lib.from(self.takerFee.scale.truncate()),\\n            UFixed6Lib.from(self.makerFee.scale.truncate())\\n        );\\n        UFixed6 scaleLimit = makerLimitTruncated.div(self.efficiencyLimit).mul(protocolParameter.minScale);\\n        if (takerFeeScaleTruncated.lt(scaleLimit) || makerFeeScaleTruncated.lt(scaleLimit))\\n            revert RiskParameterStorageInvalidError();\\n    }\\n\\n    function validateAndStore(\\n        RiskParameterStorage storage self,\\n        RiskParameter memory newValue,\\n        ProtocolParameter memory protocolParameter\\n    ) external {\\n        validate(newValue, protocolParameter);\\n\\n        if (newValue.margin.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.minMargin.gt(UFixed6.wrap(type(uint48).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.efficiencyLimit.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.makerLimit.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.pController.k.gt(UFixed6.wrap(type(uint48).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.takerFee.scale.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.makerFee.scale.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\\n        if (newValue.staleAfter > uint256(type(uint24).max)) revert RiskParameterStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256(UFixed6.unwrap(newValue.margin)                    << (256 - 24)) >> (256 - 24) |\\n            uint256(UFixed6.unwrap(newValue.maintenance)               << (256 - 24)) >> (256 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.takerFee.linearFee)        << (256 - 24)) >> (256 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.takerFee.proportionalFee)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.takerFee.adiabaticFee)     << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.makerFee.linearFee)        << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.makerFee.proportionalFee)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24) |\\n            uint256(newValue.makerLimit.truncate()                     << (256 - 48)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48) |\\n            uint256(UFixed6.unwrap(newValue.efficiencyLimit)           << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48 - 24);\\n\\n        uint256 encoded1 =\\n            uint256(newValue.makerFee.scale.truncate()                          << (256 - 48)) >> (256 - 24 - 48) |\\n            uint256(newValue.takerFee.scale.truncate()                          << (256 - 48)) >> (256 - 24 - 48 - 48) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.minRate)           << (256 - 24)) >> (256 - 24 - 48 - 48 - 24) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.maxRate)           << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetRate)        << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24) |\\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetUtilization) << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24) |\\n            uint256(Fixed6.unwrap(newValue.pController.min)                     << (256 - 32)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24 - 32);\\n\\n        uint256 encoded2 =\\n            uint256(UFixed6.unwrap(newValue.pController.k)                  << (256 - 48)) >> (256 - 48) |\\n            uint256(Fixed6.unwrap(newValue.pController.max)                 << (256 - 32)) >> (256 - 48 - 32) |\\n            uint256(UFixed6.unwrap(newValue.minMargin)                      << (256 - 48)) >> (256 - 48 - 32 - 48) |\\n            uint256(UFixed6.unwrap(newValue.minMaintenance)                 << (256 - 48)) >> (256 - 48 - 32 - 48 - 48) |\\n            uint256(UFixed6.unwrap(newValue.liquidationFee)                 << (256 - 32)) >> (256 - 48 - 32 - 48 - 48 - 32) |\\n            uint256(newValue.staleAfter                                     << (256 - 24)) >> (256 - 48 - 32 - 48 - 48 - 32 - 24) |\\n            uint256((newValue.makerReceiveOnly ? uint256(1) : uint256(0))   << (256 - 8))  >> (256 - 48 - 32 - 48 - 48 - 32 - 24 - 8);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n            sstore(add(self.slot, 2), encoded2)\\n        }\\n    }\\n}\",\"keccak256\":\"0xf1ebe5777e435a1b977ee12664583cd2df709dde06063ce9d9257c0137de2230\",\"license\":\"Apache-2.0\"},\"@perennial/core/contracts/types/Version.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { Accumulator6 } from \\\"@equilibria/root/accumulator/types/Accumulator6.sol\\\";\\n\\n/// @dev Version type\\nstruct Version {\\n    /// @dev whether this version had a valid oracle price\\n    bool valid;\\n\\n    /// @dev The price of the version\\n    Fixed6 price;\\n\\n    /// @dev The maker accumulator value\\n    Accumulator6 makerValue;\\n\\n    /// @dev The long accumulator value\\n    Accumulator6 longValue;\\n\\n    /// @dev The short accumulator value\\n    Accumulator6 shortValue;\\n\\n    /// @dev The accumulated fee for maker orders\\n    Accumulator6 makerFee;\\n\\n    /// @dev The accumulated fee for taker orders\\n    Accumulator6 takerFee;\\n\\n    /// @dev The accumulated offset for maker orders\\n    Accumulator6 makerOffset;\\n\\n    /// @dev The accumulated offset for positive taker orders (open long / close short)\\n    Accumulator6 takerPosOffset;\\n\\n    /// @dev The accumulated offset for negative taker orders (close long / open short)\\n    Accumulator6 takerNegOffset;\\n\\n    /// @dev The accumulated settlement fee for each individual order\\n    Accumulator6 settlementFee;\\n\\n    /// @dev The accumulated liquidation fee for each individual order\\n    Accumulator6 liquidationFee;\\n}\\nstruct VersionStorage { uint256 slot0; uint256 slot1; uint256 slot2; }\\nusing VersionStorageLib for VersionStorage global;\\n\\n/// @dev Manually encodes and decodes the Version struct into storage.\\n///      (external-safe): this library is safe to externalize\\n///\\n///     struct StoredVersion {\\n///         /* slot 0 */\\n///         bool valid;\\n///         int64 makerValue;\\n///         int64 longValue;\\n///         int64 shortValue;\\n///         uint48 liquidationFee;\\n///\\n///         /* slot 1 */\\n///         int64 price;\\n///         int48 makerOffset;\\n///         int48 takerPosOffset;\\n///         int48 takerNegOffset;\\n///         uint48 settlementFee;\\n///\\n///         /* slot 2 */\\n///         int48 makerFee;\\n///         int48 takerFee;\\n///     }\\n///\\nlibrary VersionStorageLib {\\n    // sig: 0xd2777e72\\n    error VersionStorageInvalidError();\\n\\n    function read(VersionStorage storage self) internal view returns (Version memory) {\\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\\n        return Version(\\n            (uint256(slot0 << (256 - 8)) >> (256 - 8)) != 0,\\n            Fixed6.wrap(int256(slot1 << (256 - 64)) >> (256 - 64)),\\n\\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64)) >> (256 - 64))),\\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64)) >> (256 - 64))),\\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64)) >> (256 - 64))),\\n\\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48)) >> (256 - 48))),\\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48 - 48)) >> (256 - 48))),\\n\\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48)) >> (256 - 48))),\\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48)) >> (256 - 48))),\\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48 - 48)) >> (256 - 48))),\\n\\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48 - 48 - 48)) >> (256 - 48))),\\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64 - 48)) >> (256 - 48)))\\n        );\\n    }\\n\\n    function store(VersionStorage storage self, Version memory newValue) external {\\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\\n        if (newValue.makerValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\\n        if (newValue.makerValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\\n        if (newValue.longValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\\n        if (newValue.longValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\\n        if (newValue.shortValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\\n        if (newValue.shortValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\\n        if (newValue.makerFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.makerFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.takerFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.takerFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.makerOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.makerOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.takerPosOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.takerPosOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.takerNegOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.takerNegOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.settlementFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.settlementFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n        if (newValue.liquidationFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\\n        if (newValue.liquidationFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\\n\\n        uint256 encoded0 =\\n            uint256((newValue.valid ? uint256(1) : uint256(0)) << (256 - 8)) >> (256 - 8) |\\n            uint256(Fixed6.unwrap(newValue.makerValue._value) << (256 - 64)) >> (256 - 8 - 64) |\\n            uint256(Fixed6.unwrap(newValue.longValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64) |\\n            uint256(Fixed6.unwrap(newValue.shortValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64 - 64) |\\n            uint256(Fixed6.unwrap(newValue.liquidationFee._value) << (256 - 48)) >> (256 - 8 - 64 - 64 - 64 - 48);\\n        uint256 encoded1 =\\n            uint256(Fixed6.unwrap(newValue.price) << (256 - 64)) >> (256 - 64) |\\n            uint256(Fixed6.unwrap(newValue.makerOffset._value) << (256 - 48)) >> (256 - 64 - 48) |\\n            uint256(Fixed6.unwrap(newValue.takerPosOffset._value) << (256 - 48)) >> (256 - 64 - 48 - 48) |\\n            uint256(Fixed6.unwrap(newValue.takerNegOffset._value) << (256 - 48)) >> (256 - 64 - 48 - 48 - 48) |\\n            uint256(Fixed6.unwrap(newValue.settlementFee._value) << (256 - 48)) >> (256 - 64 - 48 - 48 - 48 - 48);\\n        uint256 encoded2 =\\n            uint256(Fixed6.unwrap(newValue.makerFee._value) << (256 - 48)) >> (256 - 48) |\\n            uint256(Fixed6.unwrap(newValue.takerFee._value) << (256 - 48)) >> (256 - 48 - 48);\\n\\n        assembly {\\n            sstore(self.slot, encoded0)\\n            sstore(add(self.slot, 1), encoded1)\\n            sstore(add(self.slot, 2), encoded2)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb1303e4f24aa28d1f36cdb91a1b71155f568d18acc240dfd676edfd27f61fb99\",\"license\":\"Apache-2.0\"},\"@perennial/verifier/contracts/types/Intent.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity ^0.8.13;\\n\\nimport { UFixed6, UFixed6Lib } from \\\"@equilibria/root/number/types/UFixed6.sol\\\";\\nimport { Fixed6 } from \\\"@equilibria/root/number/types/Fixed6.sol\\\";\\nimport { Common, CommonLib } from \\\"@equilibria/root/verifier/types/Common.sol\\\";\\n\\nstruct Intent {\\n    /// @dev The size and direction of the order being opened by the taker\\n    ///       - Positive opens long / Negative opens short\\n    ///       - The maker will open the opposite side of the order\\n    ///       - To close, open an order in the opposite direction\\n    Fixed6 amount;\\n\\n    /// @dev The price to execute the order at\\n    Fixed6 price;\\n\\n    /// @dev The solver fee, a percentage of the substractive interface fee\\n    UFixed6 fee;\\n\\n    /// @dev The referral address of the originator of the order (ex. the interface)\\n    address originator;\\n\\n    /// @dev The referral address of the solver of the order (ex. the router)\\n    address solver;\\n\\n    /// @dev The minimium collateralization ratio that must be maintained after the order is executed\\n    UFixed6 collateralization;\\n\\n    /// @dev The common information for the intent\\n    Common common;\\n}\\nusing IntentLib for Intent global;\\n\\n/// @title IntentLib\\n/// @notice Library for Intent logic and data.\\nlibrary IntentLib {\\n    bytes32 constant public STRUCT_HASH = keccak256(\\n        \\\"Intent(int256 amount,int256 price,uint256 fee,address originator,address solver,uint256 collateralization,Common common)\\\"\\n        \\\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\\\"\\n    );\\n\\n    function hash(Intent memory self) internal pure returns (bytes32) {\\n        return keccak256(abi.encode(STRUCT_HASH, self.amount, self.price, self.fee, self.originator, self.solver, self.collateralization, CommonLib.hash(self.common)));\\n    }\\n}\\n\",\"keccak256\":\"0xc7bb16c559362c751d1889d6fea834be0066674ace8fe610f15122f1979b483b\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x6080806040523461001c57612ebc90816100218239308160220152f35b5f80fdfe600436101561000c575f80fd5b5f3560e01c634d54b69d1461001f575f80fd5b307f000000000000000000000000000000000000000000000000000000000000000014610d6f577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601610fc08112610d6f57610a6013610d6f576101e060405260043573ffffffffffffffffffffffffffffffffffffffff81168103610d6f576080526101407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc360112610d6f576100d6610da0565b602435815260443560208201526064356040820152608435606082015260a435608082015260c43560a082015260e43560c08201526101043560e0820152610124358015158103610d6f57610100820152610144358015158103610d6f5761012082015260a0526102e0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe9c0112610d6f576040516101a0810181811067ffffffffffffffff821117610d735760405261016435815261018435602082015260807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe5c360112610d6f576101c7610e22565b6101a43581526101c43560208201526101e4356040820152610204356060820152604082015260607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffddc360112610d6f5761021f610dc1565b61022435815261024435602082015261026435604082015260608201526102843560808201526102a43560a08201526102c43560c082015260807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd1c360112610d6f57610289610e22565b6102e435815261030435602082015261032435604082015261034435606082015260e082015260607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc9c360112610d6f576102e1610dc1565b6103643581526103843560208201526103a43560408201526101008201526103c4356101208201526103e435610140820152610404356101608201526104243515156104243503610d6f576104243561018082015260c0526060367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbbc0112610d6f5761036b610dc1565b610444358152610464356020820152610484358015158103610d6f57604082015260e0526104a43561010052610120367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb3c0112610d6f576103ca610de1565b6104c43581526104e43560208201526105043560408201526105243560608201526105443560808201526105643560a08201526105843560c082015260407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa5c360112610d6f57610438610e02565b6105a43581526105c435602082015260e0820152610120526080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa1c0112610d6f57610482610e22565b6105e4358152610604356020820152610624356040820152610644356060820152610140526080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff99c0112610d6f576104d9610e22565b6106643581526106843560208201526106a43560408201526106c4356060820152610160526080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff91c0112610d6f57610530610e22565b6106e4358152610704356020820152610724356040820152610744356060820152610180908152367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff89c0112610d6f57610587610e42565b6107643581526107843560208201526107a43560408201526107c43560608201526107e43560808201526108043560a08201526108243560c08201526108443560e082015261086435610100820152610884356101208201526108a4356101408201526108c4356101608201526101a052610180367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff71c0112610d6f5761062b610e42565b6108e43581526109043560208201526109243560408201526109443560608201526109643560808201526109843560a08201526109a43560c08201526109c43560e08201526109e435610100820152610a0435610120820152610a2435610140820152610a44356101608201526101c052610260367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff59c0112610d6f576106cf610dc1565b6101807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff59c360112610d6f57610702610e42565b610a64358015158103610d6f578152610a8435602082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff55c360112610d6f5761074c610e63565b610aa4358152604082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff53c360112610d6f57610789610e63565b610ac4358152606082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff51c360112610d6f576107c6610e63565b610ae4358152608082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4fc360112610d6f57610803610e63565b610b0435815260a082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4dc360112610d6f57610840610e63565b610b2435815260c082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4bc360112610d6f5761087d610e63565b610b4435815260e082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff49c360112610d6f576108ba610e63565b610b6435815261010082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff47c360112610d6f576108f8610e63565b610b8435815261012082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff45c360112610d6f57610936610e63565b610ba435815261014082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43c360112610d6f57610974610e63565b610bc4358152610160820152815260807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41c360112610d6f576109b4610e22565b610be4358152610c04356020820152610c24356040820152610c44356060820152602082015260607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff39c360112610d6f57610a0c610dc1565b610c64358152610c84356020820152610ca4351515610ca43503610d6f57610ca435604082015260408201526101807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff31c360112610d6f57610a6b610e42565b90610ce4358252610d04356020830152610d24356040830152610d44356060830152610d64356080830152610d843560a0830152610da43560c0830152610dc43560e0830152610de435610100830152610e0435610120830152610e2435610140830152610e443561016083015260c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19c360112610d6f576040519060c0820182811067ffffffffffffffff821117610d7357604052610e64358252610e84356020830152610ea4356040830152610ec4356060830152610ee4356080830152610f043560a083015260607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0dc360112610d6f57610b86610dc1565b91610f24358352610f44356020840152610f64358015158103610d6f57604084015260407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff07c360112610d6f57610c7260e09360409360209361030097610bea610e02565b610f84358152610fa43587820152610c00610e83565b50610c09610f3b565b50610c12610f83565b5060a0608001519489608001519389860151908960800151948b6080015196610c39610da0565b998a528b8a0152610cc4358c8a01526060890152608088015260a087015260c08601528885015261010084015261012083015251610f9d565b9291949061016085519680511515885284810151858901528681015151878901526060810151516060890152608081015151608089015260a08101515160a089015260c08101515160c08901528381015151848901526101008101515161010089015261012081015151610120890152610140810151516101408901520151516101608701528051610180870152828101516101a0870152848101516101c087015260608101516101e0870152608081015161020087015260a081015161022087015260c081015161024087015201518051610260860152015161028084015280516102a084015260208101516102c084015201516102e0820152f35b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b60405190610140820182811067ffffffffffffffff821117610d7357604052565b604051906060820182811067ffffffffffffffff821117610d7357604052565b60405190610100820182811067ffffffffffffffff821117610d7357604052565b604051906040820182811067ffffffffffffffff821117610d7357604052565b604051906080820182811067ffffffffffffffff821117610d7357604052565b60405190610180820182811067ffffffffffffffff821117610d7357604052565b604051906020820182811067ffffffffffffffff821117610d7357604052565b610e8b610e42565b905f82525f6020830152610e9d610e63565b5f81526040830152610ead610e63565b5f81526060830152610ebd610e63565b5f81526080830152610ecd610e63565b5f815260a0830152610edd610e63565b5f815260c0830152610eed610e63565b5f815260e0830152610efd610e63565b5f8152610100830152610f0e610e63565b5f8152610120830152610f1f610e63565b5f8152610140830152610f30610e63565b5f8152610160830152565b610f43610de1565b905f82525f60208301525f60408301525f60608301525f60808301525f60a08301525f60c0830152610f73610e02565b5f81525f602082015260e0830152565b610f8b610dc1565b905f82525f60208301525f6040830152565b610fa5610e83565b90610fae610f3b565b50610fb7610f83565b50604051906102a082019082821067ffffffffffffffff831117610d73576080916040525f83525f60208401525f60408401525f60608401525f828401525f60a08401525f60c08401525f60e08401525f6101008401525f6101208401525f6101408401525f6101608401525f6101808401525f6101a08401525f6101c08401525f6101e08401525f6102008401525f6102208401525f6102408401525f6102608401525f61028084015260408101515160408501515260608101515160608501515201515160808301515260c083015160206040820151151591015160208401528252602060c0840151015160a0845101526110c26020606085015101516080850151519061232d565b80612321575f905b610140840151906110da836125c8565b620f4240820291808304620f42401490151715612061576110fa9261272a565b61026082015260c0830151604001511561231b57620f424061112b60e08501515160c0610120870151015190612623565b045b61114561016084015161113f836125c8565b9061264e565b6102808201526112b561129f61129f620f424061119f8161118e61117760608b01516080606082015191015190612787565b611188602060c08d01510151612ac0565b90612623565b0460406101008a0151015190612623565b046111cf60a08701516111b1836125c8565b6111c960608b01516080606082015191015190612787565b9161272a565b6111e760608801516080606082015191015190612787565b6122e6576112a95f915b6112a4836112a48a8c611241611233606083015161122d61121c60a083015161010084015190612787565b9160c060e082015191015190612787565b90612787565b60808084015101519061232d565b61128c8160c0620f4240611279816112686112626020868b01510151612ac0565b86612623565b046060610100890151015190612623565b04950151611286866125c8565b9061272a565b806122c85750505f9889955b8c51612787565b612787565b61232d565b85526020850151612787565b6020820152611422620f424061131a60606101208701510151826113146112f26112ed60608b01516080606082015191015190612787565b6125c8565b9261130f611307602060c08d01510151612ac0565b915194612ac0565b612623565b04612623565b0461134460e085015161132c836125c8565b6111c960608901516080606082015191015190612787565b61129f611372611363606088015161010060a082015191015190612787565b6040608089015101519061232d565b6113b9620f42406113a889826113146040610120840151015161130f611307602060c061139e8c6125c8565b9701510151612ac0565b0491610100880151611286846125c8565b6113e36113d4606089015160c060e082015191015190612787565b606060808a015101519061232d565b9261129f620f42406114118a826113148961130f611307602060c061139e60406101208a01510151956125c8565b0494610120890151611286876125c8565b60208481015101516122c257805b61143a818361232d565b9161145a604086015161144c856125c8565b6020808a0151015191612794565b6114686040850151916125c8565b905f82820192831291129080158216911516176120615760408401526114926060840151926125c8565b80808401125f8412908015821691151617612061576114bb920160608401526080830151612787565b60808201526115f2620f424061152a6060610120870151015161130f6114f26112ed60608a01516080606082015191015190612787565b91611525611507602060c08c01510151612ac0565b8661131461151e6020604087015196015197612ac0565b9283612623565b612750565b0461153c60e085015161132c836125c8565b61129f61155b611363606088015161010060a082015191015190612787565b61159b61158b60406101208a01510151611574846125c8565b611585602060c08d01510151612ac0565b916127a8565b91610100880151611286846125c8565b6115b66113d4606089015160c060e082015191015190612787565b9261129f6115e260406101208b015101518a611585602060c06115d88b6125c8565b9301510151612ac0565b94610120890151611286876125c8565b60208481015101516122bc57805b61160a818361232d565b9161161c604086015161144c856125c8565b61162a6040850151916125c8565b905f82820192831291129080158216911516176120615760408401526116546060840151926125c8565b915f83820193841291129080158216911516176120615761167e9160608401526080830151612787565b60808201526116ae6040610120850151015161169d60208601516127dc565b906040606082015191015190612d28565b602060c08501510151602060a08601510151915f8312828481031281169083858103139015161761206157620f4240926116e89203612387565b05620f42406116f682612352565b05906020808601510151155f146122b55781905b818303925f83128015828613169185121617612061576117376040860151846020808a0151015191612794565b60a084015260e083015260c0820152611771611762606085015161010060a082015191015190612787565b6040608086015101519061232d565b6117b76040610120860151015161178b60208701516127dc565b611794846125c8565b906117a6602060c08a01510151612ac0565b926040606082015191015190612db9565b6117c7828261010087015161272a565b60408301515f8282019283129112908015821691151617612061576040830152611811611802606086015160c060e082015191015190612787565b6060608087015101519061232d565b90604061012086015101519061183361182d60208801516127dc565b916125c8565b905f82820192831291129080158216911516176120615761187c9161186f9161185b856125c8565b5f03906117a6602060c08b01510151612ac0565b918261012086015161272a565b60408201515f82820192831291129080158216911516176120615760408201526101008084015101516122ac5760c0830151604001515f901561229a576118c660208501516127dc565b6060850151906118e660c06118de60a08501516125c8565b9301516125c8565b915f8382039312818412811691841390151617612061575f82820192831291129080158216911516176120615760608501519061192c6101006118de60e08501516125c8565b915f8382039312818412811691841390151617612061575f8282039212818312811691831390151617612061575b60e08551015190611988610120870151916119826060604061010086015195015101516125c8565b90612892565b620f4240811215612290575b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0bdc0811315612269575b60a0870151519160c08801515192620f42406119e68a611188602060a06115d88285015161290b565b048551611a28620f4240611a0f60208a0151611a0a611a05888c61232d565b61233a565b612387565b05611a23611a1d87516125c8565b9161233a565b612810565b93848201948512945f831292831596801585169088161761206157604083019384518084125f146122605750602083945b019384518082135f146122585750975b611a7b611a76898d61232d565b612636565b948385039685881284168689138416176120615751906002611a9d8387612e75565b148015612246575b1561220a57505050505f915b036121ad57505050620f42408502858104620f4240148615171561206157915b865184808201125f82129080158216911516176120615781620f4240810204620f4240148215171561206157611a058385611b189388620f4240621e848097029101612ae1565b0594620f4240810290808204620f4240149015171561206157611b3b9284612ae1565b9383808601125f86129080158216911516176120615760209181520152808201916101806101208801510151151580612185575b61216d575b5050807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0bdc0027f80000000000000000000000000000000000000000000000000000000000000008214600116612061577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0bdc08105820361206157620f42409005620f4240611c0f611c0284612ac0565b6101008901515190612623565b04621e8480611c20611a05836125c8565b0591611c2b826125c8565b905f82820392128183128116918313901516176120615782808201125f8212908015821691151617612061575f8312848481031281169085858103139015161761206157828403928082019460208a01516002611c916040830151606084015190612b49565b14612129575b505060208901516002611cb36060830151604084015190612b49565b146120e5575b505050611cd36040870151856020808b0151015191612794565b611ceb606087015184604060208b0151015191612794565b611d03608087015183606060208b0151015191612794565b610160850152610140840152610120830152610100820152620f4240611df981611d61611d3e60208801516060604082015191015190612787565b6020888101510151808210156120de57505b611188602060a08a01510151612ac0565b04826113146101208801518860e082015191611dc360208301519186611dba611d89856129b8565b9260a0611db1611dab6020890196611da5885161122d8c612aca565b90612b79565b976129b8565b91015190612623565b04905190612b79565b808211156120d757505b848110156120c65761118891611df3611a76925b60c060a0840151519301515195612b94565b9361232d565b0480620f4240810204620f4240148115171561206157620f4240611e3060206101008701510151651cae8c13e00083850204612623565b04906020850151611e40816129b8565b6120955750611e5b651cae8c13e000620f42408302046125c8565b91611e72651cae8c13e000620f42408402046125c8565b915f8412838581031281169084868103139015161761206157611ebc611ea96112ed84651cae8c13e000620f42408096020461232d565b9482611eb482612352565b059403612352565b0590611ed56040870151856020808b0151015191612794565b611eed606087015184604060208b0151015191612794565b611f05608087015183606060208b0151015191612794565b6101e08501526101c08401526101a0830152610180820152602060c08401510151602060a08501510151905f828203921281831281169183139015161761206157611f82620f424091611f7c60208701516040611f6b6020830151606084015190612787565b9101518082101561208e57506125c8565b90612387565b0592602060a08201510151602060c08301510151905f828203921281831281169183139015161761206157611fd2620f424091611f7c60208501516060611f6b6020830151604084015190612787565b05808501948186125f821290801582169115161761206157620f4240611ffa61205a97612352565b059161201460608701518360406020880151015191612794565b61202c60808701518260606020880151015191612794565b612043604087015184602080880151015191612794565b6102408501526102208401526102008301526123c5565b9192909190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b90506125c8565b6112ed816115256120b260606040611e5b96015193015183612787565b91651cae8c13e000620f4240870204612623565b50611a7661118891611df386611de1565b9050611dcd565b9050611d50565b620f4240929650612107919395506112ed6120ff91612978565b838701612387565b059301838103905f8512801582841316918312161761206157915f8080611cb9565b61214a919750620f42409295506112ed61214291612978565b858803612387565b0594839003858103905f8712801582841316918312161761206157925f80611c97565b620f4240925061217d9101612352565b055f80611b74565b5061219182820161293d565b6121a66121a160208a01516127dc565b61293d565b1415611b6f565b620f4240850291858304620f424014861517156120615761152561122d926121d76121dd96612ac0565b92612623565b620f42408602868104620f42401487151715612061578082101561220357505b91611ad1565b90506121fd565b5f6122148961293d565b131561223d5750905b838203928284121691831316176120615761223790612ac0565b91611ab1565b9050519061221d565b50612252815186612e75565b15611aa5565b905097611a69565b60209094611a59565b507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0bdc06119bd565b50620f4240611994565b6122a760208501516127dc565b61195a565b61205a926123c5565b5f9061170a565b5f611600565b5f611430565b61152561016060606122de940151015184612623565b988995611298565b6112a9612315606089015161152561230e610140830151926080606082015191015190612787565b9185612623565b916111f1565b5f61112d565b60e084015151906110ca565b9190820391821161206157565b90620f42409182810292818405149015171561206157565b907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0bdc09182810292818405149015171561206157565b81810292915f82127f800000000000000000000000000000000000000000000000000000000000000082141661206157818405149015171561206157565b9290916123d0610e83565b506123d9610f3b565b506123e2610f83565b506040840151610160606086015160405192835280516020840152602081015160408401526040810151606084015260608101516080840152608081015160a084015260a081015160c084015260c081015160e084015260e081015161010084015261010081015161012084015261012081015161014084015261014081015182840152015161018082015283516101a082015260208401516101c082015260408401516101e08201526060840151610200820152608084015161022082015260a084015161024082015260c084015161026082015260e084019081516102808201526101008501516102a08201526101208501516102c08201526101408501516102e08201526125b561016086019687516103008401526101808701516103208401526101a08701516103408401526101c08701516103608401526125ad6101e088019182516103808601526102008901516103a08601526102208901516103c08601526102408901516103e08601527fe627e065dccddb829dad0df21140f6b91ad7a6fe0c8dea5fd6cfc44ae84ff77f6104406102608b019687516104008201526102808c0151610420820152a151986125ad61259f610f83565b996080815191015190612787565b905190612787565b8552516020850152516040840152929190565b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81116125f25790565b602490604051907feecaa25d0000000000000000000000000000000000000000000000000000000082526004820152fd5b8181029291811591840414171561206157565b620f4240908181029181830414901517156120615790565b811561272657612666815192620f4240918291612352565b05906126718261293d565b917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff908184036127125783800560011484151715612061576126b290612ac0565b908282029180830484149015171561206157816126f2575050506126d7905f90612865565b915b5f83820193841291129080158216911516176120615752565b810190811161206157049060018201809211612061576126d79190612865565b905061271f91925061233a565b05916126d9565b5050565b9091821561274b576126d790620f4240612745845195612352565b056129cf565b505050565b811561275a570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b9190820180921161206157565b9091821561274b576126d7908251936129cf565b9061130f6127d892611525611314956127ca6020606085015194015195612ac0565b90620f424097889183612623565b0490565b6127f660606127ee60408401516125c8565b9201516125c8565b905f82820392128183128116918313901516176120615790565b811561275a577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82147f8000000000000000000000000000000000000000000000000000000000000000821416612061570590565b5f8113612885575f1361287757505f90565b612880906125c8565b5f0390565b5061288f906125c8565b90565b90806128ff57506128a290612e5d565b600281146128da57156128b657620f424090565b7f800000000000000000000000000000000000000000000000000000000000000090565b507f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90565b611a2361288f9261233a565b61292c612917826129b8565b91602061292382612aca565b91015190612787565b80821015612938575090565b905090565b5f8113612972575f1361294e575f90565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90565b50600190565b6129818161290b565b61298a57505f90565b806129b26129ac61299d61288f9461290b565b6129a684612aca565b9061232d565b9161290b565b90612b5a565b606060408201519101518082115f14612938575090565b906129d98261293d565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90818303612aac57612a25612a1f612a15612a2b936125c8565b94611f7c8661293d565b94612ac0565b92612ac0565b90620f424092838102938185041490151715612061578115612a825782612a5a5750505061288f905f90612865565b820191821161206157612a6c91612750565b90600182018092116120615761288f9190612865565b60046040517f23d359a3000000000000000000000000000000000000000000000000000000008152fd5b61288f939250611a239150611a1d906125c8565b5f81126128805790565b606060408201519101518082105f14612938575090565b651cae8c13e00093611f7c612b1694612b09612b1094611f7c6112ed620f424098899561232d565b05916125c8565b0561233a565b0590565b620f424090818111612b345710612b3057600190565b5f90565b5050600290565b612b4457600190565b600290565b818111612b345710612b3057600190565b90620f4240918281029281840414901517156120615761288f91612750565b9080612b8b575061294e57620f424090565b61288f91612b5a565b90606082018051612ba58184612b49565b8015612cc4575050612bb682612b1a565b908115612bc7575050506020015190565b5190612be5612bdf60206040870151960151956125c8565b946125c8565b90612bf08385612b49565b15908115612cb9575b50612c8f57620f4240928284039284841161206157858303925f8712801582861316918512161761206157612c3d93612c386112ed92611f7c9461232d565b612b5a565b055f8282019283129112908015821691151617612061575f8112612c5e5790565b602490604051907fb02ef0870000000000000000000000000000000000000000000000000000000082526004820152fd5b60046040517f4a83a53f000000000000000000000000000000000000000000000000000000008152fd5b60029150145f612bf9565b90929150612cdb612bdf60408651960151956125c8565b90612ce583612b3b565b15908115612d1d575b50612c8f57838103905f8512801582841316918312161761206157611f7c6112ed620f424094612c3d94612b5a565b60029150145f612cee565b908215612db2578115612d8857612d3e826125c8565b1561275a57621e8480612d81612b0994612d7a612d69612d60612b16976125c8565b611a238461233a565b94611f7c620f42408099819561233a565b059261233a565b0590612387565b60046040517fc7d40ac9000000000000000000000000000000000000000000000000000000008152fd5b5050505f90565b91939293801580612e55575b612e4c578215612d8857611f7c91611f7c612dfe612df5612def612e1095611a23611a1d8a6125c8565b966125c8565b611a238961233a565b95612b09620f424098899687936125c8565b0590828101928312905f81129081159280158316908416176120615784019384129081151691161761206157621e8480612d81612b169361233a565b50505050505f90565b508415612dc5565b5f8113612e6f575f13612b3057600190565b50600290565b818113612b345712612b305760019056fea26469706673582212201970f2382ef183142cad329414fbb78ccbfa2dfcef2a55a7dad53c2e070ed7a164736f6c63430008180033",
  "deployedBytecode": "0x600436101561000c575f80fd5b5f3560e01c634d54b69d1461001f575f80fd5b307f000000000000000000000000000000000000000000000000000000000000000014610d6f577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601610fc08112610d6f57610a6013610d6f576101e060405260043573ffffffffffffffffffffffffffffffffffffffff81168103610d6f576080526101407fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc360112610d6f576100d6610da0565b602435815260443560208201526064356040820152608435606082015260a435608082015260c43560a082015260e43560c08201526101043560e0820152610124358015158103610d6f57610100820152610144358015158103610d6f5761012082015260a0526102e0367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe9c0112610d6f576040516101a0810181811067ffffffffffffffff821117610d735760405261016435815261018435602082015260807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe5c360112610d6f576101c7610e22565b6101a43581526101c43560208201526101e4356040820152610204356060820152604082015260607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffddc360112610d6f5761021f610dc1565b61022435815261024435602082015261026435604082015260608201526102843560808201526102a43560a08201526102c43560c082015260807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd1c360112610d6f57610289610e22565b6102e435815261030435602082015261032435604082015261034435606082015260e082015260607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc9c360112610d6f576102e1610dc1565b6103643581526103843560208201526103a43560408201526101008201526103c4356101208201526103e435610140820152610404356101608201526104243515156104243503610d6f576104243561018082015260c0526060367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffbbc0112610d6f5761036b610dc1565b610444358152610464356020820152610484358015158103610d6f57604082015260e0526104a43561010052610120367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb3c0112610d6f576103ca610de1565b6104c43581526104e43560208201526105043560408201526105243560608201526105443560808201526105643560a08201526105843560c082015260407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa5c360112610d6f57610438610e02565b6105a43581526105c435602082015260e0820152610120526080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa1c0112610d6f57610482610e22565b6105e4358152610604356020820152610624356040820152610644356060820152610140526080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff99c0112610d6f576104d9610e22565b6106643581526106843560208201526106a43560408201526106c4356060820152610160526080367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff91c0112610d6f57610530610e22565b6106e4358152610704356020820152610724356040820152610744356060820152610180908152367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff89c0112610d6f57610587610e42565b6107643581526107843560208201526107a43560408201526107c43560608201526107e43560808201526108043560a08201526108243560c08201526108443560e082015261086435610100820152610884356101208201526108a4356101408201526108c4356101608201526101a052610180367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff71c0112610d6f5761062b610e42565b6108e43581526109043560208201526109243560408201526109443560608201526109643560808201526109843560a08201526109a43560c08201526109c43560e08201526109e435610100820152610a0435610120820152610a2435610140820152610a44356101608201526101c052610260367ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff59c0112610d6f576106cf610dc1565b6101807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff59c360112610d6f57610702610e42565b610a64358015158103610d6f578152610a8435602082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff55c360112610d6f5761074c610e63565b610aa4358152604082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff53c360112610d6f57610789610e63565b610ac4358152606082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff51c360112610d6f576107c6610e63565b610ae4358152608082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4fc360112610d6f57610803610e63565b610b0435815260a082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4dc360112610d6f57610840610e63565b610b2435815260c082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff4bc360112610d6f5761087d610e63565b610b4435815260e082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff49c360112610d6f576108ba610e63565b610b6435815261010082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff47c360112610d6f576108f8610e63565b610b8435815261012082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff45c360112610d6f57610936610e63565b610ba435815261014082015260207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43c360112610d6f57610974610e63565b610bc4358152610160820152815260807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41c360112610d6f576109b4610e22565b610be4358152610c04356020820152610c24356040820152610c44356060820152602082015260607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff39c360112610d6f57610a0c610dc1565b610c64358152610c84356020820152610ca4351515610ca43503610d6f57610ca435604082015260408201526101807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff31c360112610d6f57610a6b610e42565b90610ce4358252610d04356020830152610d24356040830152610d44356060830152610d64356080830152610d843560a0830152610da43560c0830152610dc43560e0830152610de435610100830152610e0435610120830152610e2435610140830152610e443561016083015260c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19c360112610d6f576040519060c0820182811067ffffffffffffffff821117610d7357604052610e64358252610e84356020830152610ea4356040830152610ec4356060830152610ee4356080830152610f043560a083015260607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0dc360112610d6f57610b86610dc1565b91610f24358352610f44356020840152610f64358015158103610d6f57604084015260407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff07c360112610d6f57610c7260e09360409360209361030097610bea610e02565b610f84358152610fa43587820152610c00610e83565b50610c09610f3b565b50610c12610f83565b5060a0608001519489608001519389860151908960800151948b6080015196610c39610da0565b998a528b8a0152610cc4358c8a01526060890152608088015260a087015260c08601528885015261010084015261012083015251610f9d565b9291949061016085519680511515885284810151858901528681015151878901526060810151516060890152608081015151608089015260a08101515160a089015260c08101515160c08901528381015151848901526101008101515161010089015261012081015151610120890152610140810151516101408901520151516101608701528051610180870152828101516101a0870152848101516101c087015260608101516101e0870152608081015161020087015260a081015161022087015260c081015161024087015201518051610260860152015161028084015280516102a084015260208101516102c084015201516102e0820152f35b5f80fd5b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b60405190610140820182811067ffffffffffffffff821117610d7357604052565b604051906060820182811067ffffffffffffffff821117610d7357604052565b60405190610100820182811067ffffffffffffffff821117610d7357604052565b604051906040820182811067ffffffffffffffff821117610d7357604052565b604051906080820182811067ffffffffffffffff821117610d7357604052565b60405190610180820182811067ffffffffffffffff821117610d7357604052565b604051906020820182811067ffffffffffffffff821117610d7357604052565b610e8b610e42565b905f82525f6020830152610e9d610e63565b5f81526040830152610ead610e63565b5f81526060830152610ebd610e63565b5f81526080830152610ecd610e63565b5f815260a0830152610edd610e63565b5f815260c0830152610eed610e63565b5f815260e0830152610efd610e63565b5f8152610100830152610f0e610e63565b5f8152610120830152610f1f610e63565b5f8152610140830152610f30610e63565b5f8152610160830152565b610f43610de1565b905f82525f60208301525f60408301525f60608301525f60808301525f60a08301525f60c0830152610f73610e02565b5f81525f602082015260e0830152565b610f8b610dc1565b905f82525f60208301525f6040830152565b610fa5610e83565b90610fae610f3b565b50610fb7610f83565b50604051906102a082019082821067ffffffffffffffff831117610d73576080916040525f83525f60208401525f60408401525f60608401525f828401525f60a08401525f60c08401525f60e08401525f6101008401525f6101208401525f6101408401525f6101608401525f6101808401525f6101a08401525f6101c08401525f6101e08401525f6102008401525f6102208401525f6102408401525f6102608401525f61028084015260408101515160408501515260608101515160608501515201515160808301515260c083015160206040820151151591015160208401528252602060c0840151015160a0845101526110c26020606085015101516080850151519061232d565b80612321575f905b610140840151906110da836125c8565b620f4240820291808304620f42401490151715612061576110fa9261272a565b61026082015260c0830151604001511561231b57620f424061112b60e08501515160c0610120870151015190612623565b045b61114561016084015161113f836125c8565b9061264e565b6102808201526112b561129f61129f620f424061119f8161118e61117760608b01516080606082015191015190612787565b611188602060c08d01510151612ac0565b90612623565b0460406101008a0151015190612623565b046111cf60a08701516111b1836125c8565b6111c960608b01516080606082015191015190612787565b9161272a565b6111e760608801516080606082015191015190612787565b6122e6576112a95f915b6112a4836112a48a8c611241611233606083015161122d61121c60a083015161010084015190612787565b9160c060e082015191015190612787565b90612787565b60808084015101519061232d565b61128c8160c0620f4240611279816112686112626020868b01510151612ac0565b86612623565b046060610100890151015190612623565b04950151611286866125c8565b9061272a565b806122c85750505f9889955b8c51612787565b612787565b61232d565b85526020850151612787565b6020820152611422620f424061131a60606101208701510151826113146112f26112ed60608b01516080606082015191015190612787565b6125c8565b9261130f611307602060c08d01510151612ac0565b915194612ac0565b612623565b04612623565b0461134460e085015161132c836125c8565b6111c960608901516080606082015191015190612787565b61129f611372611363606088015161010060a082015191015190612787565b6040608089015101519061232d565b6113b9620f42406113a889826113146040610120840151015161130f611307602060c061139e8c6125c8565b9701510151612ac0565b0491610100880151611286846125c8565b6113e36113d4606089015160c060e082015191015190612787565b606060808a015101519061232d565b9261129f620f42406114118a826113148961130f611307602060c061139e60406101208a01510151956125c8565b0494610120890151611286876125c8565b60208481015101516122c257805b61143a818361232d565b9161145a604086015161144c856125c8565b6020808a0151015191612794565b6114686040850151916125c8565b905f82820192831291129080158216911516176120615760408401526114926060840151926125c8565b80808401125f8412908015821691151617612061576114bb920160608401526080830151612787565b60808201526115f2620f424061152a6060610120870151015161130f6114f26112ed60608a01516080606082015191015190612787565b91611525611507602060c08c01510151612ac0565b8661131461151e6020604087015196015197612ac0565b9283612623565b612750565b0461153c60e085015161132c836125c8565b61129f61155b611363606088015161010060a082015191015190612787565b61159b61158b60406101208a01510151611574846125c8565b611585602060c08d01510151612ac0565b916127a8565b91610100880151611286846125c8565b6115b66113d4606089015160c060e082015191015190612787565b9261129f6115e260406101208b015101518a611585602060c06115d88b6125c8565b9301510151612ac0565b94610120890151611286876125c8565b60208481015101516122bc57805b61160a818361232d565b9161161c604086015161144c856125c8565b61162a6040850151916125c8565b905f82820192831291129080158216911516176120615760408401526116546060840151926125c8565b915f83820193841291129080158216911516176120615761167e9160608401526080830151612787565b60808201526116ae6040610120850151015161169d60208601516127dc565b906040606082015191015190612d28565b602060c08501510151602060a08601510151915f8312828481031281169083858103139015161761206157620f4240926116e89203612387565b05620f42406116f682612352565b05906020808601510151155f146122b55781905b818303925f83128015828613169185121617612061576117376040860151846020808a0151015191612794565b60a084015260e083015260c0820152611771611762606085015161010060a082015191015190612787565b6040608086015101519061232d565b6117b76040610120860151015161178b60208701516127dc565b611794846125c8565b906117a6602060c08a01510151612ac0565b926040606082015191015190612db9565b6117c7828261010087015161272a565b60408301515f8282019283129112908015821691151617612061576040830152611811611802606086015160c060e082015191015190612787565b6060608087015101519061232d565b90604061012086015101519061183361182d60208801516127dc565b916125c8565b905f82820192831291129080158216911516176120615761187c9161186f9161185b856125c8565b5f03906117a6602060c08b01510151612ac0565b918261012086015161272a565b60408201515f82820192831291129080158216911516176120615760408201526101008084015101516122ac5760c0830151604001515f901561229a576118c660208501516127dc565b6060850151906118e660c06118de60a08501516125c8565b9301516125c8565b915f8382039312818412811691841390151617612061575f82820192831291129080158216911516176120615760608501519061192c6101006118de60e08501516125c8565b915f8382039312818412811691841390151617612061575f8282039212818312811691831390151617612061575b60e08551015190611988610120870151916119826060604061010086015195015101516125c8565b90612892565b620f4240811215612290575b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0bdc0811315612269575b60a0870151519160c08801515192620f42406119e68a611188602060a06115d88285015161290b565b048551611a28620f4240611a0f60208a0151611a0a611a05888c61232d565b61233a565b612387565b05611a23611a1d87516125c8565b9161233a565b612810565b93848201948512945f831292831596801585169088161761206157604083019384518084125f146122605750602083945b019384518082135f146122585750975b611a7b611a76898d61232d565b612636565b948385039685881284168689138416176120615751906002611a9d8387612e75565b148015612246575b1561220a57505050505f915b036121ad57505050620f42408502858104620f4240148615171561206157915b865184808201125f82129080158216911516176120615781620f4240810204620f4240148215171561206157611a058385611b189388620f4240621e848097029101612ae1565b0594620f4240810290808204620f4240149015171561206157611b3b9284612ae1565b9383808601125f86129080158216911516176120615760209181520152808201916101806101208801510151151580612185575b61216d575b5050807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0bdc0027f80000000000000000000000000000000000000000000000000000000000000008214600116612061577ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0bdc08105820361206157620f42409005620f4240611c0f611c0284612ac0565b6101008901515190612623565b04621e8480611c20611a05836125c8565b0591611c2b826125c8565b905f82820392128183128116918313901516176120615782808201125f8212908015821691151617612061575f8312848481031281169085858103139015161761206157828403928082019460208a01516002611c916040830151606084015190612b49565b14612129575b505060208901516002611cb36060830151604084015190612b49565b146120e5575b505050611cd36040870151856020808b0151015191612794565b611ceb606087015184604060208b0151015191612794565b611d03608087015183606060208b0151015191612794565b610160850152610140840152610120830152610100820152620f4240611df981611d61611d3e60208801516060604082015191015190612787565b6020888101510151808210156120de57505b611188602060a08a01510151612ac0565b04826113146101208801518860e082015191611dc360208301519186611dba611d89856129b8565b9260a0611db1611dab6020890196611da5885161122d8c612aca565b90612b79565b976129b8565b91015190612623565b04905190612b79565b808211156120d757505b848110156120c65761118891611df3611a76925b60c060a0840151519301515195612b94565b9361232d565b0480620f4240810204620f4240148115171561206157620f4240611e3060206101008701510151651cae8c13e00083850204612623565b04906020850151611e40816129b8565b6120955750611e5b651cae8c13e000620f42408302046125c8565b91611e72651cae8c13e000620f42408402046125c8565b915f8412838581031281169084868103139015161761206157611ebc611ea96112ed84651cae8c13e000620f42408096020461232d565b9482611eb482612352565b059403612352565b0590611ed56040870151856020808b0151015191612794565b611eed606087015184604060208b0151015191612794565b611f05608087015183606060208b0151015191612794565b6101e08501526101c08401526101a0830152610180820152602060c08401510151602060a08501510151905f828203921281831281169183139015161761206157611f82620f424091611f7c60208701516040611f6b6020830151606084015190612787565b9101518082101561208e57506125c8565b90612387565b0592602060a08201510151602060c08301510151905f828203921281831281169183139015161761206157611fd2620f424091611f7c60208501516060611f6b6020830151604084015190612787565b05808501948186125f821290801582169115161761206157620f4240611ffa61205a97612352565b059161201460608701518360406020880151015191612794565b61202c60808701518260606020880151015191612794565b612043604087015184602080880151015191612794565b6102408501526102208401526102008301526123c5565b9192909190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b90506125c8565b6112ed816115256120b260606040611e5b96015193015183612787565b91651cae8c13e000620f4240870204612623565b50611a7661118891611df386611de1565b9050611dcd565b9050611d50565b620f4240929650612107919395506112ed6120ff91612978565b838701612387565b059301838103905f8512801582841316918312161761206157915f8080611cb9565b61214a919750620f42409295506112ed61214291612978565b858803612387565b0594839003858103905f8712801582841316918312161761206157925f80611c97565b620f4240925061217d9101612352565b055f80611b74565b5061219182820161293d565b6121a66121a160208a01516127dc565b61293d565b1415611b6f565b620f4240850291858304620f424014861517156120615761152561122d926121d76121dd96612ac0565b92612623565b620f42408602868104620f42401487151715612061578082101561220357505b91611ad1565b90506121fd565b5f6122148961293d565b131561223d5750905b838203928284121691831316176120615761223790612ac0565b91611ab1565b9050519061221d565b50612252815186612e75565b15611aa5565b905097611a69565b60209094611a59565b507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0bdc06119bd565b50620f4240611994565b6122a760208501516127dc565b61195a565b61205a926123c5565b5f9061170a565b5f611600565b5f611430565b61152561016060606122de940151015184612623565b988995611298565b6112a9612315606089015161152561230e610140830151926080606082015191015190612787565b9185612623565b916111f1565b5f61112d565b60e084015151906110ca565b9190820391821161206157565b90620f42409182810292818405149015171561206157565b907ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0bdc09182810292818405149015171561206157565b81810292915f82127f800000000000000000000000000000000000000000000000000000000000000082141661206157818405149015171561206157565b9290916123d0610e83565b506123d9610f3b565b506123e2610f83565b506040840151610160606086015160405192835280516020840152602081015160408401526040810151606084015260608101516080840152608081015160a084015260a081015160c084015260c081015160e084015260e081015161010084015261010081015161012084015261012081015161014084015261014081015182840152015161018082015283516101a082015260208401516101c082015260408401516101e08201526060840151610200820152608084015161022082015260a084015161024082015260c084015161026082015260e084019081516102808201526101008501516102a08201526101208501516102c08201526101408501516102e08201526125b561016086019687516103008401526101808701516103208401526101a08701516103408401526101c08701516103608401526125ad6101e088019182516103808601526102008901516103a08601526102208901516103c08601526102408901516103e08601527fe627e065dccddb829dad0df21140f6b91ad7a6fe0c8dea5fd6cfc44ae84ff77f6104406102608b019687516104008201526102808c0151610420820152a151986125ad61259f610f83565b996080815191015190612787565b905190612787565b8552516020850152516040840152929190565b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81116125f25790565b602490604051907feecaa25d0000000000000000000000000000000000000000000000000000000082526004820152fd5b8181029291811591840414171561206157565b620f4240908181029181830414901517156120615790565b811561272657612666815192620f4240918291612352565b05906126718261293d565b917fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff908184036127125783800560011484151715612061576126b290612ac0565b908282029180830484149015171561206157816126f2575050506126d7905f90612865565b915b5f83820193841291129080158216911516176120615752565b810190811161206157049060018201809211612061576126d79190612865565b905061271f91925061233a565b05916126d9565b5050565b9091821561274b576126d790620f4240612745845195612352565b056129cf565b505050565b811561275a570490565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601260045260245ffd5b9190820180921161206157565b9091821561274b576126d7908251936129cf565b9061130f6127d892611525611314956127ca6020606085015194015195612ac0565b90620f424097889183612623565b0490565b6127f660606127ee60408401516125c8565b9201516125c8565b905f82820392128183128116918313901516176120615790565b811561275a577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82147f8000000000000000000000000000000000000000000000000000000000000000821416612061570590565b5f8113612885575f1361287757505f90565b612880906125c8565b5f0390565b5061288f906125c8565b90565b90806128ff57506128a290612e5d565b600281146128da57156128b657620f424090565b7f800000000000000000000000000000000000000000000000000000000000000090565b507f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90565b611a2361288f9261233a565b61292c612917826129b8565b91602061292382612aca565b91015190612787565b80821015612938575090565b905090565b5f8113612972575f1361294e575f90565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90565b50600190565b6129818161290b565b61298a57505f90565b806129b26129ac61299d61288f9461290b565b6129a684612aca565b9061232d565b9161290b565b90612b5a565b606060408201519101518082115f14612938575090565b906129d98261293d565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff90818303612aac57612a25612a1f612a15612a2b936125c8565b94611f7c8661293d565b94612ac0565b92612ac0565b90620f424092838102938185041490151715612061578115612a825782612a5a5750505061288f905f90612865565b820191821161206157612a6c91612750565b90600182018092116120615761288f9190612865565b60046040517f23d359a3000000000000000000000000000000000000000000000000000000008152fd5b61288f939250611a239150611a1d906125c8565b5f81126128805790565b606060408201519101518082105f14612938575090565b651cae8c13e00093611f7c612b1694612b09612b1094611f7c6112ed620f424098899561232d565b05916125c8565b0561233a565b0590565b620f424090818111612b345710612b3057600190565b5f90565b5050600290565b612b4457600190565b600290565b818111612b345710612b3057600190565b90620f4240918281029281840414901517156120615761288f91612750565b9080612b8b575061294e57620f424090565b61288f91612b5a565b90606082018051612ba58184612b49565b8015612cc4575050612bb682612b1a565b908115612bc7575050506020015190565b5190612be5612bdf60206040870151960151956125c8565b946125c8565b90612bf08385612b49565b15908115612cb9575b50612c8f57620f4240928284039284841161206157858303925f8712801582861316918512161761206157612c3d93612c386112ed92611f7c9461232d565b612b5a565b055f8282019283129112908015821691151617612061575f8112612c5e5790565b602490604051907fb02ef0870000000000000000000000000000000000000000000000000000000082526004820152fd5b60046040517f4a83a53f000000000000000000000000000000000000000000000000000000008152fd5b60029150145f612bf9565b90929150612cdb612bdf60408651960151956125c8565b90612ce583612b3b565b15908115612d1d575b50612c8f57838103905f8512801582841316918312161761206157611f7c6112ed620f424094612c3d94612b5a565b60029150145f612cee565b908215612db2578115612d8857612d3e826125c8565b1561275a57621e8480612d81612b0994612d7a612d69612d60612b16976125c8565b611a238461233a565b94611f7c620f42408099819561233a565b059261233a565b0590612387565b60046040517fc7d40ac9000000000000000000000000000000000000000000000000000000008152fd5b5050505f90565b91939293801580612e55575b612e4c578215612d8857611f7c91611f7c612dfe612df5612def612e1095611a23611a1d8a6125c8565b966125c8565b611a238961233a565b95612b09620f424098899687936125c8565b0590828101928312905f81129081159280158316908416176120615784019384129081151691161761206157621e8480612d81612b169361233a565b50505050505f90565b508415612dc5565b5f8113612e6f575f13612b3057600190565b50600290565b818113612b345712612b305760019056fea26469706673582212201970f2382ef183142cad329414fbb78ccbfa2dfcef2a55a7dad53c2e070ed7a164736f6c63430008180033",
  "devdoc": {
    "details": "(external-safe): this library is safe to externalize",
    "kind": "dev",
    "methods": {},
    "title": "VersionLib",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "accumulate(IMarket.Context,IMarket.SettlementContext,uint256,Order,Guarantee,OracleVersion,OracleReceipt)": {
        "notice": "Accumulates the global state for the period from `fromVersion` to `toOracleVersion`"
      }
    },
    "notice": "Manages the logic for the global order accumulation",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
