{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol": {
      "content": "//SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@equilibria/root/number/types/UFixed18.sol\";\n\ninterface IEmptySetReserve {\n    event Redeem(address indexed account, uint256 costAmount, uint256 redeemAmount);\n    event Mint(address indexed account, uint256 mintAmount, uint256 costAmount);\n    event Repay(address indexed account, uint256 repayAmount);\n\n    function debt(address borrower) external view returns (UFixed18);\n    function repay(address borrower, UFixed18 amount) external;\n    function mint(UFixed18 amount) external;\n    function redeem(UFixed18 amount) external;\n}\n"
    },
    "@equilibria/root/accumulator/types/Accumulator6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"../../number/types/UFixed6.sol\";\n\n/// @dev Accumulator6 type\nstruct Accumulator6 {\n    Fixed6 _value;\n}\n\nusing Accumulator6Lib for Accumulator6 global;\nstruct StoredAccumulator6 {\n    int256 _value;\n}\nstruct Accumulator6Storage { StoredAccumulator6 value; }\nusing Accumulator6StorageLib for Accumulator6Storage global;\n\n\n/**\n * @title Accumulator6Lib\n * @notice Library that surfaces math operations for the signed Accumulator type.\n * @dev This accumulator tracks cumulative changes to a value over time. Using the `accumulated` function, one\n * can determine how much a value has changed between two points in time. The `increment` and `decrement` functions\n * can be used to update the accumulator.\n */\nlibrary Accumulator6Lib {\n    /**\n     * Returns how much has been accumulated between two accumulators\n     * @param self The current point of the accumulation to compare with `from`\n     * @param from The starting point of the accumulation\n     * @param total Demoninator of the ratio (see `increment` and `decrement` functions)\n     */\n    function accumulated(Accumulator6 memory self, Accumulator6 memory from, UFixed6 total) internal pure returns (Fixed6) {\n        return _mul(self._value.sub(from._value), total);\n    }\n\n    /**\n     * @notice Increments an accumulator by a given ratio\n     * @dev Always rounds down in order to prevent overstating the accumulated value\n     * @param self The accumulator to increment\n     * @param amount Numerator of the ratio\n     * @param total Denominator of the ratio\n     */\n    function increment(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\n        if (amount.isZero()) return;\n        self._value = self._value.add(_div(amount, total));\n    }\n\n    /**\n     * @notice Decrements an accumulator by a given ratio\n     * @dev Always rounds down in order to prevent overstating the accumulated value\n     * @param self The accumulator to decrement\n     * @param amount Numerator of the ratio\n     * @param total Denominator of the ratio\n     */\n    function decrement(Accumulator6 memory self, Fixed6 amount, UFixed6 total) internal pure {\n        if (amount.isZero()) return;\n        self._value = self._value.add(_div(amount.mul(Fixed6Lib.NEG_ONE), total));\n    }\n\n    function _div(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\n        return amount.sign() == -1 ? amount.divOut(Fixed6Lib.from(total)) : amount.div(Fixed6Lib.from(total));\n    }\n\n    function _mul(Fixed6 amount, UFixed6 total) private pure returns (Fixed6) {\n        return amount.sign() == -1 ? amount.mulOut(Fixed6Lib.from(total)) : amount.mul(Fixed6Lib.from(total));\n    }\n}\n\nlibrary Accumulator6StorageLib {\n    function read(Accumulator6Storage storage self) internal view returns (Accumulator6 memory) {\n        StoredAccumulator6 memory storedValue = self.value;\n        return Accumulator6(Fixed6.wrap(int256(storedValue._value)));\n    }\n\n    function store(Accumulator6Storage storage self, Accumulator6 memory newValue) internal {\n        self.value = StoredAccumulator6(Fixed6.unwrap(newValue._value));\n    }\n}\n"
    },
    "@equilibria/root/adiabatic/AdiabaticMath6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../number/types/UFixed6.sol\";\nimport \"../number/types/Fixed6.sol\";\n\n/**\n * @title AdiabaticMath6\n * @notice Library for managing math operations for adiabatic fees.\n */\nlibrary AdiabaticMath6 {\n    error Adiabatic6ZeroScaleError();\n\n    /// @notice Computes the base fees for an order\n    /// @param fee The linear fee percentage\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The linear fee in underlying terms\n    function linearFee(UFixed6 fee, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return change.abs().mul(price).mul(fee);\n    }\n\n    /// @notice Computes the base fees for an order\n    /// @param scale The scale of the skew\n    /// @param fee The proportional fee percentage\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The proportional fee in underlying terms\n    function proportionalFee(UFixed6 scale, UFixed6 fee, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return change.abs().mul(price).muldiv(change.abs(), scale).mul(fee);\n    }\n\n    /// @notice Computes the adiabatic fee from a latest skew and change in skew over a linear function\n    /// @param scale The scale of the skew\n    /// @param adiabaticFee The adiabatic fee percentage\n    /// @param latest The latest skew in asset terms\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The adiabatic fee in underlying terms\n    function linearCompute(\n        UFixed6 scale,\n        UFixed6 adiabaticFee,\n        Fixed6 latest,\n        Fixed6 change,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        if (latest.isZero() && change.isZero()) return Fixed6Lib.ZERO;\n        if (scale.isZero()) revert Adiabatic6ZeroScaleError();\n\n        // normalize for skew scale\n        (Fixed6 latestScaled, Fixed6 changeScaled) =\n            (latest.div(Fixed6Lib.from(scale)), change.div(Fixed6Lib.from(scale)));\n\n        // adiabatic fee = notional * fee percentage * mean of skew range\n        return change.mul(Fixed6Lib.from(price)).mul(Fixed6Lib.from(adiabaticFee))\n            .mul(_linearMean(latestScaled, latestScaled.add(changeScaled)));\n    }\n\n    /// @notice Finds the mean value of the function f(x) = x over `from` to `to`\n    /// @param from The lower bound\n    /// @param to The upper bound\n    /// @return The mean value\n    function _linearMean(Fixed6 from, Fixed6 to) private pure returns (Fixed6) {\n        return from.add(to).div(Fixed6Lib.from(2));\n    }\n}\n"
    },
    "@equilibria/root/adiabatic/types/LinearAdiabatic6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"../../number/types/UFixed6.sol\";\nimport \"../AdiabaticMath6.sol\";\n\n/// @dev LinearAdiabatic6 type\nstruct LinearAdiabatic6 {\n    UFixed6 linearFee;\n    UFixed6 proportionalFee;\n    UFixed6 adiabaticFee;\n    UFixed6 scale;\n}\nusing LinearAdiabatic6Lib for LinearAdiabatic6 global;\n\n/**\n * @title LinearAdiabatic6Lib\n * @notice Library that that manages the linear adiabatic fee algorithm\n * @dev This algorithm specifies an adiatatic fee over the function:\n *\n *      f(skew) = adiabaticFee * skew\n *\n *      This is used to reward or penalize actions that move skew up or down this curve accordingly with net-zero\n *      value to the system with respect to the underlying asset.\n */\nlibrary LinearAdiabatic6Lib {\n    /// @notice Computes the adiabatic fee from a latest skew and change in skew\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The adiabatic fee in underlying terms\n    function compute(\n        LinearAdiabatic6 memory self,\n        Fixed6 latest,\n        Fixed6 change,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        return AdiabaticMath6.linearCompute(\n            self.scale,\n            self.adiabaticFee,\n            latest,\n            change,\n            price\n        );\n    }\n\n    /// @notice Computes the latest exposure along with all fees\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @return The latest total exposure in asset terms\n    function exposure(LinearAdiabatic6 memory self, Fixed6 latest) internal pure returns (Fixed6) {\n        return compute(self, Fixed6Lib.ZERO, latest, UFixed6Lib.ONE);\n    }\n\n    /// @dev Computes the change in exposure from a new configuration\n    /// @param self The latest fee configuration\n    /// @param newConfig The new fee configuration\n    /// @param latest The latest skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The update fee in underlying terms\n    function exposure(\n        LinearAdiabatic6 memory self,\n        LinearAdiabatic6 memory newConfig,\n        Fixed6 latest,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        return compute(newConfig, Fixed6Lib.ZERO, latest, price).sub(compute(self, Fixed6Lib.ZERO, latest, price));\n    }\n\n    /// @notice Computes the linear fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The linear fee in underlying terms\n    function linear(LinearAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.linearFee(self.linearFee, change, price);\n    }\n\n    /// @notice Computes the proportional fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The proportional fee in underlying terms\n    function proportional(LinearAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.proportionalFee(self.scale, self.proportionalFee, change, price);\n    }\n\n    /// @notice Computes the adiabatic fee\n    /// @param self The adiabatic configuration\n    /// @param latest The latest skew in asset terms\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The adiabatic fee in underlying terms\n    function adiabatic(\n        LinearAdiabatic6 memory self,\n        Fixed6 latest,\n        Fixed6 change,\n        UFixed6 price\n    ) internal pure returns (Fixed6) {\n        return compute(self, latest, change, price);\n    }\n}\n"
    },
    "@equilibria/root/adiabatic/types/NoopAdiabatic6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"../../number/types/UFixed6.sol\";\nimport \"../AdiabaticMath6.sol\";\n\n/// @dev NoopAdiabatic6 type\nstruct NoopAdiabatic6 {\n    UFixed6 linearFee;\n    UFixed6 proportionalFee;\n    UFixed6 scale;\n}\nusing NoopAdiabatic6Lib for NoopAdiabatic6 global;\n\n/**\n * @title NoopAdiabatic6Lib\n * @notice Library that that manages the no-op adiabatic fee algorithm\n * @dev This algorithm specifies a fee schedule without an adiabatic fee. This is used for fees that need unsigned\n *      fee impact without a signed shift fee based on skew.\n */\nlibrary NoopAdiabatic6Lib {\n    /// @notice Computes the linear fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The linear fee in underlying terms\n    function linear(NoopAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.linearFee(self.linearFee, change, price);\n    }\n\n    /// @notice Computes the proportional fee\n    /// @param self The adiabatic configuration\n    /// @param change The change in skew in asset terms\n    /// @param price The price of the underlying asset\n    /// @return The proportional fee in underlying terms\n    function proportional(NoopAdiabatic6 memory self, Fixed6 change, UFixed6 price) internal pure returns (UFixed6) {\n        return AdiabaticMath6.proportionalFee(self.scale, self.proportionalFee, change, price);\n    }\n}\n"
    },
    "@equilibria/root/attribute/Factory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Create2.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"./interfaces/IFactory.sol\";\nimport \"./interfaces/IInstance.sol\";\nimport \"./Pausable.sol\";\n\n/// @title Factory\n/// @notice An abstract factory that manages creates and manages instances\n/// @dev Ownable and Pausable, and satisfies the IBeacon interface by default.\nabstract contract Factory is IFactory, Ownable, Pausable {\n    /// @notice The instances mapping storage slot\n    bytes32 private constant INSTANCE_MAP_SLOT = keccak256(\"equilibria.root.Factory.instances\");\n\n    /// @notice The instance implementation address\n    address public immutable implementation;\n\n    /// @notice Constructs the contract\n    /// @param implementation_ The instance implementation address\n    constructor(address implementation_) { implementation = implementation_; }\n\n    /// @notice Initializes the contract state\n    function __Factory__initialize() internal onlyInitializer {\n        __Ownable__initialize();\n    }\n\n    /// @notice Returns whether the instance is valid\n    /// @param instance The instance to check\n    /// @return Whether the instance is valid\n    function instances(IInstance instance) public view returns (bool) {\n        return _instances()[instance];\n    }\n\n    /// @notice Creates a new instance\n    /// @dev Deploys a BeaconProxy with the this contract as the beacon\n    /// @param data The initialization data\n    /// @return newInstance The new instance\n    function _create(bytes memory data) internal returns (IInstance newInstance) {\n        newInstance = IInstance(address(new BeaconProxy(address(this), data)));\n        _register(newInstance);\n    }\n    /// @notice Creates a new instance at a deterministic address\n    /// @dev Deploys a BeaconProxy with the this contract as the beacon\n    /// @param data The initialization data\n    /// @param salt Used along with initialization data to determine a unique BeaconProxy address\n    /// @return newInstance The new instance\n    function _create2(bytes memory data, bytes32 salt) internal returns (IInstance newInstance) {\n        newInstance = IInstance(address(new BeaconProxy{salt: salt}(address(this), data)));\n        _register(newInstance);\n    }\n\n    // @notice Calculates the address at which the instance will be deployed\n    // @dev Passes the proxy's creation code along with this factory's address\n    // @param data The same initialization data used in the _create2 call\n    // @param salt Used along with initialization data to determine a unique BeaconProxy address\n    function _computeCreate2Address(bytes memory data, bytes32 salt) internal view returns (address) {\n        bytes memory bytecode = abi.encodePacked(\n            type(BeaconProxy).creationCode,\n            abi.encode(address(this), data)\n        );\n        return Create2.computeAddress(salt, keccak256(bytecode));\n    }\n\n    /// @notice Registers a new instance\n    /// @dev Called by _create automatically, or can be called manually in an extending implementation\n    /// @param newInstance The new instance\n    function _register(IInstance newInstance) internal {\n        _instances()[newInstance] = true;\n        emit InstanceRegistered(newInstance);\n    }\n\n    /// @notice Returns the storage mapping for instances\n    /// @return r The storage mapping for instances\n    function _instances() private pure returns (mapping(IInstance => bool) storage r) {\n        bytes32 slot = INSTANCE_MAP_SLOT;\n        /// @solidity memory-safe-assembly\n        assembly { r.slot := slot }\n    }\n\n    /// @notice Only allow the function by a valid instance\n    modifier onlyInstance {\n        if (!instances(IInstance(msg.sender))) revert FactoryNotInstanceError();\n        _;\n    }\n}\n"
    },
    "@equilibria/root/attribute/Initializable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"./interfaces/IInitializable.sol\";\nimport \"../storage/Storage.sol\";\n\n/**\n * @title Initializable\n * @notice Library to manage the initialization lifecycle of upgradeable contracts\n * @dev `Initializable.sol` allows the creation of pseudo-constructors for upgradeable contracts. One\n *      `initializer` should be declared per top-level contract. Child contracts can use the `onlyInitializer`\n *      modifier to tag their internal initialization functions to ensure that they can only be called\n *      from a top-level `initializer` or a constructor.\n */\nabstract contract Initializable is IInitializable {\n    /// @dev The initialized flag\n    Uint256Storage private constant _version = Uint256Storage.wrap(keccak256(\"equilibria.root.Initializable.version\"));\n\n    /// @dev The initializing flag\n    BoolStorage private constant _initializing = BoolStorage.wrap(keccak256(\"equilibria.root.Initializable.initializing\"));\n\n    /// @dev Can only be called once per version, `version` is 1-indexed\n    modifier initializer(uint256 version) {\n        if (version == 0) revert InitializableZeroVersionError();\n        if (_version.read() >= version) revert InitializableAlreadyInitializedError(version);\n\n        _version.store(version);\n        _initializing.store(true);\n\n        _;\n\n        _initializing.store(false);\n        emit Initialized(version);\n    }\n\n    /// @dev Can only be called from an initializer or constructor\n    modifier onlyInitializer() {\n        if (!_constructing() && !_initializing.read()) revert InitializableNotInitializingError();\n        _;\n    }\n\n    /**\n     * @notice Returns whether the contract is currently being constructed\n     * @dev {Address.isContract} returns false for contracts currently in the process of being constructed\n     * @return Whether the contract is currently being constructed\n     */\n    function _constructing() private view returns (bool) {\n        return !Address.isContract(address(this));\n    }\n}\n"
    },
    "@equilibria/root/attribute/Instance.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../storage/Storage.sol\";\nimport \"./interfaces/IInstance.sol\";\nimport \"./Initializable.sol\";\n\n/// @title Instance\n/// @notice An abstract contract that is created and managed by a factory\nabstract contract Instance is IInstance, Initializable {\n    /// @dev The factory address storage slot\n    AddressStorage private constant _factory = AddressStorage.wrap(keccak256(\"equilibria.root.Instance.factory\"));\n\n    /// @notice Returns the factory that created this instance\n    /// @return The factory that created this instance\n    function factory() public view returns (IFactory) { return IFactory(_factory.read()); }\n\n    /// @notice Initializes the contract setting `msg.sender` as the factory\n    function __Instance__initialize() internal onlyInitializer {\n        _factory.store(msg.sender);\n    }\n\n    /// @notice Only allow the owner defined by the factory to call the function\n    modifier onlyOwner {\n        if (msg.sender != factory().owner()) revert InstanceNotOwnerError(msg.sender);\n        _;\n    }\n\n    /// @notice Only allow the factory to call the function\n    modifier onlyFactory {\n        if (msg.sender != address(factory())) revert InstanceNotFactoryError(msg.sender);\n        _;\n    }\n\n    /// @notice Only allow the function to be called when the factory is not paused\n    modifier whenNotPaused {\n        if (factory().paused()) revert InstancePausedError();\n        _;\n    }\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/proxy/beacon/IBeacon.sol\";\nimport \"./IPausable.sol\";\nimport \"./IInstance.sol\";\n\ninterface IFactory is IBeacon, IOwnable, IPausable {\n    event InstanceRegistered(IInstance indexed instance);\n\n    error FactoryNotInstanceError();\n\n    function instances(IInstance instance) external view returns (bool);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IInitializable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\ninterface IInitializable {\n    error InitializableZeroVersionError();\n    error InitializableAlreadyInitializedError(uint256 version);\n    error InitializableNotInitializingError();\n\n    event Initialized(uint256 version);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IInstance.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IFactory.sol\";\nimport \"./IInitializable.sol\";\n\ninterface IInstance is IInitializable {\n    error InstanceNotOwnerError(address sender);\n    error InstanceNotFactoryError(address sender);\n    error InstancePausedError();\n\n    function factory() external view returns (IFactory);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IKept.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"../interfaces/IInitializable.sol\";\nimport \"../../number/types/UFixed18.sol\";\nimport \"../../token/types/Token18.sol\";\n\ninterface IKept is IInitializable {\n    struct KeepConfig {\n        UFixed18 multiplierBase;\n        uint256 bufferBase;\n        UFixed18 multiplierCalldata;\n        uint256 bufferCalldata;\n    }\n\n    event KeeperCall(address indexed sender, uint256 applicableGas, uint256 applicableValue, UFixed18 baseFee, UFixed18 calldataFee, UFixed18 keeperFee);\n\n    function ethTokenOracleFeed() external view returns (AggregatorV3Interface);\n    function keeperToken() external view returns (Token18);\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IInitializable.sol\";\n\ninterface IOwnable is IInitializable {\n    event OwnerUpdated(address indexed newOwner);\n    event PendingOwnerUpdated(address indexed newPendingOwner);\n\n    error OwnableNotOwnerError(address sender);\n    error OwnableNotPendingOwnerError(address sender);\n    error OwnableAlreadyInitializedError();\n\n    function owner() external view returns (address);\n    function pendingOwner() external view returns (address);\n    function updatePendingOwner(address newPendingOwner) external;\n    function acceptOwner() external;\n}\n"
    },
    "@equilibria/root/attribute/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./IInitializable.sol\";\nimport \"./IOwnable.sol\";\n\ninterface IPausable is IInitializable, IOwnable {\n    event PauserUpdated(address indexed newPauser);\n    event Paused();\n    event Unpaused();\n\n    error PausablePausedError();\n    error PausableNotPauserError(address sender);\n\n    function pauser() external view returns (address);\n    function paused() external view returns (bool);\n    function updatePauser(address newPauser) external;\n    function pause() external;\n    function unpause() external;\n}\n"
    },
    "@equilibria/root/attribute/Kept/Kept_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Kept.sol\";\nimport { ArbGasInfo } from \"../../gas/GasOracle_Arbitrum.sol\";\n\n/// @dev Arbitrum Kept implementation\nabstract contract Kept_Arbitrum is Kept {\n    ArbGasInfo constant ARB_GAS = ArbGasInfo(0x000000000000000000000000000000000000006C);\n    uint256 public constant ARB_GAS_MULTIPLIER = 16;\n    uint256 public constant ARB_FIXED_OVERHEAD = 140;\n\n    // https://docs.arbitrum.io/devs-how-tos/how-to-estimate-gas#breaking-down-the-formula\n    // Tx Fee = block.baseFee * l2GasUsed + ArbGasInfo.getL1BaseFeeEstimate() * 16 * (calldataLength + fixedOverhead)\n    // Dynamic buffer = (ArbGasInfo.getL1BaseFeeEstimate() * 16 * (calldataLength + fixedOverhead))\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view virtual override returns (UFixed18) {\n        return _fee(\n            ARB_GAS_MULTIPLIER * (applicableCalldata.length + ARB_FIXED_OVERHEAD),\n            multiplierCalldata,\n            bufferCalldata,\n            ARB_GAS.getL1BaseFeeEstimate()\n        );\n    }\n}\n"
    },
    "@equilibria/root/attribute/Kept/Kept.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../Initializable.sol\";\nimport \"../interfaces/IKept.sol\";\nimport \"../../storage/Storage.sol\";\n\n/// @title Kept\n/// @notice Library to manage keeper incentivization.\n/// @dev Surfaces a keep() modifier that handles measuring job gas costs and paying out rewards the keeper.\nabstract contract Kept is IKept, Initializable {\n    /// @dev The legacy Chainlink feed that is used to convert price ETH relative to the keeper token\n    AddressStorage private constant _ethTokenOracleFeed = AddressStorage.wrap(keccak256(\"equilibria.root.Kept.ethTokenOracleFeed\"));\n    function ethTokenOracleFeed() public view returns (AggregatorV3Interface) { return AggregatorV3Interface(_ethTokenOracleFeed.read()); }\n\n    /// @dev The token that the keeper is paid in\n    Token18Storage private constant _keeperToken = Token18Storage.wrap(keccak256(\"equilibria.root.Kept.keeperToken\"));\n    function keeperToken() public view returns (Token18) { return _keeperToken.read(); }\n\n    /// @notice Initializes the contract\n    /// @param ethTokenOracleFeed_ The legacy Chainlink feed that is used to convert price ETH relative to the keeper token\n    /// @param keeperToken_ The token that the keeper is paid in\n    function __Kept__initialize(\n        AggregatorV3Interface ethTokenOracleFeed_,\n        Token18 keeperToken_\n    ) internal onlyInitializer {\n        _ethTokenOracleFeed.store(address(ethTokenOracleFeed_));\n        _keeperToken.store(keeperToken_);\n    }\n\n    /// @notice Called by the keep modifier to raise the optionally raise the keeper fee\n    /// @param amount The amount of keeper fee to raise\n    /// @param data Arbitrary data passed in from the keep modifier\n    /// @return The amount of keeper fee that was actually raised\n    function _raiseKeeperFee(UFixed18 amount, bytes memory data) internal virtual returns (UFixed18) { return amount; }\n\n    /// @notice Computes the calldata portion of the keeper fee\n    /// @dev Used for L2 implementation with significant calldata costs\n    /// @param applicableCalldata The applicable calldata\n    /// @param multiplierCalldata The multiplier to apply to the calldata cost\n    /// @param bufferCalldata The buffer to apply to the calldata cost\n    /// @return The calldata portion of the keeper fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view virtual returns (UFixed18) { return UFixed18Lib.ZERO; }\n\n    /// @notice Computes the base gas portion of the keeper fee\n    /// @param applicableGas The applicable gas cost\n    /// @param multiplierBase The multiplier to apply to the gas cost\n    /// @param bufferBase The buffer to apply to the gas cost\n    /// @return The gas cost portion of the keeper fee\n    function _baseFee(\n        uint256 applicableGas,\n        UFixed18 multiplierBase,\n        uint256 bufferBase\n    ) internal view returns (UFixed18) {\n        return _fee(applicableGas, multiplierBase, bufferBase, block.basefee);\n    }\n\n    /// @notice Computes a generic keeper fee based on parameters\n    /// @dev Helper function to consolidate keeper fee computation logic\n    /// @param gas The gas cost\n    /// @param multiplier The multiplier to apply to the gas cost\n    /// @param buffer The buffer to apply to the gas cost\n    /// @return The resulting keeper fee\n    function _fee(uint256 gas, UFixed18 multiplier, uint256 buffer, uint256 baseFee) internal pure returns (UFixed18) {\n        return UFixed18Lib.from(gas).mul(multiplier).add(UFixed18Lib.from(buffer)).mul(UFixed18.wrap(baseFee));\n    }\n\n    /// @notice Placed on a function to incentivize keepers to call it\n    /// @param config The multiplier and buffer configuration to apply\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\n    /// @param applicableCalldata The applicable calldata\n    /// @param applicableValue The applicable value\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\n    modifier keep(\n        KeepConfig memory config,\n        bytes memory applicableCalldata,\n        uint256 applicableValue,\n        bytes memory data\n    ) {\n        uint256 startGas = gasleft();\n\n        _;\n\n        uint256 applicableGas = startGas - gasleft();\n\n        _handleKeeperFee(config, applicableGas, applicableCalldata, applicableValue, data);\n    }\n\n    /// @notice Called by the keep modifier to handle keeper fee computation and payment\n    /// @param config The multiplier and buffer configuration to apply\n    /// @param applicableGas The applicable gas cost\n    /// @param applicableCalldata The applicable calldata\n    /// @param applicableValue The applicable value\n    /// @param data Arbitrary data to pass to the _raiseKeeperFee function\n    function _handleKeeperFee(\n        KeepConfig memory config,\n        uint256 applicableGas,\n        bytes memory applicableCalldata,\n        uint256 applicableValue,\n        bytes memory data\n    ) internal {\n        (UFixed18 baseFee, UFixed18 calldataFee) = (\n            _baseFee(applicableGas, config.multiplierBase, config.bufferBase),\n            _calldataFee(applicableCalldata, config.multiplierCalldata, config.bufferCalldata)\n        );\n\n        UFixed18 keeperFee = UFixed18.wrap(applicableValue).add(baseFee).add(calldataFee).mul(_etherPrice());\n        keeperFee = _raiseKeeperFee(keeperFee, data);\n        keeperToken().push(msg.sender, keeperFee);\n\n        emit KeeperCall(msg.sender, applicableGas, applicableValue, baseFee, calldataFee, keeperFee);\n    }\n\n    /// @notice Returns the price of ETH in terms of the keeper token\n    /// @return The price of ETH in terms of the keeper token\n    function _etherPrice() private view returns (UFixed18) {\n        (, int256 answer, , ,) = ethTokenOracleFeed().latestRoundData();\n        return UFixed18Lib.from(Fixed18Lib.ratio(answer, 1e8)); // chainlink eth-usd feed uses 8 decimals\n    }\n}\n"
    },
    "@equilibria/root/attribute/Ownable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Initializable.sol\";\nimport \"./interfaces/IOwnable.sol\";\nimport \"../storage/Storage.sol\";\n\n/**\n * @title Ownable\n * @notice Library to manage the ownership lifecycle of upgradeable contracts.\n * @dev This contract has been extended from the Open Zeppelin library to include an\n *      unstructured storage pattern so that it can be safely mixed in with upgradeable\n *      contracts without affecting their storage patterns through inheritance.\n */\nabstract contract Ownable is IOwnable, Initializable {\n    /// @dev The owner address\n    AddressStorage private constant _owner = AddressStorage.wrap(keccak256(\"equilibria.root.Ownable.owner\"));\n    function owner() public view returns (address) { return _owner.read(); }\n\n    /// @dev The pending owner address\n    AddressStorage private constant _pendingOwner = AddressStorage.wrap(keccak256(\"equilibria.root.Ownable.pendingOwner\"));\n    function pendingOwner() public view returns (address) { return _pendingOwner.read(); }\n\n    /**\n     * @notice Initializes the contract setting `msg.sender` as the initial owner\n     */\n    function __Ownable__initialize() internal onlyInitializer {\n        if (owner() != address(0)) revert OwnableAlreadyInitializedError();\n        _updateOwner(_sender());\n    }\n\n    /**\n     * @notice Updates the new pending owner\n     * @dev Can only be called by the current owner\n     *      New owner does not take affect until that address calls `acceptOwner()`\n     * @param newPendingOwner New pending owner address\n     */\n    function updatePendingOwner(address newPendingOwner) public onlyOwner {\n        _pendingOwner.store(newPendingOwner);\n        emit PendingOwnerUpdated(newPendingOwner);\n    }\n\n    /**\n     * @notice Accepts and transfers the ownership of the contract to the pending owner\n     * @dev Can only be called by the pending owner to ensure correctness. Calls to the `_beforeAcceptOwner` hook\n     *      to perform logic before updating ownership.\n     */\n    function acceptOwner() public {\n        _beforeAcceptOwner();\n\n        if (_sender() != pendingOwner()) revert OwnableNotPendingOwnerError(_sender());\n\n        _updateOwner(pendingOwner());\n        updatePendingOwner(address(0));\n    }\n\n\n    /// @dev Hook for inheriting contracts to perform logic before accepting ownership\n    function _beforeAcceptOwner() internal virtual {}\n\n    /**\n     * @notice Updates the owner address\n     * @param newOwner New owner address\n     */\n    function _updateOwner(address newOwner) private {\n        _owner.store(newOwner);\n        emit OwnerUpdated(newOwner);\n    }\n\n    function _sender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    /// @dev Throws if called by any account other than the owner\n    modifier onlyOwner {\n        if (owner() != _sender()) revert OwnableNotOwnerError(_sender());\n        _;\n    }\n}\n"
    },
    "@equilibria/root/attribute/Pausable.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"./Initializable.sol\";\nimport \"./Ownable.sol\";\nimport \"./interfaces/IPausable.sol\";\nimport \"../storage/Storage.sol\";\n\n/**\n * @title Pausable\n * @notice Library to allow for the emergency pausing and unpausing of contract functions\n *         by an authorized account.\n * @dev This contract has been extended from the Open Zeppelin library to include an\n *      unstructured storage pattern so that it can be safely mixed in with upgradeable\n *      contracts without affecting their storage patterns through inheritance.\n */\nabstract contract Pausable is IPausable, Ownable {\n    /// @dev The pauser address\n    AddressStorage private constant _pauser = AddressStorage.wrap(keccak256(\"equilibria.root.Pausable.pauser\"));\n    function pauser() public view returns (address) { return _pauser.read(); }\n\n    /// @dev Whether the contract is paused\n    BoolStorage private constant _paused = BoolStorage.wrap(keccak256(\"equilibria.root.Pausable.paused\"));\n    function paused() public view returns (bool) { return _paused.read(); }\n\n    /**\n     * @notice Initializes the contract setting `msg.sender` as the initial pauser\n     */\n    function __Pausable__initialize() internal onlyInitializer {\n        __Ownable__initialize();\n        updatePauser(_sender());\n    }\n\n    /**\n     * @notice Updates the new pauser\n     * @dev Can only be called by the current owner\n     * @param newPauser New pauser address\n     */\n    function updatePauser(address newPauser) public onlyOwner {\n        _pauser.store(newPauser);\n        emit PauserUpdated(newPauser);\n    }\n\n    /**\n     * @notice Pauses the contract\n     * @dev Can only be called by the pauser\n     */\n    function pause() external onlyPauser {\n        _paused.store(true);\n        emit Paused();\n    }\n\n    /**\n     * @notice Unpauses the contract\n     * @dev Can only be called by the pauser\n     */\n    function unpause() external onlyPauser {\n        _paused.store(false);\n        emit Unpaused();\n    }\n\n    /// @dev Throws if called by any account other than the pauser\n    modifier onlyPauser {\n        if (_sender() != pauser() && _sender() != owner()) revert PausableNotPauserError(_sender());\n        _;\n    }\n\n    /// @dev Throws if called when the contract is paused\n    modifier whenNotPaused {\n        if (paused()) revert PausablePausedError();\n        _;\n    }\n}\n"
    },
    "@equilibria/root/gas/GasOracle_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { UFixed18, UFixed18Lib } from \"../number/types/UFixed18.sol\";\nimport { Fixed18Lib } from \"../number/types/Fixed18.sol\";\nimport { GasOracle } from \"./GasOracle.sol\";\n\n// https://github.com/OffchainLabs/nitro/blob/v2.0.14/contracts/src/precompiles/ArbGasInfo.sol#L93\ninterface ArbGasInfo {\n    /// @notice Get ArbOS's estimate of the L1 basefee in wei\n    function getL1BaseFeeEstimate() external view returns (uint256);\n}\n\ncontract GasOracle_Arbitrum is GasOracle {\n    ArbGasInfo constant ARB_GAS = ArbGasInfo(0x000000000000000000000000000000000000006C);\n\n    constructor(\n        AggregatorV3Interface feed,\n        uint256 decimals,\n        uint256 computeGas,\n        UFixed18 computeMultiplier,\n        uint256 computeBase,\n        uint256 calldataGas,\n        UFixed18 calldataMultiplier,\n        uint256 calldataBase\n    ) GasOracle(feed, decimals, computeGas, computeMultiplier, computeBase, calldataGas, calldataMultiplier, calldataBase) { }\n\n    function _calldataBaseFee() internal override view returns (uint256) { return ARB_GAS.getL1BaseFeeEstimate(); }\n}\n"
    },
    "@equilibria/root/gas/GasOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { UFixed18, UFixed18Lib } from \"../number/types/UFixed18.sol\";\nimport { Fixed18Lib } from \"../number/types/Fixed18.sol\";\nimport { IGasOracle } from \"./interfaces/IGasOracle.sol\";\n\n/// @title GasOracle\n/// @notice Standalone gas oracle for externally computing keeper rewards based on ether gas costs\ncontract GasOracle is IGasOracle {\n    /// @notice The total compute gas rewarded\n    UFixed18 public immutable COMPUTE_GAS;\n\n    /// @notice The total calldata gas rewarded\n    UFixed18 public immutable CALLDATA_GAS;\n\n    /// @notice Chainlink ETH-Token feed, where cost is expressed in terms of Token\n    AggregatorV3Interface public immutable FEED;\n\n    /// @notice The precomputed offset of the Chainlink feed (10 ^ decimals)\n    int256 public immutable FEED_OFFSET;\n\n    constructor(\n        AggregatorV3Interface feed,\n        uint256 decimals,\n        uint256 computeGas,\n        UFixed18 computeMultiplier,\n        uint256 computeBase,\n        uint256 calldataGas,\n        UFixed18 calldataMultiplier,\n        uint256 calldataBase\n    ) {\n        FEED = feed;\n        FEED_OFFSET = int256(10 ** decimals);\n        COMPUTE_GAS = _precompute(computeGas, computeMultiplier, computeBase);\n        CALLDATA_GAS = _precompute(calldataGas, calldataMultiplier, calldataBase);\n    }\n\n   /// @inheritdoc IGasOracle\n    function cost(uint256 value) external view returns (UFixed18) {\n        (UFixed18 baseFee, UFixed18 calldataFee) =\n            (UFixed18.wrap(block.basefee).mul(COMPUTE_GAS), UFixed18.wrap(_calldataBaseFee()).mul(CALLDATA_GAS));\n\n        return UFixed18.wrap(value).add(baseFee).add(calldataFee).mul(_etherPrice());\n    }\n\n    /// @notice Precomputes the total rewarded gas cost\n    /// @param gas The applicable gas cost\n    /// @param multiplier The reward multiplier to apply to the gas cost\n    /// @param base The base gas reward to add on to the gas cost\n    /// @return The total rewarded gas cost\n    function _precompute(uint256 gas, UFixed18 multiplier, uint256 base) private pure returns (UFixed18) {\n        return UFixed18Lib.from(gas).mul(multiplier).add(UFixed18Lib.from(base));\n    }\n\n    /// @notice Returns the price of ether in terms of the underlying token\n    /// @return The price of ether in terms of the underlyingtoken\n    function _etherPrice() private view returns (UFixed18) {\n        (, int256 answer, , ,) = FEED.latestRoundData();\n        return UFixed18Lib.from(Fixed18Lib.ratio(answer, FEED_OFFSET));\n    }\n\n    /// @notice Returns the base fee of the calldata\n    /// @dev Can be overridden to provide a non-zero calldata base fee for L2 implementations\n    /// @return The base fee of the calldata\n    function _calldataBaseFee() internal virtual view returns (uint256) { return 0; }\n}\n"
    },
    "@equilibria/root/gas/interfaces/IGasOracle.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { UFixed18 } from \"../../number/types/UFixed18.sol\";\n\ninterface IGasOracle {\n    function COMPUTE_GAS() external view returns (UFixed18);\n    function CALLDATA_GAS() external view returns (UFixed18);\n    function FEED() external view returns (AggregatorV3Interface);\n    function FEED_OFFSET() external view returns (int256);\n\n    /// @notice Computes the reward of a transaction\n    /// @param value The ether value of the transaction in addition to the gas cost rewarded\n    /// @return The reward of the transaction\n    function cost(uint256 value) external view returns (UFixed18);\n}\n"
    },
    "@equilibria/root/number/NumberMath.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\n\n/**\n * @title NumberMath\n * @notice Library for additional math functions that are not included in the OpenZeppelin libraries.\n */\nlibrary NumberMath {\n    error DivisionByZero();\n\n    /**\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Dividend\n     * @param b Divisor\n     * @return Resulting quotient\n     */\n    function divOut(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) revert DivisionByZero();\n        return Math.ceilDiv(a, b);\n    }\n\n    /**\n     * @notice Divides `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Dividend\n     * @param b Divisor\n     * @return Resulting quotient\n     */\n    function divOut(int256 a, int256 b) internal pure returns (int256) {\n        return sign(a) * sign(b) * int256(divOut(SignedMath.abs(a), SignedMath.abs(b)));\n    }\n\n    /**\n     * @notice Returns the sign of an int256\n     * @dev Returns: -1 for negative\n     *                0 for zero\n     *                1 for positive\n     * @param a int256 to find the sign of\n     * @return Sign of the int256\n     */\n    function sign(int256 a) internal pure returns (int256) {\n        if (a > 0) return 1;\n        if (a < 0) return -1;\n        return 0;\n    }\n}\n"
    },
    "@equilibria/root/number/types/Fixed18.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed6.sol\";\nimport \"./UFixed18.sol\";\n\n/// @dev Fixed18 type\ntype Fixed18 is int256;\nusing Fixed18Lib for Fixed18 global;\ntype Fixed18Storage is bytes32;\nusing Fixed18StorageLib for Fixed18Storage global;\n\n/**\n * @title Fixed18Lib\n * @notice Library for the signed fixed-decimal type.\n */\nlibrary Fixed18Lib {\n    error Fixed18OverflowError(uint256 value);\n\n    int256 private constant BASE = 1e18;\n    Fixed18 public constant ZERO = Fixed18.wrap(0);\n    Fixed18 public constant ONE = Fixed18.wrap(BASE);\n    Fixed18 public constant NEG_ONE = Fixed18.wrap(-1 * BASE);\n    Fixed18 public constant MAX = Fixed18.wrap(type(int256).max);\n    Fixed18 public constant MIN = Fixed18.wrap(type(int256).min);\n\n    /**\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\n     * @param a Unsigned fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(UFixed18 a) internal pure returns (Fixed18) {\n        uint256 value = UFixed18.unwrap(a);\n        if (value > uint256(type(int256).max)) revert Fixed18OverflowError(value);\n        return Fixed18.wrap(int256(value));\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\n     * @param s Sign\n     * @param m Unsigned fixed-decimal magnitude\n     * @return New signed fixed-decimal\n     */\n    function from(int256 s, UFixed18 m) internal pure returns (Fixed18) {\n        if (s > 0) return from(m);\n        if (s < 0) {\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\n            // which is the only value that would overflow when negated. Therefore,\n            // we can safely negate from(m) without checking for overflow.\n            unchecked { return Fixed18.wrap(-1 * Fixed18.unwrap(from(m))); }\n        }\n        return ZERO;\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a signed integer\n     * @param a Signed number\n     * @return New signed fixed-decimal\n     */\n    function from(int256 a) internal pure returns (Fixed18) {\n        return Fixed18.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\n     * @param a Base-6 signed fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(Fixed6 a) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed6.unwrap(a) * 1e12);\n    }\n\n    /**\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\n     * @param a Signed fixed-decimal\n     * @return Whether the signed fixed-decimal is zero.\n     */\n    function isZero(Fixed18 a) internal pure returns (bool) {\n        return Fixed18.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting summed signed fixed-decimal\n     */\n    function add(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) + Fixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts signed fixed-decimal `b` from `a`\n     * @param a Signed fixed-decimal to subtract from\n     * @param b Signed fixed-decimal to subtract\n     * @return Resulting subtracted signed fixed-decimal\n     */\n    function sub(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) - Fixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mul(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mulOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function div(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) * BASE / Fixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function divOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\n        return muldiv(a, Fixed18.wrap(b), Fixed18.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed18 a, int256 b, int256 c) internal pure returns (Fixed18) {\n        return muldivOut(a, Fixed18.wrap(b), Fixed18.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\n        return Fixed18.wrap(Fixed18.unwrap(a) * Fixed18.unwrap(b) / Fixed18.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed18 a, Fixed18 b, Fixed18 c) internal pure returns (Fixed18) {\n        return Fixed18.wrap(NumberMath.divOut(Fixed18.unwrap(a) * Fixed18.unwrap(b), Fixed18.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(Fixed18 a, Fixed18 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the signed fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(Fixed18 a, Fixed18 b) internal pure returns (uint256) {\n        (int256 au, int256 bu) = (Fixed18.unwrap(a), Fixed18.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\n     * @param a First signed number\n     * @param b Second signed number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(int256 a, int256 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(SignedMath.min(Fixed18.unwrap(a), Fixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(Fixed18 a, Fixed18 b) internal pure returns (Fixed18) {\n        return Fixed18.wrap(SignedMath.max(Fixed18.unwrap(a), Fixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\n     * @param a Signed fixed-decimal\n     * @return Truncated signed number\n     */\n    function truncate(Fixed18 a) internal pure returns (int256) {\n        return Fixed18.unwrap(a) / BASE;\n    }\n\n    /**\n     * @notice Returns the sign of the signed fixed-decimal\n     * @dev Returns: -1 for negative\n     *                0 for zero\n     *                1 for positive\n     * @param a Signed fixed-decimal\n     * @return Sign of the signed fixed-decimal\n     */\n    function sign(Fixed18 a) internal pure returns (int256) {\n        if (Fixed18.unwrap(a) > 0) return 1;\n        if (Fixed18.unwrap(a) < 0) return -1;\n        return 0;\n    }\n\n    /**\n     * @notice Returns the absolute value of the signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return Absolute value of the signed fixed-decimal\n     */\n    function abs(Fixed18 a) internal pure returns (UFixed18) {\n        return UFixed18.wrap(SignedMath.abs(Fixed18.unwrap(a)));\n    }\n}\n\nlibrary Fixed18StorageLib {\n    function read(Fixed18Storage self) internal view returns (Fixed18 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Fixed18Storage self, Fixed18 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/number/types/Fixed6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/SignedMath.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed18.sol\";\nimport \"./UFixed6.sol\";\n\n/// @dev Fixed6 type\ntype Fixed6 is int256;\nusing Fixed6Lib for Fixed6 global;\ntype Fixed6Storage is bytes32;\nusing Fixed6StorageLib for Fixed6Storage global;\n\n/**\n * @title Fixed6Lib\n * @notice Library for the signed fixed-decimal type.\n */\nlibrary Fixed6Lib {\n    error Fixed6OverflowError(uint256 value);\n\n    int256 private constant BASE = 1e6;\n    Fixed6 public constant ZERO = Fixed6.wrap(0);\n    Fixed6 public constant ONE = Fixed6.wrap(BASE);\n    Fixed6 public constant NEG_ONE = Fixed6.wrap(-1 * BASE);\n    Fixed6 public constant MAX = Fixed6.wrap(type(int256).max);\n    Fixed6 public constant MIN = Fixed6.wrap(type(int256).min);\n\n    /**\n     * @notice Creates a signed fixed-decimal from an unsigned fixed-decimal\n     * @param a Unsigned fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(UFixed6 a) internal pure returns (Fixed6) {\n        uint256 value = UFixed6.unwrap(a);\n        if (value > uint256(type(int256).max)) revert Fixed6OverflowError(value);\n        return Fixed6.wrap(int256(value));\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a sign and an unsigned fixed-decimal\n     * @param s Sign\n     * @param m Unsigned fixed-decimal magnitude\n     * @return New signed fixed-decimal\n     */\n    function from(int256 s, UFixed6 m) internal pure returns (Fixed6) {\n        if (s > 0) return from(m);\n        if (s < 0) {\n            // Since from(m) multiplies m by BASE, from(m) cannot be type(int256).min\n            // which is the only value that would overflow when negated. Therefore,\n            // we can safely negate from(m) without checking for overflow.\n            unchecked { return Fixed6.wrap(-1 * Fixed6.unwrap(from(m))); }\n        }\n        return ZERO;\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a signed integer\n     * @param a Signed number\n     * @return New signed fixed-decimal\n     */\n    function from(int256 a) internal pure returns (Fixed6) {\n        return Fixed6.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\n     * @param a Base-18 signed fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(Fixed18 a) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed18.unwrap(a) / 1e12);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-18 signed fixed-decimal\n     * @param a Base-18 signed fixed-decimal\n     * @param roundOut Whether to round the result away from zero if there is a remainder\n     * @return New signed fixed-decimal\n     */\n    function from(Fixed18 a, bool roundOut) internal pure returns (Fixed6) {\n        return roundOut ? Fixed6.wrap(NumberMath.divOut(Fixed18.unwrap(a), 1e12)): from(a);\n    }\n\n    /**\n     * @notice Returns whether the signed fixed-decimal is equal to zero.\n     * @param a Signed fixed-decimal\n     * @return Whether the signed fixed-decimal is zero.\n     */\n    function isZero(Fixed6 a) internal pure returns (bool) {\n        return Fixed6.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting summed signed fixed-decimal\n     */\n    function add(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) + Fixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts signed fixed-decimal `b` from `a`\n     * @param a Signed fixed-decimal to subtract from\n     * @param b Signed fixed-decimal to subtract\n     * @return Resulting subtracted signed fixed-decimal\n     */\n    function sub(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) - Fixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mul(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two signed fixed-decimals `a` and `b` together, rounding the result away from zero if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Resulting multiplied signed fixed-decimal\n     */\n    function mulOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function div(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) * BASE / Fixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Divides signed fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @param a Signed fixed-decimal to divide\n     * @param b Signed fixed-decimal to divide by\n     * @return Resulting divided signed fixed-decimal\n     */\n    function divOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(sign(a) * sign(b), a.abs().divOut(b.abs()));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result away from zero if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0`, `MAX` for `n/0`, and `MIN` for `-n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        if (isZero(b)) {\n            if (gt(a, ZERO)) return MAX;\n            if (lt(a, ZERO)) return MIN;\n            return ONE;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\n        return muldiv(a, Fixed6.wrap(b), Fixed6.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed number to multiply by\n     * @param c Signed number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed6 a, int256 b, int256 c) internal pure returns (Fixed6) {\n        return muldivOut(a, Fixed6.wrap(b), Fixed6.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\n        return Fixed6.wrap(Fixed6.unwrap(a) * Fixed6.unwrap(b) / Fixed6.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First signed fixed-decimal\n     * @param b Signed fixed-decimal to multiply by\n     * @param c Signed fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(Fixed6 a, Fixed6 b, Fixed6 c) internal pure returns (Fixed6) {\n        return Fixed6.wrap(NumberMath.divOut(Fixed6.unwrap(a) * Fixed6.unwrap(b), Fixed6.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is greater than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether signed fixed-decimal `a` is less than or equal to `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(Fixed6 a, Fixed6 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the signed fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(Fixed6 a, Fixed6 b) internal pure returns (uint256) {\n        (int256 au, int256 bu) = (Fixed6.unwrap(a), Fixed6.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a signed fixed-decimal representing the ratio of `a` over `b`\n     * @param a First signed number\n     * @param b Second signed number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(int256 a, int256 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(SignedMath.min(Fixed6.unwrap(a), Fixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of signed fixed-decimals `a` and `b`\n     * @param a First signed fixed-decimal\n     * @param b Second signed fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(Fixed6 a, Fixed6 b) internal pure returns (Fixed6) {\n        return Fixed6.wrap(SignedMath.max(Fixed6.unwrap(a), Fixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the signed fixed-decimal into an integer, truncating any decimal portion\n     * @param a Signed fixed-decimal\n     * @return Truncated signed number\n     */\n    function truncate(Fixed6 a) internal pure returns (int256) {\n        return Fixed6.unwrap(a) / BASE;\n    }\n\n    /**\n     * @notice Returns the sign of the signed fixed-decimal\n     * @dev Returns: -1 for negative\n     *                0 for zero\n     *                1 for positive\n     * @param a Signed fixed-decimal\n     * @return Sign of the signed fixed-decimal\n     */\n    function sign(Fixed6 a) internal pure returns (int256) {\n        if (Fixed6.unwrap(a) > 0) return 1;\n        if (Fixed6.unwrap(a) < 0) return -1;\n        return 0;\n    }\n\n    /**\n     * @notice Returns the absolute value of the signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return Absolute value of the signed fixed-decimal\n     */\n    function abs(Fixed6 a) internal pure returns (UFixed6) {\n        return UFixed6.wrap(SignedMath.abs(Fixed6.unwrap(a)));\n    }\n}\n\nlibrary Fixed6StorageLib {\n    function read(Fixed6Storage self) internal view returns (Fixed6 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Fixed6Storage self, Fixed6 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/number/types/UFixed18.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed18.sol\";\nimport \"./UFixed6.sol\";\n\n/// @dev UFixed18 type\ntype UFixed18 is uint256;\nusing UFixed18Lib for UFixed18 global;\ntype UFixed18Storage is bytes32;\nusing UFixed18StorageLib for UFixed18Storage global;\n\n/**\n * @title UFixed18Lib\n * @notice Library for the unsigned fixed-decimal type.\n */\nlibrary UFixed18Lib {\n    error UFixed18UnderflowError(int256 value);\n\n    uint256 private constant BASE = 1e18;\n    UFixed18 public constant ZERO = UFixed18.wrap(0);\n    UFixed18 public constant ONE = UFixed18.wrap(BASE);\n    UFixed18 public constant MAX = UFixed18.wrap(type(uint256).max);\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function from(Fixed18 a) internal pure returns (UFixed18) {\n        int256 value = Fixed18.unwrap(a);\n        if (value < 0) revert UFixed18UnderflowError(value);\n        return UFixed18.wrap(uint256(value));\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function unsafeFrom(Fixed18 a) internal pure returns (UFixed18) {\n        return a.lt(Fixed18Lib.ZERO) ? ZERO : from(a);\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\n     * @param a Unsigned number\n     * @return New unsigned fixed-decimal\n     */\n    function from(uint256 a) internal pure returns (UFixed18) {\n        return UFixed18.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates a signed fixed-decimal from a base-6 signed fixed-decimal\n     * @param a Base-6 signed fixed-decimal\n     * @return New signed fixed-decimal\n     */\n    function from(UFixed6 a) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed6.unwrap(a) * 1e12);\n    }\n\n    /**\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\n     * @param a Unsigned fixed-decimal\n     * @return Whether the unsigned fixed-decimal is zero.\n     */\n    function isZero(UFixed18 a) internal pure returns (bool) {\n        return UFixed18.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting summed unsigned fixed-decimal\n     */\n    function add(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) + UFixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function sub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) - UFixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function unsafeSub(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return gt(b, a) ? ZERO : sub(a, b);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mul(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mulOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function div(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) * BASE / UFixed18.unwrap(b));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function divOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * BASE, UFixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\n        return muldiv(a, UFixed18.wrap(b), UFixed18.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed18 a, uint256 b, uint256 c) internal pure returns (UFixed18) {\n        return muldivOut(a, UFixed18.wrap(b), UFixed18.wrap(c));\n    }\n\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\n        return UFixed18.wrap(UFixed18.unwrap(a) * UFixed18.unwrap(b) / UFixed18.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed18 a, UFixed18 b, UFixed18 c) internal pure returns (UFixed18) {\n        return UFixed18.wrap(NumberMath.divOut(UFixed18.unwrap(a) * UFixed18.unwrap(b), UFixed18.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(UFixed18 a, UFixed18 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(UFixed18 a, UFixed18 b) internal pure returns (uint256) {\n        (uint256 au, uint256 bu) = (UFixed18.unwrap(a), UFixed18.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\n     * @param a First unsigned number\n     * @param b Second unsigned number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(Math.min(UFixed18.unwrap(a), UFixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(UFixed18 a, UFixed18 b) internal pure returns (UFixed18) {\n        return UFixed18.wrap(Math.max(UFixed18.unwrap(a), UFixed18.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\n     * @param a Unsigned fixed-decimal\n     * @return Truncated unsigned number\n     */\n    function truncate(UFixed18 a) internal pure returns (uint256) {\n        return UFixed18.unwrap(a) / BASE;\n    }\n}\n\nlibrary UFixed18StorageLib {\n    function read(UFixed18Storage self) internal view returns (UFixed18 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(UFixed18Storage self, UFixed18 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/number/types/UFixed6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../NumberMath.sol\";\nimport \"./Fixed6.sol\";\nimport \"./UFixed18.sol\";\n\n/// @dev UFixed6 type\ntype UFixed6 is uint256;\nusing UFixed6Lib for UFixed6 global;\ntype UFixed6Storage is bytes32;\nusing UFixed6StorageLib for UFixed6Storage global;\n\n/**\n * @title UFixed6Lib\n * @notice Library for the unsigned fixed-decimal type.\n */\nlibrary UFixed6Lib {\n    error UFixed6UnderflowError(int256 value);\n\n    uint256 private constant BASE = 1e6;\n    UFixed6 public constant ZERO = UFixed6.wrap(0);\n    UFixed6 public constant ONE = UFixed6.wrap(BASE);\n    UFixed6 public constant MAX = UFixed6.wrap(type(uint256).max);\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function from(Fixed6 a) internal pure returns (UFixed6) {\n        int256 value = Fixed6.unwrap(a);\n        if (value < 0) revert UFixed6UnderflowError(value);\n        return UFixed6.wrap(uint256(value));\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a signed fixed-decimal\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Signed fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function unsafeFrom(Fixed6 a) internal pure returns (UFixed6) {\n        return a.lt(Fixed6Lib.ZERO) ? ZERO : from(a);\n    }\n\n    /**\n     * @notice Creates a unsigned fixed-decimal from a unsigned integer\n     * @param a Unsigned number\n     * @return New unsigned fixed-decimal\n     */\n    function from(uint256 a) internal pure returns (UFixed6) {\n        return UFixed6.wrap(a * BASE);\n    }\n\n    /**\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\n     * @param a Base-18 unsigned fixed-decimal\n     * @return New unsigned fixed-decimal\n     */\n    function from(UFixed18 a) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed18.unwrap(a) / 1e12);\n    }\n\n    /**\n     * @notice Creates an unsigned fixed-decimal from a base-18 unsigned fixed-decimal\n     * @param a Base-18 unsigned fixed-decimal\n     * @param roundOut Whether to round the result away from zero if there is a remainder\n     * @return New unsigned fixed-decimal\n     */\n    function from(UFixed18 a, bool roundOut) internal pure returns (UFixed6) {\n        return roundOut ? UFixed6.wrap(NumberMath.divOut(UFixed18.unwrap(a), 1e12)): from(a);\n    }\n\n    /**\n     * @notice Returns whether the unsigned fixed-decimal is equal to zero.\n     * @param a Unsigned fixed-decimal\n     * @return Whether the unsigned fixed-decimal is zero.\n     */\n    function isZero(UFixed6 a) internal pure returns (bool) {\n        return UFixed6.unwrap(a) == 0;\n    }\n\n    /**\n     * @notice Adds two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting summed unsigned fixed-decimal\n     */\n    function add(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) + UFixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `b` from `a`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function sub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) - UFixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Subtracts unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on underflow, instead returns `ZERO`\n     * @param a Unsigned fixed-decimal to subtract from\n     * @param b Unsigned fixed-decimal to subtract\n     * @return Resulting subtracted unsigned fixed-decimal\n     */\n    function unsafeSub(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return gt(b, a) ? ZERO : sub(a, b);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mul(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / BASE);\n    }\n\n    /**\n     * @notice Multiplies two unsigned fixed-decimals `a` and `b` together, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Resulting multiplied unsigned fixed-decimal\n     */\n    function mulOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), BASE));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function div(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) * BASE / UFixed6.unwrap(b));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function divOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * BASE, UFixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDiv(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return div(a, b);\n        }\n    }\n\n    /**\n     * @notice Divides unsigned fixed-decimal `a` by `b`, rounding the result up to the next integer if there is a remainder\n     * @dev Does not revert on divide-by-0, instead returns `ONE` for `0/0` and `MAX` for `n/0`.\n     * @param a Unsigned fixed-decimal to divide\n     * @param b Unsigned fixed-decimal to divide by\n     * @return Resulting divided unsigned fixed-decimal\n     */\n    function unsafeDivOut(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        if (isZero(b)) {\n            return isZero(a) ? ONE : MAX;\n        } else {\n            return divOut(a, b);\n        }\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\n        return muldiv(a, UFixed6.wrap(b), UFixed6.wrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned number to multiply by\n     * @param c Unsigned number to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed6 a, uint256 b, uint256 c) internal pure returns (UFixed6) {\n        return muldivOut(a, UFixed6.wrap(b), UFixed6.wrap(c));\n    }\n\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldiv(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\n        return UFixed6.wrap(UFixed6.unwrap(a) * UFixed6.unwrap(b) / UFixed6.unwrap(c));\n    }\n\n    /**\n     * @notice Computes a * b / c without loss of precision due to BASE conversion, rounding the result up to the next integer if there is a remainder\n     * @param a First unsigned fixed-decimal\n     * @param b Unsigned fixed-decimal to multiply by\n     * @param c Unsigned fixed-decimal to divide by\n     * @return Resulting computation\n     */\n    function muldivOut(UFixed6 a, UFixed6 b, UFixed6 c) internal pure returns (UFixed6) {\n        return UFixed6.wrap(NumberMath.divOut(UFixed6.unwrap(a) * UFixed6.unwrap(b), UFixed6.unwrap(c)));\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is equal to `b`\n     */\n    function eq(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 1;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than `b`\n     */\n    function gt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 2;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than `b`\n     */\n    function lt(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return compare(a, b) == 0;\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is greater than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is greater than or equal to `b`\n     */\n    function gte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return gt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Returns whether unsigned fixed-decimal `a` is less than or equal to `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Whether `a` is less than or equal to `b`\n     */\n    function lte(UFixed6 a, UFixed6 b) internal pure returns (bool) {\n        return lt(a, b) || eq(a, b);\n    }\n\n    /**\n     * @notice Compares the unsigned fixed-decimals `a` and `b`\n     * @dev Returns: 2 for greater than\n     *               1 for equal to\n     *               0 for less than\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Compare result of `a` and `b`\n     */\n    function compare(UFixed6 a, UFixed6 b) internal pure returns (uint256) {\n        (uint256 au, uint256 bu) = (UFixed6.unwrap(a), UFixed6.unwrap(b));\n        if (au > bu) return 2;\n        if (au < bu) return 0;\n        return 1;\n    }\n\n    /**\n     * @notice Returns a unsigned fixed-decimal representing the ratio of `a` over `b`\n     * @param a First unsigned number\n     * @param b Second unsigned number\n     * @return Ratio of `a` over `b`\n     */\n    function ratio(uint256 a, uint256 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(a * BASE / b);\n    }\n\n    /**\n     * @notice Returns the minimum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Minimum of `a` and `b`\n     */\n    function min(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(Math.min(UFixed6.unwrap(a), UFixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Returns the maximum of unsigned fixed-decimals `a` and `b`\n     * @param a First unsigned fixed-decimal\n     * @param b Second unsigned fixed-decimal\n     * @return Maximum of `a` and `b`\n     */\n    function max(UFixed6 a, UFixed6 b) internal pure returns (UFixed6) {\n        return UFixed6.wrap(Math.max(UFixed6.unwrap(a), UFixed6.unwrap(b)));\n    }\n\n    /**\n     * @notice Converts the unsigned fixed-decimal into an integer, truncating any decimal portion\n     * @param a Unsigned fixed-decimal\n     * @return Truncated unsigned number\n     */\n    function truncate(UFixed6 a) internal pure returns (uint256) {\n        return UFixed6.unwrap(a) / BASE;\n    }\n}\n\nlibrary UFixed6StorageLib {\n    function read(UFixed6Storage self) internal view returns (UFixed6 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(UFixed6Storage self, UFixed6 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/pid/types/PAccumulator6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\nimport \"./PController6.sol\";\n\n/// @dev PAccumulator6 type\nstruct PAccumulator6 {\n    Fixed6 _value;\n    Fixed6 _skew;\n}\nusing PAccumulator6Lib for PAccumulator6 global;\n\n/// @title PAccumulator6Lib\n/// @notice Accumulator for a the fixed 6-decimal PID controller. This holds the \"last seen state\" of the PID controller\n///         and works in conjunction with the PController6 to compute the current rate.\n/// @dev This implementation is specifically a P controller, with I_k and D_k both set to 0. In between updates, it\n///      continues to accumulate at a linear rate based on the previous skew, but the rate is capped at the max value.\n///      Once the rate hits the max value, it will continue to accumulate at the max value until the next update.\nlibrary PAccumulator6Lib {\n    /// @notice Accumulates the rate against notional given the prior and current state\n    /// @param self The controller accumulator\n    /// @param controller The controller configuration\n    /// @param skew The current skew\n    /// @param fromTimestamp The timestamp of the prior accumulation\n    /// @param toTimestamp The current timestamp\n    /// @param notional The notional to accumulate against\n    /// @return accumulated The total accumulated amount\n    function accumulate(\n        PAccumulator6 memory self,\n        PController6 memory controller,\n        Fixed6 skew,\n        uint256 fromTimestamp,\n        uint256 toTimestamp,\n        UFixed6 notional\n    ) internal pure returns (Fixed6 accumulated) {\n        // compute new value and intercept\n        (Fixed6 newValue, UFixed6 interceptTimestamp) =\n            controller.compute(self._value, self._skew, fromTimestamp, toTimestamp);\n\n        // accumulate rate within max\n        accumulated = _accumulate(\n            self._value.add(newValue),\n            UFixed6Lib.from(fromTimestamp),\n            interceptTimestamp,\n            notional\n        ).div(Fixed6Lib.from(2)); // rate = self._value + newValue / 2 -> divide here for added precision\n\n        // accumulate rate outside of max\n        accumulated = _accumulate(\n            newValue,\n            interceptTimestamp,\n            UFixed6Lib.from(toTimestamp),\n            notional\n        ).add(accumulated);\n\n        // update values\n        self._value = newValue;\n        self._skew = skew;\n    }\n\n    /// @notice Helper function to accumulate a singular rate against notional\n    /// @param rate The rate to accumulate\n    /// @param fromTimestamp The timestamp to accumulate from\n    /// @param toTimestamp The timestamp to accumulate to\n    /// @param notional The notional to accumulate against\n    /// @return The accumulated amount\n    function _accumulate(\n        Fixed6 rate,\n        UFixed6 fromTimestamp,\n        UFixed6 toTimestamp,\n        UFixed6 notional\n    ) private pure returns (Fixed6) {\n        return rate\n            .mul(Fixed6Lib.from(toTimestamp.sub(fromTimestamp)))\n            .mul(Fixed6Lib.from(notional))\n            .div(Fixed6Lib.from(365 days));\n    }\n}\n"
    },
    "@equilibria/root/pid/types/PController6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../../number/types/Fixed6.sol\";\n\n/// @dev PController6 type\nstruct PController6 {\n    UFixed6 k;\n    Fixed6 min;\n    Fixed6 max;\n}\nusing PController6Lib for PController6 global;\n\n/// @title PController6Lib\n/// @notice Configuration for a the fixed 6-decimal PID controller.\n/// @dev Each second, the PID controller's value is incremented by `skew / k`, with `max` as the maximum value.\nlibrary PController6Lib {\n    /// @notice compute the new value and intercept timestamp based on the prior controller state\n    /// @dev `interceptTimestamp` will never exceed `toTimestamp`\n    /// @param self the controller configuration\n    /// @param value the prior value\n    /// @param skew The prior skew\n    /// @param fromTimestamp The prior timestamp\n    /// @param toTimestamp The current timestamp\n    /// @return newValue the new value\n    /// @return interceptTimestamp the timestamp at which the value will be at the max\n    function compute(\n        PController6 memory self,\n        Fixed6 value,\n        Fixed6 skew,\n        uint256 fromTimestamp,\n        uint256 toTimestamp\n    ) internal pure returns (Fixed6 newValue, UFixed6 interceptTimestamp) {\n        // compute the new value without considering the max\n        Fixed6 newValueUncapped = value.add(\n            Fixed6Lib.from(int256(toTimestamp - fromTimestamp))\n                .mul(skew)\n                .div(Fixed6Lib.from(self.k))\n        );\n\n        // cap the new value between min and max\n        newValue = newValueUncapped.min(self.max).max(self.min);\n\n        // compute distance and range to the resultant value\n        (UFixed6 distance, Fixed6 range) = (UFixed6Lib.from(toTimestamp - fromTimestamp), newValueUncapped.sub(value));\n\n        // compute the amount of buffer until the value is outside the max\n        UFixed6 buffer = value.gt(self.max) || value.lt(self.min) ?\n            UFixed6Lib.ZERO :\n            (range.sign() > 0 ? self.max : self.min).sub(value).abs();\n\n        // compute the timestamp at which the value will be at the max\n        interceptTimestamp = range.isZero() ?\n            UFixed6Lib.from(toTimestamp) :\n            UFixed6Lib.from(fromTimestamp).add(distance.muldiv(buffer, range.abs())).min(UFixed6Lib.from(toTimestamp));\n    }\n}\n"
    },
    "@equilibria/root/storage/Storage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../number/types/UFixed18.sol\";\n\n/// @dev Stored boolean slot\ntype BoolStorage is bytes32;\nusing BoolStorageLib for BoolStorage global;\n\n/// @dev Stored uint256 slot\ntype Uint256Storage is bytes32;\nusing Uint256StorageLib for Uint256Storage global;\n\n/// @dev Stored int256 slot\ntype Int256Storage is bytes32;\nusing Int256StorageLib for Int256Storage global;\n\n/// @dev Stored address slot\ntype AddressStorage is bytes32;\nusing AddressStorageLib for AddressStorage global;\n\n/// @dev Stored bytes32 slot\ntype Bytes32Storage is bytes32;\nusing Bytes32StorageLib for Bytes32Storage global;\n\n/**\n * @title BoolStorageLib\n * @notice Library to manage storage and retrieval of a boolean at a fixed storage slot\n */\nlibrary BoolStorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored bool value\n     */\n    function read(BoolStorage self) internal view returns (bool value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value boolean value to store\n     */\n    function store(BoolStorage self, bool value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title Uint256StorageLib\n * @notice Library to manage storage and retrieval of an uint256 at a fixed storage slot\n */\nlibrary Uint256StorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored uint256 value\n     */\n    function read(Uint256Storage self) internal view returns (uint256 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value uint256 value to store\n     */\n    function store(Uint256Storage self, uint256 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title Int256StorageLib\n * @notice Library to manage storage and retrieval of an int256 at a fixed storage slot\n */\nlibrary Int256StorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored int256 value\n     */\n    function read(Int256Storage self) internal view returns (int256 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value int256 value to store\n     */\n    function store(Int256Storage self, int256 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title AddressStorageLib\n * @notice Library to manage storage and retrieval of an address at a fixed storage slot\n */\nlibrary AddressStorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored address value\n     */\n    function read(AddressStorage self) internal view returns (address value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value address value to store\n     */\n    function store(AddressStorage self, address value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n\n/**\n * @title Bytes32StorageLib\n * @notice Library to manage storage and retrieval of a bytes32 at a fixed storage slot\n */\nlibrary Bytes32StorageLib {\n    /**\n     * @notice Retrieves the stored value\n     * @param self Storage slot\n     * @return value Stored bytes32 value\n     */\n    function read(Bytes32Storage self) internal view returns (bytes32 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    /**\n     * @notice Stores the value at the specific slot\n     * @param self Storage slot\n     * @param value bytes32 value to store\n     */\n    function store(Bytes32Storage self, bytes32 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/token/types/Token18.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"../../number/types/UFixed18.sol\";\n\n/// @dev Token18\ntype Token18 is address;\nusing Token18Lib for Token18 global;\ntype Token18Storage is bytes32;\nusing Token18StorageLib for Token18Storage global;\n\n/**\n * @title Token18Lib\n * @notice Library to manage 18-decimal ERC20s that is compliant with the fixed-decimal types.\n * @dev Maintains significant gas savings over other Token implementations since no conversion take place\n */\nlibrary Token18Lib {\n    using SafeERC20 for IERC20;\n\n    Token18 public constant ZERO = Token18.wrap(address(0));\n\n    /**\n     * @notice Returns whether a token is the zero address\n     * @param self Token to check for\n     * @return Whether the token is the zero address\n     */\n    function isZero(Token18 self) internal pure returns (bool) {\n        return Token18.unwrap(self) == Token18.unwrap(ZERO);\n    }\n\n    /**\n     * @notice Returns whether the two tokens are equal\n     * @param a First token to compare\n     * @param b Second token to compare\n     * @return Whether the two tokens are equal\n     */\n    function eq(Token18 a, Token18 b) internal pure returns (bool) {\n        return Token18.unwrap(a) ==  Token18.unwrap(b);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend infinite tokens from the caller\n     * @dev Uses `approve` rather than `safeApprove` since the race condition\n     *      in safeApprove does not apply when going to an infinite approval\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     */\n    function approve(Token18 self, address grantee) internal {\n        IERC20(Token18.unwrap(self)).approve(grantee, type(uint256).max);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend `amount` tokens from the caller\n     * @dev There are important race conditions to be aware of when using this function\n            with values other than 0. This will revert if moving from non-zero to non-zero amounts\n            See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a55b7d13722e7ce850b626da2313f3e66ca1d101/contracts/token/ERC20/IERC20.sol#L57\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     * @param amount Amount of tokens to approve to spend\n     */\n    function approve(Token18 self, address grantee, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeApprove(grantee, UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers all held tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to receive the tokens\n     */\n    function push(Token18 self, address recipient) internal {\n        push(self, recipient, balanceOf(self, address(this)));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function push(Token18 self, address recipient, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeTransfer(recipient, UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to the caller\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param amount Amount of tokens to transfer\n     */\n    function pull(Token18 self, address benefactor, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, address(this), UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function pullTo(Token18 self, address benefactor, address recipient, UFixed18 amount) internal {\n        IERC20(Token18.unwrap(self)).safeTransferFrom(benefactor, recipient, UFixed18.unwrap(amount));\n    }\n\n    /**\n     * @notice Returns the name of the token\n     * @param self Token to check for\n     * @return Token name\n     */\n    function name(Token18 self) internal view returns (string memory) {\n        return IERC20Metadata(Token18.unwrap(self)).name();\n    }\n\n    /**\n     * @notice Returns the symbol of the token\n     * @param self Token to check for\n     * @return Token symbol\n     */\n    function symbol(Token18 self) internal view returns (string memory) {\n        return IERC20Metadata(Token18.unwrap(self)).symbol();\n    }\n\n    /**\n     * @notice Returns the `self` token balance of the caller\n     * @param self Token to check for\n     * @return Token balance of the caller\n     */\n    function balanceOf(Token18 self) internal view returns (UFixed18) {\n        return balanceOf(self, address(this));\n    }\n\n    /**\n     * @notice Returns the `self` token balance of `account`\n     * @param self Token to check for\n     * @param account Account to check\n     * @return Token balance of the account\n     */\n    function balanceOf(Token18 self, address account) internal view returns (UFixed18) {\n        return UFixed18.wrap(IERC20(Token18.unwrap(self)).balanceOf(account));\n    }\n\n    /**\n     * @notice Returns the `self` total supply\n     * @param self Token to check for\n     * @return The total supply of the token\n     */\n    function totalSupply(Token18 self) internal view returns (UFixed18) {\n        return UFixed18.wrap(IERC20(Token18.unwrap(self)).totalSupply());\n    }\n}\n\nlibrary Token18StorageLib {\n    function read(Token18Storage self) internal view returns (Token18 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Token18Storage self, Token18 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/token/types/Token6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../number/types/UFixed6.sol\";\n\n/// @dev Token6\ntype Token6 is address;\nusing Token6Lib for Token6 global;\ntype Token6Storage is bytes32;\nusing Token6StorageLib for Token6Storage global;\n\n/**\n * @title Token6Lib\n * @notice Library to manage 6-decimal ERC20s that is compliant with the fixed-decimal types.\n */\nlibrary Token6Lib {\n    using SafeERC20 for IERC20;\n\n    Token6 public constant ZERO = Token6.wrap(address(0));\n\n    /**\n     * @notice Returns whether a token is the zero address\n     * @param self Token to check for\n     * @return Whether the token is the zero address\n     */\n    function isZero(Token6 self) internal pure returns (bool) {\n        return Token6.unwrap(self) == Token6.unwrap(ZERO);\n    }\n\n    /**\n     * @notice Returns whether the two tokens are equal\n     * @param a First token to compare\n     * @param b Second token to compare\n     * @return Whether the two tokens are equal\n     */\n    function eq(Token6 a, Token6 b) internal pure returns (bool) {\n        return Token6.unwrap(a) ==  Token6.unwrap(b);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend infinite tokens from the caller\n     * @dev Uses `approve` rather than `safeApprove` since the race condition\n     *      in safeApprove does not apply when going to an infinite approval\n     * @param self Token to grant approval\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     */\n    function approve(Token6 self, address grantee) internal {\n        IERC20(Token6.unwrap(self)).approve(grantee, type(uint256).max);\n    }\n\n    /**\n     * @notice Approves `grantee` to spend `amount` tokens from the caller\n     * @dev There are important race conditions to be aware of when using this function\n            with values other than 0. This will revert if moving from non-zero to non-zero amounts\n            See https://github.com/OpenZeppelin/openzeppelin-contracts/blob/a55b7d13722e7ce850b626da2313f3e66ca1d101/contracts/token/ERC20/IERC20.sol#L57\n     * @param self Token to grant approval\n     * @param self Token to grant approval\n     * @param grantee Address to allow spending\n     * @param amount Amount of tokens to approve to spend\n     */\n    function approve(Token6 self, address grantee, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeApprove(grantee, UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers all held tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to receive the tokens\n     */\n    function push(Token6 self, address recipient) internal {\n        push(self, recipient, balanceOf(self, address(this)));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the caller to the `recipient`\n     * @param self Token to transfer\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function push(Token6 self, address recipient, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeTransfer(recipient, UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to the caller\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param amount Amount of tokens to transfer\n     */\n    function pull(Token6 self, address benefactor, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeTransferFrom(benefactor, address(this), UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Transfers `amount` tokens from the `benefactor` to `recipient`\n     * @dev Reverts if trying to pull Ether\n     * @param self Token to transfer\n     * @param benefactor Address to transfer tokens from\n     * @param recipient Address to transfer tokens to\n     * @param amount Amount of tokens to transfer\n     */\n    function pullTo(Token6 self, address benefactor, address recipient, UFixed6 amount) internal {\n        IERC20(Token6.unwrap(self)).safeTransferFrom(benefactor, recipient, UFixed6.unwrap(amount));\n    }\n\n    /**\n     * @notice Returns the name of the token\n     * @param self Token to check for\n     * @return Token name\n     */\n    function name(Token6 self) internal view returns (string memory) {\n        return IERC20Metadata(Token6.unwrap(self)).name();\n    }\n\n    /**\n     * @notice Returns the symbol of the token\n     * @param self Token to check for\n     * @return Token symbol\n     */\n    function symbol(Token6 self) internal view returns (string memory) {\n        return IERC20Metadata(Token6.unwrap(self)).symbol();\n    }\n\n    /**\n     * @notice Returns the `self` token balance of the caller\n     * @param self Token to check for\n     * @return Token balance of the caller\n     */\n    function balanceOf(Token6 self) internal view returns (UFixed6) {\n        return balanceOf(self, address(this));\n    }\n\n    /**\n     * @notice Returns the `self` token balance of `account`\n     * @param self Token to check for\n     * @param account Account to check\n     * @return Token balance of the account\n     */\n    function balanceOf(Token6 self, address account) internal view returns (UFixed6) {\n        return UFixed6.wrap(IERC20(Token6.unwrap(self)).balanceOf(account));\n    }\n\n    /**\n     * @notice Returns the `self` total supply\n     * @param self Token to check for\n     * @return The total supply of the token\n     */\n    function totalSupply(Token6 self) internal view returns (UFixed6) {\n        return UFixed6.wrap(IERC20(Token6.unwrap(self)).totalSupply());\n    }\n}\n\nlibrary Token6StorageLib {\n    function read(Token6Storage self) internal view returns (Token6 value) {\n        assembly (\"memory-safe\") {\n            value := sload(self)\n        }\n    }\n\n    function store(Token6Storage self, Token6 value) internal {\n        assembly (\"memory-safe\") {\n            sstore(self, value)\n        }\n    }\n}\n"
    },
    "@equilibria/root/utilization/CurveMath6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../number/types/UFixed6.sol\";\nimport \"../number/types/Fixed6.sol\";\n\n/**\n * @title CurveMath6\n * @notice Library for managing math operations for utilization curves.\n */\nlibrary CurveMath6 {\n    error CurveMath6OutOfBoundsError();\n\n    /**\n     * @notice Computes a linear interpolation between two points\n     * @param startX First point's x-coordinate\n     * @param startY First point's y-coordinate\n     * @param endX Second point's x-coordinate\n     * @param endY Second point's y-coordinate\n     * @param targetX x-coordinate to interpolate\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\n     */\n    function linearInterpolation(\n        UFixed6 startX,\n        Fixed6 startY,\n        UFixed6 endX,\n        Fixed6 endY,\n        UFixed6 targetX\n    ) internal pure returns (Fixed6) {\n        if (targetX.lt(startX) || targetX.gt(endX)) revert CurveMath6OutOfBoundsError();\n\n        UFixed6 xRange = endX.sub(startX);\n        Fixed6 yRange = endY.sub(startY);\n        UFixed6 xRatio = targetX.sub(startX).div(xRange);\n        return yRange.mul(Fixed6Lib.from(xRatio)).add(startY);\n    }\n\n    /**\n     * @notice Computes a linear interpolation between two points\n     * @param startX First point's x-coordinate\n     * @param startY First point's y-coordinate\n     * @param endX Second point's x-coordinate\n     * @param endY Second point's y-coordinate\n     * @param targetX x-coordinate to interpolate\n     * @return y-coordinate for `targetX` along the line from (`startX`, `startY`) -> (`endX`, `endY`)\n     */\n    function linearInterpolation(\n        UFixed6 startX,\n        UFixed6 startY,\n        UFixed6 endX,\n        UFixed6 endY,\n        UFixed6 targetX\n    ) internal pure returns (UFixed6) {\n        return UFixed6Lib.from(linearInterpolation(startX, Fixed6Lib.from(startY), endX, Fixed6Lib.from(endY), targetX));\n    }\n}\n"
    },
    "@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport \"../CurveMath6.sol\";\nimport \"../../number/types/UFixed6.sol\";\n\n/// @dev UJumpRateUtilizationCurve6 type\nstruct UJumpRateUtilizationCurve6 {\n    UFixed6 minRate;\n    UFixed6 maxRate;\n    UFixed6 targetRate;\n    UFixed6 targetUtilization;\n}\nusing UJumpRateUtilizationCurve6Lib for UJumpRateUtilizationCurve6 global;\n\n/**\n * @title UJumpRateUtilizationCurve6Lib\n * @notice Library for the unsigned base-6 Jump Rate utilization curve type\n */\nlibrary UJumpRateUtilizationCurve6Lib {\n    /**\n     * @notice Computes the corresponding rate for a utilization ratio\n     * @param utilization The utilization ratio\n     * @return The corresponding rate\n     */\n    function compute(UJumpRateUtilizationCurve6 memory self, UFixed6 utilization) internal pure returns (UFixed6) {\n        if (utilization.lt(self.targetUtilization)) {\n            return CurveMath6.linearInterpolation(\n                UFixed6Lib.ZERO,\n                self.minRate,\n                self.targetUtilization,\n                self.targetRate,\n                utilization\n            );\n        }\n        if (utilization.lt(UFixed6Lib.ONE)) {\n            return CurveMath6.linearInterpolation(\n                self.targetUtilization,\n                self.targetRate,\n                UFixed6Lib.ONE,\n                self.maxRate,\n                utilization\n            );\n        }\n        return self.maxRate;\n    }\n\n    function accumulate(\n        UJumpRateUtilizationCurve6 memory self,\n        UFixed6 utilization,\n        uint256 fromTimestamp,\n        uint256 toTimestamp,\n        UFixed6 notional\n    ) internal pure returns (UFixed6) {\n        return compute(self, utilization)\n            .mul(UFixed6Lib.from(toTimestamp - fromTimestamp))\n            .mul(notional)\n            .div(UFixed6Lib.from(365 days));\n    }\n}\n"
    },
    "@equilibria/root/verifier/interfaces/IVerifierBase.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common } from \"../types/Common.sol\";\nimport { GroupCancellation } from \"../types/GroupCancellation.sol\";\n\ninterface IVerifierBase {\n    // sig: 0xfec563a0\n    /// @custom:error Signer is trying to cancel a nonce for another user\n    error VerifierInvalidSignerError();\n    // sig: 0xa568ee00\n    /// @custom:error Message was meant for another protocol, version, or chain\n    error VerifierInvalidDomainError();\n    // sig: 0xb09262f6\n    /// @custom:error Signature length was unexpected\n    error VerifierInvalidSignatureError();\n    // sig: 0xe6784f14\n    /// @custom:error Nonce has already been used\n    error VerifierInvalidNonceError();\n    // sig: 0x79998279\n    /// @custom:error Group nonce has already been used\n    error VerifierInvalidGroupError();\n    // sig: 0x27661908\n    /// @custom:error Block timestamp has exceeded user-assigned expiration\n    error VerifierInvalidExpiryError();\n\n    /// @notice Emitted when a nonce is cancelled\n    event NonceCancelled(address indexed account, uint256 nonce);\n    /// @notice Emitted when a group nonce is cancelled\n    event GroupCancelled(address indexed account, uint256 group);\n\n    /// @notice Returns whether the nonce has been cancelled\n    /// @param account The account to check the nonce for\n    /// @param nonce The nonce to check\n    /// @return True if the nonce has been cancelled\n    function nonces(address account, uint256 nonce) external view returns (bool);\n\n    /// @notice Returns whether the group nonce has been cancelled\n    /// @param account The account to check the group nonce for\n    /// @param nonce The group nonce to check\n    /// @return True if the group nonce has been cancelled\n    function groups(address account, uint256 nonce) external view returns (bool);\n\n    /// @notice Verifies the signature of no-op common message\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param common The common data of the message\n    /// @param signature The signature of the account for the message\n    function verifyCommon(Common calldata common, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a group cancellation type\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param groupCancellation The group cancellation to verify\n    /// @param signature The signature of the account for the group cancellation\n    function verifyGroupCancellation(GroupCancellation calldata groupCancellation, bytes calldata signature) external;\n\n    /// @notice Cancels a nonce\n    /// @param nonce The nonce to cancel\n    function cancelNonce(uint256 nonce) external;\n\n    /// @notice Cancels a nonce for an account via a signed message\n    /// @dev Process a no-op message that will invalidate the specified nonce\n    /// @param common The common data of the message\n    /// @param signature The signature of the account for the message\n    function cancelNonceWithSignature(Common calldata common, bytes calldata signature) external;\n\n    /// @notice Cancels a group nonce\n    /// @param group The group nonce to cancel\n    function cancelGroup(uint256 group) external;\n\n    /// @notice Cancels a group for an account via a signed message\n    /// @param groupCancellation The group cancellation message\n    /// @param signature The signature of the account for the group cancellation\n    function cancelGroupWithSignature(GroupCancellation calldata groupCancellation, bytes calldata signature) external;\n}\n"
    },
    "@equilibria/root/verifier/types/Common.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\n/// @notice Fields which need to be hashed in any EIP712 action\nstruct Common {\n    /// @dev The target account of the message (usually the account on behalf of which the action is being performed)\n    address account;\n    /// @dev EOA signing the message (usually either the account or a delegate of the account)\n    address signer;\n    /// @dev ensures the message is unique to a particular protocol version, chain, and verifier\n    address domain;\n    /// @dev per-sender nonce which is automatically cancelled upon validation\n    uint256 nonce;\n    /// @dev per-sender nonce which must be manually cancelled with a GroupCancellation message\n    uint256 group;\n    /// @dev prevents this message from having the intended effect after a specified timestamp\n    uint256 expiry;\n}\nusing CommonLib for Common global;\n\n/// @title CommonLib\n/// @notice Library collecting fields which need to be hashed in any EIP712 message\nlibrary CommonLib {\n    /// @dev used to verify a signed message\n    bytes32 constant public STRUCT_HASH =\n        keccak256(\"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\");\n\n    /// @dev used to create a signed message\n    function hash(Common memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.account, self.signer, self.domain, self.nonce, self.group, self.expiry));\n    }\n}\n"
    },
    "@equilibria/root/verifier/types/GroupCancellation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common, CommonLib } from \"./Common.sol\";\n\nstruct GroupCancellation {\n    /// @dev The group to cancel\n    uint256 group;\n\n    /// @dev The common information for EIP712 actions\n    Common common;\n}\nusing GroupCancellationLib for GroupCancellation global;\n\n/// @title GroupCancellationLib\n/// @notice Library used to hash and verify action to cancel a group nonce.\nlibrary GroupCancellationLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"GroupCancellation(uint256 group,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    function hash(GroupCancellation memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.group, CommonLib.hash(self.common)));\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Create2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Create2.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Helper to make usage of the `CREATE2` EVM opcode easier and safer.\n * `CREATE2` can be used to compute in advance the address where a smart\n * contract will be deployed, which allows for interesting new mechanisms known\n * as 'counterfactual interactions'.\n *\n * See the https://eips.ethereum.org/EIPS/eip-1014#motivation[EIP] for more\n * information.\n */\nlibrary Create2 {\n    /**\n     * @dev Deploys a contract using `CREATE2`. The address where the contract\n     * will be deployed can be known in advance via {computeAddress}.\n     *\n     * The bytecode for a contract can be obtained from Solidity with\n     * `type(contractName).creationCode`.\n     *\n     * Requirements:\n     *\n     * - `bytecode` must not be empty.\n     * - `salt` must have not been used for `bytecode` already.\n     * - the factory must have a balance of at least `amount`.\n     * - if `amount` is non-zero, `bytecode` must have a `payable` constructor.\n     */\n    function deploy(\n        uint256 amount,\n        bytes32 salt,\n        bytes memory bytecode\n    ) internal returns (address addr) {\n        require(address(this).balance >= amount, \"Create2: insufficient balance\");\n        require(bytecode.length != 0, \"Create2: bytecode length is zero\");\n        /// @solidity memory-safe-assembly\n        assembly {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n        }\n        require(addr != address(0), \"Create2: Failed on deploy\");\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy}. Any change in the\n     * `bytecodeHash` or `salt` will result in a new destination address.\n     */\n    function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal view returns (address) {\n        return computeAddress(salt, bytecodeHash, address(this));\n    }\n\n    /**\n     * @dev Returns the address where a contract will be stored if deployed via {deploy} from a contract located at\n     * `deployer`. If `deployer` is this contract's address, returns the same value as {computeAddress}.\n     */\n    function computeAddress(\n        bytes32 salt,\n        bytes32 bytecodeHash,\n        address deployer\n    ) internal pure returns (address addr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   |  ptr ...   ptr + 0x0B (start) ...   ptr + 0x20 ...   ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |             |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := keccak256(start, 85)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@perennial/account/contracts/Account.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { Instance } from \"@equilibria/root/attribute/Instance.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { UFixed18, UFixed18Lib } from \"@equilibria/root/number/types/UFixed18.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\n\nimport { IAccount } from \"./interfaces/IAccount.sol\";\nimport { IMarket, Position } from \"@perennial/core/contracts/interfaces/IMarket.sol\";\n\n/// @title Account\n/// @notice Collateral Accounts allow users to manage collateral across Perennial markets\ncontract Account is IAccount, Instance {\n    UFixed6 private constant UNCHANGED_POSITION = UFixed6Lib.MAX;\n\n    /// @dev EOA of the user who owns this collateral account\n    address public owner;\n\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU Reserve address\n    IEmptySetReserve public immutable reserve;\n\n    /// @dev Construct collateral account and set approvals for controller and DSU reserve\n    /// @param usdc_ USDC stablecoin\n    /// @param dsu_ Digital Standard Unit stablecoin\n    /// @param reserve_ DSU SimpleReserve contract, used for wrapping/unwrapping USDC to/from DSU\n    constructor(Token6 usdc_, Token18 dsu_, IEmptySetReserve reserve_) {\n        USDC = usdc_;\n        DSU = dsu_;\n        reserve = reserve_;\n    }\n\n    /// @inheritdoc IAccount\n    function initialize(address owner_) external initializer(1) {\n        __Instance__initialize();\n        owner = owner_;\n\n        // approve the Controller to interact with this account's DSU\n        DSU.approve(address(factory()));\n\n        // approve DSU facilities to wrap and unwrap USDC for this account\n        DSU.approve(address(reserve));\n        USDC.approve(address(reserve));\n    }\n\n    /// @inheritdoc IAccount\n    function deposit(UFixed6 amount) external {\n        USDC.pull(msg.sender, amount);\n    }\n\n    /// @inheritdoc IAccount\n    function marketTransfer(IMarket market, Fixed6 amount) external ownerOrController {\n        // implicitly approve this market to spend our DSU\n        DSU.approve(address(market));\n\n        // if account does not have enough DSU for the deposit, wrap everything\n         if (amount.gt(Fixed6Lib.ZERO))\n            wrapIfNecessary(UFixed18Lib.from(amount.abs()), true);\n\n        // pass magic numbers to avoid changing position; market will pull/push collateral from/to this contract\n        market.update(owner, UNCHANGED_POSITION, UNCHANGED_POSITION, UNCHANGED_POSITION, amount, false);\n    }\n\n    /// @inheritdoc IAccount\n    function withdraw(UFixed6 amount, bool shouldUnwrap) external ownerOrController {\n        UFixed6 usdcBalance = USDC.balanceOf();\n        if (shouldUnwrap && usdcBalance.lt(amount)) {\n            UFixed18 unwrapAmount = amount.eq(UFixed6Lib.MAX) ?\n                DSU.balanceOf() :\n                UFixed18Lib.from(amount.sub(usdcBalance)).min(DSU.balanceOf());\n            unwrap(unwrapAmount);\n        }\n        UFixed6 pushAmount = amount.eq(UFixed6Lib.MAX) ? USDC.balanceOf() : amount;\n        USDC.push(owner, pushAmount);\n    }\n\n    /// @inheritdoc IAccount\n    function wrap(UFixed18 amount) public ownerOrController {\n        reserve.mint(amount);\n    }\n\n    /// @inheritdoc IAccount\n    function wrapIfNecessary(UFixed18 amount, bool wrapAll) public ownerOrController {\n        if (DSU.balanceOf().lt(amount)) {\n            UFixed6 usdcBalance = USDC.balanceOf();\n            if (!usdcBalance.eq(UFixed6Lib.ZERO))\n                wrap(wrapAll ? UFixed18Lib.from(usdcBalance) : amount);\n        }\n    }\n\n    /// @inheritdoc IAccount\n    function unwrap(UFixed18 amount) public ownerOrController {\n        reserve.redeem(amount);\n    }\n\n    /// @dev Reverts if not called by the owner of the collateral account, or the collateral account controller\n    modifier ownerOrController {\n        if (msg.sender != owner && msg.sender != address(factory())) revert AccountNotAuthorizedError();\n        _;\n    }\n}\n"
    },
    "@perennial/account/contracts/Controller_Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { Kept_Arbitrum, Kept } from \"@equilibria/root/attribute/Kept/Kept_Arbitrum.sol\";\nimport { UFixed18 } from \"@equilibria/root/number/types/UFixed18.sol\";\nimport { IVerifierBase } from \"@equilibria/root/verifier/interfaces/IVerifierBase.sol\";\nimport { IMarketFactory } from \"@perennial/core/contracts/interfaces/IMarketFactory.sol\";\nimport { Controller_Incentivized } from \"./Controller_Incentivized.sol\";\n\n/// @title Controller_Arbitrum\n/// @notice Controller which compensates keepers for handling or relaying messages on Arbitrum L2.\ncontract Controller_Arbitrum is Controller_Incentivized, Kept_Arbitrum {\n    /// @dev Creates instance of Controller which compensates keepers\n    /// @param implementation Pristine collateral account contract\n    /// @param marketFactory Market Factory contract\n    /// @param nonceManager Verifier contract to which nonce and group cancellations are relayed\n    constructor(\n        address implementation,\n        IMarketFactory marketFactory,\n        IVerifierBase nonceManager\n    ) Controller_Incentivized(implementation, marketFactory, nonceManager) {}\n\n    /// @dev Use the Kept_Arbitrum implementation for calculating the dynamic fee\n    function _calldataFee(\n        bytes memory applicableCalldata,\n        UFixed18 multiplierCalldata,\n        uint256 bufferCalldata\n    ) internal view override(Kept_Arbitrum, Kept) returns (UFixed18) {\n        return Kept_Arbitrum._calldataFee(applicableCalldata, multiplierCalldata, bufferCalldata);\n    }\n\n    /// @dev Transfers funds from collateral account to controller, and limits compensation\n    /// to the user-defined maxFee in the Action message\n    /// @param amount Calculated keeper fee\n    /// @param data Encoded address of collateral account and UFixed6 user-specified maximum fee\n    /// @return raisedKeeperFee Amount pulled from controller to keeper\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal override(Controller_Incentivized, Kept) returns (UFixed18 raisedKeeperFee) {\n        return Controller_Incentivized._raiseKeeperFee(amount, data);\n    }\n}\n"
    },
    "@perennial/account/contracts/Controller_Incentivized.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AggregatorV3Interface } from \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport { IEmptySetReserve } from \"@equilibria/emptyset-batcher/interfaces/IEmptySetReserve.sol\";\nimport { Kept } from \"@equilibria/root/attribute/Kept/Kept.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { UFixed18, UFixed18Lib } from \"@equilibria/root/number/types/UFixed18.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { IVerifierBase } from \"@equilibria/root/verifier/interfaces/IVerifierBase.sol\";\nimport { IMarket } from \"@perennial/core/contracts/interfaces/IMarket.sol\";\nimport { IMarketFactory } from \"@perennial/core/contracts/interfaces/IMarketFactory.sol\";\n\nimport { IAccount } from \"./interfaces/IAccount.sol\";\nimport { IController } from \"./interfaces/IController.sol\";\nimport { IRelayer } from \"./interfaces/IRelayer.sol\";\nimport { Controller, IAccountVerifier } from \"./Controller.sol\";\nimport { Action } from \"./types/Action.sol\";\nimport { DeployAccount } from \"./types/DeployAccount.sol\";\nimport { MarketTransfer } from \"./types/MarketTransfer.sol\";\nimport { RebalanceConfigChange } from \"./types/RebalanceConfigChange.sol\";\nimport { RelayedNonceCancellation } from \"./types/RelayedNonceCancellation.sol\";\nimport { RelayedGroupCancellation } from \"./types/RelayedGroupCancellation.sol\";\nimport { RelayedOperatorUpdate } from \"./types/RelayedOperatorUpdate.sol\";\nimport { RelayedSignerUpdate } from \"./types/RelayedSignerUpdate.sol\";\nimport { RelayedAccessUpdateBatch } from \"./types/RelayedAccessUpdateBatch.sol\";\nimport { Withdrawal } from \"./types/Withdrawal.sol\";\n\n/// @title Controller_Incentivized\n/// @notice Controller which compensates keepers for handling or relaying messages. Subclass to handle differences in\n/// gas calculations on different chains.\nabstract contract Controller_Incentivized is Controller, IRelayer, Kept {\n    /// @dev Handles relayed messages for nonce cancellation\n    IVerifierBase public immutable nonceManager;\n\n    /// @dev Configuration used to calculate keeper compensation\n    KeepConfig public keepConfig;\n\n    /// @dev Configuration used to calculate keeper compensation with buffered gas\n    KeepConfig public keepConfigBuffered;\n\n    /// @dev Configuration used to calculate keeper compensation to withdraw from a collateral account\n    KeepConfig public keepConfigWithdrawal;\n\n    /// @dev Creates instance of Controller which compensates keepers\n    /// @param implementation_ Pristine collateral account contract\n    /// @param marketFactory_ Market factory contract\n    /// @param nonceManager_ Verifier contract to which nonce and group cancellations are relayed\n    constructor(\n        address implementation_,\n        IMarketFactory marketFactory_,\n        IVerifierBase nonceManager_\n    ) Controller(implementation_, marketFactory_) {\n        nonceManager = nonceManager_;\n    }\n\n    /// @notice Configures message verification and keeper compensation\n    /// @param verifier_ Contract used to validate collateral account message signatures\n    /// @param chainlinkFeed_ ETH-USD price feed used for calculating keeper compensation\n    /// @param keepConfig_ Configuration used for unbuffered keeper compensation\n    /// @param keepConfigBuffered_ Configuration used for buffered keeper compensation\n    /// @param keepConfigWithdrawal_ Configuration used to compensate keepers for withdrawals\n    function initialize(\n        IAccountVerifier verifier_,\n        AggregatorV3Interface chainlinkFeed_,\n        KeepConfig memory keepConfig_,\n        KeepConfig memory keepConfigBuffered_,\n        KeepConfig memory keepConfigWithdrawal_\n    ) external initializer(1) {\n        __Factory__initialize();\n        __Kept__initialize(chainlinkFeed_, DSU);\n        verifier = verifier_;\n        keepConfig = keepConfig_;\n        keepConfigBuffered = keepConfigBuffered_;\n        keepConfigWithdrawal = keepConfigWithdrawal_;\n    }\n\n    /// @inheritdoc IController\n    function changeRebalanceConfigWithSignature(\n        RebalanceConfigChange calldata configChange,\n        bytes calldata signature\n    )\n        external\n        override\n        keepCollateralAccount(\n            configChange.action.common.account,\n            abi.encode(configChange, signature),\n            configChange.action.maxFee,\n            0\n        )\n    {\n        _changeRebalanceConfigWithSignature(configChange, signature);\n    }\n\n    /// @inheritdoc IController\n    function deployAccountWithSignature(\n        DeployAccount calldata deployAccount_,\n        bytes calldata signature\n    )\n        external\n        override\n        keepCollateralAccount(\n            deployAccount_.action.common.account,\n            abi.encode(deployAccount_, signature),\n            deployAccount_.action.maxFee,\n            0\n        )\n    {\n        _deployAccountWithSignature(deployAccount_, signature);\n    }\n\n    /// @inheritdoc IController\n    function marketTransferWithSignature(\n        MarketTransfer calldata marketTransfer,\n        bytes calldata signature\n    )\n        external\n        override\n        keepCollateralAccount(\n            marketTransfer.action.common.account,\n            abi.encode(marketTransfer, signature),\n            marketTransfer.action.maxFee,\n            1\n        )\n    {\n        IAccount account = IAccount(getAccountAddress(marketTransfer.action.common.account));\n        _marketTransferWithSignature(account, marketTransfer, signature);\n    }\n\n    /// @inheritdoc IController\n    function rebalanceGroup(\n        address owner,\n        uint256 group\n    )\n        external\n        override\n        keepCollateralAccount(\n            owner,\n            abi.encode(owner, group),\n            groupToMaxRebalanceFee[owner][group],\n            groupToMarkets[owner][group].length\n        )\n    {\n        _rebalanceGroup(owner, group);\n    }\n\n    /// @inheritdoc IController\n    function withdrawWithSignature(\n        Withdrawal calldata withdrawal,\n        bytes calldata signature\n    ) override external {\n        address account = getAccountAddress(withdrawal.action.common.account);\n        // levy fee prior to withdrawal\n        bytes memory data = abi.encode(account, withdrawal.action.maxFee);\n        _handleKeeperFee(\n            keepConfigWithdrawal,\n            0, // no way to calculate applicable gas prior to invocation\n            abi.encode(withdrawal, signature),\n            0,\n            data\n        );\n        _withdrawWithSignature(IAccount(account), withdrawal, signature);\n    }\n\n    /// @inheritdoc IRelayer\n    function relayNonceCancellation(\n        RelayedNonceCancellation calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    )\n        external\n        override\n        keepCollateralAccount(\n            message.action.common.account,\n            abi.encode(message, outerSignature, innerSignature),\n            message.action.maxFee,\n            0\n        )\n    {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRelayedNonceCancellation(message, outerSignature);\n\n        // relay the message to Verifier\n        nonceManager.cancelNonceWithSignature(message.nonceCancellation, innerSignature);\n    }\n\n    /// @inheritdoc IRelayer\n    function relayGroupCancellation(\n        RelayedGroupCancellation calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    )\n        external\n        override\n        keepCollateralAccount(\n            message.action.common.account,\n            abi.encode(message, outerSignature, innerSignature),\n            message.action.maxFee,\n            0\n        )\n    {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRelayedGroupCancellation(message, outerSignature);\n\n        // relay the message to Verifier\n        nonceManager.cancelGroupWithSignature(message.groupCancellation, innerSignature);\n    }\n\n    /// @inheritdoc IRelayer\n    function relayOperatorUpdate(\n        RelayedOperatorUpdate calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    )\n        external\n        override\n        keepCollateralAccount(\n            message.action.common.account,\n            abi.encode(message, outerSignature, innerSignature),\n            message.action.maxFee,\n            0\n        )\n    {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRelayedOperatorUpdate(message, outerSignature);\n\n        // relay the message to MarketFactory\n        marketFactory.updateOperatorWithSignature(message.operatorUpdate, innerSignature);\n    }\n\n    /// @inheritdoc IRelayer\n    function relaySignerUpdate(\n        RelayedSignerUpdate calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    )\n        external\n        override\n        keepCollateralAccount(\n            message.action.common.account,\n            abi.encode(message, outerSignature, innerSignature),\n            message.action.maxFee,\n            0\n        )\n    {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRelayedSignerUpdate(message, outerSignature);\n\n        // relay the message to MarketFactory\n        marketFactory.updateSignerWithSignature(message.signerUpdate, innerSignature);\n    }\n\n    /// @inheritdoc IRelayer\n    function relayAccessUpdateBatch(\n        RelayedAccessUpdateBatch calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    )\n        external\n        override\n        keepCollateralAccount(\n            message.action.common.account,\n            abi.encode(message, outerSignature, innerSignature),\n            message.action.maxFee,\n            0\n        )\n    {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRelayedAccessUpdateBatch(message, outerSignature);\n\n        // relay the message to MarketFactory\n        marketFactory.updateAccessBatchWithSignature(message.accessUpdateBatch, innerSignature);\n    }\n\n    /// @dev Transfers funds from collateral account to controller, and limits compensation\n    /// to the user-defined maxFee in the Action message\n    /// @param amount Calculated keeper fee\n    /// @param data Encoded address of collateral account and UFixed6 user-specified maximum fee\n    /// @return raisedKeeperFee Amount pulled from controller to keeper\n    function _raiseKeeperFee(\n        UFixed18 amount,\n        bytes memory data\n    ) internal virtual override returns (UFixed18 raisedKeeperFee) {\n        (address account, UFixed6 maxFee) = abi.decode(data, (address, UFixed6));\n        raisedKeeperFee = amount.min(UFixed18Lib.from(maxFee));\n\n        // if the account has insufficient DSU to pay the fee, wrap\n        IAccount(account).wrapIfNecessary(raisedKeeperFee, false);\n\n        // transfer DSU to the Controller, such that Kept can transfer to keeper\n        DSU.pull(account, raisedKeeperFee);\n    }\n\n    modifier keepCollateralAccount(\n        address account,\n        bytes memory applicableCalldata,\n        UFixed6 maxFee,\n        uint256 bufferMultiplier\n    ) {\n        bytes memory data = abi.encode(getAccountAddress(account), maxFee);\n        uint256 startGas = gasleft();\n\n        _;\n\n        uint256 applicableGas = startGas - gasleft();\n\n        _handleKeeperFee(\n            bufferMultiplier > 0\n                ? KeepConfig(\n                    keepConfigBuffered.multiplierBase,\n                    keepConfigBuffered.bufferBase * (bufferMultiplier),\n                    keepConfigBuffered.multiplierCalldata,\n                    keepConfigBuffered.bufferCalldata * (bufferMultiplier)\n                )\n                : keepConfig,\n            applicableGas,\n            applicableCalldata,\n            0,\n            data\n        );\n    }\n}\n"
    },
    "@perennial/account/contracts/Controller.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.24;\n\nimport { Create2 } from \"@openzeppelin/contracts/utils/Create2.sol\";\n\nimport { Factory } from \"@equilibria/root/attribute/Factory.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { IMarketFactory } from \"@perennial/core/contracts/interfaces/IMarketFactory.sol\";\n\nimport { IAccount, IMarket } from \"./interfaces/IAccount.sol\";\nimport { IAccountVerifier, IController } from \"./interfaces/IController.sol\";\nimport { RebalanceLib } from \"./libs/RebalanceLib.sol\";\nimport { Account } from \"./Account.sol\";\nimport { DeployAccount, DeployAccountLib } from \"./types/DeployAccount.sol\";\nimport { MarketTransfer, MarketTransferLib } from \"./types/MarketTransfer.sol\";\nimport { RebalanceConfig, RebalanceConfigLib } from \"./types/RebalanceConfig.sol\";\nimport { RebalanceConfigChange, RebalanceConfigChangeLib } from \"./types/RebalanceConfigChange.sol\";\nimport { Withdrawal, WithdrawalLib } from \"./types/Withdrawal.sol\";\n\n/// @title Controller\n/// @notice Facilitates unpermissioned actions between collateral accounts and markets,\n/// without keeper compensation.  No message relaying facilities are provided.\ncontract Controller is Factory, IController {\n    // used for deterministic address creation through create2\n    bytes32 constant SALT = keccak256(\"Perennial V2 Collateral Accounts\");\n\n    uint256 constant MAX_GROUPS_PER_OWNER = 8;\n    uint256 constant MAX_MARKETS_PER_GROUP = 4;\n\n    /// @dev USDC stablecoin address\n    Token6 public immutable USDC; // solhint-disable-line var-name-mixedcase\n\n    /// @dev DSU address\n    Token18 public immutable DSU; // solhint-disable-line var-name-mixedcase\n\n    /// @inheritdoc IController\n    IMarketFactory public immutable marketFactory;\n\n    /// @inheritdoc IController\n    IAccountVerifier public verifier;\n\n    /// @dev Mapping of rebalance configuration\n    /// owner => group => market => config\n    mapping(address => mapping(uint256 => mapping(address => RebalanceConfig))) private _rebalanceConfigs;\n\n    /// @dev Prevents markets from being added to multiple rebalance groups\n    /// owner => market => group\n    mapping(address => mapping(address => uint256)) public marketToGroup;\n\n    /// @dev Allows iteration through markets in a rebalance group\n    /// owner => group => markets\n    mapping(address => mapping(uint256 => IMarket[])) public groupToMarkets;\n\n    /// @dev Limits relayer/keeper compensation for rebalancing a group, in DSU\n    mapping(address => mapping(uint256 => UFixed6)) public groupToMaxRebalanceFee;\n\n    /// @dev Creates instance of Controller\n    /// @param implementation_ Collateral account contract initialized with stablecoin addresses\n    constructor(address implementation_, IMarketFactory marketFactory_) Factory(implementation_) {\n        USDC = Account(implementation_).USDC();\n        DSU = Account(implementation_).DSU();\n        marketFactory = marketFactory_;\n    }\n\n    /// @inheritdoc IController\n    function initialize(\n        IAccountVerifier verifier_\n    ) external initializer(1) {\n        __Factory__initialize();\n        verifier = verifier_;\n    }\n\n    /// @inheritdoc IController\n    function getAccountAddress(address owner) public view returns (address) {\n        // calculate the hash for an uninitialized account for the owner\n        return _computeCreate2Address(abi.encodeCall(Account.initialize, (owner)), SALT);\n    }\n\n    /// @inheritdoc IController\n    function changeRebalanceConfigWithSignature(\n        RebalanceConfigChange calldata configChange,\n        bytes calldata signature\n    ) virtual external {\n        _changeRebalanceConfigWithSignature(configChange, signature);\n    }\n\n    /// @inheritdoc IController\n    function checkGroup(address owner, uint256 group) public view returns (\n        Fixed6 groupCollateral,\n        bool canRebalance,\n        Fixed6[] memory imbalances\n    ) {\n        // query owner's collateral in each market and calculate sum\n        Fixed6[] memory actualCollateral;\n        (actualCollateral, groupCollateral) = _queryMarketCollateral(owner, group);\n        imbalances = new Fixed6[](actualCollateral.length);\n\n        // determine if anything is outside the rebalance threshold\n        for (uint256 i; i < actualCollateral.length; i++) {\n            IMarket market = groupToMarkets[owner][group][i];\n            RebalanceConfig memory marketRebalanceConfig = _rebalanceConfigs[owner][group][address(market)];\n            (bool canMarketRebalance, Fixed6 imbalance) =\n                RebalanceLib.checkMarket(\n                    marketRebalanceConfig,\n                    groupToMaxRebalanceFee[owner][group],\n                    groupCollateral,\n                    actualCollateral[i]\n                );\n            imbalances[i] = imbalance;\n            canRebalance = canRebalance || canMarketRebalance;\n        }\n\n        // if group does not exist or was deleted, arrays will be empty and function will return (0, false, 0)\n    }\n\n    /// @inheritdoc IController\n    function deployAccount() public returns (IAccount) {\n        return _createAccount(msg.sender);\n    }\n\n    /// @inheritdoc IController\n    function deployAccountWithSignature(\n        DeployAccount calldata deployAccountAction,\n        bytes calldata signature\n    ) virtual external {\n        _deployAccountWithSignature(deployAccountAction, signature);\n    }\n\n    /// @inheritdoc IController\n    function marketTransferWithSignature(\n        MarketTransfer calldata marketTransfer,\n        bytes calldata signature\n    ) virtual external {\n        IAccount account = IAccount(getAccountAddress(marketTransfer.action.common.account));\n        _marketTransferWithSignature(account, marketTransfer, signature);\n    }\n\n    /// @inheritdoc IController\n    function rebalanceConfigs(\n        address owner,\n        uint256 group,\n        address market\n    ) external view returns (RebalanceConfig memory) {\n        return _rebalanceConfigs[owner][group][market];\n    }\n\n    /// @inheritdoc IController\n    function rebalanceGroupMarkets(\n        address owner,\n        uint256 group\n    ) external view returns (IMarket[] memory markets) {\n        markets = groupToMarkets[owner][group];\n    }\n\n    /// @inheritdoc IController\n    function withdrawWithSignature(Withdrawal calldata withdrawal, bytes calldata signature) virtual external {\n        IAccount account = IAccount(getAccountAddress(withdrawal.action.common.account));\n        _withdrawWithSignature(account, withdrawal, signature);\n    }\n\n    /// @inheritdoc IController\n    function rebalanceGroup(address owner, uint256 group) virtual external {\n        _rebalanceGroup(owner, group);\n    }\n\n    function _changeRebalanceConfigWithSignature(RebalanceConfigChange calldata configChange, bytes calldata signature) internal {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyRebalanceConfigChange(configChange, signature);\n        // sum of the target allocations of all markets in the group\n        _updateRebalanceGroup(configChange, configChange.action.common.account);\n    }\n\n    function _createAccount(address owner) internal returns (IAccount account) {\n        account = Account(address(_create2(abi.encodeCall(Account.initialize, (owner)), SALT)));\n        emit AccountDeployed(owner, account);\n    }\n\n    function _deployAccountWithSignature(\n        DeployAccount calldata deployAccount_,\n        bytes calldata signature\n    ) internal returns (IAccount account) {\n        address owner = deployAccount_.action.common.account;\n        verifier.verifyDeployAccount(deployAccount_, signature);\n\n        // create the account\n        account = _createAccount(owner);\n    }\n\n    function _marketTransferWithSignature(\n        IAccount account,\n        MarketTransfer calldata marketTransfer,\n        bytes calldata signature\n    ) internal {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyMarketTransfer(marketTransfer, signature);\n\n        // only Markets with DSU collateral are supported\n        IMarket market = IMarket(marketTransfer.market);\n        if (!market.token().eq(DSU)) revert ControllerUnsupportedMarketError(market);\n\n        account.marketTransfer(market, marketTransfer.amount);\n    }\n\n    function _withdrawWithSignature(\n        IAccount account,\n        Withdrawal calldata withdrawal,\n        bytes calldata signature\n    ) internal {\n        // ensure the message was signed by the owner or a delegated signer\n        verifier.verifyWithdrawal(withdrawal, signature);\n\n        // call the account's implementation to push to owner\n        account.withdraw(withdrawal.amount, withdrawal.unwrap);\n    }\n\n    function _rebalanceGroup(address owner, uint256 group) internal {\n        // settles each markets, such that locals are up-to-date\n        _settleMarkets(owner, group);\n\n        // determine imbalances\n        (, bool canRebalance, Fixed6[] memory imbalances) = checkGroup(owner, group);\n        if (!canRebalance) revert ControllerGroupBalancedError();\n\n        IAccount account = IAccount(getAccountAddress(owner));\n        // pull collateral from markets with surplus collateral\n        for (uint256 i; i < imbalances.length; i++) {\n            IMarket market = groupToMarkets[owner][group][i];\n            if (Fixed6.unwrap(imbalances[i]) < 0) account.marketTransfer(market, imbalances[i]);\n        }\n\n        // push collateral to markets with insufficient collateral\n        for (uint256 i; i < imbalances.length; i++) {\n            IMarket market = groupToMarkets[owner][group][i];\n            if (Fixed6.unwrap(imbalances[i]) > 0) account.marketTransfer(market, imbalances[i]);\n        }\n\n        emit GroupRebalanced(owner, group);\n    }\n\n    /// @dev checks current collateral for each market in a group and aggregates collateral for the group\n    function _queryMarketCollateral(address owner, uint256 group) private view returns (\n        Fixed6[] memory actualCollateral,\n        Fixed6 groupCollateral\n    ) {\n        actualCollateral = new Fixed6[](groupToMarkets[owner][group].length);\n        for (uint256 i; i < actualCollateral.length; i++) {\n            Fixed6 collateral = groupToMarkets[owner][group][i].locals(owner).collateral;\n            actualCollateral[i] = collateral;\n            groupCollateral = groupCollateral.add(collateral);\n        }\n    }\n\n    /// @dev settles each market in a rebalancing group\n    function _settleMarkets(address owner, uint256 group) private {\n        for (uint256 i; i < groupToMarkets[owner][group].length; i++)\n            groupToMarkets[owner][group][i].settle(owner);\n    }\n\n    /// @dev overwrites rebalance configuration of all markets for a particular owner and group\n    /// @param message already-verified message with new configuration\n    /// @param owner identifies the owner of the collateral account\n    function _updateRebalanceGroup(\n        RebalanceConfigChange calldata message,\n        address owner\n    ) private {\n        // ensure group index is valid\n        if (message.group == 0 || message.group > MAX_GROUPS_PER_OWNER)\n            revert ControllerInvalidRebalanceGroupError();\n\n        if (message.markets.length > MAX_MARKETS_PER_GROUP)\n            revert ControllerInvalidRebalanceMarketsError();\n\n        // delete the existing group\n        for (uint256 i; i < groupToMarkets[owner][message.group].length; i++) {\n            address market = address(groupToMarkets[owner][message.group][i]);\n            delete _rebalanceConfigs[owner][message.group][market];\n            delete marketToGroup[owner][market];\n        }\n        delete groupToMarkets[owner][message.group];\n\n        UFixed6 totalAllocation;\n        for (uint256 i; i < message.markets.length; i++) {\n            // ensure market is not pointing to a different group\n            uint256 currentGroup = marketToGroup[owner][message.markets[i]];\n            if (currentGroup != 0)\n                revert ControllerMarketAlreadyInGroupError(IMarket(message.markets[i]), currentGroup);\n\n            // rewrite over all the old configuration\n            marketToGroup[owner][message.markets[i]] = message.group;\n            _rebalanceConfigs[owner][message.group][message.markets[i]] = message.configs[i];\n            groupToMarkets[owner][message.group].push(IMarket(message.markets[i]));\n            groupToMaxRebalanceFee[owner][message.group] = message.maxFee;\n\n            // ensure target allocation across all markets totals 100%\n            // read from storage to trap duplicate markets in the message\n            totalAllocation = totalAllocation.add(message.configs[i].target);\n\n            emit RebalanceMarketConfigured(owner, message.group, message.markets[i], message.configs[i]);\n        }\n\n        // if not deleting the group, ensure rebalance targets add to 100%\n        if (message.markets.length != 0 && !totalAllocation.eq(UFixed6Lib.ONE))\n            revert ControllerInvalidRebalanceTargetsError();\n\n        emit RebalanceGroupConfigured(owner, message.group, message.markets.length);\n    }\n}\n"
    },
    "@perennial/account/contracts/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IMarket } from \"@perennial/core/contracts/interfaces/IMarket.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed18 } from \"@equilibria/root/number/types/UFixed18.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\n\n/// @notice Collateral Accounts allow users to manage collateral across Perennial markets\ninterface IAccount {\n    // sig: 0x9041f6c1\n    /// @custom:error Only the owner or the collateral account controller may withdraw\n    error AccountNotAuthorizedError();\n\n    /// @notice Sets owner, contract, and token addresses, and runs approvals for a collateral account\n    /// @param owner Address of the user for which the account was created\n    function initialize(address owner) external;\n\n    /// @notice Transfer USDC collateral from msg.sender to this account\n    /// @param amount Quantity of USDC to transfer in 6-decimal precision\n    function deposit(UFixed6 amount) external;\n\n    /// @notice used for transferring and rebalancing collateral\n    /// @param market Market to transfer funds to/from, which identifies the token\n    /// @param amount Quantity to deposit (positive) or withdraw (negative)\n    function marketTransfer(IMarket market, Fixed6 amount) external;\n\n    /// @notice Transfer USDC collateral from this account to the owner\n    /// @param amount Quantity of tokens to transfer in 6-decimal precision; set to UFixed6.MAX for full withdrawal\n    /// @param shouldUnwrap If amount exceeds USDC balance and this is true, DSU will be unwrapped as necessary to facilitate withdrawal\n    function withdraw(UFixed6 amount, bool shouldUnwrap) external;\n\n    /// @notice Converts a specified amount of USDC to DSU\n    /// @param amount Quantity of DSU to mint, in 18-decimal precision\n    function wrap(UFixed18 amount) external;\n\n    /// @notice Wraps if DSU balance is under a specified amount\n    /// @param amount Desired quantity of DSU\n    /// @param wrapAll True to wrap full USDC balance, false to wrap specified amount\n    function wrapIfNecessary(UFixed18 amount, bool wrapAll) external;\n\n    /// @notice Converts a specified amount of DSU to USDC\n    /// @param amount Quantity of DSU to burn, in 18-decimal precision\n    function unwrap(UFixed18 amount) external;\n}\n"
    },
    "@perennial/account/contracts/interfaces/IAccountVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IVerifierBase } from \"@equilibria/root/verifier/interfaces/IVerifierBase.sol\";\nimport { IRelayVerifier } from \"./IRelayVerifier.sol\";\nimport { Action } from \"../types/Action.sol\";\nimport { DeployAccount } from \"../types/DeployAccount.sol\";\nimport { MarketTransfer } from \"../types/MarketTransfer.sol\";\nimport { RebalanceConfigChange } from \"../types/RebalanceConfigChange.sol\";\nimport { Withdrawal } from \"../types/Withdrawal.sol\";\n\n/// @notice EIP712 signed message verifier for Perennial V2 Collateral Accounts.\ninterface IAccountVerifier is IVerifierBase, IRelayVerifier {\n    /// @notice Verifies the signature of no-op action message\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param action Data common to all action messages\n    /// @param signature EIP712 signature for the message\n    function verifyAction(Action calldata action, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a request to deploy a collateral account\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param deployAccount message to verify, which includes the owner of the collateral account\n    /// @param signature EIP712 signature for the message\n    function verifyDeployAccount(DeployAccount calldata deployAccount, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a request to transfer funds between a collateral account and a market\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param transfer message to verify\n    /// @param signature EIP712 signature for the message\n    function verifyMarketTransfer(MarketTransfer calldata transfer, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a request to change rebalancing configuration for multiple markets\n    /// @dev Cancels the nonce after verifying the signature\n    /// @param change message to verify\n    /// @param signature EIP712 signature for the message\n    function verifyRebalanceConfigChange(RebalanceConfigChange calldata change, bytes calldata signature) external;\n\n    /// @notice Verifies the signature of a request to transfer funds from the collateral account back to the owner\n    /// @dev Cancels the nonce after verifying the signature\n    ///      Reverts if the signature does not match the signer\n    /// @param withdrawal message to verify, which includes the owner of the collateral account\n    /// @param signature EIP712 signature for the message\n    function verifyWithdrawal(Withdrawal calldata withdrawal, bytes calldata signature) external;\n}\n"
    },
    "@perennial/account/contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Token6 } from \"@equilibria/root/token/types/Token6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { IMarketFactory } from \"@perennial/core/contracts/interfaces/IMarketFactory.sol\";\n\nimport { IAccount, IMarket } from \"../interfaces/IAccount.sol\";\nimport { IAccountVerifier } from \"../interfaces/IAccountVerifier.sol\";\nimport { DeployAccount } from \"../types/DeployAccount.sol\";\nimport { MarketTransfer } from \"../types/MarketTransfer.sol\";\nimport { RebalanceConfig } from \"../types/RebalanceConfig.sol\";\nimport { RebalanceConfigChange } from \"../types/RebalanceConfigChange.sol\";\nimport { Withdrawal } from \"../types/Withdrawal.sol\";\n\n/// @notice Facilitates unpermissioned actions between collateral accounts and markets\ninterface IController {\n    /// @notice Emitted when a collateral account is deployed\n    /// @param owner EOA for whom the collateral account was created\n    /// @param account contract address of the collateral account\n    event AccountDeployed(address indexed owner, IAccount indexed account);\n\n    /// @notice Emitted when a group has been rebalanced\n    /// @param owner Owner of the collateral account for which the rebalance group was created or modified\n    /// @param group Identifies the rebalance group within context of owner\n    event GroupRebalanced(address indexed owner, uint256 indexed group);\n\n    /// @notice Emitted when a rebalance group is created or updated\n    /// @param owner Owner of the collateral account for which the rebalance group was created or modified\n    /// @param group Identifies the rebalance group within context of owner\n    /// @param markets Number of markets in the group (0 if group was deleted)\n    event RebalanceGroupConfigured(address indexed owner, uint256 indexed group, uint256 markets);\n\n    /// @notice Emitted for each market in a rebalance group upon creation of the group\n    /// or when any changes are made to the group\n    /// @param owner Owner of the collateral account for which the rebalance group was created or modified\n    /// @param group Identifies the rebalance group within context of owner\n    /// @param market The Perennial market for which this configuration applies\n    /// @param newConfig Rebalance configuration for the market, which may or may not have changed\n    event RebalanceMarketConfigured(\n        address indexed owner,\n        uint256 indexed group,\n        address indexed market,\n        RebalanceConfig newConfig\n    );\n\n    // sig: 0xdc72f280\n    /// @custom:error Group is balanced and ineligible for rebalance\n    error ControllerGroupBalancedError();\n\n    // sig: 0xbd3648e9\n    /// @custom:error A RebalanceConfigChange message had a mismatch in number of markets and configs\n    error ControllerInvalidRebalanceConfigError();\n\n    // sig: 0xa16ba7f2\n    /// @custom:error Group number was out-of-range; each collateral account may have up to 8 groups, indexed 1-8\n    error ControllerInvalidRebalanceGroupError();\n\n    // sig: 0xecce9fda\n    /// @custom:error Group has too many markets; each group may have 1-4 markets\n    error ControllerInvalidRebalanceMarketsError();\n\n    // sig: 0x64580a1c\n    /// @custom:error The sum of `target` collateral allocations for each market in a group does not total 100%.\n    /// This could also indicate a duplicate market was in the list.\n    error ControllerInvalidRebalanceTargetsError();\n\n    // sig: 0x43e749f8\n    /// @custom:error Signer is not authorized to interact with the specified collateral account\n    error ControllerInvalidSignerError();\n\n    // sig: 0xa4a79a03\n    /// @custom:error A market in this rebalancing configuration is already a member of a different group\n    /// @param market Identifies which market in the message which is causing the problem\n    /// @param group Identifies the group in which the aforementioned market is a member\n    error ControllerMarketAlreadyInGroupError(IMarket market, uint256 group);\n\n    // sig: 0xdcca49cd\n    /// @custom:error Attempt to interact with a Market which does not use DSU as collateral\n    /// @param market Market with non-DSU collateral\n    error ControllerUnsupportedMarketError(IMarket market);\n\n    /// @dev Contract used to validate delegated signers and relay certain messages\n    function marketFactory() external view returns (IMarketFactory);\n\n    /// @dev Contract used to validate message signatures\n    function verifier() external view returns (IAccountVerifier);\n\n    /// @notice Sets contract addresses used for message verification and token management\n    /// @param verifier Contract used to validate collateral account message signatures\n    function initialize(\n        IAccountVerifier verifier\n    ) external;\n\n    /// @notice Returns the deterministic address of the collateral account for a user,\n    /// regardless of whether or not it exists.\n    /// @param owner Identifies the user whose collateral account address is desired\n    function getAccountAddress(address owner) external view returns (address);\n\n    /// @notice Deploys the collateral account for msg.sender and returns the address of the account\n    function deployAccount() external returns (IAccount);\n\n    /// @notice Deploys a collateral account via a signed message\n    /// @param deployAccountAction Message requesting creation of a collateral account\n    /// @param signature ERC712 message signature\n    function deployAccountWithSignature(DeployAccount calldata deployAccountAction, bytes calldata signature) external;\n\n    /// @notice Transfers tokens between a collateral account and a specified Perennial Market\n    /// @param marketTransfer Message requesting a deposit to or withdrawal from the Market\n    /// @param signature ERC712 message signature\n    function marketTransferWithSignature(MarketTransfer calldata marketTransfer, bytes calldata signature) external;\n\n    /// @notice Adjusts the rebalancing configuration of one or more markets\n    /// @param configChange Message with new rebalance group configuration\n    /// @param signature ERC712 message signature\n    function changeRebalanceConfigWithSignature(RebalanceConfigChange calldata configChange,\n        bytes calldata signature) external;\n\n    /// @notice Checks all markets in a rebalance group to see if anything may be rebalanced\n    /// @param owner User whose collateral account may be rebalanced using this group\n    /// @param group Identifies the group within the context of the owner\n    /// @return groupCollateral Sum of ower's collateral across each market in the group\n    /// @return canRebalance True if one or more markets in the group are eligible for rebalancing\n    /// @return imbalances The difference between target and actual collateral for each market\n    function checkGroup(address owner, uint256 group) external view returns (\n        Fixed6 groupCollateral,\n        bool canRebalance,\n        Fixed6[] memory imbalances\n    );\n\n    /// @notice Called by keepers to rebalance an unbalanced group\n    /// @param owner User whose collateral account may be rebalanced using this group\n    /// @param group Identifies the group within the context of the owner\n    function rebalanceGroup(address owner, uint256 group) external;\n\n    /// @notice Retrieves rebalance configuration for a specified owner, group, and market\n    /// @param owner User for whom the collateral account was created\n    /// @param group Identifies a collection of markets, each with their own configuration\n    /// @param market Identifies which Perennial market for which the configuration is desired\n    function rebalanceConfigs(\n        address owner,\n        uint256 group,\n        address market\n    ) external view returns (RebalanceConfig memory);\n\n    /// @notice Retrieves array of markets in an owner's rebalance group\n    /// @param owner User for whom the collateral account was created\n    /// @param group Identifies which collection of markets is desired for the owner\n    /// @return markets Array containing each market in the rebalance group\n    function rebalanceGroupMarkets(\n        address owner,\n        uint256 group\n    ) external view returns (IMarket[] memory markets);\n\n    /// @notice Transfers tokens from the collateral account back to the owner of the account\n    /// @param withdrawal Message requesting a withdrawal\n    /// @param signature ERC712 message signature\n    function withdrawWithSignature(Withdrawal calldata withdrawal, bytes calldata signature) external;\n}\n"
    },
    "@perennial/account/contracts/interfaces/IRelayer.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { RelayedNonceCancellation } from \"../types/RelayedNonceCancellation.sol\";\nimport { RelayedGroupCancellation } from \"../types/RelayedGroupCancellation.sol\";\nimport { RelayedOperatorUpdate } from \"../types/RelayedOperatorUpdate.sol\";\nimport { RelayedSignerUpdate } from \"../types/RelayedSignerUpdate.sol\";\nimport { RelayedAccessUpdateBatch } from \"../types/RelayedAccessUpdateBatch.sol\";\n\n// @notice Relays messages to downstream handlers, compensating keepers for the transaction\ninterface IRelayer {\n    /// @notice Relays a message to Verifier extension to invalidate a nonce\n    /// @param message Request with details needed for keeper compensation\n    /// @param outerSignature Signature of the RelayedNonceCancellation message\n    /// @param innerSignature Signature of the embedded Common message\n    function relayNonceCancellation(\n        RelayedNonceCancellation calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) external;\n\n    /// @notice Relays a message to Verifier extension to invalidate a group nonce\n    /// @param message Request with details needed for keeper compensation\n    /// @param outerSignature Signature of the RelayedGroupCancellation message\n    /// @param innerSignature Signature of the embedded GroupCancellation message\n    function relayGroupCancellation(\n        RelayedGroupCancellation calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) external;\n\n    /// @notice Relays a message to MarketFactory to update status of an operator\n    /// @param message Request with details needed for keeper compensation\n    /// @param outerSignature Signature of the RelayedOperatorUpdate message\n    /// @param innerSignature Signature of the embedded OperatorUpdate message\n    function relayOperatorUpdate(\n        RelayedOperatorUpdate calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) external;\n\n    /// @notice Relays a message to MarketFactory to update status of a delegated signer\n    /// @param message Request with details needed for keeper compensation\n    /// @param outerSignature Signature of the RelayedSignerUpdate message\n    /// @param innerSignature Signature of the embedded SignerUpdate message\n    function relaySignerUpdate(\n        RelayedSignerUpdate calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) external;\n\n    /// @notice Relays a message to MarketFactory to update multiple operators and signers\n    /// @param message Request with details needed for keeper compensation\n    /// @param outerSignature Signature of the RelayedAccessUpdateBatch message\n    /// @param innerSignature Signature of the embedded AccessUpdateBatch message\n    function relayAccessUpdateBatch(\n        RelayedAccessUpdateBatch calldata message,\n        bytes calldata outerSignature,\n        bytes calldata innerSignature\n    ) external;\n}"
    },
    "@perennial/account/contracts/interfaces/IRelayVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IVerifierBase } from \"@equilibria/root/verifier/interfaces/IVerifierBase.sol\";\nimport { RelayedNonceCancellation } from \"../types/RelayedNonceCancellation.sol\";\nimport { RelayedGroupCancellation } from \"../types/RelayedGroupCancellation.sol\";\nimport { RelayedOperatorUpdate } from \"../types/RelayedOperatorUpdate.sol\";\nimport { RelayedSignerUpdate } from \"../types/RelayedSignerUpdate.sol\";\nimport { RelayedAccessUpdateBatch } from \"../types/RelayedAccessUpdateBatch.sol\";\n\n/// @notice EIP712 signed message verifier for relaying messages through Collateral Accounts Controller.\ninterface IRelayVerifier is IVerifierBase {\n    /// @dev Verifies a request to relay a nonce cancellation request\n    /// @param message Wrapped message adding details needed for keeper compensation\n    /// @param outerSignature EIP712 signature for the preceeding message\n    function verifyRelayedNonceCancellation(\n        RelayedNonceCancellation calldata message,\n        bytes calldata outerSignature\n    ) external;\n\n    /// @dev Verifies a request to relay a group nonce cancellation request\n    /// @param message Wrapped message adding details needed for keeper compensation\n    /// @param outerSignature EIP712 signature for the preceeding message\n    function verifyRelayedGroupCancellation(\n        RelayedGroupCancellation calldata message,\n        bytes calldata outerSignature\n    ) external;\n\n    /// @dev Verifies a request to relay an operator update\n    /// @param message Wrapped message adding details needed for keeper compensation\n    /// @param outerSignature EIP712 signature for the preceeding message\n    function verifyRelayedOperatorUpdate(\n        RelayedOperatorUpdate calldata message,\n        bytes calldata outerSignature\n    ) external;\n\n    /// @dev Verifies a request to relay an update to designated signers\n    /// @param message Wrapped message adding details needed for keeper compensation\n    /// @param outerSignature EIP712 signature for the preceeding message\n    function verifyRelayedSignerUpdate(\n        RelayedSignerUpdate calldata message,\n        bytes calldata outerSignature\n    ) external;\n\n    /// @dev Verifies a request to relay a message updating multiple operators and signers\n    /// @param message Wrapped message adding details needed for keeper compensation\n    /// @param outerSignature EIP712 signature for the preceeding message\n    function verifyRelayedAccessUpdateBatch(\n        RelayedAccessUpdateBatch calldata message,\n        bytes calldata outerSignature\n    ) external;\n}\n"
    },
    "@perennial/account/contracts/libs/RebalanceLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { IController } from \"../interfaces/IController.sol\";\nimport { RebalanceConfig } from \"../types/RebalanceConfig.sol\";\n\n/// @title RebalanceLib\n/// @notice Facilities for rebalancing collateral accounts\nlibrary RebalanceLib {\n    /// @dev Compares actual market collateral for owner with their account's target\n    /// @param marketConfig Rebalance group configuration for this market\n    /// @param maxFee Maximum fee paid to keeper for rebalancing the group\n    /// @param groupCollateral Owner's collateral across all markets in the group\n    /// @param marketCollateral Owner's actual amount of collateral in this market\n    /// @return canRebalance True if actual collateral in this market is outside of configured threshold\n    /// @return imbalance Amount which needs to be transferred to balance the market\n    function checkMarket(\n        RebalanceConfig memory marketConfig,\n        UFixed6 maxFee,\n        Fixed6 groupCollateral,\n        Fixed6 marketCollateral\n    ) internal pure returns (bool canRebalance, Fixed6 imbalance) {\n        // determine how much collateral the market should have\n        Fixed6 targetCollateral = groupCollateral.mul(Fixed6Lib.from(marketConfig.target));\n\n        // if target is zero, prevent divide-by-zero condition\n        if (targetCollateral.eq(Fixed6Lib.ZERO)) {\n            imbalance = marketCollateral.mul(Fixed6Lib.NEG_ONE);\n            // can rebalance if market is not empty and imbalance exceeds max fee paid to keeper\n            canRebalance = !marketCollateral.eq(Fixed6Lib.ZERO) && imbalance.abs().gt(maxFee);\n            return (canRebalance, imbalance);\n        }\n        // calculate percentage difference between actual and target collateral\n        Fixed6 pctFromTarget = Fixed6Lib.ONE.sub(marketCollateral.div(targetCollateral));\n\n        // return negative number for surplus, positive number for deficit\n        imbalance = targetCollateral.sub(marketCollateral);\n\n        // if this percentage exceeds the configured threshold,\n        // and the amount to rebalance exceeds max fee paid to keeper, the market may be rebalanced\n        canRebalance = pctFromTarget.abs().gt(marketConfig.threshold)\n            && imbalance.abs().gt(maxFee);\n    }\n}"
    },
    "@perennial/account/contracts/types/Action.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @notice Fields which need to be hashed for each collateral account action\nstruct Action {\n    /// @dev Largest amount to compensate relayer/keeper for the transaction in DSU\n    UFixed6 maxFee;\n    /// @dev Information shared across all EIP712 collateral account actions;\n    /// populate common.account with the owner of the collateral account\n    Common common;\n}\nusing ActionLib for Action global;\n\n/// @title ActionLib\n/// @notice Library used to hash and verifiy fields common to all collateral-account-related messages\nlibrary ActionLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(Action memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.maxFee, CommonLib.hash(self.common)));\n    }\n}\n"
    },
    "@perennial/account/contracts/types/DeployAccount.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct DeployAccount {\n    /// @dev Common information for collateral account actions\n    Action action;\n}\nusing DeployAccountLib for DeployAccount global;\n\n/// @title DeployAccountLib\n/// @notice Library used to hash and verify action to deploy a collateral account\nlibrary DeployAccountLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"DeployAccount(Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(DeployAccount memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, ActionLib.hash(self.action)));\n    }\n}\n"
    },
    "@perennial/account/contracts/types/MarketTransfer.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct MarketTransfer {\n    /// @dev Identifies the market to which funds should be sent\n    address market;\n    /// @dev Amount to deposit (positive) or withdraw (negative);\n    /// set to Fixed6Lib.MIN to fully withdraw from market.\n    Fixed6 amount;\n    /// @dev Common information for collateral account actions\n    Action action;\n}\nusing MarketTransferLib for MarketTransfer global;\n\n/// @title MarketTransferLib\n/// @notice Library used to hash and verify action to move funds to/from a market\nlibrary MarketTransferLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"MarketTransfer(address market,int256 amount,Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(MarketTransfer memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.market, self.amount, ActionLib.hash(self.action)));\n    }\n}\n"
    },
    "@perennial/account/contracts/types/RebalanceConfig.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev Rebalancing configuration for a single market\nstruct RebalanceConfig {\n    /// @dev Percentage of collateral from the group to deposit into the market\n    UFixed6 target;\n    /// @dev Ratio of market collateral to target after which keepers may rebalance\n    UFixed6 threshold;\n}\n\nstruct RebalanceConfigStorage { uint256 slot0; }\nusing RebalanceConfigLib for RebalanceConfigStorage global;\n\n/// @title RebalanceConfigLib\n/// @notice Library used to hash and manage storage for rebalancing configuration for a single market\nlibrary RebalanceConfigLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RebalanceConfig(uint256 target,uint256 threshold)\"\n    );\n\n    /// sig: 0xd673935e\n    error RebalanceConfigStorageInvalidError();\n\n    /// @dev hashes this instance for inclusion in an EIP-712 message\n    function hash(RebalanceConfig memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.target, self.threshold));\n    }\n\n    /// @dev extracts two unsigned values from a single storage slot\n    function read(RebalanceConfigStorage storage self) internal view returns (RebalanceConfig memory) {\n        uint256 slot0 = self.slot0;\n        return RebalanceConfig(\n            UFixed6.wrap(uint256(slot0 << (256 - 32)) >> (256 - 32)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32)) >> (256 - 32))\n        );\n    }\n\n    /// @dev ensures values do not exceed 100% and writes them to a single storage slot\n    function store(RebalanceConfigStorage storage self, RebalanceConfig memory newValue) external {\n        if (newValue.target.gt(UFixed6Lib.ONE)) revert RebalanceConfigStorageInvalidError();\n        if (newValue.threshold.gt(UFixed6Lib.ONE)) revert RebalanceConfigStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(UFixed6.unwrap(newValue.target)    << (256 - 32)) >> (256 - 32) |\n            uint256(UFixed6.unwrap(newValue.threshold) << (256 - 32)) >> (256 - 32 - 32);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}\n"
    },
    "@perennial/account/contracts/types/RebalanceConfigChange.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\nimport { RebalanceConfig, RebalanceConfigLib } from \"./RebalanceConfig.sol\";\nimport { IController } from \"../interfaces/IController.sol\";\n\n/// @dev Action message to change configuration for a group of markets\nstruct RebalanceConfigChange {\n    /// @dev Identifies which group to change; indexed 1-8\n    uint256 group;\n    /// @dev List of 1-4 markets in which collateral shall be managed.\n    /// Markets may be added to or removed from an existing group. Leave empty to delete the group.\n    address[] markets;\n    /// @dev Target allocation for markets in the aforementioned array\n    RebalanceConfig[] configs;\n    /// @dev Largest amount to compensate a relayer/keeper for rebalancing the group in DSU.\n    /// This amount also prevents keepers from rebalancing imbalances smaller than the keeper fee.\n    UFixed6 maxFee;\n    /// @dev Common information for collateral account actions\n    Action action;\n}\nusing RebalanceConfigChangeLib for RebalanceConfigChange global;\n\n/// @title RebalanceConfigChangeLib\n/// @notice Library used to hash and verify action to change rebalancing configuration\nlibrary RebalanceConfigChangeLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RebalanceConfigChange(uint256 group,address[] markets,RebalanceConfig[] configs,uint256 maxFee,Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n        \"RebalanceConfig(uint256 target,uint256 threshold)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RebalanceConfigChange memory self) internal pure returns (bytes32) {\n        bytes32[] memory encodedConfigs = new bytes32[](self.configs.length);\n\n        // ensure consistent error for length mismatch\n        if (self.markets.length != self.configs.length)\n            revert IController.ControllerInvalidRebalanceConfigError();\n\n        for (uint256 i = 0; i < self.markets.length; ++i) {\n            encodedConfigs[i] = RebalanceConfigLib.hash(self.configs[i]);\n        }\n        return keccak256(abi.encode(\n            STRUCT_HASH,\n            self.group,\n            keccak256(abi.encodePacked(self.markets)),\n            keccak256(abi.encodePacked(encodedConfigs)),\n            self.maxFee,\n            ActionLib.hash(self.action)\n        ));\n    }\n}\n"
    },
    "@perennial/account/contracts/types/RelayedAccessUpdateBatch.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { AccessUpdateBatch, AccessUpdateBatchLib } from \"@perennial/verifier/contracts/types/AccessUpdateBatch.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct RelayedAccessUpdateBatch {\n    /// @dev Message to relay to MarketFactory\n    AccessUpdateBatch accessUpdateBatch;\n    /// @dev Common information for relayed actions\n    Action action;\n}\nusing RelayedAccessUpdateBatchLib for RelayedAccessUpdateBatch global;\n\n/// @title RelayedAccessUpdateBatchLib\n/// @notice Library used to hash and verify action to relay a message to change status of operators and signers\nlibrary RelayedAccessUpdateBatchLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RelayedAccessUpdateBatch(AccessUpdateBatch accessUpdateBatch,Action action)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"AccessUpdateBatch(AccessUpdate[] operators,AccessUpdate[] signers,Common common)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RelayedAccessUpdateBatch memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, AccessUpdateBatchLib.hash(self.accessUpdateBatch), ActionLib.hash(self.action)));\n    }\n}\n"
    },
    "@perennial/account/contracts/types/RelayedGroupCancellation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { GroupCancellation, GroupCancellationLib } from \"@equilibria/root/verifier/types/GroupCancellation.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct RelayedGroupCancellation {\n    /// @dev Message to relay to verifier, identifying the group to cancel\n    GroupCancellation groupCancellation;\n    /// @dev Common information for relayed actions\n    Action action;\n}\nusing RelayedGroupCancellationLib for RelayedGroupCancellation global;\n\n/// @title RelayedGroupCancellationLib\n/// @notice Library used to hash and verify action to relay a message to cancel a group\nlibrary RelayedGroupCancellationLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RelayedGroupCancellation(GroupCancellation groupCancellation,Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n        \"GroupCancellation(uint256 group,Common common)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RelayedGroupCancellation memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, GroupCancellationLib.hash(self.groupCancellation), ActionLib.hash(self.action)));\n    }\n}"
    },
    "@perennial/account/contracts/types/RelayedNonceCancellation.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct RelayedNonceCancellation {\n    /// @dev Message to relay to verifier, identifying the nonce to cancel\n    Common nonceCancellation;\n    /// @dev Common information for relayed actions\n    Action action;\n}\nusing RelayedNonceCancellationLib for RelayedNonceCancellation global;\n\n/// @title RelayedNonceCancellationLib\n/// @notice Library used to hash and verify action to relay a message to cancel a nonce\nlibrary RelayedNonceCancellationLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RelayedNonceCancellation(Common nonceCancellation,Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RelayedNonceCancellation memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, CommonLib.hash(self.nonceCancellation), ActionLib.hash(self.action)));\n    }\n}"
    },
    "@perennial/account/contracts/types/RelayedOperatorUpdate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { OperatorUpdate, OperatorUpdateLib } from \"@perennial/verifier/contracts/types/OperatorUpdate.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct RelayedOperatorUpdate {\n    /// @dev Message to relay to MarketFactory\n    OperatorUpdate operatorUpdate;\n    /// @dev Common information for relayed actions\n    Action action;\n}\nusing RelayedOperatorUpdateLib for RelayedOperatorUpdate global;\n\n/// @title RelayedOperatorUpdateLib\n/// @notice Library used to hash and verify action to relay a message to update an operator\nlibrary RelayedOperatorUpdateLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RelayedOperatorUpdate(OperatorUpdate operatorUpdate,Action action)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n        \"OperatorUpdate(AccessUpdate access,Common common)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RelayedOperatorUpdate memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, OperatorUpdateLib.hash(self.operatorUpdate), ActionLib.hash(self.action)));\n    }\n}\n"
    },
    "@perennial/account/contracts/types/RelayedSignerUpdate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { SignerUpdate, SignerUpdateLib } from \"@perennial/verifier/contracts/types/SignerUpdate.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct RelayedSignerUpdate {\n    /// @dev Message to relay to MarketFactory\n    SignerUpdate signerUpdate;\n    /// @dev Common information for relayed actions\n    Action action;\n}\nusing RelayedSignerUpdateLib for RelayedSignerUpdate global;\n\n/// @title RelayedSignerUpdateLib\n/// @notice Library used to hash and verify action to relay a message to update a signer\nlibrary RelayedSignerUpdateLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"RelayedSignerUpdate(SignerUpdate signerUpdate,Action action)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n        \"SignerUpdate(AccessUpdate access,Common common)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(RelayedSignerUpdate memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, SignerUpdateLib.hash(self.signerUpdate), ActionLib.hash(self.action)));\n    }\n}\n"
    },
    "@perennial/account/contracts/types/Withdrawal.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Action, ActionLib } from \"./Action.sol\";\n\nstruct Withdrawal {\n    /// @dev Quantity to transfer from account to owner; set to UFixed6.MAX for full withdrawal\n    UFixed6 amount;\n    /// @dev True unwrap DSU to USDC as needed to satisfy specified withdrawal amount\n    bool unwrap;\n    /// @dev Common information for collateral account actions;\n    /// set action.common.account to the owner of the collateral account\n    Action action;\n}\nusing WithdrawalLib for Withdrawal global;\n\n/// @title WithdrawalLib\n/// @notice Library used to hash and verify action to withdraw from a collateral account\nlibrary WithdrawalLib {\n    /// @dev Used to verify a signed message\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"Withdrawal(uint256 amount,bool unwrap,Action action)\"\n        \"Action(uint256 maxFee,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    /// @dev Used to create a signed message\n    function hash(Withdrawal memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.amount, self.unwrap, ActionLib.hash(self.action)));\n    }\n}"
    },
    "@perennial/core/contracts/interfaces/IMarket.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IInstance } from \"@equilibria/root/attribute/interfaces/IInstance.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Token18 } from \"@equilibria/root/token/types/Token18.sol\";\nimport { Intent } from \"@perennial/verifier/contracts/types/Intent.sol\";\nimport { IOracleProvider } from \"./IOracleProvider.sol\";\nimport { OracleVersion } from \"../types/OracleVersion.sol\";\nimport { MarketParameter } from \"../types/MarketParameter.sol\";\nimport { RiskParameter } from \"../types/RiskParameter.sol\";\nimport { Version } from \"../types/Version.sol\";\nimport { Local } from \"../types/Local.sol\";\nimport { Global } from \"../types/Global.sol\";\nimport { Position } from \"../types/Position.sol\";\nimport { Checkpoint } from \"../types/Checkpoint.sol\";\nimport { Order } from \"../types/Order.sol\";\nimport { Guarantee } from \"../types/Guarantee.sol\";\nimport { VersionAccumulationResult } from \"../libs/VersionLib.sol\";\nimport { CheckpointAccumulationResult } from \"../libs/CheckpointLib.sol\";\n\ninterface IMarket is IInstance {\n    struct MarketDefinition {\n        Token18 token;\n        IOracleProvider oracle;\n    }\n\n    struct Context {\n        address account;\n        MarketParameter marketParameter;\n        RiskParameter riskParameter;\n        OracleVersion latestOracleVersion;\n        uint256 currentTimestamp;\n        Global global;\n        Local local;\n        Position latestPositionGlobal;\n        Position latestPositionLocal;\n        Order pendingGlobal;\n        Order pendingLocal;\n    }\n\n    struct SettlementContext {\n        Version latestVersion;\n        Checkpoint latestCheckpoint;\n        OracleVersion orderOracleVersion;\n    }\n\n    struct UpdateContext {\n        bool operator;\n        bool signer;\n        address liquidator;\n        address orderReferrer;\n        UFixed6 orderReferralFee;\n        address guaranteeReferrer;\n        UFixed6 guaranteeReferralFee;\n        Order orderGlobal;\n        Order orderLocal;\n        Position currentPositionGlobal;\n        Position currentPositionLocal;\n        Guarantee guaranteeGlobal;\n        Guarantee guaranteeLocal;\n        UFixed6 collateralization;\n    }\n\n    event OrderCreated(address indexed account, Order order, Guarantee guarantee, address liquidator, address orderReferrer, address guaranteeReferrer);\n    event PositionProcessed(uint256 orderId, Order order, VersionAccumulationResult accumulationResult);\n    event AccountPositionProcessed(address indexed account, uint256 orderId, Order order, CheckpointAccumulationResult accumulationResult);\n    event BeneficiaryUpdated(address newBeneficiary);\n    event CoordinatorUpdated(address newCoordinator);\n    /// @notice Fee earned by an account was transferred from market to a receiver\n    /// @param account User who earned the fee\n    /// @param receiver Delegated operator of the account, or the account itself\n    /// @param amount Collateral transferred from market to receiver\n    event FeeClaimed(address indexed account, address indexed receiver, UFixed6 amount);\n    event ExposureClaimed(address indexed account, Fixed6 amount);\n    event ParameterUpdated(MarketParameter newParameter);\n    event RiskParameterUpdated(RiskParameter newRiskParameter);\n\n    // sig: 0x0fe90964\n    error MarketInsufficientLiquidityError();\n    // sig: 0x00e2b6a8\n    error MarketInsufficientMarginError();\n    // sig: 0x442145e5\n    error MarketInsufficientCollateralError();\n    // sig: 0xba555da7\n    error MarketProtectedError();\n    // sig: 0x6ed43d8e\n    error MarketMakerOverLimitError();\n    // sig: 0x29ab4c44\n    error MarketClosedError();\n    // sig: 0x07732aee\n    error MarketCollateralBelowLimitError();\n    // sig: 0x5bdace60\n    error MarketOperatorNotAllowedError();\n    // sig: 0x8a68c1dc\n    error MarketNotSingleSidedError();\n    // sig: 0x736f9fda\n    error MarketOverCloseError();\n    // sig: 0x935bdc21\n    error MarketExceedsPendingIdLimitError();\n    // sig: 0x9bca0625\n    error MarketNotCoordinatorError();\n    // sig: 0xb602d086\n    error MarketNotBeneficiaryError();\n    // sig: 0x3222db45\n    /// @custom:error Sender is not authorized to interact with markets on behalf of the account\n    error MarketNotOperatorError();\n    // sig: 0x534f7fe6\n    error MarketInvalidProtectionError();\n    // sig: 0xab1e3a00\n    error MarketStalePriceError();\n    // sig: 0x15f9ae70\n    error MarketEfficiencyUnderLimitError();\n    // sig: 0x7302d51a\n    error MarketInvalidMarketParameterError(uint256 code);\n    // sig: 0xc5f0e98a\n    error MarketInvalidRiskParameterError(uint256 code);\n    // sig: 0x9dbdc5fd\n    error MarketInvalidReferrerError();\n    // sig: 0x5c5cb438\n    error MarketSettleOnlyError();\n    // sig: 0x1e9d2296\n    error MarketInvalidIntentFeeError();\n    // sig: 0xaf5dfc8f\n    error MarketIntentPriceDeviationError();\n\n    // sig: 0x2142bc27\n    error GlobalStorageInvalidError();\n    // sig: 0xc83d08ec\n    error LocalStorageInvalidError();\n    // sig: 0x7c53e926\n    error MarketParameterStorageInvalidError();\n    // sig: 0x98eb4898\n    error PositionStorageLocalInvalidError();\n    // sig: 0x7ecd083f\n    error RiskParameterStorageInvalidError();\n    // sig: 0xd2777e72\n    error VersionStorageInvalidError();\n\n    function initialize(MarketDefinition calldata definition_) external;\n    function migrate() external;\n    function token() external view returns (Token18);\n    function oracle() external view returns (IOracleProvider);\n    function beneficiary() external view returns (address);\n    function coordinator() external view returns (address);\n    function positions(address account) external view returns (Position memory);\n    function pendingOrders(address account, uint256 id) external view returns (Order memory);\n    function guarantees(address account, uint256 id) external view returns (Guarantee memory);\n    function pendings(address account) external view returns (Order memory);\n    function locals(address account) external view returns (Local memory);\n    function versions(uint256 timestamp) external view returns (Version memory);\n    function position() external view returns (Position memory);\n    function pendingOrder(uint256 id) external view returns (Order memory);\n    function guarantee(uint256 id) external view returns (Guarantee memory);\n    function pending() external view returns (Order memory);\n    function global() external view returns (Global memory);\n    function checkpoints(address account, uint256 version) external view returns (Checkpoint memory);\n    function liquidators(address account, uint256 id) external view returns (address);\n    function orderReferrers(address account, uint256 id) external view returns (address);\n    function guaranteeReferrers(address account, uint256 id) external view returns (address);\n    function settle(address account) external;\n    function update(address account, Intent calldata intent, bytes memory signature) external;\n    function update(address account, Fixed6 amount, Fixed6 collateral, address referrer) external;\n    function update(address account, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect) external;\n    function update(address account, UFixed6 newMaker, UFixed6 newLong, UFixed6 newShort, Fixed6 collateral, bool protect, address referrer) external;\n    function parameter() external view returns (MarketParameter memory);\n    function riskParameter() external view returns (RiskParameter memory);\n    function updateBeneficiary(address newBeneficiary) external;\n    function updateCoordinator(address newCoordinator) external;\n    function updateParameter(MarketParameter memory newParameter) external;\n    function updateRiskParameter(RiskParameter memory newRiskParameter) external;\n    function claimFee(address account) external returns (UFixed6);\n}\n"
    },
    "@perennial/core/contracts/interfaces/IMarketFactory.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IFactory } from \"@equilibria/root/attribute/interfaces/IFactory.sol\";\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { IVerifier } from \"@perennial/verifier/contracts/interfaces/IVerifier.sol\";\nimport { OperatorUpdate } from \"@perennial/verifier/contracts/types/OperatorUpdate.sol\";\nimport { SignerUpdate } from \"@perennial/verifier/contracts/types/SignerUpdate.sol\";\nimport { AccessUpdate } from \"@perennial/verifier/contracts/types/AccessUpdate.sol\";\nimport { AccessUpdateBatch } from \"@perennial/verifier/contracts/types/AccessUpdateBatch.sol\";\nimport { ProtocolParameter } from \"../types/ProtocolParameter.sol\";\nimport { IMarket } from \"./IMarket.sol\";\nimport { IOracleProvider } from \"./IOracleProvider.sol\";\n\ninterface IMarketFactory is IFactory {\n    event ParameterUpdated(ProtocolParameter newParameter);\n    event ExtensionUpdated(address indexed operator, bool newEnabled);\n    event OperatorUpdated(address indexed account, address indexed operator, bool newEnabled);\n    event SignerUpdated(address indexed account, address indexed signer, bool newEnabled);\n    event ReferralFeeUpdated(address indexed referrer, UFixed6 newFee);\n    event MarketCreated(IMarket indexed market, IMarket.MarketDefinition definition);\n\n    // sig: 0x0a37dc74\n    error FactoryInvalidPayoffError();\n    // sig: 0x5116bce5\n    error FactoryInvalidOracleError();\n    // sig: 0x213e2260\n    error FactoryAlreadyRegisteredError();\n    // sig: 0x6928a80f\n    error MarketFactoryInvalidSignerError();\n    // sig: 0x199d4b3e\n    error MarketFactoryInvalidReferralFeeError();\n\n    // sig: 0x4dc1bc59\n    error ProtocolParameterStorageInvalidError();\n\n    function oracleFactory() external view returns (IFactory);\n    function verifier() external view returns (IVerifier);\n    function parameter() external view returns (ProtocolParameter memory);\n    function extensions(address extension) external view returns (bool);\n    function operators(address account, address operator) external view returns (bool);\n    function signers(address signer, address operator) external view returns (bool);\n    function referralFees(address referrer) external view returns (UFixed6);\n    function markets(IOracleProvider oracle) external view returns (IMarket);\n    function authorization(address account, address sender, address signer, address orderReferrer) external view returns (bool, bool, UFixed6);\n    function initialize() external;\n    function updateParameter(ProtocolParameter memory newParameter) external;\n    function updateExtension(address extension, bool newEnabled) external;\n    function updateOperator(address operator, bool newEnabled) external;\n    function updateOperatorWithSignature(OperatorUpdate calldata operatorUpdate, bytes calldata signature) external;\n    function updateSigner(address signer, bool newEnabled) external;\n    function updateSignerWithSignature(SignerUpdate calldata signerUpdate, bytes calldata signature) external;\n    function updateAccessBatch(AccessUpdate[] calldata operators, AccessUpdate[] calldata signers) external;\n    function updateAccessBatchWithSignature(AccessUpdateBatch calldata accessUpdateBatch, bytes calldata signature) external;\n    function updateReferralFee(address referrer, UFixed6 newReferralFee) external;\n    function create(IMarket.MarketDefinition calldata definition) external returns (IMarket);\n}\n"
    },
    "@perennial/core/contracts/interfaces/IOracleProvider.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { OracleReceipt } from \"../types/OracleReceipt.sol\";\nimport { OracleVersion } from \"../types/OracleVersion.sol\";\nimport { IMarket } from \"./IMarket.sol\";\n\n/// @dev OracleVersion Invariants\n///       - Version are requested at a timestamp, the current timestamp is determined by the oracle\n///         - The current timestamp may not be equal to block.timestamp, for example when batching timestamps\n///       - Versions are allowed to \"fail\" and will be marked as .valid = false\n///         - Invalid versions will always include the latest valid price as its price field\n///       - Versions must be committed in order, i.e. all requested versions prior to latestVersion must be available\n///       - Non-requested versions may be committed, but will not receive a settlement fee\n///         - This is useful for immediately liquidating an account with a valid off-chain price in between orders\n///         - Satisfying the above constraints, only versions more recent than the latest version may be committed\n///       - Current must always be greater than Latest, never equal\ninterface IOracleProvider {\n    // sig: 0x652fafab\n    error OracleProviderUnauthorizedError();\n\n    event OracleProviderVersionRequested(uint256 indexed version, bool newPrice);\n    event OracleProviderVersionFulfilled(OracleVersion version);\n\n    function request(IMarket market, address account) external;\n    function status() external view returns (OracleVersion memory, uint256);\n    function latest() external view returns (OracleVersion memory);\n    function current() external view returns (uint256);\n    function at(uint256 timestamp) external view returns (OracleVersion memory, OracleReceipt memory);\n}"
    },
    "@perennial/core/contracts/libs/CheckpointLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Accumulator6 } from \"@equilibria/root/accumulator/types/Accumulator6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { IMarket } from \"../interfaces/IMarket.sol\";\nimport { Position } from \"../types/Position.sol\";\nimport { Order } from \"../types/Order.sol\";\nimport { Version } from \"../types/Version.sol\";\nimport { Checkpoint } from \"../types/Checkpoint.sol\";\nimport { Guarantee } from \"../types/Guarantee.sol\";\n\nstruct CheckpointAccumulationResponse {\n    /// @dev Total Collateral change due to collateral, price override, and trade fee and offset\n    Fixed6 collateral;\n\n    /// @dev Liquidation fee accumulated for this checkpoint (only if the order is protected)\n    UFixed6 liquidationFee;\n\n    /// @dev Subtractive fee accumulated from the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 subtractiveFee;\n\n    /// @dev Solver fee accumulated the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 solverFee;\n}\n\nstruct CheckpointAccumulationResult {\n    /// @dev Total Collateral change due to pnl, funding, and interest from the previous position to the next position\n    Fixed6 collateral;\n\n    /// @dev Collateral change from the difference between the price override and underlying market price\n    Fixed6 priceOverride;\n\n    /// @dev Trade fee accumulated for this checkpoint\n    UFixed6 tradeFee;\n\n    /// @dev Trade price impact accumulated for this checkpoint\n    Fixed6 offset;\n\n    /// @dev Settlement fee charged for this checkpoint\n    UFixed6 settlementFee;\n\n    /// @dev Liquidation fee accumulated for this checkpoint (only if the order is protected)\n    UFixed6 liquidationFee;\n\n    /// @dev Subtractive fee accumulated from the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 subtractiveFee;\n\n    /// @dev Solver fee accumulated the previous position to the next position (this amount is included in the linear fee)\n    UFixed6 solverFee;\n}\n\n/// @title CheckpointLib\n/// @dev (external-safe): this library is safe to externalize\n/// @notice Manages the logic for the local order accumulation\nlibrary CheckpointLib {\n    /// @notice Accumulate pnl and fees from the latest position to next position\n    /// @param order The next order\n    /// @param fromVersion The previous latest version\n    /// @param toVersion The next latest version\n    /// @return next The next checkpoint\n    /// @return response The accumulated pnl and fees\n    function accumulate(\n        IMarket.Context memory context,\n        IMarket.SettlementContext memory settlementContext,\n        uint256 orderId,\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory fromVersion,\n        Version memory toVersion\n    ) external returns (Checkpoint memory next, CheckpointAccumulationResponse memory) {\n        CheckpointAccumulationResult memory result;\n\n        // accumulate\n        result.collateral = _accumulateCollateral(context.latestPositionLocal, fromVersion, toVersion);\n        result.priceOverride = _accumulatePriceOverride(guarantee, toVersion);\n        (result.tradeFee, result.subtractiveFee, result.solverFee) = _accumulateFee(order, guarantee, toVersion);\n        result.offset = _accumulateOffset(order, guarantee, toVersion);\n        result.settlementFee = _accumulateSettlementFee(order, guarantee, toVersion);\n        result.liquidationFee = _accumulateLiquidationFee(order, toVersion);\n\n        // update checkpoint\n        next.collateral = settlementContext.latestCheckpoint.collateral\n            .sub(settlementContext.latestCheckpoint.tradeFee)                       // trade fee processed post settlement\n            .sub(Fixed6Lib.from(settlementContext.latestCheckpoint.settlementFee)); // settlement / liquidation fee processed post settlement\n        next.collateral = next.collateral\n            .add(settlementContext.latestCheckpoint.transfer)                       // deposit / withdrawal processed post settlement\n            .add(result.collateral)                                                 // incorporate collateral change at this settlement\n            .add(result.priceOverride);                                             // incorporate price override pnl at this settlement\n        next.transfer = order.collateral;\n        next.tradeFee = Fixed6Lib.from(result.tradeFee).add(result.offset);\n        next.settlementFee = result.settlementFee.add(result.liquidationFee);\n\n        emit IMarket.AccountPositionProcessed(context.account, orderId, order, result);\n\n        return (next, _response(result));\n    }\n\n    /// @notice Converts the accumulation result into a response\n    /// @param result The accumulation result\n    /// @return response The accumulation response\n    function _response(\n        CheckpointAccumulationResult memory result\n    ) private pure returns (CheckpointAccumulationResponse memory response) {\n        response.collateral = result.collateral\n            .add(result.priceOverride)\n            .sub(Fixed6Lib.from(result.tradeFee))\n            .sub(result.offset)\n            .sub(Fixed6Lib.from(result.settlementFee));\n        response.liquidationFee = result.liquidationFee;\n        response.subtractiveFee = result.subtractiveFee;\n        response.solverFee = result.solverFee;\n    }\n\n    /// @notice Accumulate pnl, funding, and interest from the latest position to next position\n    /// @param fromPosition The previous latest position\n    /// @param fromVersion The previous latest version\n    /// @param toVersion The next version\n    function _accumulateCollateral(\n        Position memory fromPosition,\n        Version memory fromVersion,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        return toVersion.makerValue.accumulated(fromVersion.makerValue, fromPosition.maker)\n            .add(toVersion.longValue.accumulated(fromVersion.longValue, fromPosition.long))\n            .add(toVersion.shortValue.accumulated(fromVersion.shortValue, fromPosition.short));\n    }\n\n    /// @notice Accumulate trade fees for the next position\n    /// @param order The next order\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulateFee(\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (UFixed6 tradeFee, UFixed6 subtractiveFee, UFixed6 solverFee) {\n        UFixed6 takerTotal = order.takerTotal().sub(guarantee.takerFee);\n\n        // accumulate total trade fees on maker and taker orders\n        UFixed6 makerFee = Fixed6Lib.ZERO\n            .sub(toVersion.makerFee.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()))\n            .abs();\n        UFixed6 takerFee = Fixed6Lib.ZERO\n            .sub(toVersion.takerFee.accumulated(Accumulator6(Fixed6Lib.ZERO), takerTotal))\n            .abs();\n\n        // compute portion of trade fees that are subtractive\n        UFixed6 makerSubtractiveFee = order.makerTotal().isZero() ?\n            UFixed6Lib.ZERO :\n            makerFee.muldiv(order.makerReferral, order.makerTotal());\n        UFixed6 takerSubtractiveFee = takerTotal.isZero() ?\n            UFixed6Lib.ZERO :\n            takerFee.muldiv(order.takerReferral, takerTotal);\n\n        // compute portion of subtractive fees that are solver fees\n        solverFee = takerTotal.isZero() ?\n            UFixed6Lib.ZERO :\n            takerFee.muldiv(guarantee.referral, takerTotal); // guarantee.referral is instantiated as a subset of order.takerReferral\n\n        tradeFee = makerFee.add(takerFee);\n        subtractiveFee = makerSubtractiveFee.add(takerSubtractiveFee).sub(solverFee);\n\n    }\n\n    /// @notice Accumulate price offset for the next position\n    /// @dev This includes adjustment for linear, proportional, and adiabatic order fees\n    /// @param order The next order\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulateOffset(\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        (UFixed6 takerPos, UFixed6 takerNeg) =\n            (order.takerPos().sub(guarantee.takerPos), order.takerNeg().sub(guarantee.takerNeg));\n\n        return Fixed6Lib.ZERO\n            .sub(toVersion.makerOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), order.makerTotal()))\n            .sub(toVersion.takerPosOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), takerPos))\n            .sub(toVersion.takerNegOffset.accumulated(Accumulator6(Fixed6Lib.ZERO), takerNeg));\n    }\n\n\n    /// @notice Accumulate settlement fees for the next position\n    /// @param order The next order\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulateSettlementFee(\n        Order memory order,\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (UFixed6) {\n        uint256 orders = order.orders - guarantee.orders;\n\n        return toVersion.settlementFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.from(orders)).abs();\n    }\n\n    /// @notice Accumulate liquidation fees for the next position\n    /// @param order The next order\n    /// @param toVersion The next version\n    function _accumulateLiquidationFee(\n        Order memory order,\n        Version memory toVersion\n    ) private pure returns (UFixed6) {\n        if (!order.protected()) return UFixed6Lib.ZERO;\n        return toVersion.liquidationFee.accumulated(Accumulator6(Fixed6Lib.ZERO), UFixed6Lib.ONE).abs();\n    }\n\n    /// @notice Accumulate price override pnl for the next position\n    /// @param guarantee The next guarantee\n    /// @param toVersion The next version\n    function _accumulatePriceOverride(\n        Guarantee memory guarantee,\n        Version memory toVersion\n    ) private pure returns (Fixed6) {\n        if (!toVersion.valid) return Fixed6Lib.ZERO;\n        return guarantee.priceAdjustment(toVersion.price);\n    }\n}\n"
    },
    "@perennial/core/contracts/libs/VersionLib.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { IMarket } from \"../interfaces/IMarket.sol\";\nimport { MarketParameter } from \"../types/MarketParameter.sol\";\nimport { RiskParameter } from \"../types/RiskParameter.sol\";\nimport { Global } from \"../types/Global.sol\";\nimport { Position } from \"../types/Position.sol\";\nimport { Order } from \"../types/Order.sol\";\nimport { Guarantee } from \"../types/Guarantee.sol\";\nimport { Version } from \"../types/Version.sol\";\nimport { OracleVersion } from \"../types/OracleVersion.sol\";\nimport { OracleReceipt } from \"../types/OracleReceipt.sol\";\n\n/// @dev The response of the version accumulation\n///      Contains only select fee information needed for the downstream market contract\n///      Returned by the accumulate function\nstruct VersionAccumulationResponse {\n    /// @dev The total market fee charged including (tradeFee, tradeOffsetMarket, fundingFee, interestFee)\n    UFixed6 marketFee;\n\n    /// @dev The settlement fee charged\n    UFixed6 settlementFee;\n\n    /// @dev The market's adiabatic exposure\n    Fixed6 marketExposure;\n}\n\n/// @dev The result of the version accumulation\n///      Contains all the accumulated values for the version\n///      Emitted via the PositionProcessed event\nstruct VersionAccumulationResult {\n    /// @dev The trade fee charged\n    UFixed6 tradeFee;\n\n    /// @dev The subtractive fee charged\n    UFixed6 subtractiveFee;\n\n    /// @dev The total price impact of the trade (including linear, proportional, and adiabatic)\n    Fixed6 tradeOffset;\n\n    /// @dev The portion of the trade offset that the makers receive\n    Fixed6 tradeOffsetMaker;\n\n    /// @dev The portion of the trade offset that the market receives (if there are no makers)\n    UFixed6 tradeOffsetMarket;\n\n    /// @dev The adiabatic exposure accrued\n    Fixed6 adiabaticExposure;\n\n    /// @dev The adiabatic exposure accrued by makers\n    Fixed6 adiabaticExposureMaker;\n\n    /// @dev The adiabatic exposure accrued by the market\n    Fixed6 adiabaticExposureMarket;\n\n    /// @dev Funding accrued by makers\n    Fixed6 fundingMaker;\n\n    /// @dev Funding accrued by longs\n    Fixed6 fundingLong;\n\n    /// @dev Funding accrued by shorts\n    Fixed6 fundingShort;\n\n    /// @dev Funding received by the protocol\n    UFixed6 fundingFee;\n\n    /// @dev Interest accrued by makers\n    Fixed6 interestMaker;\n\n    /// @dev Interest accrued by longs\n    Fixed6 interestLong;\n\n    /// @dev Interest accrued by shorts\n    Fixed6 interestShort;\n\n    /// @dev Interest received by the protocol\n    UFixed6 interestFee;\n\n    /// @dev Price-based profit/loss accrued by makers\n    Fixed6 pnlMaker;\n\n    /// @dev Price-based profit/loss accrued by longs\n    Fixed6 pnlLong;\n\n    /// @dev Price-based profit/loss accrued by shorts\n    Fixed6 pnlShort;\n\n    /// @dev Total settlement fee charged\n    UFixed6 settlementFee;\n\n    /// @dev Snapshot of the riskParameter.liquidationFee at the version (0 if not valid)\n    UFixed6 liquidationFee;\n}\n\n/// @dev The in-memory context for the version accumulation\nstruct VersionAccumulationContext {\n    Global global;\n    Position fromPosition;\n    uint256 orderId;\n    Order order;\n    Guarantee guarantee;\n    OracleVersion fromOracleVersion;\n    OracleVersion toOracleVersion;\n    OracleReceipt toOracleReceipt;\n    MarketParameter marketParameter;\n    RiskParameter riskParameter;\n}\n\n/// @title VersionLib\n/// @dev (external-safe): this library is safe to externalize\n/// @notice Manages the logic for the global order accumulation\nlibrary VersionLib {\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\n    function accumulate(\n        IMarket.Context memory context,\n        IMarket.SettlementContext memory settlementContext,\n        uint256 newOrderId,\n        Order memory newOrder,\n        Guarantee memory newGuarantee,\n        OracleVersion memory oracleVersion,\n        OracleReceipt memory oracleReceipt\n    ) external returns (Version memory next, Global memory nextGlobal, VersionAccumulationResponse memory response) {\n        VersionAccumulationContext memory accumulationContext = VersionAccumulationContext(\n            context.global,\n            context.latestPositionGlobal,\n            newOrderId,\n            newOrder,\n            newGuarantee,\n            settlementContext.orderOracleVersion,\n            oracleVersion,\n            oracleReceipt,\n            context.marketParameter,\n            context.riskParameter\n        );\n\n        return _accumulate(settlementContext.latestVersion, accumulationContext);\n    }\n\n    /// @notice Accumulates the global state for the period from `fromVersion` to `toOracleVersion`\n    /// @param self The Version object to update\n    /// @param context The accumulation context\n    /// @return next The accumulated version\n    /// @return nextGlobal The next global state\n    /// @return response The accumulation response\n    function _accumulate(\n        Version memory self,\n        VersionAccumulationContext memory context\n    ) private returns (Version memory next, Global memory nextGlobal, VersionAccumulationResponse memory response) {\n        VersionAccumulationResult memory result;\n\n        // setup next accumulators\n        _next(self, next);\n\n        // record oracle version\n        (next.valid, next.price) = (context.toOracleVersion.valid, context.toOracleVersion.price);\n        context.global.latestPrice = context.toOracleVersion.price;\n\n        // accumulate settlement fee\n        result.settlementFee = _accumulateSettlementFee(next, context);\n\n        // accumulate liquidation fee\n        result.liquidationFee = _accumulateLiquidationFee(next, context);\n\n        // accumulate fee\n        _accumulateFee(next, context, result);\n\n        // accumulate linear fee\n        _accumulateLinearFee(next, context, result);\n\n        // accumulate proportional fee\n        _accumulateProportionalFee(next, context, result);\n\n        // accumulate adiabatic exposure\n        _accumulateAdiabaticExposure(next, context, result);\n\n        // accumulate adiabatic fee\n        _accumulateAdiabaticFee(next, context, result);\n\n        // if closed, don't accrue anything else\n        if (context.marketParameter.closed) return _return(context, result, next);\n\n        // accumulate funding\n        (result.fundingMaker, result.fundingLong, result.fundingShort, result.fundingFee) =\n            _accumulateFunding(next, context);\n\n        // accumulate interest\n        (result.interestMaker, result.interestLong, result.interestShort, result.interestFee) =\n            _accumulateInterest(next, context);\n\n        // accumulate P&L\n        (result.pnlMaker, result.pnlLong, result.pnlShort) = _accumulatePNL(next, context);\n\n        return _return(context, result, next);\n    }\n\n    function _return(\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result,\n        Version memory next\n    ) private returns (Version memory, Global memory, VersionAccumulationResponse memory) {\n        emit IMarket.PositionProcessed(context.orderId, context.order, result);\n\n        return (next, context.global, _response(result));\n    }\n\n    /// @notice Converts the accumulation result into a response\n    /// @param result The accumulation result\n    /// @return response The accumulation response\n    function _response(\n        VersionAccumulationResult memory result\n    ) private pure returns (VersionAccumulationResponse memory response) {\n        response.marketFee = result.tradeFee\n            .add(result.tradeOffsetMarket)\n            .add(result.fundingFee)\n            .add(result.interestFee);\n        response.settlementFee = result.settlementFee;\n        response.marketExposure = result.adiabaticExposureMarket;\n    }\n\n    /// @notice Copies over the version-over-version accumulators to prepare the next version\n    /// @param self The Version object to update\n    function _next(Version memory self, Version memory next) internal pure {\n        next.makerValue._value = self.makerValue._value;\n        next.longValue._value = self.longValue._value;\n        next.shortValue._value = self.shortValue._value;\n    }\n\n    /// @notice Globally accumulates settlement fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateSettlementFee(\n        Version memory next,\n        VersionAccumulationContext memory context\n    ) private pure returns (UFixed6 settlementFee) {\n        uint256 orders = context.order.orders - context.guarantee.orders;\n        settlementFee = orders == 0 ? UFixed6Lib.ZERO : context.toOracleReceipt.settlementFee;\n        next.settlementFee.decrement(Fixed6Lib.from(settlementFee), UFixed6Lib.from(orders));\n    }\n\n    /// @notice Globally accumulates hypothetical liquidation fee since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateLiquidationFee(\n        Version memory next,\n        VersionAccumulationContext memory context\n    ) private pure returns (UFixed6 liquidationFee) {\n        liquidationFee = context.toOracleVersion.valid ?\n            context.toOracleReceipt.settlementFee.mul(context.riskParameter.liquidationFee) :\n            UFixed6Lib.ZERO;\n        next.liquidationFee.decrement(Fixed6Lib.from(liquidationFee), UFixed6Lib.ONE);\n    }\n\n    /// @notice Globally accumulates linear fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateFee(\n        Version memory next,\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        UFixed6 makerFee = context.order.makerTotal()\n            .mul(context.toOracleVersion.price.abs())\n            .mul(context.marketParameter.makerFee);\n        next.makerFee.decrement(Fixed6Lib.from(makerFee), context.order.makerTotal());\n        UFixed6 makerSubtractiveFee = context.order.makerTotal().isZero() ?\n            UFixed6Lib.ZERO :\n            makerFee.muldiv(context.order.makerReferral, context.order.makerTotal());\n\n        UFixed6 takerTotal = context.order.takerTotal().sub(context.guarantee.takerFee);\n        UFixed6 takerFee = takerTotal\n            .mul(context.toOracleVersion.price.abs())\n            .mul(context.marketParameter.takerFee);\n        next.takerFee.decrement(Fixed6Lib.from(takerFee), takerTotal);\n        UFixed6 takerSubtractiveFee = takerTotal.isZero() ?\n            UFixed6Lib.ZERO :\n            takerFee.muldiv(context.order.takerReferral, takerTotal);\n\n        result.tradeFee = result.tradeFee.add(makerFee).add(takerFee).sub(makerSubtractiveFee).sub(takerSubtractiveFee);\n        result.subtractiveFee = result.subtractiveFee.add(makerSubtractiveFee).add(takerSubtractiveFee);\n    }\n\n    /// @notice Globally accumulates linear fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateLinearFee(\n        Version memory next,\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        UFixed6 makerLinearFee = context.riskParameter.makerFee.linear(\n            Fixed6Lib.from(context.order.makerTotal()),\n            context.toOracleVersion.price.abs()\n        );\n        next.makerOffset.decrement(Fixed6Lib.from(makerLinearFee), context.order.makerTotal());\n\n        UFixed6 takerPosTotal = context.order.takerPos().sub(context.guarantee.takerPos);\n        UFixed6 takerPosLinearFee = context.riskParameter.takerFee.linear(\n            Fixed6Lib.from(takerPosTotal),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerPosOffset.decrement(Fixed6Lib.from(takerPosLinearFee), takerPosTotal);\n\n        UFixed6 takerNegTotal = context.order.takerNeg().sub(context.guarantee.takerNeg);\n        UFixed6 takerNegLinearFee = context.riskParameter.takerFee.linear(\n            Fixed6Lib.from(takerNegTotal),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerNegOffset.decrement(Fixed6Lib.from(takerNegLinearFee), takerNegTotal);\n\n        UFixed6 linearFee = makerLinearFee.add(takerPosLinearFee).add(takerNegLinearFee);\n        UFixed6 marketFee = context.fromPosition.maker.isZero() ? linearFee : UFixed6Lib.ZERO;\n        UFixed6 makerFee = linearFee.sub(marketFee);\n        next.makerValue.increment(Fixed6Lib.from(makerFee), context.fromPosition.maker);\n\n        result.tradeOffset = result.tradeOffset.add(Fixed6Lib.from(linearFee));\n        result.tradeOffsetMaker = result.tradeOffsetMaker.add(Fixed6Lib.from(makerFee));\n        result.tradeOffsetMarket = result.tradeOffsetMarket.add(marketFee);\n    }\n\n    /// @notice Globally accumulates proportional fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateProportionalFee(\n        Version memory next,\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        UFixed6 makerProportionalFee = context.riskParameter.makerFee.proportional(\n            Fixed6Lib.from(context.order.makerTotal()),\n            context.toOracleVersion.price.abs()\n        );\n        next.makerOffset.decrement(Fixed6Lib.from(makerProportionalFee), context.order.makerTotal());\n\n        UFixed6 takerPos = context.order.takerPos().sub(context.guarantee.takerPos);\n        UFixed6 takerPosProportionalFee = context.riskParameter.takerFee.proportional(\n            Fixed6Lib.from(takerPos),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerPosOffset.decrement(Fixed6Lib.from(takerPosProportionalFee), takerPos);\n\n        UFixed6 takerNeg = context.order.takerNeg().sub(context.guarantee.takerNeg);\n        UFixed6 takerNegProportionalFee = context.riskParameter.takerFee.proportional(\n            Fixed6Lib.from(takerNeg),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerNegOffset.decrement(Fixed6Lib.from(takerNegProportionalFee), takerNeg);\n\n        UFixed6 proportionalFee = makerProportionalFee.add(takerPosProportionalFee).add(takerNegProportionalFee);\n        UFixed6 marketFee = context.fromPosition.maker.isZero() ? proportionalFee : UFixed6Lib.ZERO;\n        UFixed6 makerFee = proportionalFee.sub(marketFee);\n        next.makerValue.increment(Fixed6Lib.from(makerFee), context.fromPosition.maker);\n\n        result.tradeOffset = result.tradeOffset.add(Fixed6Lib.from(proportionalFee));\n        result.tradeOffsetMaker = result.tradeOffsetMaker.add(Fixed6Lib.from(makerFee));\n        result.tradeOffsetMarket = result.tradeOffsetMarket.add(marketFee);\n    }\n\n    /// @notice Globally accumulates adiabatic fees since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    function _accumulateAdiabaticFee(\n        Version memory next,\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        Fixed6 adiabaticFee;\n\n        // position fee from positive skew taker orders\n        UFixed6 takerPos = context.order.takerPos().sub(context.guarantee.takerPos);\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\n            context.fromPosition.skew(),\n            Fixed6Lib.from(takerPos),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerPosOffset.decrement(adiabaticFee, takerPos);\n        result.tradeOffset = result.tradeOffset.add(adiabaticFee);\n\n        // position fee from negative skew taker orders\n        UFixed6 takerNeg = context.order.takerNeg().sub(context.guarantee.takerNeg);\n        adiabaticFee = context.riskParameter.takerFee.adiabatic(\n            context.fromPosition.skew().add(Fixed6Lib.from(takerPos)),\n            Fixed6Lib.from(-1, takerNeg),\n            context.toOracleVersion.price.abs()\n        );\n        next.takerNegOffset.decrement(adiabaticFee, takerNeg);\n        result.tradeOffset = result.tradeOffset.add(adiabaticFee);\n    }\n\n    /// @notice Globally accumulates single component of the position fees exposure since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @param result The accumulation result\n    function _accumulateAdiabaticExposure(\n        Version memory next,\n        VersionAccumulationContext memory context,\n        VersionAccumulationResult memory result\n    ) private pure {\n        Fixed6 exposure = context.riskParameter.takerFee.exposure(context.fromPosition.skew());\n\n        Fixed6 adiabaticExposure = context.toOracleVersion.price.sub(context.fromOracleVersion.price).mul(exposure);\n        Fixed6 adiabaticExposureMaker = adiabaticExposure.mul(Fixed6Lib.NEG_ONE);\n        Fixed6 adiabaticExposureMarket = context.fromPosition.maker.isZero() ? adiabaticExposureMaker : Fixed6Lib.ZERO;\n        adiabaticExposureMaker = adiabaticExposureMaker.sub(adiabaticExposureMarket);\n        next.makerValue.increment(adiabaticExposureMaker, context.fromPosition.maker);\n\n        result.adiabaticExposure = adiabaticExposure;\n        result.adiabaticExposureMarket = adiabaticExposureMarket;\n        result.adiabaticExposureMaker = adiabaticExposureMaker;\n    }\n\n    /// @notice Globally accumulates all long-short funding since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return fundingMaker The total funding accrued by makers\n    /// @return fundingLong The total funding accrued by longs\n    /// @return fundingShort The total funding accrued by shorts\n    /// @return fundingFee The total fee accrued from funding accumulation\n    function _accumulateFunding(Version memory next, VersionAccumulationContext memory context) private pure returns (\n        Fixed6 fundingMaker,\n        Fixed6 fundingLong,\n        Fixed6 fundingShort,\n        UFixed6 fundingFee\n    ) {\n        Fixed6 toSkew = context.toOracleVersion.valid ?\n            context.fromPosition.skew().add(context.order.long()).sub(context.order.short()) :\n            context.fromPosition.skew();\n\n        // Compute long-short funding rate\n        Fixed6 funding = context.global.pAccumulator.accumulate(\n            context.riskParameter.pController,\n            toSkew.unsafeDiv(Fixed6Lib.from(context.riskParameter.takerFee.scale)).min(Fixed6Lib.ONE).max(Fixed6Lib.NEG_ONE),\n            context.fromOracleVersion.timestamp,\n            context.toOracleVersion.timestamp,\n            context.fromPosition.takerSocialized().mul(context.fromOracleVersion.price.abs())\n        );\n\n        // Handle maker receive-only status\n        if (context.riskParameter.makerReceiveOnly && funding.sign() != context.fromPosition.skew().sign())\n            funding = funding.mul(Fixed6Lib.NEG_ONE);\n\n        // Initialize long and short funding\n        (fundingLong, fundingShort) = (Fixed6Lib.NEG_ONE.mul(funding), funding);\n\n        // Compute fee spread\n        fundingFee = funding.abs().mul(context.marketParameter.fundingFee);\n        Fixed6 fundingSpread = Fixed6Lib.from(fundingFee).div(Fixed6Lib.from(2));\n\n        // Adjust funding with spread\n        (fundingLong, fundingShort) = (\n            fundingLong.sub(Fixed6Lib.from(fundingFee)).add(fundingSpread),\n            fundingShort.sub(fundingSpread)\n        );\n\n        // Redirect net portion of minor's side to maker\n        if (context.fromPosition.long.gt(context.fromPosition.short)) {\n            fundingMaker = fundingShort.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\n            fundingShort = fundingShort.sub(fundingMaker);\n        }\n        if (context.fromPosition.short.gt(context.fromPosition.long)) {\n            fundingMaker = fundingLong.mul(Fixed6Lib.from(context.fromPosition.socializedMakerPortion()));\n            fundingLong = fundingLong.sub(fundingMaker);\n        }\n\n        next.makerValue.increment(fundingMaker, context.fromPosition.maker);\n        next.longValue.increment(fundingLong, context.fromPosition.long);\n        next.shortValue.increment(fundingShort, context.fromPosition.short);\n    }\n\n    /// @notice Globally accumulates all maker interest since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return interestMaker The total interest accrued by makers\n    /// @return interestLong The total interest accrued by longs\n    /// @return interestShort The total interest accrued by shorts\n    /// @return interestFee The total fee accrued from interest accumulation\n    function _accumulateInterest(\n        Version memory next,\n        VersionAccumulationContext memory context\n    ) private pure returns (Fixed6 interestMaker, Fixed6 interestLong, Fixed6 interestShort, UFixed6 interestFee) {\n        UFixed6 notional = context.fromPosition.long.add(context.fromPosition.short).min(context.fromPosition.maker).mul(context.fromOracleVersion.price.abs());\n\n        // Compute maker interest\n        UFixed6 interest = context.riskParameter.utilizationCurve.accumulate(\n            context.fromPosition.utilization(context.riskParameter),\n            context.fromOracleVersion.timestamp,\n            context.toOracleVersion.timestamp,\n            notional\n        );\n\n        // Compute fee\n        interestFee = interest.mul(context.marketParameter.interestFee);\n\n        // Adjust long and short funding with spread\n        interestLong = Fixed6Lib.from(\n            context.fromPosition.major().isZero() ?\n            interest :\n            interest.muldiv(context.fromPosition.long, context.fromPosition.long.add(context.fromPosition.short))\n        );\n        interestShort = Fixed6Lib.from(interest).sub(interestLong);\n        interestMaker = Fixed6Lib.from(interest.sub(interestFee));\n\n        interestLong = interestLong.mul(Fixed6Lib.NEG_ONE);\n        interestShort = interestShort.mul(Fixed6Lib.NEG_ONE);\n        next.makerValue.increment(interestMaker, context.fromPosition.maker);\n        next.longValue.increment(interestLong, context.fromPosition.long);\n        next.shortValue.increment(interestShort, context.fromPosition.short);\n    }\n\n    /// @notice Globally accumulates position profit & loss since last oracle update\n    /// @param next The Version object to update\n    /// @param context The accumulation context\n    /// @return pnlMaker The total pnl accrued by makers\n    /// @return pnlLong The total pnl accrued by longs\n    /// @return pnlShort The total pnl accrued by shorts\n    function _accumulatePNL(\n        Version memory next,\n        VersionAccumulationContext memory context\n    ) private pure returns (Fixed6 pnlMaker, Fixed6 pnlLong, Fixed6 pnlShort) {\n        pnlLong = context.toOracleVersion.price.sub(context.fromOracleVersion.price)\n            .mul(Fixed6Lib.from(context.fromPosition.longSocialized()));\n        pnlShort = context.fromOracleVersion.price.sub(context.toOracleVersion.price)\n            .mul(Fixed6Lib.from(context.fromPosition.shortSocialized()));\n        pnlMaker = pnlLong.add(pnlShort).mul(Fixed6Lib.NEG_ONE);\n\n        next.longValue.increment(pnlLong, context.fromPosition.long);\n        next.shortValue.increment(pnlShort, context.fromPosition.short);\n        next.makerValue.increment(pnlMaker, context.fromPosition.maker);\n    }\n}\n"
    },
    "@perennial/core/contracts/types/Checkpoint.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\n\n/// @dev Checkpoint type\nstruct Checkpoint {\n    /// @dev The trade fee that the order incurred at the checkpoint settlement\n    Fixed6 tradeFee;\n\n    // @dev The settlement and liquidation fee that the order incurred at the checkpoint settlement\n    UFixed6 settlementFee;\n\n    /// @dev The amount deposited or withdrawn at the checkpoint settlement\n    Fixed6 transfer;\n\n    /// @dev The collateral at the time of the checkpoint settlement\n    Fixed6 collateral;\n}\nstruct CheckpointStorage { uint256 slot0; }\nusing CheckpointStorageLib for CheckpointStorage global;\n\n/// @dev Manually encodes and decodes the Checkpoint struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredCheckpoint {\n///         /* slot 0 */\n///         int48 tradeFee;\n///         uint48 settlementFee;\n///         int64 transfer;\n///         int64 collateral;\n///     }\n///\nlibrary CheckpointStorageLib {\n    // sig: 0xba85116a\n    error CheckpointStorageInvalidError();\n\n    function read(CheckpointStorage storage self) internal view returns (Checkpoint memory) {\n        uint256 slot0 = self.slot0;\n        return Checkpoint(\n            Fixed6.wrap(int256(slot0 << (256 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(slot0 << (256 - 48 - 48)) >> (256 - 48)),\n            Fixed6.wrap(int256(slot0 << (256 - 48 - 48 - 64)) >> (256 - 64)),\n            Fixed6.wrap(int256(slot0 << (256 - 48 - 48 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(CheckpointStorage storage self, Checkpoint memory newValue) external {\n        if (newValue.tradeFee.gt(Fixed6.wrap(type(int48).max))) revert CheckpointStorageInvalidError();\n        if (newValue.tradeFee.lt(Fixed6.wrap(type(int48).min))) revert CheckpointStorageInvalidError();\n        if (newValue.settlementFee.gt(UFixed6.wrap(type(uint48).max))) revert CheckpointStorageInvalidError();\n        if (newValue.transfer.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.transfer.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert CheckpointStorageInvalidError();\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert CheckpointStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(Fixed6.unwrap(newValue.tradeFee)        << (256 - 48)) >> (256 - 48) |\n            uint256(UFixed6.unwrap(newValue.settlementFee)  << (256 - 48)) >> (256 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.transfer)        << (256 - 64)) >> (256 - 48 - 48 - 64) |\n            uint256(Fixed6.unwrap(newValue.collateral)      << (256 - 64)) >> (256 - 48 - 48 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}\n"
    },
    "@perennial/core/contracts/types/Global.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { PAccumulator6 } from \"@equilibria/root/pid/types/PAccumulator6.sol\";\nimport { MarketParameter } from \"./MarketParameter.sol\";\nimport { RiskParameter } from \"./RiskParameter.sol\";\nimport { Position } from \"./Position.sol\";\nimport { OracleVersion } from \"./OracleVersion.sol\";\nimport { OracleReceipt } from \"./OracleReceipt.sol\";\nimport { VersionAccumulationResponse } from \"../libs/VersionLib.sol\";\n\n/// @dev Global type\nstruct Global {\n    /// @dev The current position ID\n    uint256 currentId;\n\n    /// @dev The latest position id\n    uint256 latestId;\n\n    /// @dev The accrued protocol fee\n    UFixed6 protocolFee;\n\n    /// @dev The accrued oracle fee\n    UFixed6 oracleFee;\n\n    /// @dev The accrued risk fee\n    UFixed6 riskFee;\n\n    /// @dev The latest valid price in the market\n    Fixed6 latestPrice;\n\n    /// @dev The accumulated market exposure\n    Fixed6 exposure;\n\n    /// @dev The current PAccumulator state\n    PAccumulator6 pAccumulator;\n}\nusing GlobalLib for Global global;\nstruct GlobalStorage { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing GlobalStorageLib for GlobalStorage global;\n\n/// @title Global\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the global market state\nlibrary GlobalLib {\n    /// @notice Updates market exposure based on a change in the risk parameter configuration\n    /// @param self The Global object to update\n    /// @param latestRiskParameter The latest risk parameter configuration\n    /// @param newRiskParameter The new risk parameter configuration\n    /// @param latestPosition The latest position\n    function update(\n        Global memory self,\n        RiskParameter memory latestRiskParameter,\n        RiskParameter memory newRiskParameter,\n        Position memory latestPosition\n    ) internal pure {\n        Fixed6 exposureChange = latestRiskParameter.takerFee\n            .exposure(newRiskParameter.takerFee, latestPosition.skew(), self.latestPrice.abs());\n        self.exposure = self.exposure.sub(exposureChange);\n    }\n\n    /// @notice Increments the fees by `amount` using current parameters\n    /// @dev Computes the fees based on the current market parameters\n    ///      market fee -> trade fee + market's trade offset + funding fee + interest fee\n    ///        1. oracle fee taken out as a percentage of what's left of market fee\n    ///        2. risk fee taken out as a percentage of what's left of market fee\n    ///        3. protocol fee is what's left of market fee\n    /// @param self The Global object to update\n    /// @param newLatestId The new latest position id\n    /// @param accumulation The accumulation result\n    /// @param marketParameter The current market parameters\n    /// @param oracleReceipt The receipt of the corresponding oracle version\n    function update(\n        Global memory self,\n        uint256 newLatestId,\n        VersionAccumulationResponse memory accumulation,\n        MarketParameter memory marketParameter,\n        OracleReceipt memory oracleReceipt\n    ) internal pure {\n        UFixed6 marketFee = accumulation.marketFee;\n\n        UFixed6 oracleFee = marketFee.mul(oracleReceipt.oracleFee);\n        marketFee = marketFee.sub(oracleFee);\n\n        UFixed6 riskFee = marketFee.mul(marketParameter.riskFee);\n        marketFee = marketFee.sub(riskFee);\n\n        self.latestId = newLatestId;\n        self.protocolFee = self.protocolFee.add(marketFee);\n        self.oracleFee = self.oracleFee.add(accumulation.settlementFee).add(oracleFee);\n        self.riskFee = self.riskFee.add(riskFee);\n        self.exposure = self.exposure.add(accumulation.marketExposure);\n    }\n\n    /// @notice Overrides the price of the oracle with the latest global version if it is empty\n    /// @param self The Global object to read from\n    /// @param oracleVersion The oracle version to update\n    function overrideIfZero(Global memory self, OracleVersion memory oracleVersion) internal pure {\n        if (oracleVersion.price.isZero()) oracleVersion.price = self.latestPrice;\n    }\n}\n\n/// @dev Manually encodes and decodes the Global struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredGlobal {\n///         /* slot 0 */\n///         uint32 currentId;           // <= 4.29b\n///         uint32 latestId;            // <= 4.29b\n///         uint48 protocolFee;         // <= 281m\n///         uint48 oracleFee;           // <= 281m\n///         uint48 riskFee;             // <= 281m\n///\n///         /* slot 1 */\n///         int32 pAccumulator.value;   // <= 214000%\n///         int24 pAccumulator.skew;    // <= 838%\n///         int64 latestPrice;          // <= 9.22t\n///         int64 exposure;             // <= 9.22t\n///     }\n///\nlibrary GlobalStorageLib {\n    // sig: 0x2142bc27\n    error GlobalStorageInvalidError();\n\n    function read(GlobalStorage storage self) internal view returns (Global memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n        return Global(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 48 - 48 - 48)) >> (256 - 48)),\n            Fixed6.wrap(int256(slot1 << (256 - 32 - 24 - 64)) >> (256 - 64)),\n            Fixed6.wrap(int256(slot1 << (256 - 32 - 24 - 64 - 64)) >> (256 - 64)),\n            PAccumulator6(\n                Fixed6.wrap(int256(slot1 << (256 - 32)) >> (256 - 32)),\n                Fixed6.wrap(int256(slot1 << (256 - 32 - 24)) >> (256 - 24))\n            )\n        );\n    }\n\n    function store(GlobalStorage storage self, Global memory newValue) external {\n        if (newValue.currentId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\n        if (newValue.latestId > uint256(type(uint32).max)) revert GlobalStorageInvalidError();\n        if (newValue.protocolFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\n        if (newValue.oracleFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\n        if (newValue.riskFee.gt(UFixed6.wrap(type(uint48).max))) revert GlobalStorageInvalidError();\n        if (newValue.latestPrice.gt(Fixed6.wrap(type(int64).max))) revert GlobalStorageInvalidError();\n        if (newValue.latestPrice.lt(Fixed6.wrap(type(int64).min))) revert GlobalStorageInvalidError();\n        if (newValue.exposure.gt(Fixed6.wrap(type(int64).max))) revert GlobalStorageInvalidError();\n        if (newValue.exposure.lt(Fixed6.wrap(type(int64).min))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._value.gt(Fixed6.wrap(type(int32).max))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._value.lt(Fixed6.wrap(type(int32).min))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._skew.gt(Fixed6.wrap(type(int24).max))) revert GlobalStorageInvalidError();\n        if (newValue.pAccumulator._skew.lt(Fixed6.wrap(type(int24).min))) revert GlobalStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(UFixed6.unwrap(newValue.protocolFee) << (256 - 48)) >> (256 - 32 - 32 - 48) |\n            uint256(UFixed6.unwrap(newValue.oracleFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48) |\n            uint256(UFixed6.unwrap(newValue.riskFee) << (256 - 48)) >> (256 - 32 - 32 - 48 - 48 - 48);\n\n        uint256 encoded1 =\n            uint256(Fixed6.unwrap(newValue.pAccumulator._value) << (256 - 32)) >> (256 - 32) |\n            uint256(Fixed6.unwrap(newValue.pAccumulator._skew) << (256 - 24)) >> (256 - 32 - 24) |\n            uint256(Fixed6.unwrap(newValue.latestPrice) << (256 - 64)) >> (256 - 32 - 24 - 64) |\n            uint256(Fixed6.unwrap(newValue.exposure) << (256 - 64)) >> (256 - 32 - 24 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}\n"
    },
    "@perennial/core/contracts/types/Guarantee.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Order } from \"./Order.sol\";\n\n/// @dev Guarantee type\nstruct Guarantee {\n    /// @dev The quantity of guarantees that that will be exempt from the settlement fee\n    uint256 orders;\n\n    /// @dev The notional of the magnitude with the price override (local only)\n    Fixed6 notional;\n\n    /// @dev The positive skew (open long / close short) guarantee size\n    UFixed6 takerPos;\n\n    /// @dev The negative skew (close long / open short) guarantee size\n    UFixed6 takerNeg;\n\n    /// @dev The magnitude of the guarantee that be exempt from the trade fee\n    UFixed6 takerFee;\n\n    /// @dev The referral fee multiplied by the size applicable to the referral (local only)\n    UFixed6 referral;\n}\nusing GuaranteeLib for Guarantee global;\nstruct GuaranteeStorageGlobal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing GuaranteeStorageGlobalLib for GuaranteeStorageGlobal global;\nstruct GuaranteeStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing GuaranteeStorageLocalLib for GuaranteeStorageLocal global;\n\n/// @title Guarantee\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the state for an account's update guarantee\nlibrary GuaranteeLib {\n    /// @notice Prepares the next guarantee from the current guarantee\n    /// @param self The guarantee object to update\n    function next(Guarantee memory self) internal pure  {\n        invalidate(self);\n        self.orders = 0;\n    }\n\n    /// @notice Invalidates the guarantee\n    /// @param self The guarantee object to update\n    function invalidate(Guarantee memory self) internal pure {\n        (self.takerPos, self.takerNeg, self.notional, self.takerFee, self.referral) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, Fixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Creates a new guarantee from an order\n    /// @param order The order to create the guarantee from\n    /// @param priceOverride The price override\n    /// @param referralFee The the percentage of the subtractive fee to take as a solver referral fee\n    /// @param chargeSettlementFee Whether the order will still be charged the settlement fee\n    /// @param chargeTradeFee Whether the order will still be charged the trade fee\n    /// @return newGuarantee The resulting guarantee\n    function from(\n        Order memory order,\n        Fixed6 priceOverride,\n        UFixed6 referralFee,\n        bool chargeSettlementFee,\n        bool chargeTradeFee\n    ) internal pure returns (Guarantee memory newGuarantee) {\n        // maker orders and one intent order per fill will be required to pay the settlement fee\n        if (!order.takerTotal().isZero() && !chargeSettlementFee) newGuarantee.orders = order.orders;\n\n        (newGuarantee.takerPos, newGuarantee.takerNeg) =\n            (order.longPos.add(order.shortNeg), order.longNeg.add(order.shortPos));\n        newGuarantee.takerFee = chargeTradeFee ? UFixed6Lib.ZERO : order.takerTotal();\n\n        newGuarantee.notional = taker(newGuarantee).mul(priceOverride);\n        newGuarantee.referral = order.takerReferral.mul(referralFee);\n    }\n\n    /// @notice Returns the taker delta of the guarantee\n    /// @param self The guarantee object to check\n    /// @return The taker delta of the guarantee\n    function taker(Guarantee memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.takerPos).sub(Fixed6Lib.from(self.takerNeg));\n    }\n\n    /// @notice Returns the total taker delta of the guarantee\n    /// @param self The guarantee object to check\n    /// @return The total taker delta of the guarantee\n    function takerTotal(Guarantee memory self) internal pure returns (UFixed6) {\n        return self.takerPos.add(self.takerNeg);\n    }\n\n    /// @notice Returns the collateral adjusted due to the price override\n    /// @param self The guarantee object to check\n    /// @param price The oracle price to compare to the price override\n    /// @return The collateral adjusted due to the price override\n    function priceAdjustment(Guarantee memory self, Fixed6 price) internal pure returns (Fixed6) {\n        return self.taker().mul(price).sub(self.notional);\n    }\n\n    /// @notice Returns the price deviation of the guarantee from the oracle price\n    /// @dev The price deviation is the difference between the prices over the closest price to zero\n    ///      Only supports new guarantees for updates, does not work for aggregated guarantees (local / global)\n    /// @param self The guarantee object to check\n    /// @param price The oracle price to compare\n    /// @return The price deviation of the guarantee from the oracle price\n    function priceDeviation(Guarantee memory self, Fixed6 price) internal pure returns (UFixed6) {\n        if (takerTotal(self).isZero()) return UFixed6Lib.ZERO;\n\n        Fixed6 guaranteePrice = self.notional.div(taker(self));\n        return guaranteePrice.sub(price).abs().unsafeDiv(guaranteePrice.abs().min(price.abs()));\n    }\n\n    /// @notice Updates the current global guarantee with a new local guarantee\n    /// @param self The guarantee object to update\n    /// @param guarantee The new guarantee\n    function add(Guarantee memory self, Guarantee memory guarantee) internal pure {\n        self.orders = self.orders + guarantee.orders;\n        (self.notional, self.takerPos, self.takerNeg, self.takerFee, self.referral) = (\n            self.notional.add(guarantee.notional),\n            self.takerPos.add(guarantee.takerPos),\n            self.takerNeg.add(guarantee.takerNeg),\n            self.takerFee.add(guarantee.takerFee),\n            self.referral.add(guarantee.referral)\n        );\n    }\n}\n\n/// @dev Manually encodes and decodes the global Guarantee struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredGuaranteeGlobal {\n///         /* slot 0 */\n///         uint32 orders;\n///         uint64 takerPos;\n///         uint64 takerNeg;\n///         uint64 takerFee;\n///     }\n///\nlibrary GuaranteeStorageGlobalLib {\n    function read(GuaranteeStorageGlobal storage self) internal view returns (Guarantee memory) {\n        uint256 slot0 = self.slot0;\n        return Guarantee(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            Fixed6Lib.ZERO,\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6Lib.ZERO\n        );\n    }\n\n    function store(GuaranteeStorageGlobal storage self, Guarantee memory newValue) internal {\n        GuaranteeStorageLib.validate(newValue);\n\n        uint256 encoded0 =\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32) |\n            uint256(UFixed6.unwrap(newValue.takerPos) << (256 - 64)) >> (256 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerNeg) << (256 - 64)) >> (256 - 32 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 64)) >> (256 - 32 - 64 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}\n\n/// @dev Manually encodes and decodes the local Guarantee struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredGuaranteeLocal {\n///         /* slot 0 */\n///         uint32 orders;\n///         int64 notional;\n///         uint64 takerPos;\n///         uint64 takerNeg;\n///\n///         /* slot 1 */\n///         uint64 takerFee;\n///         uint64 referral;\n///     }\n///\nlibrary GuaranteeStorageLocalLib {\n    function read(GuaranteeStorageLocal storage self) internal view returns (Guarantee memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n        return Guarantee(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(GuaranteeStorageLocal storage self, Guarantee memory newValue) internal {\n        GuaranteeStorageLib.validate(newValue);\n\n        if (newValue.notional.gt(Fixed6.wrap(type(int64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.notional.lt(Fixed6.wrap(type(int64).min))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.referral.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32) |\n            uint256(Fixed6.unwrap(newValue.notional) << (256 - 64)) >> (256 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerPos) << (256 - 64)) >> (256 - 32 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerNeg) << (256 - 64)) >> (256 - 32 - 64 - 64 - 64);\n        uint256 encode1 =\n            uint256(UFixed6.unwrap(newValue.takerFee) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.referral) << (256 - 64)) >> (256 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encode1)\n        }\n    }\n}\n\nlibrary GuaranteeStorageLib {\n    // sig: 0xfd030f36\n    error GuaranteeStorageInvalidError();\n\n    function validate(Guarantee memory newValue) internal pure {\n        if (newValue.orders > type(uint32).max) revert GuaranteeStorageInvalidError();\n        if (newValue.takerPos.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.takerNeg.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n        if (newValue.takerFee.gt(UFixed6.wrap(type(uint64).max))) revert GuaranteeStorageLib.GuaranteeStorageInvalidError();\n    }\n}"
    },
    "@perennial/core/contracts/types/Local.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { CheckpointAccumulationResponse } from \"../libs/CheckpointLib.sol\";\n\n/// @dev Local type\nstruct Local {\n    /// @dev The current position id\n    uint256 currentId;\n\n    /// @dev The latest position id\n    uint256 latestId;\n\n    /// @dev The collateral balance\n    Fixed6 collateral;\n\n    /// @dev The claimable balance\n    UFixed6 claimable;\n}\nusing LocalLib for Local global;\nstruct LocalStorage { uint256 slot0; uint256 slot1; }\nusing LocalStorageLib for LocalStorage global;\n\n/// @title Local\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the local account state\nlibrary LocalLib {\n    /// @notice Updates the collateral with the new deposit or withdrwal\n    /// @param self The Local object to update\n    /// @param transfer The amount to update the collateral by\n    function update(Local memory self, Fixed6 transfer) internal pure {\n        self.collateral = self.collateral.add(transfer);\n    }\n\n    /// @notice Updates the collateral with the new collateral change\n    /// @param self The Local object to update\n    /// @param accumulation The accumulation result\n    function update(\n        Local memory self,\n        uint256 newId,\n        CheckpointAccumulationResponse memory accumulation\n    ) internal pure {\n        self.collateral = self.collateral.add(accumulation.collateral).sub(Fixed6Lib.from(accumulation.liquidationFee));\n        self.latestId = newId;\n    }\n\n    /// @notice Updates the claimable with the new amount\n    /// @param self The Local object to update\n    /// @param amount The amount to update the claimable by\n    function credit(Local memory self, UFixed6 amount) internal pure {\n        self.claimable = self.claimable.add(amount);\n    }\n}\n\n/// @dev Manually encodes and decodes the Local struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredLocal {\n///         /* slot 0 */\n///         uint32 currentId;       // <= 4.29b\n///         uint32 latestId;        // <= 4.29b\n///         int64 collateral;       // <= 9.22t\n///         uint64 claimable;       // <= 18.44t\n///         bytes4 __DEPRECATED;    // UNSAFE UNTIL RESET\n///     }\n///\nlibrary LocalStorageLib {\n    // sig: 0xc83d08ec\n    error LocalStorageInvalidError();\n\n    function read(LocalStorage storage self) internal view returns (Local memory) {\n        uint256 slot0 = self.slot0;\n        return Local(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(LocalStorage storage self, Local memory newValue) internal {\n        if (newValue.currentId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\n        if (newValue.latestId > uint256(type(uint32).max)) revert LocalStorageInvalidError();\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert LocalStorageInvalidError();\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert LocalStorageInvalidError();\n        if (newValue.claimable.gt(UFixed6.wrap(type(uint64).max))) revert LocalStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.currentId << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.latestId << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.claimable) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}"
    },
    "@perennial/core/contracts/types/MarketParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { ProtocolParameter } from \"./ProtocolParameter.sol\";\n\n/// @dev MarketParameter type\nstruct MarketParameter {\n    /// @dev The fee that is taken out of funding\n    UFixed6 fundingFee;\n\n    /// @dev The fee that is taken out of interest\n    UFixed6 interestFee;\n\n    /// @dev The fee that is taken out of maker and taker fees\n    UFixed6 makerFee;\n\n    /// @dev The fee that is taken out of maker and taker fees\n    UFixed6 takerFee;\n\n    /// @dev The share of the collected fees that is paid to the risk coordinator\n    UFixed6 riskFee;\n\n    /// @dev The maximum amount of orders that can be pending at one time globally\n    uint256 maxPendingGlobal;\n\n    /// @dev The maximum amount of orders that can be pending at one time per account\n    uint256 maxPendingLocal;\n\n    /// @dev The maximum deviation percentage from the oracle price that is allowed for an intent price override\n    UFixed6 maxPriceDeviation;\n\n    /// @dev Whether the market is in close-only mode\n    bool closed;\n\n     /// @dev Whether the market is in settle-only mode\n    bool settle;\n}\nstruct MarketParameterStorage { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing MarketParameterStorageLib for MarketParameterStorage global;\n\n/// @dev Manually encodes and decodes the MarketParameter struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///    struct StoredMarketParameter {\n///        /* slot 0 */\n///        uint24 fundingFee;          // <= 1677%\n///        uint24 interestFee;         // <= 1677%\n///        uint24 makerFee;            // <= 1677%\n///        uint24 takerFee;            // <= 1677%\n///        uint24 riskFee;             // <= 1677%\n///        uint16 maxPendingGlobal;    // <= 65k\n///        uint16 maxPendingLocal;     // <= 65k\n///        uint24 maxPriceDeviation;   // <= 1677%\n///        uint24 __unallocated__;\n///        uint8 flags;\n///    }\n///\nlibrary MarketParameterStorageLib {\n    // sig: 0x7c53e926\n    error MarketParameterStorageInvalidError();\n\n    function read(MarketParameterStorage storage self) internal view returns (MarketParameter memory) {\n        uint256 slot0 = self.slot0;\n\n        uint256 flags = uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 24 - 24 - 8)) >> (256 - 8);\n        (bool closed, bool settle) =\n            (flags & 0x04 == 0x04, flags & 0x08 == 0x08);\n\n        return MarketParameter(\n            UFixed6.wrap(uint256(slot0 << (256 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                         uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16)) >> (256 - 16),\n                         uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16)) >> (256 - 16),\n            UFixed6.wrap(uint256(slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 24)) >> (256 - 24)),\n            closed,\n            settle\n        );\n    }\n\n    function validate(MarketParameter memory self, ProtocolParameter memory protocolParameter) private pure {\n        if (self.fundingFee.max(self.interestFee).max(self.makerFee).max(self.takerFee).gt(protocolParameter.maxCut))\n            revert MarketParameterStorageInvalidError();\n\n        if (self.riskFee.gt(UFixed6Lib.ONE))\n            revert MarketParameterStorageInvalidError();\n    }\n\n    function validateAndStore(\n        MarketParameterStorage storage self,\n        MarketParameter memory newValue,\n        ProtocolParameter memory protocolParameter\n    ) external {\n        validate(newValue, protocolParameter);\n\n        if (newValue.maxPendingGlobal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\n        if (newValue.maxPendingLocal > uint256(type(uint16).max)) revert MarketParameterStorageInvalidError();\n        if (newValue.maxPriceDeviation.gt(UFixed6.wrap(type(uint24).max))) revert MarketParameterStorageInvalidError();\n\n        _store(self, newValue);\n    }\n\n    function _store(MarketParameterStorage storage self, MarketParameter memory newValue) private {\n        uint256 flags = (newValue.closed ? 0x04 : 0x00) |\n            (newValue.settle ? 0x08 : 0x00);\n\n        uint256 encoded0 =\n            uint256(UFixed6.unwrap(newValue.fundingFee)         << (256 - 24)) >> (256 - 24) |\n            uint256(UFixed6.unwrap(newValue.interestFee)        << (256 - 24)) >> (256 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.makerFee)           << (256 - 24)) >> (256 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.takerFee)           << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.riskFee)            << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24) |\n            uint256(newValue.maxPendingGlobal                   << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16) |\n            uint256(newValue.maxPendingLocal                    << (256 - 16)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16) |\n            uint256(UFixed6.unwrap(newValue.maxPriceDeviation)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 24) |\n            uint256(flags                                       << (256 - 8))  >> (256 - 24 - 24 - 24 - 24 - 24 - 16 - 16 - 24 - 24 - 8);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n}"
    },
    "@perennial/core/contracts/types/OracleReceipt.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev The cost receipt of for a corresponding oracle version\nstruct OracleReceipt {\n    /// @dev The fixed settlement fee of the request\n    UFixed6 settlementFee;\n\n    /// @dev The relative oracle fee percentage of the request\n    UFixed6 oracleFee;\n}\n"
    },
    "@perennial/core/contracts/types/OracleVersion.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\n\n/// @dev A singular oracle version with its corresponding data\nstruct OracleVersion {\n    /// @dev the timestamp of the oracle update\n    uint256 timestamp;\n\n    /// @dev The oracle price of the corresponding version\n    Fixed6 price;\n\n    /// @dev Whether the version is valid\n    bool valid;\n}\n"
    },
    "@perennial/core/contracts/types/Order.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { OracleVersion } from \"./OracleVersion.sol\";\nimport { Position } from \"./Position.sol\";\nimport { MarketParameter } from \"./MarketParameter.sol\";\n\n/// @dev Order type\nstruct Order {\n    /// @dev The timestamp of the order\n    uint256 timestamp;\n\n    /// @dev The quantity of orders that are included in this order\n    uint256 orders;\n\n    /// @dev The change in the collateral\n    Fixed6 collateral;\n\n    /// @dev The positive skew maker order size\n    UFixed6 makerPos;\n\n    /// @dev The negative skew maker order size\n    UFixed6 makerNeg;\n\n    /// @dev The positive skew long order size\n    UFixed6 longPos;\n\n    /// @dev The negative skew long order size\n    UFixed6 longNeg;\n\n    /// @dev The positive skew short order size\n    UFixed6 shortPos;\n\n    /// @dev The negative skew short order size\n    UFixed6 shortNeg;\n\n    /// @dev The protection status semaphore (local only)\n    uint256 protection;\n\n    /// @dev The referral fee multiplied by the size applicable to the referral\n    UFixed6 makerReferral;\n\n    /// @dev The referral fee multiplied by the size applicable to the referral\n    UFixed6 takerReferral;\n}\nusing OrderLib for Order global;\nstruct OrderStorageGlobal { uint256 slot0; uint256 slot1; uint256 slot2; } // SECURITY: must remain at (3) slots\nusing OrderStorageGlobalLib for OrderStorageGlobal global;\nstruct OrderStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing OrderStorageLocalLib for OrderStorageLocal global;\n\n/// @title Order\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the state for an account's update order\nlibrary OrderLib {\n    /// @notice Returns whether the order is ready to be settled\n    /// @param self The order object to check\n    /// @param latestVersion The latest oracle version\n    /// @return Whether the order is ready to be settled\n    function ready(Order memory self, OracleVersion memory latestVersion) internal pure returns (bool) {\n        return latestVersion.timestamp >= self.timestamp;\n    }\n\n    /// @notice Prepares the next order from the current order\n    /// @param self The order object to update\n    /// @param timestamp The current timestamp\n    function next(Order memory self, uint256 timestamp) internal pure  {\n        invalidate(self);\n        (self.timestamp, self.orders, self.collateral, self.protection) = (timestamp, 0, Fixed6Lib.ZERO, 0);\n    }\n\n    /// @notice Invalidates the order\n    /// @param self The order object to update\n    function invalidate(Order memory self) internal pure {\n        (self.makerReferral, self.takerReferral) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) =\n            (UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Creates a new order from the an intent order request\n    /// @param timestamp The current timestamp\n    /// @param position The current position\n    /// @param amount The magnitude and direction of the order\n    /// @param collateral The change in the collateral\n    /// @param referralFee The referral fee\n    /// @return newOrder The resulting order\n    function from(\n        uint256 timestamp,\n        Position memory position,\n        Fixed6 amount,\n        Fixed6 collateral,\n        UFixed6 referralFee\n    ) internal pure returns (Order memory newOrder) {\n        newOrder.timestamp = timestamp;\n        newOrder.collateral = collateral;\n        newOrder.orders = amount.isZero() ? 0 : 1;\n        newOrder.takerReferral = amount.abs().mul(referralFee);\n\n        // If the order is not counter to the current position, it is opening\n        if (amount.sign() == 0 || position.skew().sign() == 0 || position.skew().sign() == amount.sign()) {\n            newOrder.longPos = amount.max(Fixed6Lib.ZERO).abs();\n            newOrder.shortPos = amount.min(Fixed6Lib.ZERO).abs();\n\n        // If the order is counter to the current position, it is closing\n        } else {\n            newOrder.shortNeg = amount.max(Fixed6Lib.ZERO).abs();\n            newOrder.longNeg = amount.min(Fixed6Lib.ZERO).abs();\n        }\n    }\n\n    /// @notice Creates a new order from the current position and an update request\n    /// @param timestamp The current timestamp\n    /// @param position The current position\n    /// @param collateral The change in the collateral\n    /// @param newMaker The new maker\n    /// @param newLong The new long\n    /// @param newShort The new short\n    /// @param protect Whether to protect the order\n    /// @param referralFee The referral fee\n    /// @return newOrder The resulting order\n    function from(\n        uint256 timestamp,\n        Position memory position,\n        Fixed6 collateral,\n        UFixed6 newMaker,\n        UFixed6 newLong,\n        UFixed6 newShort,\n        bool protect,\n        UFixed6 referralFee\n    ) internal pure returns (Order memory newOrder) {\n        (Fixed6 makerAmount, Fixed6 longAmount, Fixed6 shortAmount) = (\n            Fixed6Lib.from(newMaker).sub(Fixed6Lib.from(position.maker)),\n            Fixed6Lib.from(newLong).sub(Fixed6Lib.from(position.long)),\n            Fixed6Lib.from(newShort).sub(Fixed6Lib.from(position.short))\n        );\n\n        UFixed6 referral = makerAmount.abs().add(longAmount.abs()).add(shortAmount.abs()).mul(referralFee);\n\n        newOrder = Order(\n            timestamp,\n            0,\n            collateral,\n            makerAmount.max(Fixed6Lib.ZERO).abs(),\n            makerAmount.min(Fixed6Lib.ZERO).abs(),\n            longAmount.max(Fixed6Lib.ZERO).abs(),\n            longAmount.min(Fixed6Lib.ZERO).abs(),\n            shortAmount.max(Fixed6Lib.ZERO).abs(),\n            shortAmount.min(Fixed6Lib.ZERO).abs(),\n            protect ? 1 : 0,\n            makerAmount.isZero() ? UFixed6Lib.ZERO : referral,\n            makerAmount.isZero() ? referral : UFixed6Lib.ZERO\n        );\n        if (!isEmpty(newOrder)) newOrder.orders = 1;\n    }\n\n    /// @notice Returns whether the order increases any of the account's positions\n    /// @return Whether the order increases any of the account's positions\n    function increasesPosition(Order memory self) internal pure returns (bool) {\n        return increasesMaker(self) || increasesTaker(self);\n    }\n\n    /// @notice Returns whether the order increases the account's long or short positions\n    /// @return Whether the order increases the account's long or short positions\n    function increasesTaker(Order memory self) internal pure returns (bool) {\n        return !self.longPos.isZero() || !self.shortPos.isZero();\n    }\n\n    /// @notice Returns whether the order increases the account's maker position\n    /// @return Whether the order increases the account's maker positions\n    function increasesMaker(Order memory self) internal pure returns (bool) {\n        return !self.makerPos.isZero();\n    }\n\n    /// @notice Returns whether the order decreases the liquidity of the market\n    /// @return Whether the order decreases the liquidity of the market\n    function decreasesLiquidity(Order memory self, Position memory currentPosition) internal pure returns (bool) {\n        Fixed6 currentSkew = currentPosition.skew();\n        Fixed6 latestSkew = currentSkew.sub(long(self)).add(short(self));\n        return !self.makerNeg.isZero() || currentSkew.abs().gt(latestSkew.abs());\n    }\n\n    /// @notice Returns whether the order decreases the efficieny of the market\n    /// @dev Decreased efficiency ratio intuitively means that the market is \"more efficient\" on an OI to LP basis.\n    /// @return Whether the order decreases the liquidity of the market\n    function decreasesEfficiency(Order memory self, Position memory currentPosition) internal pure returns (bool) {\n        UFixed6 currentMajor = currentPosition.major();\n        UFixed6 latestMajor = UFixed6Lib.from(Fixed6Lib.from(currentPosition.long).sub(long(self)))\n            .max(UFixed6Lib.from(Fixed6Lib.from(currentPosition.short).sub(short(self))));\n        return !self.makerNeg.isZero() || currentMajor.gt(latestMajor);\n    }\n\n    /// @notice Returns whether the order is applicable for liquidity checks\n    /// @param self The Order object to check\n    /// @param marketParameter The market parameter\n    /// @return Whether the order is applicable for liquidity checks\n    function liquidityCheckApplicable(\n        Order memory self,\n        MarketParameter memory marketParameter\n    ) internal pure returns (bool) {\n        return !marketParameter.closed &&\n        // not \"a taker order that is increasing\" ->\n        // not (any of the following)\n        //  - taker is empty (not a taker order)\n        //  - taker is increasing (position going more long or short)\n            ((long(self).isZero() && short(self).isZero()) || increasesTaker(self));\n    }\n\n    /// @notice Returns whether the order is protected\n    /// @param self The order object to check\n    /// @return Whether the order is protected\n    function protected(Order memory self) internal pure returns (bool) {\n        return self.protection != 0;\n    }\n\n    /// @notice Returns whether the order is empty\n    /// @param self The order object to check\n    /// @return Whether the order is empty\n    function isEmpty(Order memory self) internal pure returns (bool) {\n        return pos(self).isZero() && neg(self).isZero();\n    }\n\n     /// @notice Returns the direction of the order\n    /// @dev 0 = maker, 1 = long, 2 = short\n    /// @param self The position object to check\n    /// @return The direction of the position\n    function direction(Order memory self) internal pure returns (uint256) {\n        if (!self.longPos.isZero() || !self.longNeg.isZero()) return 1;\n        if (!self.shortPos.isZero() || !self.shortNeg.isZero()) return 2;\n\n        return 0;\n    }\n\n    /// @notice Returns the magnitude of the order\n    /// @param self The order object to check\n    /// @return The magnitude of the order\n    function magnitude(Order memory self) internal pure returns (Fixed6) {\n        return maker(self).add(long(self)).add(short(self));\n    }\n\n    /// @notice Returns the maker delta of the order\n    /// @param self The order object to check\n    /// @return The maker delta of the order\n    function maker(Order memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.makerPos).sub(Fixed6Lib.from(self.makerNeg));\n    }\n\n    /// @notice Returns the long delta of the order\n    /// @param self The order object to check\n    /// @return The long delta of the order\n    function long(Order memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.longPos).sub(Fixed6Lib.from(self.longNeg));\n    }\n\n    /// @notice Returns the short delta of the order\n    /// @param self The order object to check\n    /// @return The short delta of the order\n    function short(Order memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.shortPos).sub(Fixed6Lib.from(self.shortNeg));\n    }\n\n    /// @notice Returns the positive taker delta of the order\n    /// @param self The order object to check\n    /// @return The positive taker delta of the order\n    function takerPos(Order memory self) internal pure returns (UFixed6) {\n        return self.longPos.add(self.shortNeg);\n    }\n\n    /// @notice Returns the negative taker delta of the order\n    /// @param self The order object to check\n    /// @return The negative taker delta of the order\n    function takerNeg(Order memory self) internal pure returns (UFixed6) {\n        return self.shortPos.add(self.longNeg);\n    }\n\n    /// @notice Returns the total maker delta of the order\n    /// @param self The order object to check\n    /// @return The total maker delta of the order\n    function makerTotal(Order memory self) internal pure returns (UFixed6) {\n        return self.makerPos.add(self.makerNeg);\n    }\n\n    /// @notice Returns the total taker delta of the order\n    /// @param self The order object to check\n    /// @return The total taker delta of the order\n    function takerTotal(Order memory self) internal pure returns (UFixed6) {\n        return self.takerPos().add(self.takerNeg());\n    }\n\n    /// @notice Returns the positive delta of the order\n    /// @param self The order object to check\n    /// @return The positive delta of the order\n    function pos(Order memory self) internal pure returns (UFixed6) {\n        return self.makerPos.add(self.longPos).add(self.shortPos);\n    }\n\n    /// @notice Returns the positive delta of the order\n    /// @param self The order object to check\n    /// @return The positive delta of the order\n    function neg(Order memory self) internal pure returns (UFixed6) {\n        return self.makerNeg.add(self.longNeg).add(self.shortNeg);\n    }\n\n    /// @notice Updates the current global order with a new local order\n    /// @param self The order object to update\n    /// @param order The new order\n    function add(Order memory self, Order memory order) internal pure {\n        (self.orders, self.collateral, self.protection, self.makerReferral, self.takerReferral) = (\n            self.orders + order.orders,\n            self.collateral.add(order.collateral),\n            self.protection + order.protection,\n            self.makerReferral.add(order.makerReferral),\n            self.takerReferral.add(order.takerReferral)\n        );\n\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) = (\n            self.makerPos.add(order.makerPos),\n            self.makerNeg.add(order.makerNeg),\n            self.longPos.add(order.longPos),\n            self.longNeg.add(order.longNeg),\n            self.shortPos.add(order.shortPos),\n            self.shortNeg.add(order.shortNeg)\n        );\n    }\n\n    /// @notice Subtracts the latest local order from current global order\n    /// @param self The order object to update\n    /// @param order The latest order\n    function sub(Order memory self, Order memory order) internal pure {\n        (self.orders, self.collateral, self.protection, self.makerReferral, self.takerReferral) = (\n            self.orders - order.orders,\n            self.collateral.sub(order.collateral),\n            self.protection - order.protection,\n            self.makerReferral.sub(order.makerReferral),\n            self.takerReferral.sub(order.takerReferral)\n        );\n\n        (self.makerPos, self.makerNeg, self.longPos, self.longNeg, self.shortPos, self.shortNeg) = (\n            self.makerPos.sub(order.makerPos),\n            self.makerNeg.sub(order.makerNeg),\n            self.longPos.sub(order.longPos),\n            self.longNeg.sub(order.longNeg),\n            self.shortPos.sub(order.shortPos),\n            self.shortNeg.sub(order.shortNeg)\n        );\n    }\n}\n\n/// @dev Manually encodes and decodes the global Order struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredOrderGlobal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint32 orders;\n///         int64 collateral;\n///         uint64 makerPos;\n///         uint64 makerNeg;\n///\n///         /* slot 1 */\n///         uint64 longPos;\n///         uint64 longNeg;\n///         uint64 shortPos;\n///         uint64 shortNeg;\n///\n///         /* slot 2 */\n///         uint64 takerReferral;\n///         uint64 makerReferral;\n///     }\n///\nlibrary OrderStorageGlobalLib {\n    function read(OrderStorageGlobal storage self) internal view returns (Order memory) {\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\n\n        return Order(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64 - 64 - 64)) >> (256 - 64)),\n            0,\n            UFixed6.wrap(uint256(slot2 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot2 << (256 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(OrderStorageGlobal storage self, Order memory newValue) internal {\n        OrderStorageLib.validate(newValue);\n\n        if (newValue.makerPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.makerNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.longPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.longNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.shortPos.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.shortNeg.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageLib.OrderStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.makerPos) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.makerNeg) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64 - 64);\n        uint256 encoded1 =\n            uint256(UFixed6.unwrap(newValue.longPos) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.longNeg) << (256 - 64)) >> (256 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.shortPos) << (256 - 64)) >> (256 - 64 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.shortNeg) << (256 - 64)) >> (256 - 64 - 64 - 64 - 64);\n        uint256 encoded2 =\n            uint256(UFixed6.unwrap(newValue.makerReferral) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerReferral) << (256 - 64)) >> (256 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n            sstore(add(self.slot, 2), encoded2)\n        }\n    }\n}\n\n/// @dev Manually encodes and decodes the local Order struct into storage.\n///\n///     struct StoredOrderLocal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint32 orders;\n///         int64 collateral;\n///         uint2 direction;\n///         uint62 magnitudePos;\n///         uint62 magnitudeNeg;\n///         uint1 protection;\n///\n///         /* slot 1 */\n///         uint64 takerReferral;\n///         uint64 makerReferral;\n///     }\n///\nlibrary OrderStorageLocalLib {\n    function read(OrderStorageLocal storage self) internal view returns (Order memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n\n        uint256 direction = uint256(slot0 << (256 - 32 - 32 - 64 - 2)) >> (256 - 2);\n        UFixed6 magnitudePos = UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62)) >> (256 - 62));\n        UFixed6 magnitudeNeg = UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62 - 62)) >> (256 - 62));\n\n        return Order(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            uint256(slot0 << (256 - 32 - 32)) >> (256 - 32),\n            Fixed6.wrap(int256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\n            direction == 0 ? magnitudePos : UFixed6Lib.ZERO,\n            direction == 0 ? magnitudeNeg : UFixed6Lib.ZERO,\n            direction == 1 ? magnitudePos : UFixed6Lib.ZERO,\n            direction == 1 ? magnitudeNeg : UFixed6Lib.ZERO,\n            direction == 2 ? magnitudePos : UFixed6Lib.ZERO,\n            direction == 2 ? magnitudeNeg : UFixed6Lib.ZERO,\n            uint256(slot0 << (256 - 32 - 32 - 64 - 2 - 62 - 62 - 1)) >> (256 - 1),\n            UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot1 << (256 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(OrderStorageLocal storage self, Order memory newValue) internal {\n        OrderStorageLib.validate(newValue);\n\n        (UFixed6 magnitudePos, UFixed6 magnitudeNeg) = (newValue.pos(), newValue.neg());\n\n        if (magnitudePos.gt(UFixed6.wrap(2 ** 62 - 1))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (magnitudeNeg.gt(UFixed6.wrap(2 ** 62 - 1))) revert OrderStorageLib.OrderStorageInvalidError();\n        if (newValue.protection > 1) revert OrderStorageLib.OrderStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.orders << (256 - 32)) >> (256 - 32 - 32) |\n            uint256(Fixed6.unwrap(newValue.collateral) << (256 - 64)) >> (256 - 32 - 32 - 64) |\n            uint256(newValue.direction() << (256 - 2)) >> (256 - 32 - 32 - 64 - 2) |\n            uint256(UFixed6.unwrap(magnitudePos) << (256 - 62)) >> (256 - 32 - 32 - 64 - 2 - 62) |\n            uint256(UFixed6.unwrap(magnitudeNeg) << (256 - 62)) >> (256 - 32 - 32 - 64 - 2 - 62 - 62) |\n            uint256(newValue.protection << (256 - 1)) >> (256 - 32 - 32 - 64 - 2 - 62 - 62 - 1);\n        uint256 encoded1 =\n            uint256(UFixed6.unwrap(newValue.makerReferral) << (256 - 64)) >> (256 - 64) |\n            uint256(UFixed6.unwrap(newValue.takerReferral) << (256 - 64)) >> (256 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n        }\n    }\n}\n\nlibrary OrderStorageLib {\n    // sig: 0x67e45965\n    error OrderStorageInvalidError();\n\n    function validate(Order memory newValue) internal pure {\n        if (newValue.timestamp > type(uint32).max) revert OrderStorageInvalidError();\n        if (newValue.orders > type(uint32).max) revert OrderStorageInvalidError();\n        if (newValue.collateral.gt(Fixed6.wrap(type(int64).max))) revert OrderStorageInvalidError();\n        if (newValue.collateral.lt(Fixed6.wrap(type(int64).min))) revert OrderStorageInvalidError();\n        if (newValue.makerReferral.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageInvalidError();\n        if (newValue.takerReferral.gt(UFixed6.wrap(type(uint64).max))) revert OrderStorageInvalidError();\n    }\n}"
    },
    "@perennial/core/contracts/types/Position.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6, Fixed6Lib } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { OracleVersion } from \"./OracleVersion.sol\";\nimport { RiskParameter } from \"./RiskParameter.sol\";\nimport { Order } from \"./Order.sol\";\n\n/// @dev Position type\nstruct Position {\n    /// @dev The timestamp of the position\n    uint256 timestamp;\n\n    /// @dev The maker position size\n    UFixed6 maker;\n\n    /// @dev The long position size\n    UFixed6 long;\n\n    /// @dev The short position size\n    UFixed6 short;\n}\nusing PositionLib for Position global;\nstruct PositionStorageGlobal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing PositionStorageGlobalLib for PositionStorageGlobal global;\nstruct PositionStorageLocal { uint256 slot0; uint256 slot1; } // SECURITY: must remain at (2) slots\nusing PositionStorageLocalLib for PositionStorageLocal global;\n\n/// @title Position\n/// @dev (external-unsafe): this library must be used internally only\n/// @notice Holds the state for a position\nlibrary PositionLib {\n    /// @notice Returns a cloned copy of the position\n    /// @param self The position object to clone\n    /// @return A cloned copy of the position\n    function clone(Position memory self) internal pure returns (Position memory) {\n        return Position(self.timestamp, self.maker, self.long, self.short);\n    }\n\n    /// @notice Updates the position with a new order\n    /// @param self The position object to update\n    /// @param order The new order\n    function update(Position memory self, Order memory order) internal pure {\n        self.timestamp = order.timestamp;\n\n        (self.maker, self.long, self.short) = (\n            UFixed6Lib.from(Fixed6Lib.from(self.maker).add(order.maker())),\n            UFixed6Lib.from(Fixed6Lib.from(self.long).add(order.long())),\n            UFixed6Lib.from(Fixed6Lib.from(self.short).add(order.short()))\n        );\n    }\n\n    /// @notice Returns the direction of the position\n    /// @dev 0 = maker, 1 = long, 2 = short\n    /// @param self The position object to check\n    /// @return The direction of the position\n    function direction(Position memory self) internal pure returns (uint256) {\n        return self.long.isZero() ? (self.short.isZero() ? 0 : 2) : 1;\n    }\n\n    /// @notice Returns the maximum position size\n    /// @param self The position object to check\n    /// @return The maximum position size\n    function magnitude(Position memory self) internal pure returns (UFixed6) {\n        return self.long.max(self.short).max(self.maker);\n    }\n\n    /// @notice Returns the maximum taker position size\n    /// @param self The position object to check\n    /// @return The maximum taker position size\n    function major(Position memory self) internal pure returns (UFixed6) {\n        return self.long.max(self.short);\n    }\n\n    /// @notice Returns the minimum maker position size\n    /// @param self The position object to check\n    /// @return The minimum maker position size\n    function minor(Position memory self) internal pure returns (UFixed6) {\n        return self.long.min(self.short);\n    }\n\n    /// @notice Returns the skew of the position\n    /// @param self The position object to check\n    /// @return The skew of the position\n    function skew(Position memory self) internal pure returns (Fixed6) {\n        return Fixed6Lib.from(self.long).sub(Fixed6Lib.from(self.short));\n    }\n\n    /// @notice Returns the utilization of the position\n    /// @dev utilization = major / (maker + minor)\n    /// @param self The position object to check\n    /// @param riskParameter The current risk parameter\n    /// @return The utilization of the position\n    function utilization(Position memory self, RiskParameter memory riskParameter) internal pure returns (UFixed6) {\n        // long-short net utilization of the maker position\n        UFixed6 netUtilization = major(self).unsafeDiv(self.maker.add(minor(self)));\n\n        // efficiency limit utilization of the maker position\n        UFixed6 efficiencyUtilization = major(self).mul(riskParameter.efficiencyLimit).unsafeDiv(self.maker);\n\n        // maximum of the two utilizations, capped at 100%\n        return netUtilization.max(efficiencyUtilization).min(UFixed6Lib.ONE);\n    }\n\n    /// @notice Returns the portion of the position that is covered by the maker\n    /// @param self The position object to check\n    /// @return The portion of the position that is covered by the maker\n    function socializedMakerPortion(Position memory self) internal pure returns (UFixed6) {\n        return takerSocialized(self).isZero() ?\n            UFixed6Lib.ZERO :\n            takerSocialized(self).sub(minor(self)).div(takerSocialized(self));\n    }\n\n    /// @notice Returns the long position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The long position with socialization taken into account\n    function longSocialized(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.add(self.short).min(self.long);\n    }\n\n    /// @notice Returns the short position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The short position with socialization taken into account\n    function shortSocialized(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.add(self.long).min(self.short);\n    }\n\n    /// @notice Returns the major position with socialization taken into account\n    /// @param self The position object to check\n    /// @return The major position with socialization taken into account\n    function takerSocialized(Position memory self) internal pure returns (UFixed6) {\n        return major(self).min(minor(self).add(self.maker));\n    }\n\n    /// @notice Returns the efficiency of the position\n    /// @dev efficiency = maker / major\n    /// @param self The position object to check\n    /// @return The efficiency of the position\n    function efficiency(Position memory self) internal pure returns (UFixed6) {\n        return self.maker.unsafeDiv(major(self)).min(UFixed6Lib.ONE);\n    }\n\n    /// @notice Returns the whether the position is socialized\n    /// @param self The position object to check\n    /// @return Whether the position is socialized\n    function socialized(Position memory self) internal pure returns (bool) {\n        return self.maker.add(self.short).lt(self.long) || self.maker.add(self.long).lt(self.short);\n    }\n\n    /// @notice Returns the whether the position is single-sided\n    /// @param self The position object to check\n    /// @return Whether the position is single-sided\n    function singleSided(Position memory self) internal pure returns (bool) {\n        return magnitude(self).eq(self.long.add(self.short).add(self.maker));\n    }\n\n    /// @notice Returns the whether the position is empty\n    /// @param self The position object to check\n    /// @return Whether the position is empty\n    function empty(Position memory self) internal pure returns (bool) {\n        return magnitude(self).isZero();\n    }\n\n    /// @notice Returns the maintenance requirement of the position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The maintenance requirement of the position\n    function maintenance(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.maintenance, riskParameter.minMaintenance);\n    }\n\n    /// @notice Returns the margin requirement of the position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateralization The collateralization requirement override provided by the caller\n    /// @return The margin requirement of the position\n    function margin(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        UFixed6 collateralization\n    ) internal pure returns (UFixed6) {\n        return _collateralRequirement(positionMagnitude, latestVersion, riskParameter.margin.max(collateralization), riskParameter.minMargin);\n    }\n\n    /// @notice Returns the maintenance requirement of the position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The maintenance requirement of the position\n    function maintenance(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        return maintenance(magnitude(self), latestVersion, riskParameter);\n    }\n\n    /// @notice Returns the margin requirement of the position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @return The margin requirement of the position\n    function margin(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter\n    ) internal pure returns (UFixed6) {\n        return margin(magnitude(self), latestVersion, riskParameter, UFixed6Lib.ZERO);\n    }\n\n    /// @notice Returns the collateral requirement of the position magnitude\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param requirementRatio The ratio requirement to the notional\n    /// @param requirementFixed The fixed requirement\n    /// @return The collateral requirement of the position magnitude\n    function _collateralRequirement(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        UFixed6 requirementRatio,\n        UFixed6 requirementFixed\n    ) private pure returns (UFixed6) {\n        if (positionMagnitude.isZero()) return UFixed6Lib.ZERO;\n        return positionMagnitude.mul(latestVersion.price.abs()).mul(requirementRatio).max(requirementFixed);\n    }\n\n    /// @notice Returns the whether the position is maintained\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is maintained\n    function maintained(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return UFixed6Lib.unsafeFrom(collateral).gte(maintenance(positionMagnitude, latestVersion, riskParameter));\n    }\n\n    /// @notice Returns the whether the position is margined\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param positionMagnitude The position magnitude value to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateralization The collateralization requirement override provided by the caller\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is margined\n    function margined(\n        UFixed6 positionMagnitude,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        UFixed6 collateralization,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return UFixed6Lib.unsafeFrom(collateral).gte(margin(positionMagnitude, latestVersion, riskParameter, collateralization));\n    }\n\n    /// @notice Returns the whether the position is maintained\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is maintained\n    function maintained(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return maintained(magnitude(self), latestVersion, riskParameter, collateral);\n    }\n\n    /// @notice Returns the whether the position is margined\n    /// @dev shortfall is considered solvent for 0-position\n    /// @param self The position object to check\n    /// @param latestVersion The latest oracle version\n    /// @param riskParameter The current risk parameter\n    /// @param collateralization The collateralization requirement override provided by the caller\n    /// @param collateral The current account's collateral\n    /// @return Whether the position is margined\n    function margined(\n        Position memory self,\n        OracleVersion memory latestVersion,\n        RiskParameter memory riskParameter,\n        UFixed6 collateralization,\n        Fixed6 collateral\n    ) internal pure returns (bool) {\n        return margined(magnitude(self), latestVersion, riskParameter, collateralization, collateral);\n    }\n}\n\n/// @dev Manually encodes and decodes the global Position struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredPositionGlobal {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint32 __unallocated__;\n///         uint64 maker;\n///         uint64 long;\n///         uint64 short;\n///\n///         /* slot 1 */\n///         uint64 maker (deprecated);\n///         uint192 __unallocated__;\n///     }\n///\nlibrary PositionStorageGlobalLib {\n    function read(PositionStorageGlobal storage self) internal view returns (Position memory) {\n        uint256 slot0 = self.slot0;\n        return Position(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64)) >> (256 - 64)),\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 32 - 64 - 64 - 64)) >> (256 - 64))\n        );\n    }\n\n    function store(PositionStorageGlobal storage self, Position memory newValue) public {\n        PositionStorageLib.validate(newValue);\n\n        if (newValue.maker.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\n        if (newValue.long.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\n        if (newValue.short.gt(UFixed6.wrap(type(uint64).max))) revert PositionStorageLib.PositionStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(UFixed6.unwrap(newValue.maker) << (256 - 64)) >> (256 - 32 - 32 - 64) |\n            uint256(UFixed6.unwrap(newValue.long) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64) |\n            uint256(UFixed6.unwrap(newValue.short) << (256 - 64)) >> (256 - 32 - 32 - 64 - 64 - 64);\n\n        assembly {\n            sstore(self.slot, encoded0)\n        }\n    }\n\n    function migrate(PositionStorageGlobal storage self) external {\n        Position memory position = read(self);\n        uint256 slot1 = self.slot1;\n        UFixed6 deprecatedMaker = UFixed6.wrap(uint256(slot1 << (256 - 64)) >> (256 - 64));\n\n        // only migrate if the deprecated maker is set and new maker is unset to avoid double-migration\n        if (deprecatedMaker.isZero() || !position.maker.isZero())\n            revert PositionStorageLib.PositionStorageInvalidMigrationError();\n\n        position.maker = deprecatedMaker;\n        store(self, position);\n        assembly {\n            sstore(add(self.slot, 1), 0) // Part of the v2.3 migration. Can be removed once migration is complete.\n        }\n    }\n}\n\n/// @dev Manually encodes and decodes the local Position struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredPositionLocal (v0) {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint216 __unallocated__;\n///         uint8 layout;\n///\n///         /* slot 1 */\n///         uint2 direction;\n///         uint62 magnitude;\n///         uint192 __unallocated__;\n///     }\n///\n///     note: fresh Positions will still default to v0 until they are saved to, but this is safe because\n///           slot1 is still reserved and will return correct default values.\n///\n///     struct StoredPositionLocal (v1) {\n///         /* slot 0 */\n///         uint32 timestamp;\n///         uint2 direction;\n///         uint62 magnitude;\n///         uint152 __unallocated__;\n///         uint8 layout; // v2.3 migration -- can remove once all accounts have been migrated\n///     }\n///\nlibrary PositionStorageLocalLib {\n    function read(PositionStorageLocal storage self) internal view returns (Position memory) {\n        (uint256 slot0, uint256 slot1) = (self.slot0, self.slot1);\n        uint256 layout = uint256(slot0 << (256 - 32 - 216 - 8)) >> (256 - 8);\n\n        uint256 direction = layout == 0 ?\n            uint256(slot1 << (256 - 2)) >> (256 - 2) :\n            uint256(slot0 << (256 - 32 - 2)) >> (256 - 2);\n        UFixed6 magnitude = layout == 0 ?\n            UFixed6.wrap(uint256(slot1 << (256 - 2 - 62)) >> (256 - 62)) :\n            UFixed6.wrap(uint256(slot0 << (256 - 32 - 2 - 62)) >> (256 - 62));\n\n        return Position(\n            uint256(slot0 << (256 - 32)) >> (256 - 32),\n            direction == 0 ? magnitude : UFixed6Lib.ZERO,\n            direction == 1 ? magnitude : UFixed6Lib.ZERO,\n            direction == 2 ? magnitude : UFixed6Lib.ZERO\n        );\n    }\n\n    function store(PositionStorageLocal storage self, Position memory newValue) external {\n        PositionStorageLib.validate(newValue);\n\n        uint256 layout = 1;\n        UFixed6 magnitude = newValue.magnitude();\n\n        if (magnitude.gt(UFixed6.wrap(2 ** 62 - 1))) revert PositionStorageLib.PositionStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(newValue.timestamp << (256 - 32)) >> (256 - 32) |\n            uint256(newValue.direction() << (256 - 2)) >> (256 - 32 - 2) |\n            uint256(UFixed6.unwrap(magnitude) << (256 - 62)) >> (256 - 32 - 2 - 62) |\n            uint256(layout << (256 - 8)) >> (256 - 32 - 2 - 62 - 152 - 8);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), 0) // Part of the v2.3 migration. Can be removed once migration is complete.\n        }\n    }\n}\n\nlibrary PositionStorageLib {\n    // sig: 0x52a8a97f\n    error PositionStorageInvalidError();\n    // sig: 0x1bacb3a2\n    error PositionStorageInvalidMigrationError();\n\n    function validate(Position memory newValue) internal pure {\n        if (newValue.timestamp > type(uint32).max) revert PositionStorageInvalidError();\n    }\n}"
    },
    "@perennial/core/contracts/types/ProtocolParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\n\n/// @dev ProtocolParameter type\nstruct ProtocolParameter {\n    /// @dev The maximum for market fee parameters\n    UFixed6 maxFee;\n\n    /// @dev The maximum for liquidationFee market parameter\n    UFixed6 maxLiquidationFee;\n\n    /// @dev The maximum for market cut parameters\n    UFixed6 maxCut;\n\n    /// @dev The maximum for market rate parameters\n    UFixed6 maxRate;\n\n    /// @dev The minimum for market maintenance parameters\n    UFixed6 minMaintenance;\n\n    /// @dev The minimum for market efficiency parameters\n    UFixed6 minEfficiency;\n\n    /// @dev The default referrer fee percentage for orders\n    UFixed6 referralFee;\n\n    /// @dev The minimum ratio between scale vs makerLimit / efficiencyLimit\n    UFixed6 minScale;\n\n    /// @dev The maximum for parameter restricting maximum time between oracle version and update\n    uint256 maxStaleAfter;\n}\nstruct StoredProtocolParameter {\n    /* slot 0 (29) */\n    uint24 maxFee;                  // <= 1677%\n    uint32 maxLiquidationFee;       // <= 4294\n    uint24 maxCut;                  // <= 1677%\n    uint32 maxRate;                 // <= 214748% (capped at 31 bits to accommodate int32 rates)\n    uint24 minMaintenance;          // <= 1677%\n    uint24 minEfficiency;           // <= 1677%\n    uint24 referralFee;             // <= 1677%\n    uint24 minScale;                // <= 1677%\n    uint24 maxStaleAfter;           // <= 4660 hours\n}\nstruct ProtocolParameterStorage { StoredProtocolParameter value; } // SECURITY: must remain at (1) slots\nusing ProtocolParameterStorageLib for ProtocolParameterStorage global;\n\n/// @dev (external-safe): this library is safe to externalize\nlibrary ProtocolParameterStorageLib {\n    // sig: 0x4dc1bc59\n    error ProtocolParameterStorageInvalidError();\n\n    function read(ProtocolParameterStorage storage self) internal view returns (ProtocolParameter memory) {\n        StoredProtocolParameter memory value = self.value;\n        return ProtocolParameter(\n            UFixed6.wrap(uint256(value.maxFee)),\n            UFixed6.wrap(uint256(value.maxLiquidationFee)),\n            UFixed6.wrap(uint256(value.maxCut)),\n            UFixed6.wrap(uint256(value.maxRate)),\n            UFixed6.wrap(uint256(value.minMaintenance)),\n            UFixed6.wrap(uint256(value.minEfficiency)),\n            UFixed6.wrap(uint256(value.referralFee)),\n            UFixed6.wrap(uint256(value.minScale)),\n            uint24(value.maxStaleAfter)\n        );\n    }\n\n    function validate(ProtocolParameter memory self) internal pure {\n        if (self.maxCut.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\n        if (self.referralFee.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\n        if (self.minScale.gt(UFixed6Lib.ONE)) revert ProtocolParameterStorageInvalidError();\n    }\n\n    function validateAndStore(ProtocolParameterStorage storage self, ProtocolParameter memory newValue) internal {\n        validate(newValue);\n\n        if (newValue.maxFee.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.maxLiquidationFee.gt(UFixed6.wrap(type(uint32).max))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.maxRate.gt(UFixed6.wrap(type(uint32).max / 2))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.minMaintenance.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.minEfficiency.gt(UFixed6.wrap(type(uint24).max))) revert ProtocolParameterStorageInvalidError();\n        if (newValue.maxStaleAfter > uint256(type(uint24).max)) revert ProtocolParameterStorageInvalidError();\n\n        self.value = StoredProtocolParameter(\n            uint24(UFixed6.unwrap(newValue.maxFee)),\n            uint32(UFixed6.unwrap(newValue.maxLiquidationFee)),\n            uint24(UFixed6.unwrap(newValue.maxCut)),\n            uint32(UFixed6.unwrap(newValue.maxRate)),\n            uint24(UFixed6.unwrap(newValue.minMaintenance)),\n            uint24(UFixed6.unwrap(newValue.minEfficiency)),\n            uint24(UFixed6.unwrap(newValue.referralFee)),\n            uint24(UFixed6.unwrap(newValue.minScale)),\n            uint24(newValue.maxStaleAfter)\n        );\n    }\n}"
    },
    "@perennial/core/contracts/types/RiskParameter.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { UJumpRateUtilizationCurve6 } from \"@equilibria/root/utilization/types/UJumpRateUtilizationCurve6.sol\";\nimport { PController6 } from \"@equilibria/root/pid/types/PController6.sol\";\nimport { LinearAdiabatic6 } from \"@equilibria/root/adiabatic/types/LinearAdiabatic6.sol\";\nimport { NoopAdiabatic6 } from \"@equilibria/root/adiabatic/types/NoopAdiabatic6.sol\";\nimport { ProtocolParameter } from \"./ProtocolParameter.sol\";\n\n/// @dev RiskParameter type\nstruct RiskParameter {\n    /// @dev The minimum amount of collateral required to open a new position as a percentage of notional\n    UFixed6 margin;\n\n    /// @dev The minimum amount of collateral that must be maintained as a percentage of notional\n    UFixed6 maintenance;\n\n    /// @dev The taker impact fee\n    LinearAdiabatic6 takerFee;\n\n    /// @dev The maker fee configuration\n    NoopAdiabatic6 makerFee;\n\n    /// @dev The maximum amount of maker positions that opened\n    UFixed6 makerLimit;\n\n    /// @dev The minimum limit of the efficiency metric\n    UFixed6 efficiencyLimit;\n\n    /// @dev Multiple of the settlement fee charged when a position is liquidated\n    UFixed6 liquidationFee;\n\n    /// @dev The utilization curve that is used to compute maker interest\n    UJumpRateUtilizationCurve6 utilizationCurve;\n\n    /// @dev The p controller that is used to compute long-short funding\n    PController6 pController;\n\n    /// @dev The minimum fixed amount that is required to open a position\n    UFixed6 minMargin;\n\n    /// @dev The minimum fixed amount that is required for maintenance\n    UFixed6 minMaintenance;\n\n    /// @dev The maximum amount of time since the latest oracle version that update may still be called\n    uint256 staleAfter;\n\n    /// @dev Whether or not the maker should always receive positive funding\n    bool makerReceiveOnly;\n}\nstruct RiskParameterStorage { uint256 slot0; uint256 slot1; uint256 slot2; } // SECURITY: must remain at (3) slots\nusing RiskParameterStorageLib for RiskParameterStorage global;\n\n/// @dev Manually encodes and decodes the local Position struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///    struct StoredRiskParameter {\n///        /* slot 0 */ (30)\n///        uint24 margin;                              // <= 1677%\n///        uint24 maintenance;                         // <= 1677%\n///        uint24 takerLinearFee;                      // <= 1677%\n///        uint24 takerProportionalFee;                // <= 1677%\n///        uint24 takerAdiabaticFee;                   // <= 1677% (must maintain location due to updateRiskParameter)\n///        uint24 makerLinearFee;                      // <= 1677%\n///        uint24 makerProportionalFee;                // <= 1677%\n///        uint48 makerLimit;                          // <= 281t (no decimals)\n///        uint24 efficiencyLimit;                     // <= 1677%\n///\n///        /* slot 1 */ (31)\n///        bytes3 __unallocated__;\n///        uint48 makerSkewScale;                      // <= 281t (no decimals) (must maintain location due to updateRiskParameter)\n///        uint48 takerSkewScale;                      // <= 281t (no decimals) (must maintain location due to updateRiskParameter)\n///        uint24 utilizationCurveMinRate;             // <= 1677%\n///        uint24 utilizationCurveMaxRate;             // <= 1677%\n///        uint24 utilizationCurveTargetRate;          // <= 1677%\n///        uint24 utilizationCurveTargetUtilization;   // <= 1677%\n///        int32 pControllerMin;                       // <= 214748%\n///\n///        /* slot 2 */ (30)\n///        uint48 pControllerK;                        // <= 281m\n///        int32 pControllerMax;                       // <= 214748%\n///        uint48 minMargin;                           // <= 281m\n///        uint48 minMaintenance;                      // <= 281m\n///        uint32 liquidationFee;                      // <= 4294\n///        uint24 staleAfter;                          // <= 16m s\n///        bool makerReceiveOnly;\n///    }\nlibrary RiskParameterStorageLib {\n    // sig: 0x7ecd083f\n    error RiskParameterStorageInvalidError();\n\n    function read(RiskParameterStorage storage self) internal view returns (RiskParameter memory) {\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\n        return RiskParameter(\n            UFixed6.wrap(uint256(       slot0 << (256 - 24)) >> (256 - 24)),\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24)) >> (256 - 24)),\n            LinearAdiabatic6(\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6Lib.from(uint256(slot1 << (256 - 24 - 48 - 48)) >> (256 - 48))\n            ),\n            NoopAdiabatic6(\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6Lib.from(uint256(slot1 << (256 - 24 - 48)) >> (256 - 48))\n            ),\n            UFixed6Lib.from(uint256(    slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(       slot0 << (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48 - 24)) >> (256 - 24)),\n\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 32)) >> (256 - 32)),\n            UJumpRateUtilizationCurve6(\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24)) >> (256 - 24)),\n                UFixed6.wrap(uint256(   slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24)) >> (256 - 24))\n            ),\n\n            PController6(\n                UFixed6.wrap(uint256(   slot2 << (256 - 48)) >> (256 - 48)),\n                Fixed6.wrap(int256(     slot1 << (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24 - 32)) >> (256 - 32)),\n                Fixed6.wrap(int256(     slot2 << (256 - 48 - 32)) >> (256 - 32))\n            ),\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48)) >> (256 - 48)),\n            UFixed6.wrap(uint256(       slot2 << (256 - 48 - 32 - 48 - 48)) >> (256 - 48)),\n                         uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 32 - 24)) >> (256 - 24),\n            0 !=        (uint256(       slot2 << (256 - 48 - 32 - 48 - 48 - 32 - 24 - 8)) >> (256 - 8))\n        );\n    }\n\n    function validate(RiskParameter memory self, ProtocolParameter memory protocolParameter) private pure {\n        if (\n            self.takerFee.linearFee.max(self.takerFee.proportionalFee).max(self.takerFee.adiabaticFee)\n                .max(self.makerFee.linearFee).max(self.makerFee.proportionalFee)\n                .gt(protocolParameter.maxFee)\n        ) revert RiskParameterStorageInvalidError();\n\n        if (self.liquidationFee.gt(protocolParameter.maxLiquidationFee)) revert RiskParameterStorageInvalidError();\n\n        if (\n            self.utilizationCurve.minRate.max(self.utilizationCurve.maxRate).max(self.utilizationCurve.targetRate)\n                .max(self.pController.max.abs()).max(self.pController.min.abs())\n                .gt(protocolParameter.maxRate)\n        ) revert RiskParameterStorageInvalidError();\n\n        if (self.staleAfter > protocolParameter.maxStaleAfter) revert RiskParameterStorageInvalidError();\n\n        if (self.maintenance.lt(protocolParameter.minMaintenance)) revert RiskParameterStorageInvalidError();\n        if (self.maintenance.gt(UFixed6Lib.ONE)) revert RiskParameterStorageInvalidError();\n\n        if (self.margin.lt(self.maintenance)) revert RiskParameterStorageInvalidError();\n        if (self.margin.gt(UFixed6Lib.ONE)) revert RiskParameterStorageInvalidError();\n\n        if (self.efficiencyLimit.lt(protocolParameter.minEfficiency)) revert RiskParameterStorageInvalidError();\n\n        if (self.utilizationCurve.targetUtilization.gt(UFixed6Lib.ONE)) revert RiskParameterStorageInvalidError();\n\n        if (self.minMargin.lt(self.minMaintenance)) revert RiskParameterStorageInvalidError();\n\n        (UFixed6 makerLimitTruncated, UFixed6 takerFeeScaleTruncated, UFixed6 makerFeeScaleTruncated) = (\n            UFixed6Lib.from(self.makerLimit.truncate()),\n            UFixed6Lib.from(self.takerFee.scale.truncate()),\n            UFixed6Lib.from(self.makerFee.scale.truncate())\n        );\n        UFixed6 scaleLimit = makerLimitTruncated.div(self.efficiencyLimit).mul(protocolParameter.minScale);\n        if (takerFeeScaleTruncated.lt(scaleLimit) || makerFeeScaleTruncated.lt(scaleLimit))\n            revert RiskParameterStorageInvalidError();\n    }\n\n    function validateAndStore(\n        RiskParameterStorage storage self,\n        RiskParameter memory newValue,\n        ProtocolParameter memory protocolParameter\n    ) external {\n        validate(newValue, protocolParameter);\n\n        if (newValue.margin.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.minMargin.gt(UFixed6.wrap(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.efficiencyLimit.gt(UFixed6.wrap(type(uint24).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.makerLimit.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.pController.k.gt(UFixed6.wrap(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.takerFee.scale.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.makerFee.scale.gt(UFixed6Lib.from(type(uint48).max))) revert RiskParameterStorageInvalidError();\n        if (newValue.staleAfter > uint256(type(uint24).max)) revert RiskParameterStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256(UFixed6.unwrap(newValue.margin)                    << (256 - 24)) >> (256 - 24) |\n            uint256(UFixed6.unwrap(newValue.maintenance)               << (256 - 24)) >> (256 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.takerFee.linearFee)        << (256 - 24)) >> (256 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.takerFee.proportionalFee)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.takerFee.adiabaticFee)     << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.makerFee.linearFee)        << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.makerFee.proportionalFee)  << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24) |\n            uint256(newValue.makerLimit.truncate()                     << (256 - 48)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48) |\n            uint256(UFixed6.unwrap(newValue.efficiencyLimit)           << (256 - 24)) >> (256 - 24 - 24 - 24 - 24 - 24 - 24 - 24 - 48 - 24);\n\n        uint256 encoded1 =\n            uint256(newValue.makerFee.scale.truncate()                          << (256 - 48)) >> (256 - 24 - 48) |\n            uint256(newValue.takerFee.scale.truncate()                          << (256 - 48)) >> (256 - 24 - 48 - 48) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.minRate)           << (256 - 24)) >> (256 - 24 - 48 - 48 - 24) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.maxRate)           << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetRate)        << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24) |\n            uint256(UFixed6.unwrap(newValue.utilizationCurve.targetUtilization) << (256 - 24)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24) |\n            uint256(Fixed6.unwrap(newValue.pController.min)                     << (256 - 32)) >> (256 - 24 - 48 - 48 - 24 - 24 - 24 - 24 - 32);\n\n        uint256 encoded2 =\n            uint256(UFixed6.unwrap(newValue.pController.k)                  << (256 - 48)) >> (256 - 48) |\n            uint256(Fixed6.unwrap(newValue.pController.max)                 << (256 - 32)) >> (256 - 48 - 32) |\n            uint256(UFixed6.unwrap(newValue.minMargin)                      << (256 - 48)) >> (256 - 48 - 32 - 48) |\n            uint256(UFixed6.unwrap(newValue.minMaintenance)                 << (256 - 48)) >> (256 - 48 - 32 - 48 - 48) |\n            uint256(UFixed6.unwrap(newValue.liquidationFee)                 << (256 - 32)) >> (256 - 48 - 32 - 48 - 48 - 32) |\n            uint256(newValue.staleAfter                                     << (256 - 24)) >> (256 - 48 - 32 - 48 - 48 - 32 - 24) |\n            uint256((newValue.makerReceiveOnly ? uint256(1) : uint256(0))   << (256 - 8))  >> (256 - 48 - 32 - 48 - 48 - 32 - 24 - 8);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n            sstore(add(self.slot, 2), encoded2)\n        }\n    }\n}"
    },
    "@perennial/core/contracts/types/Version.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Accumulator6 } from \"@equilibria/root/accumulator/types/Accumulator6.sol\";\n\n/// @dev Version type\nstruct Version {\n    /// @dev whether this version had a valid oracle price\n    bool valid;\n\n    /// @dev The price of the version\n    Fixed6 price;\n\n    /// @dev The maker accumulator value\n    Accumulator6 makerValue;\n\n    /// @dev The long accumulator value\n    Accumulator6 longValue;\n\n    /// @dev The short accumulator value\n    Accumulator6 shortValue;\n\n    /// @dev The accumulated fee for maker orders\n    Accumulator6 makerFee;\n\n    /// @dev The accumulated fee for taker orders\n    Accumulator6 takerFee;\n\n    /// @dev The accumulated offset for maker orders\n    Accumulator6 makerOffset;\n\n    /// @dev The accumulated offset for positive taker orders (open long / close short)\n    Accumulator6 takerPosOffset;\n\n    /// @dev The accumulated offset for negative taker orders (close long / open short)\n    Accumulator6 takerNegOffset;\n\n    /// @dev The accumulated settlement fee for each individual order\n    Accumulator6 settlementFee;\n\n    /// @dev The accumulated liquidation fee for each individual order\n    Accumulator6 liquidationFee;\n}\nstruct VersionStorage { uint256 slot0; uint256 slot1; uint256 slot2; }\nusing VersionStorageLib for VersionStorage global;\n\n/// @dev Manually encodes and decodes the Version struct into storage.\n///      (external-safe): this library is safe to externalize\n///\n///     struct StoredVersion {\n///         /* slot 0 */\n///         bool valid;\n///         int64 makerValue;\n///         int64 longValue;\n///         int64 shortValue;\n///         uint48 liquidationFee;\n///\n///         /* slot 1 */\n///         int64 price;\n///         int48 makerOffset;\n///         int48 takerPosOffset;\n///         int48 takerNegOffset;\n///         uint48 settlementFee;\n///\n///         /* slot 2 */\n///         int48 makerFee;\n///         int48 takerFee;\n///     }\n///\nlibrary VersionStorageLib {\n    // sig: 0xd2777e72\n    error VersionStorageInvalidError();\n\n    function read(VersionStorage storage self) internal view returns (Version memory) {\n        (uint256 slot0, uint256 slot1, uint256 slot2) = (self.slot0, self.slot1, self.slot2);\n        return Version(\n            (uint256(slot0 << (256 - 8)) >> (256 - 8)) != 0,\n            Fixed6.wrap(int256(slot1 << (256 - 64)) >> (256 - 64)),\n\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64)) >> (256 - 64))),\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64)) >> (256 - 64))),\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64)) >> (256 - 64))),\n\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot2 << (256 - 48 - 48)) >> (256 - 48))),\n\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48 - 48)) >> (256 - 48))),\n\n            Accumulator6(Fixed6.wrap(int256(slot1 << (256 - 64 - 48 - 48 - 48 - 48)) >> (256 - 48))),\n            Accumulator6(Fixed6.wrap(int256(slot0 << (256 - 8 - 64 - 64 - 64 - 48)) >> (256 - 48)))\n        );\n    }\n\n    function store(VersionStorage storage self, Version memory newValue) external {\n        if (newValue.price.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.price.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.makerValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.makerValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.longValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.longValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.shortValue._value.gt(Fixed6.wrap(type(int64).max))) revert VersionStorageInvalidError();\n        if (newValue.shortValue._value.lt(Fixed6.wrap(type(int64).min))) revert VersionStorageInvalidError();\n        if (newValue.makerFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.makerFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.takerFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.takerFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.makerOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.makerOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.takerPosOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.takerPosOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.takerNegOffset._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.takerNegOffset._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.settlementFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.settlementFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n        if (newValue.liquidationFee._value.gt(Fixed6.wrap(type(int48).max))) revert VersionStorageInvalidError();\n        if (newValue.liquidationFee._value.lt(Fixed6.wrap(type(int48).min))) revert VersionStorageInvalidError();\n\n        uint256 encoded0 =\n            uint256((newValue.valid ? uint256(1) : uint256(0)) << (256 - 8)) >> (256 - 8) |\n            uint256(Fixed6.unwrap(newValue.makerValue._value) << (256 - 64)) >> (256 - 8 - 64) |\n            uint256(Fixed6.unwrap(newValue.longValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64) |\n            uint256(Fixed6.unwrap(newValue.shortValue._value) << (256 - 64)) >> (256 - 8 - 64 - 64 - 64) |\n            uint256(Fixed6.unwrap(newValue.liquidationFee._value) << (256 - 48)) >> (256 - 8 - 64 - 64 - 64 - 48);\n        uint256 encoded1 =\n            uint256(Fixed6.unwrap(newValue.price) << (256 - 64)) >> (256 - 64) |\n            uint256(Fixed6.unwrap(newValue.makerOffset._value) << (256 - 48)) >> (256 - 64 - 48) |\n            uint256(Fixed6.unwrap(newValue.takerPosOffset._value) << (256 - 48)) >> (256 - 64 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.takerNegOffset._value) << (256 - 48)) >> (256 - 64 - 48 - 48 - 48) |\n            uint256(Fixed6.unwrap(newValue.settlementFee._value) << (256 - 48)) >> (256 - 64 - 48 - 48 - 48 - 48);\n        uint256 encoded2 =\n            uint256(Fixed6.unwrap(newValue.makerFee._value) << (256 - 48)) >> (256 - 48) |\n            uint256(Fixed6.unwrap(newValue.takerFee._value) << (256 - 48)) >> (256 - 48 - 48);\n\n        assembly {\n            sstore(self.slot, encoded0)\n            sstore(add(self.slot, 1), encoded1)\n            sstore(add(self.slot, 2), encoded2)\n        }\n    }\n}\n"
    },
    "@perennial/verifier/contracts/interfaces/IVerifier.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { IVerifierBase } from \"@equilibria/root/verifier/interfaces/IVerifierBase.sol\";\nimport { Common } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { Intent } from \"../types/Intent.sol\";\nimport { OperatorUpdate } from \"../types/OperatorUpdate.sol\";\nimport { SignerUpdate } from \"../types/SignerUpdate.sol\";\nimport { AccessUpdateBatch } from \"../types/AccessUpdateBatch.sol\";\n\ninterface IVerifier is IVerifierBase {\n    function verifyIntent(Intent calldata intent, bytes calldata signature) external;\n    function verifyOperatorUpdate(OperatorUpdate calldata operatorUpdate, bytes calldata signature) external;\n    function verifySignerUpdate(SignerUpdate calldata signerUpdate, bytes calldata signature) external;\n    function verifyAccessUpdateBatch(AccessUpdateBatch calldata accessUpdateBatch, bytes calldata signature) external;\n}"
    },
    "@perennial/verifier/contracts/types/AccessUpdate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\n\nstruct AccessUpdate {\n    /// @dev The generic signer or operator to approve for the signing account\n    address accessor;\n\n    /// @dev The new status of the signer or operator\n    bool approved;\n}\nusing AccessUpdateLib for AccessUpdate global;\n\n/// @title AccessUpdateLib\n/// @notice Library for AccessUpdate logic and data.\nlibrary AccessUpdateLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\"AccessUpdate(address accessor,bool approved)\");\n\n    function hash(AccessUpdate memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.accessor, self.approved));\n    }\n}\n"
    },
    "@perennial/verifier/contracts/types/AccessUpdateBatch.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { AccessUpdate, AccessUpdateLib } from \"../types/AccessUpdate.sol\";\n\nstruct AccessUpdateBatch {\n    /// @dev The operator access update messages\n    AccessUpdate[] operators;\n\n    /// @dev The signer access update messages\n    AccessUpdate[] signers;\n\n    /// @dev The common information for the intent\n    Common common;\n}\nusing AccessUpdateBatchLib for AccessUpdateBatch global;\n\n/// @title AccessUpdateBatchLib\n/// @notice Library for AccessUpdateBatch logic and data.\nlibrary AccessUpdateBatchLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"AccessUpdateBatch(AccessUpdate[] operators,AccessUpdate[] signers,Common common)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    function hash(AccessUpdateBatch memory self) internal pure returns (bytes32) {\n        bytes32[] memory operatorHashes = new bytes32[](self.operators.length);\n        bytes32[] memory signerHashes = new bytes32[](self.signers.length);\n\n        for (uint256 i = 0; i < self.operators.length; i++)\n            operatorHashes[i] = AccessUpdateLib.hash(self.operators[i]);\n        for (uint256 i = 0; i < self.signers.length; i++)\n            signerHashes[i] = AccessUpdateLib.hash(self.signers[i]);\n\n        return keccak256(\n            abi.encode(\n                STRUCT_HASH,\n                keccak256(abi.encodePacked(operatorHashes)),\n                keccak256(abi.encodePacked(signerHashes)),\n                CommonLib.hash(self.common)\n            )\n        );\n    }\n}\n"
    },
    "@perennial/verifier/contracts/types/Intent.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6, UFixed6Lib } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\n\nstruct Intent {\n    /// @dev The size and direction of the order being opened by the taker\n    ///       - Positive opens long / Negative opens short\n    ///       - The maker will open the opposite side of the order\n    ///       - To close, open an order in the opposite direction\n    Fixed6 amount;\n\n    /// @dev The price to execute the order at\n    Fixed6 price;\n\n    /// @dev The solver fee, a percentage of the substractive interface fee\n    UFixed6 fee;\n\n    /// @dev The referral address of the originator of the order (ex. the interface)\n    address originator;\n\n    /// @dev The referral address of the solver of the order (ex. the router)\n    address solver;\n\n    /// @dev The minimium collateralization ratio that must be maintained after the order is executed\n    UFixed6 collateralization;\n\n    /// @dev The common information for the intent\n    Common common;\n}\nusing IntentLib for Intent global;\n\n/// @title IntentLib\n/// @notice Library for Intent logic and data.\nlibrary IntentLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"Intent(int256 amount,int256 price,uint256 fee,address originator,address solver,uint256 collateralization,Common common)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    function hash(Intent memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, self.amount, self.price, self.fee, self.originator, self.solver, self.collateralization, CommonLib.hash(self.common)));\n    }\n}\n"
    },
    "@perennial/verifier/contracts/types/OperatorUpdate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { AccessUpdate, AccessUpdateLib } from \"./AccessUpdate.sol\";\n\nstruct OperatorUpdate {\n    /// @dev The operator access to update\n    AccessUpdate access;\n\n    /// @dev The common information for the intent\n    Common common;\n}\nusing OperatorUpdateLib for OperatorUpdate global;\n\n/// @title OperatorUpdateLib\n/// @notice Library for OperatorUpdate logic and data.\nlibrary OperatorUpdateLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"OperatorUpdate(AccessUpdate access,Common common)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    function hash(OperatorUpdate memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, AccessUpdateLib.hash(self.access), CommonLib.hash(self.common)));\n    }\n}\n"
    },
    "@perennial/verifier/contracts/types/SignerUpdate.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.13;\n\nimport { UFixed6 } from \"@equilibria/root/number/types/UFixed6.sol\";\nimport { Fixed6 } from \"@equilibria/root/number/types/Fixed6.sol\";\nimport { Common, CommonLib } from \"@equilibria/root/verifier/types/Common.sol\";\nimport { AccessUpdate, AccessUpdateLib } from \"./AccessUpdate.sol\";\n\nstruct SignerUpdate {\n    /// @dev The signer access to update\n    AccessUpdate access;\n\n    /// @dev The common information for the intent\n    Common common;\n}\nusing SignerUpdateLib for SignerUpdate global;\n\n/// @title SignerUpdateLib\n/// @notice Library for SignerUpdate logic and data.\nlibrary SignerUpdateLib {\n    bytes32 constant public STRUCT_HASH = keccak256(\n        \"SignerUpdate(AccessUpdate access,Common common)\"\n        \"AccessUpdate(address accessor,bool approved)\"\n        \"Common(address account,address signer,address domain,uint256 nonce,uint256 group,uint256 expiry)\"\n    );\n\n    function hash(SignerUpdate memory self) internal pure returns (bytes32) {\n        return keccak256(abi.encode(STRUCT_HASH, AccessUpdateLib.hash(self.access), CommonLib.hash(self.common)));\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 80000
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "evm.methodIdentifiers", "metadata"],
        "": ["ast"]
      }
    }
  }
}
